<!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><script></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.ico?v=6.3.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.ico?v=6.3.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.ico?v=6.3.0"><link rel="mask-icon" href="/images/logo.ico?v=6.3.0" color="#222"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"6.3.0",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="本文为cissp中密码学与对称加密算法章节的学习笔记"><meta name="keywords" content="学习笔记,cissp,douiduo,diyz.bid"><meta property="og:type" content="article"><meta property="og:title" content="cissp学习笔记（6）——密码学与对称加密算法"><meta property="og:url" content="https://www.diyz.bid/notes/cissp学习笔记（6）——密码学与对称加密算法/index.html"><meta property="og:site_name" content="doubiduo"><meta property="og:description" content="本文为cissp中密码学与对称加密算法章节的学习笔记"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://www.diyz.bid/notes/cissp学习笔记（6）——密码学与对称加密算法/对称密钥密码学.png"><meta property="og:image" content="https://www.diyz.bid/notes/cissp学习笔记（6）——密码学与对称加密算法/非对称密钥密码学.png"><meta property="og:updated_time" content="2018-09-13T10:32:44.909Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="cissp学习笔记（6）——密码学与对称加密算法"><meta name="twitter:description" content="本文为cissp中密码学与对称加密算法章节的学习笔记"><meta name="twitter:image" content="https://www.diyz.bid/notes/cissp学习笔记（6）——密码学与对称加密算法/对称密钥密码学.png"><link rel="alternate" href="/atom.xml" title="doubiduo" type="application/atom+xml"><link rel="canonical" href="https://www.diyz.bid/notes/cissp学习笔记（6）——密码学与对称加密算法/"><script type="text/javascript" id="page.configurations">CONFIG.page={sidebar:""}</script><title>cissp学习笔记（6）——密码学与对称加密算法 | doubiduo</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-124427626-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-124427626-1")</script><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?9c8b377e488072512752a147d13a537c";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style type="text/css">.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.logo-line-after i{right:initial}</style></noscript><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-2020224399094607",enable_page_level_ads:!0})</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">doubiduo</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">diyz.bid</h1></div><div class="site-nav-toggle"> <button aria-label="切换导航栏"><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="menu-item-icon fa fa-fw fa-link"></i><br>友情链接</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user-circle"></i><br>关于</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.diyz.bid/notes/cissp学习笔记（6）——密码学与对称加密算法/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/images/diyz.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="doubiduo"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">cissp学习笔记（6）——密码学与对称加密算法</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-09-13 16:41:19 / 修改时间：18:32:44" itemprop="dateCreated datePublished" datetime="2018-09-13T16:41:19+08:00">2018-09-13</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/notes/" itemprop="url" rel="index"><span itemprop="name">notes</span></a></span></span> <span class="post-symbolscount"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span title="本文字数">15k</span></span> <span id="/notes/cissp学习笔记（6）——密码学与对称加密算法/" class="leancloud_visitors" data-flag-title="cissp学习笔记（6）——密码学与对称加密算法"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span><div class="post-description">本文为cissp中密码学与对称加密算法章节的学习笔记</div></div></header><div class="post-body" itemprop="articleBody"><p>在本章的考试大纲内容有:<br>安全工程</p><ul><li>I. 应用加密学<ul><li>I.1 密码学生命周期(例如， 密码学的局限性、算法/协议的管理)</li><li>I.2 密码学的种类(对称密码学、非对称密码学、椭圆曲线密码学)</li><li>I.7 不可否认性</li><li>I.8 完整性(哈希和撤盐)</li></ul></li></ul><h3 id="6-1-密码学历史上的里程碑"><a href="#6-1-密码学历史上的里程碑" class="headerlink" title="6.1 密码学历史上的里程碑"></a>6.1 密码学历史上的里程碑</h3><p>　　伴随着人类通信的发展，为了对那些局外人隐藏通信的真正含义， 保密的方法应运而生。古人类社会使有复杂的秘密符号系统代表战争中安全的地方。现代文明社会使用多种代码和密码促进个人和组织之间的私人通信。</p><h4 id="6-1-1-凯撒密码"><a href="#6-1-1-凯撒密码" class="headerlink" title="6.1.1 凯撒密码"></a>6.1.1 凯撒密码</h4><p>　　凯撒密码简单地将字母表中的每个字母都替换为其后的第三个字母。这是单一字母的替代置换密码， 也被称C3密码。</p><h4 id="6-1-2-美国内战"><a href="#6-1-2-美国内战" class="headerlink" title="6.1.2 美国内战"></a>6.1.2 美国内战</h4><p>　　在美国内战期间， 由于北部联邦和南部联邦的支持者都通过窃听对方的电报线路来刺探情报， 因此双方对前线的安全通信都使用了相对先进的密码系统。这些系统使用词汇替代和置换(详细内容参看”密码”部分)的复杂组合， 从而试图破坏敌人的破译企图。在内战中广泛使用的另一个系统是由军医Albert J. Myer开发的一系列标记符号。</p><h4 id="6-1-3-Ultra-与Enigma"><a href="#6-1-3-Ultra-与Enigma" class="headerlink" title="6.1.3 Ultra 与Enigma"></a>6.1.3 Ultra 与Enigma</h4><p>　　德国军事产业复合体为了官方使用而改造了一种名为Enigma的商业编码机。它使用一系列3到6个转子实现了一种极复杂的替换密码。使用同时代的技术对加密消息进行破译的唯一可行方法是使用类似的机器， 这些机器应当具有与传输设备使用的相同转子设置。<br>　　同盟国军方开始了一项代号为川剧的绝密工作， 其目的是对Enigma编码进行攻击。最终， 当波兰军方成功地复原了一台Enigma原型机并且与英国和美国的密码术专家共享了他们的成果时，他们的努力得到了回报。同盟国在1940年成功地破解了Enigma编码， 历史学家相信这次成功为最终战胜轴心国起到了重要的作用。<br>　　日本人在第二次世界大战期间使用了类似的一台机器， 被称为Japanese Purple Machine。美国人对这个密码系统的攻击效果显著， 导致日本人的密码在战争结束前就己被破解。</p><h3 id="6-2-密码学基础"><a href="#6-2-密码学基础" class="headerlink" title="6.2 密码学基础"></a>6.2 密码学基础</h3><h4 id="6-2-1-密码学的目标"><a href="#6-2-1-密码学的目标" class="headerlink" title="6.2.1 密码学的目标"></a>6.2.1 密码学的目标</h4><p>　　安全从业人员利用密码系统达到下列4个基本目标: 机密性、完整性、身份认证和不可否认性。实现每个目标都需要满足很多设计需求， 并且不是所有的加密系统都要达到所有4个目标。</p><h5 id="1-机密性"><a href="#1-机密性" class="headerlink" title="1. 机密性"></a>1. 机密性</h5><p>　　机密性确保数据在存储中(例如， 存储在磁盘上)或在传输中(例如， 在两方或多方之间传递)保持秘密状态。强制实施机<br>密性的密码系统主要有两种类型: 对称密钥密码系统使密码系统中的所有用户都能够使用一个共享的密钥， 公钥密码系统使系统中的每个用户都能够使用公钥和私钥的单独组合。<br>当开发以提供保密为目的的加密系统时， 你必须考虑两种不同类型的数据:</p><ul><li>静态数据或存储数据， 是指数据保存在固定和等待接入的位置。静态数据的例子包括存储在硬盘、磁带备份、云存储服务、USB设备和其他存储介质上的数据。</li><li>运动中的数据或线缆上的数据， 是指在两个系统之间通过网络传输的数据。运动中的数据可能在企业网络、无线网络或公共互联网上进行传输。</li></ul><h5 id="2-完整性"><a href="#2-完整性" class="headerlink" title="2. 完整性"></a>2. 完整性</h5><p>　　完整性确保数据在传输的过程中不会被修改。完整性检查能确保存储的数据在创建和被访问期间不会遭受篡改。这样做可以防止所有形式的修改: 第三方企图插入错误信息的有意修改以及因传输过程中的错误导致的无意修改。消息完整性通过使用在传输消息时创建的数字签名消息摘要来强制实施。消息的接收者简单地对消息摘要和签名的有效性进行验证， 确保消息未在传输过程中修改。公共和私钥密码系统都能够强制实施完整性。</p><h5 id="3-身份认证"><a href="#3-身份认证" class="headerlink" title="3. 身份认证"></a>3. 身份认证</h5><p>　　身份认证对声明的系统用户身份进行验证， 并且是密码系统的主要功能。</p><h5 id="4-不可否认性"><a href="#4-不可否认性" class="headerlink" title="4. 不可否认性"></a>4. 不可否认性</h5><p>　　不可否认性为接收者提供了担保， 保证消息确实来自发送者而不是来自伪装成发送者的人。不可否认性能够防止发送者宣称原先从未发送过信息(也被称为否认消息)。秘密密钥(或对称密钥)密码系统(如简单的替代密码)并不提供对不可否认性的保证。</p><h4 id="6-2-2-密码学概念"><a href="#6-2-2-密码学概念" class="headerlink" title="6.2.2 密码学概念"></a>6.2.2 密码学概念</h4><p>　　消息在成为编码形式之前， 被称为明文消息， 并且在描述加密函数时使用字母P表示。消息的发送者使用密码学算法将明文消息加密为密文消息， 并且使用字母C表示。消息通过一些物理的或电子的方式被传送给接收者。接收者随后使用预先确定的算法对密文消息进行解密，从而得到明文形式的消息。<br>　　所有密码学算法都依赖密钥来维护其安全性。在很大程度上， 密钥只不过是一个数字。密钥往往是一个非常大的二进制数， 不过仍然是一个数字。每种算法都具有一个特定的密钥空间。密钥空间是一段值的范围， 此范围内的值可作为密钥算法的有效密钥。密钥空间由其位的长度定义。位的长度只不过是密钥中的比特数或位数(0s和1s)。密钥空间的范围为: 从所有位全部为0到所有位全部为1。如果采用另一种方式表示，那么密钥空间的范围为0到2n， 其中n是密钥的位的长度。因此， 128位密钥的值可以从0到2128(大约为3.40282367* 10^38， 这是一个相当大的数字)。保护密钥的安全是非常重要的。事实上， 从密码学获得的所有安全性就只能依赖于保证秘密使用密钥的能力。</p><h4 id="6-2-3-密码学的数学原理"><a href="#6-2-3-密码学的数学原理" class="headerlink" title="6.2.3 密码学的数学原理"></a>6.2.3 密码学的数学原理</h4><h5 id="1-二进制数学"><a href="#1-二进制数学" class="headerlink" title="1. 二进制数学"></a>1. 二进制数学</h5><p>　　二进制数学定义了一些形成所有计算机神经系统的比特和字节所使用的规则。计算机依赖的二进制系统起源于电。在电流中， 只有两种可能的状态: 开(代表存在电流)和关(代表没有电流)。电子设备执行的所有计算都必须利用这些术语来表达， 这就出现了现代电子学中对二进制的使用。</p><h5 id="2-逻辑运算"><a href="#2-逻辑运算" class="headerlink" title="2. 逻辑运算"></a>2. 逻辑运算</h5><p>　　密码学的二进制数学使用多种逻辑函数来操纵数据。</p><ul><li><p>AND<br>AND 运算(用符号^表示)可以检查两个值是否都为真。在二进制数学中， 每个变量都只有两种可能的值， 因而为且也函数准备了4种可能的输入。</p></li><li><p>OR<br>OR运算(用符号v来表示)可以检查是否至少有一个输入值为真，只有在两个输入值都为假时， OR函数的结果才会返回假。</p></li><li><p>NOT<br>NOT 运算(用符号~或!来表示)简单地将输入值取反。</p></li><li><p>XOR<br>异或(XOR)操作通常用符号⊕表示。只有在一个输入值为真时， XOR函数的结果才为真。如果两个输入值都为假或都为真， 那么XOR 函数的结果为假。</p></li></ul><h5 id="3-模函数"><a href="#3-模函数" class="headerlink" title="3. 模函数"></a>3. 模函数</h5><p>　　计算机本来也不理解小数系统， 并且这些余数在计算机执行很多数学运算时起到了至关重要的作用。模函数十分简单， 也就是在完成除法运算后得到余数。</p><h5 id="4-单向函数"><a href="#4-单向函数" class="headerlink" title="4. 单向函数"></a>4. 单向函数</h5><p>　　单向函数是一种数学运算， 它可以通过所有可能的输入值组合得出结果， 但是反向得出输入值却是不可能的。公钥密码系统都建立在单向函数的基础上。</p><h5 id="5-随机数"><a href="#5-随机数" class="headerlink" title="5. 随机数"></a>5. 随机数</h5><p>　　密码学往往通过在加密过程中添加随机性来获得强度。实现这个目标的一种方法是使用随机数。随机数是随机数字发生器， 起到了数学函数中占位符变量的作用。执行数学函数时， 占位符会被替换为在处理时刻生成的随机数。每次使用数学函数时， 随机数都会产生一个独特的数字。随机数的一个更为人接受的示例是初始向量(Initialization Vector， IV)， 这是一个与分组长度相同的随机比特串， 并且与原始消息相异或。在每次使用相同密钥加密相同的消息时， IV都被用于创建独特的密文。</p><h5 id="6-零知识证明"><a href="#6-零知识证明" class="headerlink" title="6. 零知识证明"></a>6. 零知识证明</h5><p>　　密码学的一个优点是建立了这样的机制: 在不向第三方揭示事实本身的情况下向第三方证明对事实的了解。这种机制通常涉及密码和其他秘密的身份认证。</p><h5 id="7-分割知识"><a href="#7-分割知识" class="headerlink" title="7. 分割知识"></a>7. 分割知识</h5><p>　　如果执行某个操作所需的信息或权限在多个用户之间分配时， 任何一个人都没有足够的权限来危害环境的安全性。单个解决方案中包含的这种职责分离和两人控制被称为分割知识。分割知识的最佳示例就是密钥托管的概念。通过使用密钥托管， 密码密钥、数字签名甚至数字证书， 可以被存储在或备份在一种被称为密钥托管数据库的特殊数据库中。</p><h5 id="8-工作函数"><a href="#8-工作函数" class="headerlink" title="8. 工作函数"></a>8. 工作函数</h5><p>　　通过使用工作函数或工作因数， 从成本和/或时间方面来度量所有努力， 就可以度量密码学系统的强度。通常， 针对加密系统执行完全穷举攻击所需的时间和努力， 就是工作函数所表示的内容。密码系统提供的安全性和保护与工作函辈U因数的值成正比。工作函数的大小应当与受保护资产的相对值匹配。工作函数只需稍大于受保护资产的时间值。换句话说， 所有安全性(包括密码学)都应当是有效益的和有效率的。保护某个资产所花费的成本不能超过这个资产自身的价值， 但是一定要保证提供足够的保护。因此， 如果信息由于时间的推移而失去价值， 那么工作函数的大小只需确保在数据失去价值前提供保护即可。</p><h4 id="6-2-4-密码"><a href="#6-2-4-密码" class="headerlink" title="6.2.4 密码"></a>6.2.4 密码</h4><h5 id="1-编码与密码"><a href="#1-编码与密码" class="headerlink" title="1. 编码与密码"></a>1. 编码与密码</h5><p>　　编码是密码学系统中表示词汇或短语的符号， 有时是秘密的， 但是不一定提供机密性。编码的常见示例是执法机构使用的通信”10系统”。 在这个系统中， 语句”我收到你的信息， 并且理解其含义”被表示成编码短语”10-4”这个编码是众人皆知的， 但是它确实提供了通信的简易性。一些编码是秘密的。为了传输机密的消息， 这些编码可能使用数学函数或密码字典来表示词汇、短语或句子。另一方面， 密码总是意味着隐藏消息的真实含义。密码使用各种技术修改和/或重新排列消息中的字符或比特， 从而实现机密性。在比特(也就是二进制编码的单个位)、字符(也就是ASCII码消息的单个字符)或分组(也就是一条消息的固定长度分段， 通常用比特数表示)的基础上， 密码将消息从明文转换为密文。</p><h5 id="2-换位密码"><a href="#2-换位密码" class="headerlink" title="2. 换位密码"></a>2. 换位密码</h5><p>　　换位密码使用某种加密算法重新排列明文消息中的字母， 从而形成密文消息。解密算法只需反演加密转换过程就可以得到原始消息。</p><h5 id="3-替代密码"><a href="#3-替代密码" class="headerlink" title="3. 替代密码"></a>3. 替代密码</h5><p>　　替代密码使用加密算法将明文消息中的每一个字符或比特都替换为不同的宇符。与换位密码一样， 有很多替代密码比本章提供的示例更复杂。多字母替代密码在相同的消息中使用多个字母表来阻碍解密操作。多字母替代密码的一个著名示例是Vigenere密码。虽然多宇母替代能够防范直接的频率分析， 但是容易遭受二阶形式的频率分析(也被称为周期分析攻击， 这种攻击基于密钥的重复使用进行频率检查)。</p><h5 id="4-一次性填充"><a href="#4-一次性填充" class="headerlink" title="4. 一次性填充"></a>4. 一次性填充</h5><p>　　一次性填充是一种极为强大的替代密码。一次性填充对明文消息的每个字母都使用一个不同的字母表。它们可以通过下面的加密函数来表示， 其中K是以C表示的字母的加密密钥:</p><p><center>c = (P + K) mod 26</center><br>　　通常， 一次性填充被记为插入函数的一个很长的数字序列。一次性填充的巨大好处是: 如果运用得当， 它是一个不可破解的加密方案。由于不存在重复的字母替代模式， 这使得密码分析工作徒劳无益。然而， 为了确保算法的完整性， 必须满足下列几个要求:</p><ul><li>加密密钥必须随机生成。使用一个短语或书中的一段话会引入密码分析人员破译这个编码的可能性。</li><li>一次性填充必须进行物理保护， 以防泄露。如果敌人具有这个一次性填充的副本， 那么他们就可以轻易地破译加密的消息。</li><li>每个一次性填充必须只使用一次。如果填充被重复使用， 那么密码分析人员可以比较多个使用相同填充的加密消息中的相似之处， 井有可能确定使用的密钥值。</li><li>密钥必须至少与被加密的消息一样长， 这是因为每个密钥元素都只对消息中的一个字符进行编码。</li></ul><p>　　一次性填充一直被用于保护极其敏感的通信， 不能被广泛使用的主要障碍是很难生成， 以及分发和保护所需的冗长密钥。由于密钥的长度问题， 一次性填充在实际中只可用于短消息。</p><h5 id="5-滚动密钥密码"><a href="#5-滚动密钥密码" class="headerlink" title="5. 滚动密钥密码"></a>5. 滚动密钥密码</h5><p>　　密码学的许多脆弱性都涉及密钥的有限长度。通过在加密和解密期间为每个密码转换使用不同的字母表， 一次性填充避免了这些脆弱性。然而， 因为要求填充的物理交换， 所以一次性填充难以实现。对于这个难题， 一个常见的解决方案是使用漆动密钥密码， 也被称为书籍密码。在这种密码中，加密密钥与消息本身一样辰， 并且往往从一般的书籍中选取。</p><h5 id="6-分组密码"><a href="#6-分组密码" class="headerlink" title="6. 分组密码"></a>6. 分组密码</h5><p>　　分组密码按消息的”组块”或分组进行操作， 并且对整个消息分组同时应用加密算法。换位密码就是分组密码的一个例子。在挑战/响应算法中使用的简单算法， 是取出完整的词汇井且逆向排列字母。更加复杂的柱状换位密码对整条消息(或一段消息)进行操作， 并且使用换位算法和保密密钥对消息进行加密。大多数现代加密算法都实现了某些类型的分组密码。</p><h5 id="7-流密码"><a href="#7-流密码" class="headerlink" title="7. 流密码"></a>7. 流密码</h5><p>　　流密码对消息、(或数据流)中的每个字符或每一位进行操作， 每次只处理一个字符/一位。凯撒密码就是流密码的一个例子。一次性填充也是一种流密码， 这是因为该算法对明文信息中的每个宇符独立进行操作。流密码也可以作为一种分组密码使用。在此类情况下， 某个缓冲区被填满实时数据，随后这些数据作为分组进行加密井传送给接收方。</p><h5 id="7-混淆与扩散"><a href="#7-混淆与扩散" class="headerlink" title="7. 混淆与扩散"></a>7. 混淆与扩散</h5><p>　　密码学算法依靠两种基本的操作来隐藏明文信息: 、混淆与扩散。混淆出现在明文和密钥的关系十分复杂时， 此时攻击者不能通过继续修改明文和分析产生的密文来确定密钥。扩散出现在明文的改变导致多种变化时， 这些变化被扩散到整个密文中。</p><h3 id="6-现代密码学"><a href="#6-现代密码学" class="headerlink" title="6. 现代密码学"></a>6. 现代密码学</h3><p>　　为了实现密码学的机密性、完整性、身份认证和不可否认性目标， 现代密码系统利用计算复杂的算法和长密钥。</p><h4 id="6-3-1-密钥"><a href="#6-3-1-密钥" class="headerlink" title="6.3.1 密钥"></a>6.3.1 密钥</h4><p>　　在密码学的早期， 其中一条主导原则就是” 通过隐匿实现安全”。密码学家们认为保护加密算法安全的最好办法就是对外人隐藏算法的细节。旧的密码系统要求通信双方保持对信息加密和解密所使用算法的安全性， 井且不对第三方泄露。算法的任何泄露都可能导致对于对整个系统的破坏。<br>　　现代密码系统并不依赖于其算法的安全性。通过向公众开放审查， 实际上也改善了算法的安全性。计算机安全机构对于算法的广泛分析， 允许从业人员发现并纠正潜在的安全脆弱性， 并且确保他们用于保护通信的算法尽可能安全。现代密码系统不依赖于保密的算法， 而是依赖于具体的用户或用户组专用的一个或多个密钥。对换位密码的讨论中曾经提到过， 柱状换位中使用的密钥被用于指导加密和解密操作。然而， 只要选择了外人猜不出的密钥，柱状换位就可以被用于双方的安全通信。只要密钥的安全性得到维护， 那么就不必担心第三方会知道算法的细节。</p><h4 id="6-3-2-对称密钥算法"><a href="#6-3-2-对称密钥算法" class="headerlink" title="6.3.2 对称密钥算法"></a>6.3.2 对称密钥算法</h4><p>　　对称密钥算法依赖于一个”共享的秘密”加密密钥， 该密钥会被分发给所有参与通信的成员。所有通信成员都使用这个密钥进行消息的加密和解密， 因此发送者和接收者都拥有共享密钥的副本。通信两端会使用相同的密钥加密和解密消息。当使用很长的密钥时， 对称加密难以被破解。对称密钥算法主要被用于执行批量加密， 并且只为安全服务提供机密性。对称密钥密码学也被称为秘密密钥密码学和私有密钥密码学。<br><img src="/notes/cissp学习笔记（6）——密码学与对称加密算法/对称密钥密码学.png"><br>对称密钥密码学具有下列几个弱点:</p><ul><li><strong>密钥分发是一个主要问题</strong> 在使用对称密钥协议建立通信之前， 通信参与者必须具备一种安全交换密钥的方法。如果没有可用的安全电子通道， 那么往往必须使用离线的密钥分发方法(已不属于交换) 。</li><li><strong>对密钥密码学井未实现不可否认性</strong> 由于任意通信方都可以利用共享的密钥对消息进行加密和解密， 因此无法分辨指定消息的来源。</li><li><strong>这种算法不可扩展</strong> 对于大的用户组来说， 使用对称密钥密码进行通信非常困难。只有在每个可能的用户组合共享私有密钥时， 组中个人之间的安全专有通信才能实现。</li><li><strong>密钥必须经常更新</strong> 每当有成员离开用户组时， 所有涉及这个成员的密钥都必须被抛弃。</li></ul><p>　　对称密钥密码学的主要强度在于能够以极快的速度进行操作。对称密钥算法的速度很快， 通常是非对称密钥算法的1000倍到10000倍之间。鉴于其数学特性， 对称密钥密码学还可以在硬件上实现， 这为更高速度的运行创造了机会。</p><h4 id="6-3-3-非对称密钥算法"><a href="#6-3-3-非对称密钥算法" class="headerlink" title="6.3.3 非对称密钥算法"></a>6.3.3 非对称密钥算法</h4><p>　　非对称密钥算法也被称为公钥算法， 它为对称密钥加密的弱点提供了解决方案。在这个系统中，每个用户都有两个密钥: 一个在所有用户之间共享的公钥， 以及另一个只有用户自己知道并保管的私钥。但是让人意想不到的是: 相对立的和相关的密钥必须被先后应用于加密和解密。换句话说，如果使用公钥加密消息， 那么只有相关的私钥能够进行解密， 反之亦然。<br><img src="/notes/cissp学习笔记（6）——密码学与对称加密算法/非对称密钥密码学.png"><br>下面列出了非对称密钥密码学的主要优点:</p><ul><li><strong>增加新用户只需要生成一对公钥-私钥对</strong> 这个新用户与非对称密码系统中的所有用户通信时都使用这对相同的密钥， 从而使得算法非常容易扩展。</li><li><strong>从非对称系统中更容易删除用户</strong> 非对称算法提供了一种密钥撤消机制， 这个机制准许密钥被取消， 从而能够有效地从非对称系统中删除用户。</li><li><strong>只有在用户的私钥被破坏时， 才需要进行密钥重建</strong> 如果某位用户离开了公司， 那么系统管理员只需要简单地将该用户的密钥作废即可。其他密钥都不会被破坏， 因此其他用户都不需要进行密钥重建。</li><li><strong>非对称密钥加密提供了完整性、身份认证和不可否认性</strong> 如果某位用户没有与其他个体共享其私钥， 那么具有该用户签名的消息就是正确无误的， 并且具有特定的来源， 在以后的任何时刻都不能被否认。</li><li><strong>密钥分发是一个简单的过程</strong> 希望加入非对称密码系统的用户， 只需要使他们的公钥对于所有与他们进行通信的人来说可用就可以了。目前尚无办法从公钥导出私钥。</li><li><strong>不需要预先存在通信链接</strong> 两个个体可以从通信一开始就进行安全的通信。非对称密码学并不要求预先存在能够提供安全数据交换机制的关系。</li></ul><p>　　公钥密码学的主要弱点是运算速度慢。因此， 很多需要安全传输大量数据的应用程序会使用公钥密码学建立连接， 然后交换对称密钥。会话任务的剩余部分随后来用对称密码学开始运作。下表比较了对称和非对称密码学系统。仔细查看这个表可以发现， 一种系统中的弱点恰好与另一种系统中的优点互补。</p><table><thead><tr><th>对称密码学系统</th><th>非对称密码学系统</th></tr></thead><tbody><tr><td>单个共享的密钥</td><td>密钥对</td></tr><tr><td>带外交换</td><td>带内交换</td></tr><tr><td>不可扩展</td><td>可扩展</td></tr><tr><td>快速</td><td>慢速</td></tr><tr><td>批量加密</td><td>小块数据分组、数字签名、数字封装、数字证书</td></tr><tr><td>机密性</td><td>完整性、机密性、身份认证、不可否认性</td></tr></tbody></table><h4 id="6-3-4-散列算法"><a href="#6-3-4-散列算法" class="headerlink" title="6.3.4 散列算法"></a>6.3.4 散列算法</h4><p>目前常用的一些散列算法:</p><ul><li>消息摘要2(MD2)</li><li>消息摘要5(MD5)</li><li>安全散列算法(SHA-0、SHA-l和SHA-2)</li><li>基于散列的消息身份认证代码(Hashed Message Authentication Code， HMAC)</li></ul><h3 id="6-4-对称密码"><a href="#6-4-对称密码" class="headerlink" title="6.4 对称密码"></a>6.4 对称密码</h3><h4 id="6-4-1-数据加密标准"><a href="#6-4-1-数据加密标准" class="headerlink" title="6.4.1 数据加密标准"></a>6.4.1 数据加密标准</h4><p>　　美国政府在1977年公布了数据加密标准(DES)， 并且将之作为向所有政府通信而提议的标准密码系统。由于该算法中的缺陷， 密码学界和政府不再认为DES是安全的。大家普遍相信情报机构已经能轻易破解DES加密的信息。DES在2001年12月被高级加密标准取代。<br>　　DES是一个64位的分组密码， 具有5种操作模式: 电子代码本(Electronic CodeBook， ECB)模式、密码分组链接(Cipher Block Chaining， CBC)模式、密码回馈(Cipher FeedBack， CFB)模式以及输出回馈(Output FeedBack， OFB)模式和计数(CounTeR， CTR)模式。这些模式将在接下来的内容中进行阐述。所有DES模式每次处理64位的明文， 并且生成一个64位的密文分组。DES使用的密钥长度为56位。DES 利用长序列的异或(XOR)操作生成密文。每个加密/解密操作都要重复16次这个过程， 每次重复通常被称为”一轮”加密， 因此DES要执行16轮加密。</p><h5 id="1-电子代码本模式"><a href="#1-电子代码本模式" class="headerlink" title="1. 电子代码本模式"></a>1. 电子代码本模式</h5><p>　　电子代码本(ECB)模式是最容易了解的模式， 但安全性最差。这个算法每次处理一个64位分组，它简单地使用所选择的密钥对这个分组进行加密。这意味着如果算法多次遇到相同的分组， 那么将产生完全相同的加密分组。除了最短传输之外， 这个脆弱性使得通过ECB模式进行传输并不现实。在日常使用中， ECB只被用于交换少量数据。例如， 启动其他DES模式的密钥和参数以及数据库中的单元。</p><h5 id="2-密码分组链接模式"><a href="#2-密码分组链接模式" class="headerlink" title="2. 密码分组链接模式"></a>2. 密码分组链接模式</h5><p>　　在密码分组链接(CBC)模式中， 未加密文本的每个分组在使用DES算法加密之前， 都与前一密文分组进行异或操作。解密过程简单地将密文解密， 并且反向执行异或操作。CBC创建了一个IV，并且将这个IV与消息的第一个分组相异或， 从而每次操作都生成独特的输出。IV必须被发送给接收方， 我们既可以将IV以明文形式置于完整的密文之前， 也可以使用与消息所用的相同的密钥通过ECB加密模式保护它。在使用CBC 模式时， 需要考虑的一个重要问题是错误传播， 也就是如果一个分组在传输中被破坏， 那么这个分组将无法解密， 并且下一个分组也是如此。</p><h5 id="3-密码回馈模式"><a href="#3-密码回馈模式" class="headerlink" title="3. 密码回馈模式"></a>3. 密码回馈模式</h5><p>　　密码回馈(CFB)模式是流密码形式的CBC。换句话说， CFB针对实时生成的数据进行操作。不过， CFB并不将消息分为若干分组， 而是使用相同分组大小的内存缓冲区。在缓冲区被填满时， 对数据进行加密并发送给接收方。接着， 系统等待下一个缓冲区被新生成的数据填满，然后继续进行加密和传输。除了将先前存在的数据变化为实时数据， CFB的操作方式与CBC一样， 也使用了IV和链接。</p><h5 id="4-输出回馈模式"><a href="#4-输出回馈模式" class="headerlink" title="4. 输出回馈模式"></a>4. 输出回馈模式</h5><p>　　在输出回馈(OFB)模式中， DES的操作样式几乎与在CFB模式中的操作样式完全相同。不过，DES并不将明文分组与前一个密文分组的加密版本相异或， 而是将明文与某个种子值相异或。对于第一个被加密的分组来说， 初始向量被用于创建种子值。通过对先前的种子值运行DES算法， 就可以派生出之后的种子值。OFB模式的主要优点是不存在链接功能， 并且传输错误不会通过传播影响之后分组的解密。</p><h5 id="5-计数模式"><a href="#5-计数模式" class="headerlink" title="5. 计数模式"></a>5. 计数模式</h5><p>　　在计数(CTR)模式中运行的DES使用的流密码， 类似于在CFB和OFB模式中使用的流密码。不过， 这种模式并不根据前一个种子值的结果为每个加密/解密操作创建种子值， 而是使用一个简单的、每次操作后都增加的计数。与OFB模式一样， CTR模式中也不传播错误。</p><h4 id="6-4-2-三重数据加密算法-3DES"><a href="#6-4-2-三重数据加密算法-3DES" class="headerlink" title="6.4.2 三重数据加密算法(3DES)"></a>6.4.2 三重数据加密算法(3DES)</h4><p>　　3DES具有4种版本。第1种版本只是使用三个不同的密钥(K1、K2和K3)对明文加密三次。它被称为DES-EEE3模式(三个E表示存在三个加密操作， 而数字3表示使用三个不同的密钥)， 这种模式可以利用下面的符号来表示， 其中E(K，P)表示使用密钥K加密明文P:</p><p><center>E(K1，E(K2，E(K3，P)))</center><br>　　DES-EEE3 具有的密钥的有效长度为168位。<br>　　第2种3DES版本DES-EDE3也使用三个密钥， 但是将第二个加密操作替换为解密操作，如下所示:</p><p><center>E(K1，D(K2，E(K3，P)))</center><br>　　第3种3DES版本DES-EEE2只使用两个密钥Kl和K2，如下所示:</p><p><center>E(K1，E(K2，E(Kl，P)))</center><br>　　第4种3DES版本DES-EDE2也使用两个密钥， 但是在中间使用一个解密操作， 如下所示:</p><p><center>E(K1，D(K2E(K1，P)))</center><br>　　第3种和第4种3DES 版本具有的密钥的有效长度都为112位。</p><h4 id="6-4-3-国际数据加密算法-IDEA"><a href="#6-4-3-国际数据加密算法-IDEA" class="headerlink" title="6.4.3 国际数据加密算法(IDEA)"></a>6.4.3 国际数据加密算法(IDEA)</h4><p>　　国际数据加密算法(IDEA)的分组密码是针对DES算法的密钥长度不够而开发的。与DES一样，IDEA对64位的明文/密文分组进行操作。然而， 国际数据加密算法采用128位的密钥进行操作。这个密钥随后在一系列操作中被分解成52个16位的子密钥。这些子密钥接着使用异或和模运算的组合对输入的文本进行操作，从而生成输入消息的加密/解密版本。IDEA能够在DES使用的4种模式(ECB、CBC、CFB和OFB)中工作。</p><h4 id="6-4-4-Blowfish"><a href="#6-4-4-Blowfish" class="headerlink" title="6.4.4 Blowfish"></a>6.4.4 Blowfish</h4><p>　　Bruce Schneier的Blowfish分组密码是DES和IDEA的另一种选择。与它的这些前辈们一样，Blowfish对64位文本分组进行操作。然而， Blowfish扩展了IDEA的密钥强度， 甚至准许使用变长密钥， 范围从相对不安全的32位到相当难破解的448位。很显然， 较长的密钥将导致加密/解密时间的相应增加。不过， 计时试验已经表明， Blowfish是比IDEA和DES更快的算法。</p><h4 id="6-4-5-Skipjack"><a href="#6-4-5-Skipjack" class="headerlink" title="6.4.5 Skipjack"></a>6.4.5 Skipjack</h4><p>　　Skipjack算法由美国政府在联邦信息处理标准(Federal Information Processing Standard，FIPS)185， 即托管加密标准证书(Escrowed Encryption Standard， EES)中批准使用。与许多分组密码一样，Skipjack对64位的文本分组进行操作。这种算法使用一个80位的密钥， 并且支持DES支持的相同4种操作模式。</p><h4 id="6-4-6-高级加密标准-AES"><a href="#6-4-6-高级加密标准-AES" class="headerlink" title="6.4.6 高级加密标准(AES)"></a>6.4.6 高级加密标准(AES)</h4><p>　　AES密码准许使用三种密钥强度:128位、192位和256位。AES最初的规范支持128位分组的处理， 但是Rijndael超出了这个规范， 它准许密码学家使用与密钥长度相等的分组大小。如下所示， 加密的轮数依赖于所边的密钥长度:</p><ul><li>128位密钥需要10轮加密。</li><li>192位密钥需要12轮加密。</li><li>256位密钥需要14轮加密。</li></ul><p>下表列出了某些常见且著名的对称加密算法及其分组大小和密钥大小：</p><table><thead><tr><th>算法名</th><th>分组大小(单位为位)</th><th>密钥大小(单位为位)</th></tr></thead><tbody><tr><td>数据加密标准(DES)</td><td>64</td><td>56</td></tr><tr><td>三重DES(3DES)</td><td>64</td><td>112或168</td></tr><tr><td>高级加密标准(AES)</td><td>128</td><td>128、192、256</td></tr><tr><td>Rijndael</td><td>可变</td><td>128、192、256</td></tr><tr><td>Twofish</td><td>128</td><td>1-256</td></tr><tr><td>Blowfish(通常在SSH中使用)</td><td>64</td><td>32-448</td></tr><tr><td>IDEA(在PGP中使用)</td><td>64</td><td>128</td></tr><tr><td>基于RSA的Rivest密码5(RC5)</td><td>32、64、128</td><td>0-2040</td></tr><tr><td>基于RSA的Rivest密码4(RC4)</td><td>流式</td><td>128</td></tr><tr><td>基予RSA的Rivest密码2(RC2)</td><td>64</td><td>128</td></tr><tr><td>Skipjack</td><td>64</td><td>80</td></tr></tbody></table><h4 id="6-4-7-对称密钥管理"><a href="#6-4-7-对称密钥管理" class="headerlink" title="6.4.7 对称密钥管理"></a>6.4.7 对称密钥管理</h4><p>　　由于加密密钥中包含的信息对于密码系统而言是至关重要的， 因此密码系统的管理员和用户必须采取特殊的措施以保护密钥材料的安全。这些安全措施被统称为密钥管理实践。它们包含密钥的生成、分发、存储、销毁、恢复和托管。</p><h5 id="1-创建和分发对称密码"><a href="#1-创建和分发对称密码" class="headerlink" title="1. 创建和分发对称密码"></a>1. 创建和分发对称密码</h5><ul><li><strong>离线分发</strong> 在技术方面最简单的方法涉及密钥材料的物理交换。一方向另一方提供包含密钥的一张纸或一份存储介质。在很多硬件加密设备中， 密钥材料以电子设备的形式存在， 这类似于插入到加密设备中的真实的钥匙。然而， 这些方法都具有各自固有的缺陷。如果通过电子邮件发送密钥材料， 那么密钥材料就可能被截获。电话可能会被窃听。包含密钥的纸张则可能被无意丢进废纸篓或丢失。</li><li><strong>公钥加密</strong> 许多通信人员希望在没有密钥分发之争的情况下获得密钥加密的速度优势。因此，许多人使用公钥加密来建立初始的通信链接。一旦链接成功建立， 并且双方对相互的身份都感到满意， 那么他们就会在安全的公钥链接上交换密钥。随后， 通信双方从基于公钥算法的通信进入基于秘密密钥算法的通信， 并且能够享受快速的处理过程。一般而言， 与公钥加密相比， 私有密钥加密的速度快数千倍。</li><li><strong>Diffie-Hellman算法</strong> 某些情况下， 无论是公钥加密还是离线分发， 都是不充分的。双方可能需要相互通信， 但是他们没有物理手段交换密钥材料， 并且没有适当的公钥基础设施来促进秘密密钥的交换。在这样的情况下， 像Diffie-Hellman这样的密钥交换算法被证明是极为有用的机制。</li></ul><h5 id="2-存储和销毁对称密钥"><a href="#2-存储和销毁对称密钥" class="headerlink" title="2. 存储和销毁对称密钥"></a>2. 存储和销毁对称密钥</h5><p>　　在对称密钥加密中， 另一个主要的挑战是在密码系统中使用的密钥必须进行安全保管。以下给出了存储加密密钥的最佳实践:</p><ul><li>永远不要将加密密钥存储在存放加密数据的同一个系统中， 这将使攻击者更容易进行攻击!</li><li>对于敏感的密钥， 可以考虑两个不同的人分别持有密钥的一半。他们必须合在一起才能构成完整的密钥。这是众所周知的知识分割原则(己在本章前面提到)。</li></ul><p>当知道密钥的用户离开组织或不再被允许访问通过密钥包含的材料时， 密钥必须更改， 同时使用该密钥进行加密的所有材料必须用新的密钥进行重新加密。销毁一个密钥并将一个用户从对称密码系统中移除是困难的， 这也是组织转而使用非对称算法的一个重要原因。</p><h5 id="3-密钥托管"><a href="#3-密钥托管" class="headerlink" title="3. 密钥托管"></a>3. 密钥托管</h5><p>　　在过去10年中， 人们提议通过下列两种主要途径进行密钥托管:</p><ul><li><strong>公平密码系统</strong> 在这种托管方法中， 通信中使用的私有密钥被分为两个或多个部分， 这些部分都被交给独立的第三方。每个部分本身都是无用的， 但是通过重新组合可以获得私有密钥。政府获得法律授权访问特定的密钥时， 需要向所有第三方提供法院的证据， 随后才能重新组装这个私有密钥。</li><li><strong>托管加密标准</strong> 这种托管方法向政府提供解密密文的技术手段。这个标准是本章前面讨论的Skipjack算法的基础。</li></ul><h4 id="6-4-8-密码生命周期"><a href="#6-4-8-密码生命周期" class="headerlink" title="6.4.8 密码生命周期"></a>6.4.8 密码生命周期</h4><p>　　安全专家在选择一个加密算法和相应的管理控制措施时必须考虑密码的生命周期以确保算法、协议和选择的密钥长度足以保存密码系统的完整性， 以确保能够用于保护所需时间内信息的完整性和安全性。安全专家可以使用以下算法和协议管理控制:</p><ul><li>确定组织内可以接受和使用的加密算法(例如， AES、3DES和RSA) 。</li><li>基于传输信息的敏感性确定每个算法可接受使用的密钥长度。</li><li>列出可以使用的安全传输协议(如SSL和TLS) 。</li></ul><h3 id="6-5-考试要点"><a href="#6-5-考试要点" class="headerlink" title="6.5 考试要点"></a>6.5 考试要点</h3><ul><li><strong>理解机密性、完整性和不可否认性在密码系统中扮演的角色</strong> 机密性是密码学的一个主要目标，它确保信息不对未授权的个人泄漏， 并且准许加密信息、以在开放的网络中自由传输。对称和非对称密码系统都能够保证机密性。完整性为消息的接收方提供了消息在发送者建立和接收者接收到的时间范围内没有被(有意或无意)修改的保证。对称和非对称密码系统都能够保证完整性。不可否认性提供了不可否认的证据， 从而证明消息的发送者确实是这个消息的作者。它防止发送者否认他们发送了原始信息。</li><li><strong>了解如何使用密码系统达到身份认证的目标</strong> 身份认证提供了对用户身份的保证。使用身份认证的一种可能方案是挑战/响应协议， 其中的远程用户被要求使用只有通信双方知道的密钥对消息进行加密。对称和非对称的密码系统都可以实现身份认证。</li><li><strong>熟悉密码学的基本术语</strong> 当发送者希望向接收者传送一份私有消息时， 发送者会取出明文(未加密的)消息， 并且使用某种算法和某个密钥对明文消息进行加密， 从而生成发送给接收者的密文消息。接收者随后使用相似的算法和密钥对密文进行解密， 并且重建原始的明文消息以供查看。</li><li><strong>理解编码和密码之间的区剔， 井且能够解释密码的基本类型</strong> 编码是对词汇或短语操作的符号密码学系统， 有时是隐秘的， 但是并不能永远提供机密性。不过， 密码永远意味着对消息的真实含义进行隐藏。了解下列密码类型的工作方式: 换位密码、替代密码(包括一次性填充)、流密码以及分组密码。</li><li><strong>了解成功应用一次性填充的要求</strong> 要获得成功的一次性填充， 密钥必须随机生成， 并且不使用任何己知的模式。密钥必须至少和被加密的消息一样长。填充必须防止物理泄露， 并且每个填充在被丢弃前必须只使用一次。</li><li><strong>理解零知识证明的概念</strong> 零知识证明是一个通信概念。正如数字签名和数字证书一样， 零知识证明交换特定类型的信息， 但是不传输实际的数据。</li><li><strong>理解知识分割</strong> 分割知识意味着执行某个操作所需的知识或权限在多个用户之间分配， 这样可以确保任何一个人都没有足够的权限来危害环境的安全性。”M of N控制”是分割知识的一个示例。</li><li><strong>理解工作函数(工作因数)</strong> 工作函数或工作因数通过度量解密消息所需的成本和/或时间， 来度量密码学系统的强度。通常， 针对加密系统执行完全穷举攻击所需的时间和努力就是工作函数所表示的内容。密码系统提供的安全性和保护与工作函数/因数的值成正比。</li><li><strong>理解密钥安全性的重要性</strong> 密码学密钥为密码系统提供秘密性的必要组件。现代密码系统使用至少128位的密钥来提供足够的安全性。通常， 人们都赞同数据加密标准。(DES)56位密钥的长度己无法提供足够的安全性。</li><li><strong>了解对称和非对称密钥系统之间的差异</strong> 对称密钥密码系统(或密钥密码系统)依赖于一个共享密钥的使用。它们的速度远远快于非对称算法， 但是缺乏对可扩展性、简单密钥分发和不可否认性的支持。非对称密码系统对双方之间的通信使用公共/私钥对， 但是要比对称算法的操作速度慢得多。</li><li><strong>能够解释数据加密标准(DES)和三重DES(3DES)的基本操作模式</strong> 数据加密标准具有4 种操作模式: 电子代码本(ECB)模式、密码分组链接(CBC)模式、密码回馈(CFB)模式和输出回馈(OFB)模式。ECB模式被认为是最不安全的， 并且只用于短消息。3DES使用DES的三次选代， 利用两或三个不同的密钥， 从而将密钥的有效强度各自增加到112位或168位。</li><li><strong>了解高级加密标准(AES)</strong> 高级加密标准使用Rijndael算法， 并且是美国政府安全交换敏感但非分类数据的标准。AES使用128、192和256位的密钥和固定128位大小的分组达到比旧的DES算法高得多的安全性。</li></ul><h3 id="6-6-复习题"><a href="#6-6-复习题" class="headerlink" title="6.6 复习题"></a>6.6 复习题</h3><ol><li><p>4位的密钥空间存在多少个密钥?<br>A. 4<br>B. 8<br>C. 16<br>D. 128</p></li><li><p>Jolm近期收到一封来自Bill的电子邮件。需要满足什么密码学目标， 才能让John相信Bill是这封邮件的发送者?<br>A. 不可否认性<br>B. 机密性<br>C. 可用性<br>D. 完整性</p></li><li><p>数据加密标准(DES)密码系统中使用的密钥长度是多少?<br>A. 56位<br>B. 128位<br>C. 192位<br>D. 256位</p></li><li><p>什么类型的加密方式， 依赖于不断变化消息中字符的位置去实现机密性?<br>A. 流加密<br>B. 换位加密<br>C. 块加密<br>D. 替换加密</p></li><li><p>下列哪一个不是高级加密标准Rijndael算法可能的密钥长度?<br>A. 56位<br>B. 128位<br>C. 192位<br>D. 256位</p></li><li><p>秘密密钥加密系统不能实现下列哪一项?<br>A. 不可否认性<br>B. 机密性<br>C. 可用性<br>D. 密钥分发</p></li><li><p>如果配置正确， 己知唯一的牢不可破的加密系统是什么?<br>A. 换位密码<br>B. 替代密码<br>C. 高级加密标准<br>D. 一次性填充</p></li><li><p>数学函数16模3的输出值是多少?<br>A. 0<br>B. 1<br>C. 3<br>D. 5</p></li><li><p>在20世纪40年代， 一队来自美国的密码破译专家成功破解了基于一次一密的被称为VENONA的项目。该项目破坏了什么规则， 导致引起这个事件?<br>A. 密钥值必须随机<br>B. 密钥值必须和信息一样长<br>C. 密钥值必须仅能被用一次<br>D. 密钥值必须防止物理泄露</p></li><li><p>以下密码类型中， 哪一项对大块的消息而不是单个字符或位的消息进行操作?<br>A. 流加密<br>B. 凯撒加密<br>C. 块加密<br>D. ROT3加密</p></li><li><p>为了通过使用对称加密算法对双向通信进行保护， 需要的加密密钥的最小数目是多少?<br>A. 1<br>B. 2<br>C. 3<br>D. 4</p></li><li><p>Dave正在开发一个需要多人才能取回密钥的密钥托管系统， 但并不依靠每个参与者到现场。他正在使用什么类型的技术?<br>A. 分割知识<br>B. M of N控制<br>C. 工作函数<br>D. 零知识证明</p></li><li><p>下面哪种数据加密标准(DES)操作模式能被用于大量信息， 确保在加密/解密过程中不会因为一个早期的错误而破坏整个通信?<br>A. 密码分组链接(CBC)<br>B. 电子代码本(ECB)<br>C. 密码回馈(CFB)<br>D. 输出回馈(OFB)</p></li><li><p>许多加密算法依赖于分解大素数乘积的难题。它们依靠的这个问题的特点是什么?<br>A. 包含扩散<br>B. 包含泪淆<br>C. 包含单向函数<br>D. 遵照Kerchoff原则</p></li><li><p>全面实现有10人参与的对称算法需要多少个密钥?<br>A. 10<br>B. 20<br>C. 45<br>D. 100</p></li><li><p>高级加密标准使用的分块大小是多少?<br>A. 32位<br>B. 64位<br>C. 128位<br>D. 可变</p></li><li><p>什么样的攻击， 使得凯撒密码几乎无法使用?<br>A. 中间人攻击<br>B. 托管攻击<br>C. 频率分析攻击<br>D. 换位攻击</p></li><li><p>什么类型的密码系统经常利用一个通道， 借助一本著名的书来加密密钥?<br>A. Vernam 加密<br>B. 轮换密钥加密<br>C. Skipjack 加密<br>D. Twofish 加密</p></li><li><p>哪个入围的AES利用了预白噪声化和后白噪声化技术?<br>A. Rijndael<br>B. Twofish<br>C. Blowfish<br>D. Skipjack</p></li><li><p>全面实现有10人参与的非对称算法需要多少个密钥?<br>A. 10<br>B. 20<br>C. 45<br>D. 100</p></li></ol></div><div></div><div><div><div style="text-align:center;color:#555;font-size:14px">-------------End-------------</div></div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>Thank you very much for your donation.</div> <button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'> <span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"> <img id="wechat_qr" src="/images/wechatpay.png" alt=" 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"> <img id="alipay_qr" src="/images/alipay.png" alt=" 支付宝"><p>支付宝</p></div><div id="bitcoin" style="display:inline-block"> <img id="bitcoin_qr" src="/images/bitcoin.png" alt=" 比特币"><p>比特币</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/cissp/" rel="tag"><i class="fa fa-tag"></i> cissp</a><a href="/tags/学习笔记/" rel="tag"><i class="fa fa-tag"></i> 学习笔记</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/notes/cissp学习笔记（5）——保护资产的安全/" rel="next" title="cissp学习笔记（5）——保护资产的安全"><i class="fa fa-chevron-left"></i> cissp学习笔记（5）——保护资产的安全</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"></div></div></footer></div></article></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zODM5Mi8xNDkyMA=="></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/diyz.jpg" alt=""><p class="site-author-name" itemprop="name"></p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">21</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">16</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a rel="external nofollow" href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=1321425651" target="_blank" title="QQ" rel="external nofollow"><i class="fa fa-fw fa-qq"></i> QQ</a></span><span class="links-of-author-item"><a rel="external nofollow" href="mailto:1321425651@qq.com" target="_blank" title="E-Mail" rel="external nofollow"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a rel="external nofollow" href="https://github.com/doubiduo" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a rel="external nofollow" href="https://steamcommunity.com/id/doubiduo" target="_blank" title="Steam" rel="external nofollow"><i class="fa fa-fw fa-steam"></i> Steam</a></span><span class="links-of-author-item"><a rel="external nofollow" href="https://www.diyz.bid/atom.xml" target="_blank" title="RSS" rel="external nofollow"><i class="fa fa-fw fa-rss"></i> RSS</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-密码学历史上的里程碑"><span class="nav-text">6.1 密码学历史上的里程碑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-1-凯撒密码"><span class="nav-text">6.1.1 凯撒密码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-2-美国内战"><span class="nav-text">6.1.2 美国内战</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-3-Ultra-与Enigma"><span class="nav-text">6.1.3 Ultra 与Enigma</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-密码学基础"><span class="nav-text">6.2 密码学基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-1-密码学的目标"><span class="nav-text">6.2.1 密码学的目标</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-机密性"><span class="nav-text">1. 机密性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-完整性"><span class="nav-text">2. 完整性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-身份认证"><span class="nav-text">3. 身份认证</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-不可否认性"><span class="nav-text">4. 不可否认性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-2-密码学概念"><span class="nav-text">6.2.2 密码学概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-3-密码学的数学原理"><span class="nav-text">6.2.3 密码学的数学原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-二进制数学"><span class="nav-text">1. 二进制数学</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-逻辑运算"><span class="nav-text">2. 逻辑运算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-模函数"><span class="nav-text">3. 模函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-单向函数"><span class="nav-text">4. 单向函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-随机数"><span class="nav-text">5. 随机数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-零知识证明"><span class="nav-text">6. 零知识证明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-分割知识"><span class="nav-text">7. 分割知识</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-工作函数"><span class="nav-text">8. 工作函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-4-密码"><span class="nav-text">6.2.4 密码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-编码与密码"><span class="nav-text">1. 编码与密码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-换位密码"><span class="nav-text">2. 换位密码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-替代密码"><span class="nav-text">3. 替代密码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-一次性填充"><span class="nav-text">4. 一次性填充</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-滚动密钥密码"><span class="nav-text">5. 滚动密钥密码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-分组密码"><span class="nav-text">6. 分组密码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-流密码"><span class="nav-text">7. 流密码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-混淆与扩散"><span class="nav-text">7. 混淆与扩散</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-现代密码学"><span class="nav-text">6. 现代密码学</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-1-密钥"><span class="nav-text">6.3.1 密钥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-2-对称密钥算法"><span class="nav-text">6.3.2 对称密钥算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-3-非对称密钥算法"><span class="nav-text">6.3.3 非对称密钥算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-4-散列算法"><span class="nav-text">6.3.4 散列算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-对称密码"><span class="nav-text">6.4 对称密码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-1-数据加密标准"><span class="nav-text">6.4.1 数据加密标准</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-电子代码本模式"><span class="nav-text">1. 电子代码本模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-密码分组链接模式"><span class="nav-text">2. 密码分组链接模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-密码回馈模式"><span class="nav-text">3. 密码回馈模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-输出回馈模式"><span class="nav-text">4. 输出回馈模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-计数模式"><span class="nav-text">5. 计数模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-2-三重数据加密算法-3DES"><span class="nav-text">6.4.2 三重数据加密算法(3DES)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-3-国际数据加密算法-IDEA"><span class="nav-text">6.4.3 国际数据加密算法(IDEA)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-4-Blowfish"><span class="nav-text">6.4.4 Blowfish</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-5-Skipjack"><span class="nav-text">6.4.5 Skipjack</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-6-高级加密标准-AES"><span class="nav-text">6.4.6 高级加密标准(AES)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-7-对称密钥管理"><span class="nav-text">6.4.7 对称密钥管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-创建和分发对称密码"><span class="nav-text">1. 创建和分发对称密码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-存储和销毁对称密钥"><span class="nav-text">2. 存储和销毁对称密钥</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-密钥托管"><span class="nav-text">3. 密钥托管</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-8-密码生命周期"><span class="nav-text">6.4.8 密码生命周期</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-考试要点"><span class="nav-text">6.5 考试要点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-复习题"><span class="nav-text">6.6 复习题</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span><span class="with-love" id="animate"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">doubiduo</span></div><div class="powered-by">由 <a rel="external nofollow" class="theme-link" target="_blank" rel="external nofollow" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info"><div class="powered-by"></div> <span class="post-count">全站共115.1k字</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script><script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script><script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script><script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script><script type="text/javascript">!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((n=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script><script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script><script>AV.initialize("auf5TIy4OQOv6c52DIqTOgHd-gzGzoHsz","tBf3kX7KmYaId0Nh4PlLx3XQ")</script><script>function showTime(e){var t=new AV.Query(e),c=[],u=$(".leancloud_visitors");u.each(function(){c.push($(this).attr("id").trim())}),t.containedIn("url",c),t.find().done(function(e){var t=".leancloud-visitors-count";if(0!==e.length){for(var n=0;n<e.length;n++){var o=e[n],i=o.get("url"),s=o.get("time"),r=document.getElementById(i);$(r).find(t).text(s)}for(n=0;n<c.length;n++){i=c[n],r=document.getElementById(i);var l=$(r).find(t);""==l.text()&&l.text(0)}}else u.find(t).text(0)}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(i){var e=$(".leancloud_visitors"),s=e.attr("id").trim(),r=e.attr("data-flag-title").trim(),t=new AV.Query(i);t.equalTo("url",s),t.find({success:function(e){if(0<e.length){var t=e[0];t.fetchWhenSave(!0),t.increment("time"),t.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var n=new i,o=new AV.ACL;o.setPublicReadAccess(!0),o.setPublicWriteAccess(!0),n.setACL(o),n.set("title",r),n.set("url",s),n.set("time",1),n.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):1<$(".post-title-link").length&&showTime(e)})</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script></body></html>